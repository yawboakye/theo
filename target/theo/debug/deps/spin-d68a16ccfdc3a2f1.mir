// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn barrier::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/barrier.rs:72:1: 72:34>::wait(_1: &barrier::Barrier<R>) -> BarrierWaitResult {
    debug self => _1;
    let mut _0: barrier::BarrierWaitResult;
    let mut _2: mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _3: &mutex::Mutex<barrier::BarrierState, R>;
    let mut _4: &mut barrier::BarrierState;
    let mut _5: &mut mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _6: (usize, bool);
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: &barrier::BarrierState;
    let mut _10: &mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _11: usize;
    let mut _13: &barrier::BarrierState;
    let mut _14: &mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _15: bool;
    let mut _16: usize;
    let mut _17: &barrier::BarrierState;
    let mut _18: &mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: &barrier::BarrierState;
    let mut _22: &mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _23: usize;
    let _24: ();
    let mut _25: mutex::MutexGuard<'_, barrier::BarrierState>;
    let _26: ();
    let mut _27: mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _28: &mutex::Mutex<barrier::BarrierState, R>;
    let mut _29: &mut barrier::BarrierState;
    let mut _30: &mut mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _31: usize;
    let mut _32: usize;
    let mut _33: &barrier::BarrierState;
    let mut _34: &mutex::MutexGuard<'_, barrier::BarrierState>;
    let mut _35: &mut barrier::BarrierState;
    let mut _36: &mut mutex::MutexGuard<'_, barrier::BarrierState>;
    scope 1 {
        debug lock => _2;
        let _12: usize;
        scope 2 {
            debug local_gen => _12;
        }
    }

    bb0: {
        _3 = &((*_1).0: mutex::Mutex<barrier::BarrierState, R>);
        _2 = mutex::Mutex::<BarrierState, R>::lock(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = <mutex::MutexGuard<'_, BarrierState> as DerefMut>::deref_mut(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = CheckedAdd(((*_4).0: usize), const 1_usize);
        assert(!move (_6.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_4).0: usize), const 1_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        ((*_4).0: usize) = move (_6.0: usize);
        _10 = &_2;
        _9 = <mutex::MutexGuard<'_, BarrierState> as Deref>::deref(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = ((*_9).0: usize);
        _11 = ((*_1).1: usize);
        _7 = Lt(move _8, move _11);
        switchInt(move _7) -> [0: bb16, otherwise: bb5];
    }

    bb5: {
        _14 = &_2;
        _13 = <mutex::MutexGuard<'_, BarrierState> as Deref>::deref(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = ((*_13).1: usize);
        goto -> bb7;
    }

    bb7: {
        _18 = &_2;
        _17 = <mutex::MutexGuard<'_, BarrierState> as Deref>::deref(move _18) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = ((*_17).1: usize);
        _15 = Eq(_12, move _16);
        switchInt(move _15) -> [0: bb15, otherwise: bb9];
    }

    bb9: {
        _22 = &_2;
        _21 = <mutex::MutexGuard<'_, BarrierState> as Deref>::deref(move _22) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _20 = ((*_21).0: usize);
        _23 = ((*_1).1: usize);
        _19 = Lt(move _20, move _23);
        switchInt(move _19) -> [0: bb15, otherwise: bb11];
    }

    bb11: {
        _25 = move _2;
        _24 = core::mem::drop::<mutex::MutexGuard<'_, BarrierState>>(move _25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _26 = <R as RelaxStrategy>::relax() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _28 = &((*_1).0: mutex::Mutex<barrier::BarrierState, R>);
        _27 = mutex::Mutex::<BarrierState, R>::lock(move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _2 = move _27;
        goto -> bb7;
    }

    bb15: {
        _0 = BarrierWaitResult(const false);
        goto -> bb21;
    }

    bb16: {
        _30 = &mut _2;
        _29 = <mutex::MutexGuard<'_, BarrierState> as DerefMut>::deref_mut(move _30) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        ((*_29).0: usize) = const 0_usize;
        _34 = &_2;
        _33 = <mutex::MutexGuard<'_, BarrierState> as Deref>::deref(move _34) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _32 = ((*_33).1: usize);
        _31 = num::<impl usize>::wrapping_add(move _32, const 1_usize) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _36 = &mut _2;
        _35 = <mutex::MutexGuard<'_, BarrierState> as DerefMut>::deref_mut(move _36) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        ((*_35).1: usize) = move _31;
        _0 = BarrierWaitResult(const true);
        goto -> bb21;
    }

    bb21: {
        drop(_2) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        return;
    }
}

fn barrier::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/barrier.rs:134:1: 134:19>::new(_1: usize) -> barrier::Barrier<R> {
    debug n => _1;
    let mut _0: barrier::Barrier<R>;
    let mut _2: mutex::Mutex<barrier::BarrierState, R>;
    let mut _3: barrier::BarrierState;

    bb0: {
        _3 = BarrierState { count: const 0_usize, generation_id: const 0_usize };
        _2 = mutex::Mutex::<BarrierState, R>::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = barrier::Barrier::<R> { lock: move _2, num_threads: _1 };
        return;
    }
}

// MIR FOR CTFE
fn barrier::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/barrier.rs:134:1: 134:19>::new(_1: usize) -> barrier::Barrier<R> {
    debug n => _1;
    let mut _0: barrier::Barrier<R>;
    let mut _2: mutex::Mutex<barrier::BarrierState, R>;
    let mut _3: barrier::BarrierState;
    let mut _4: usize;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = BarrierState { count: const 0_usize, generation_id: const 0_usize };
        ConstEvalCounter;
        _2 = mutex::Mutex::<BarrierState, R>::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        _4 = _1;
        _0 = barrier::Barrier::<R> { lock: move _2, num_threads: move _4 };
        StorageDead(_4);
        StorageDead(_2);
        return;
    }
}

fn barrier::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/barrier.rs:161:1: 161:23>::is_leader(_1: &BarrierWaitResult) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = ((*_1).0: bool);
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:46:1: 46:55>::fmt(_1: &lazy::Lazy<T, F, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &once::Once<T, R>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let mut _13: &&str;

    bb0: {
        _7 = const "Lazy";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "cell";
        _10 = &((*_1).0: once::Once<T, R>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "init";
        _13 = const _;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

promoted[0] in lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:46:1: 46:55>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "..";
        _0 = &_1;
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:63:1: 63:28>::new(_1: F) -> lazy::Lazy<T, F, R> {
    debug f => _1;
    let mut _0: lazy::Lazy<T, F, R>;
    let mut _2: once::Once<T, R>;
    let mut _3: core::cell::Cell<core::option::Option<F>>;
    let mut _4: core::option::Option<F>;

    bb0: {
        _2 = once::Once::<T, R>::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Option::<F>::Some(move _1);
        _3 = Cell::<Option<F>>::new(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = lazy::Lazy::<T, F, R> { cell: move _2, init: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:63:1: 63:28>::new(_1: F) -> lazy::Lazy<T, F, R> {
    debug f => _1;
    let mut _0: lazy::Lazy<T, F, R>;
    let mut _2: once::Once<T, R>;
    let mut _3: core::cell::Cell<core::option::Option<F>>;
    let mut _4: core::option::Option<F>;
    let mut _5: F;
    let mut _6: bool;

    bb0: {
        _6 = const false;
        _6 = const true;
        StorageLive(_2);
        ConstEvalCounter;
        _2 = once::Once::<T, R>::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _6 = const false;
        _5 = move _1;
        _4 = Option::<F>::Some(move _5);
        StorageDead(_5);
        ConstEvalCounter;
        _3 = Cell::<Option<F>>::new(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_4);
        _0 = lazy::Lazy::<T, F, R> { cell: move _2, init: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:63:1: 63:28>::as_mut_ptr(_1: &lazy::Lazy<T, F, R>) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: &once::Once<T, R>;

    bb0: {
        _2 = &((*_1).0: once::Once<T, R>);
        _0 = once::Once::<T, R>::as_mut_ptr(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:82:1: 82:58>::force(_1: &lazy::Lazy<T, F, R>) -> &T {
    debug this => _1;
    let mut _0: &T;
    let mut _2: &once::Once<T, R>;
    let mut _3: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:98:29: 98:31};
    let mut _4: &&lazy::Lazy<T, F, R>;

    bb0: {
        _2 = &((*_1).0: once::Once<T, R>);
        _4 = &_1;
        _3 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:98:29: 98:31} { this: move _4 };
        _0 = once::Once::<T, R>::call_once::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:98:29: 98:31}>(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:82:1: 82:58>::force::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:98:29: 98:31}) -> T {
    debug this => (*(_1.0: &&lazy::Lazy<T, F, R>));
    let mut _0: T;
    let mut _2: core::option::Option<F>;
    let mut _3: &core::cell::Cell<core::option::Option<F>>;
    let mut _4: isize;
    let _5: F;
    let mut _6: !;
    let mut _7: &&lazy::Lazy<T, F, R>;
    let mut _8: &lazy::Lazy<T, F, R>;
    scope 1 {
        debug f => _5;
    }

    bb0: {
        _7 = deref_copy (_1.0: &&lazy::Lazy<T, F, R>);
        _8 = deref_copy (*_7);
        _3 = &((*_8).1: core::cell::Cell<core::option::Option<F>>);
        _2 = Cell::<Option<F>>::take(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _6 = panic(const "Lazy instance has previously been poisoned") -> unwind unreachable;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_2 as Some).0: F);
        _0 = <F as FnOnce<()>>::call_once(move _5, const ()) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:105:1: 105:68>::deref(_1: &lazy::Lazy<T, F, R>) -> &T {
    debug self => _1;
    let mut _0: &T;

    bb0: {
        _0 = lazy::Lazy::<T, F, R>::force(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lazy::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/lazy.rs:113:1: 113:54>::default() -> lazy::Lazy<T, fn() -> T, R> {
    let mut _0: lazy::Lazy<T, fn() -> T, R>;
    let mut _1: fn() -> T;

    bb0: {
        _1 = <T as core::default::Default>::default as fn() -> T (PointerCoercion(ReifyFnPointer));
        _0 = lazy::Lazy::<T, fn() -> T, R>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:93:1: 93:27>::new(_1: T) -> SpinMutex<T, R> {
    debug data => _1;
    let mut _0: mutex::spin::SpinMutex<T, R>;
    let mut _2: core::sync::atomic::AtomicBool;
    let mut _3: core::cell::UnsafeCell<T>;

    bb0: {
        _2 = AtomicBool::new(const false) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = UnsafeCell::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = SpinMutex::<T, R> { phantom: const ZeroSized: PhantomData<R>, lock: move _2, data: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:93:1: 93:27>::new(_1: T) -> SpinMutex<T, R> {
    debug data => _1;
    let mut _0: mutex::spin::SpinMutex<T, R>;
    let mut _2: core::sync::atomic::AtomicBool;
    let mut _3: core::cell::UnsafeCell<T>;
    let mut _4: T;
    let mut _5: core::marker::PhantomData<R>;
    let mut _6: bool;

    bb0: {
        _6 = const false;
        _6 = const true;
        StorageLive(_2);
        ConstEvalCounter;
        _2 = AtomicBool::new(const false) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_3);
        StorageLive(_4);
        _6 = const false;
        _4 = move _1;
        ConstEvalCounter;
        _3 = UnsafeCell::<T>::new(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_4);
        StorageLive(_5);
        _5 = PhantomData::<R>;
        _0 = SpinMutex::<T, R> { phantom: move _5, lock: move _2, data: move _3 };
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:93:1: 93:27>::into_inner(_1: SpinMutex<T, R>) -> T {
    debug self => _1;
    let mut _0: T;
    let _2: core::cell::UnsafeCell<T>;
    scope 1 {
        debug data => _2;
    }

    bb0: {
        _2 = move (_1.2: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::into_inner(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:93:1: 93:27>::as_mut_ptr(_1: &SpinMutex<T, R>) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: &core::cell::UnsafeCell<T>;

    bb0: {
        _2 = &((*_1).2: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::get(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:161:1: 161:50>::lock(_1: &SpinMutex<T, R>) -> SpinMutexGuard<'_, T> {
    debug self => _1;
    let mut _0: mutex::spin::SpinMutexGuard<'_, T>;
    let mut _2: bool;
    let mut _3: &core::result::Result<bool, bool>;
    let _4: core::result::Result<bool, bool>;
    let mut _5: &core::sync::atomic::AtomicBool;
    let mut _6: core::sync::atomic::Ordering;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: bool;
    let _9: ();
    let _10: &core::sync::atomic::AtomicBool;
    let mut _11: *mut T;
    let mut _12: &mut T;
    let mut _13: *mut T;
    let mut _14: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _5 = &((*_1).1: core::sync::atomic::AtomicBool);
        _6 = Acquire;
        _7 = Relaxed;
        _4 = AtomicBool::compare_exchange_weak(move _5, const false, const true, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = &_4;
        _2 = Result::<bool, bool>::is_err(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _2) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _8 = SpinMutex::<T, R>::is_locked(_1) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _8) -> [0: bb1, otherwise: bb6];
    }

    bb6: {
        _9 = <R as RelaxStrategy>::relax() -> [return: bb4, unwind unreachable];
    }

    bb7: {
        _10 = &((*_1).1: core::sync::atomic::AtomicBool);
        _14 = &((*_1).2: core::cell::UnsafeCell<T>);
        _13 = UnsafeCell::<T>::get(move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = &mut (*_13);
        _11 = &raw mut (*_12);
        _0 = SpinMutexGuard::<'_, T> { lock: _10, data: move _11 };
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:198:1: 198:35>::is_locked(_1: &SpinMutex<T, R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::sync::atomic::AtomicBool;
    let mut _3: core::sync::atomic::Ordering;

    bb0: {
        _2 = &((*_1).1: core::sync::atomic::AtomicBool);
        _3 = Relaxed;
        _0 = AtomicBool::load(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:198:1: 198:35>::force_unlock(_1: &SpinMutex<T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: &core::sync::atomic::AtomicBool;
    let mut _4: core::sync::atomic::Ordering;

    bb0: {
        _3 = &((*_1).1: core::sync::atomic::AtomicBool);
        _4 = Release;
        _2 = AtomicBool::store(move _3, const false, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:198:1: 198:35>::try_lock(_1: &SpinMutex<T, R>) -> Option<SpinMutexGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<mutex::spin::SpinMutexGuard<'_, T>>;
    let mut _2: bool;
    let mut _3: &core::result::Result<bool, bool>;
    let _4: core::result::Result<bool, bool>;
    let mut _5: &core::sync::atomic::AtomicBool;
    let mut _6: core::sync::atomic::Ordering;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: mutex::spin::SpinMutexGuard<'_, T>;
    let _9: &core::sync::atomic::AtomicBool;
    let mut _10: *mut T;
    let mut _11: &mut T;
    let mut _12: *mut T;
    let mut _13: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _5 = &((*_1).1: core::sync::atomic::AtomicBool);
        _6 = Acquire;
        _7 = Relaxed;
        _4 = AtomicBool::compare_exchange(move _5, const false, const true, move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = Result::<bool, bool>::is_ok(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _2) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _9 = &((*_1).1: core::sync::atomic::AtomicBool);
        _13 = &((*_1).2: core::cell::UnsafeCell<T>);
        _12 = UnsafeCell::<T>::get(move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = &mut (*_12);
        _10 = &raw mut (*_11);
        _8 = SpinMutexGuard::<'_, T> { lock: _9, data: move _10 };
        _0 = Option::<SpinMutexGuard<'_, T>>::Some(move _8);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<SpinMutexGuard<'_, T>>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:198:1: 198:35>::get_mut(_1: &mut SpinMutex<T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: *mut T;
    let mut _3: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _3 = &((*_1).2: core::cell::UnsafeCell<T>);
        _2 = UnsafeCell::<T>::get(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &mut (*_2);
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt(_1: &SpinMutex<T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<mutex::spin::SpinMutexGuard<'_, T>>;
    let mut _4: isize;
    let _5: mutex::spin::SpinMutexGuard<'_, T>;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:279:27: 279:31};
    let mut _12: &mutex::spin::SpinMutexGuard<'_, T>;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:280:27: 280:31};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug guard => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = SpinMutex::<T, R>::try_lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb9, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Some).0: mutex::spin::SpinMutexGuard<'_, T>);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:279:27: 279:31} { guard: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:279:27: 279:31}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:280:27: 280:31} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:280:27: 280:31}>(move _6, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        drop(_5) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Mutex { <locked> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Mutex { data: "];
        _0 = &_1;
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:279:27: 279:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug guard => (*(_1.0: &mutex::spin::SpinMutexGuard<'_, T>));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;
    let mut _4: &mutex::spin::SpinMutexGuard<'_, T>;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _4 = deref_copy (_1.0: &mutex::spin::SpinMutexGuard<'_, T>);
        _3 = <SpinMutexGuard<'_, T> as Deref>::deref(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_3, _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:280:27: 280:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:275:1: 275:63>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:286:1: 286:57>::default() -> SpinMutex<T, R> {
    let mut _0: mutex::spin::SpinMutex<T, R>;
    let mut _1: T;

    bb0: {
        _1 = <T as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = SpinMutex::<T, R>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:292:1: 292:39>::from(_1: T) -> SpinMutex<T, R> {
    debug data => _1;
    let mut _0: mutex::spin::SpinMutex<T, R>;

    bb0: {
        _0 = SpinMutex::<T, R>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:298:1: 298:42>::leak(_1: SpinMutexGuard<'_, T>) -> &mut T {
    debug this => _1;
    let mut _0: &mut T;
    let mut _2: core::mem::ManuallyDrop<mutex::spin::SpinMutexGuard<'_, T>>;
    let mut _3: &mut mutex::spin::SpinMutexGuard<'_, T>;
    let mut _4: &mut core::mem::ManuallyDrop<mutex::spin::SpinMutexGuard<'_, T>>;
    let mut _5: *mut T;
    scope 1 {
        debug this => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = ManuallyDrop::<SpinMutexGuard<'_, T>>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <ManuallyDrop<SpinMutexGuard<'_, T>> as DerefMut>::deref_mut(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = deref_copy ((*_3).1: *mut T);
        _0 = &mut (*_5);
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:320:1: 320:70>::fmt(_1: &SpinMutexGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <SpinMutexGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:326:1: 326:74>::fmt(_1: &SpinMutexGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <SpinMutexGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Display>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:332:1: 332:52>::deref(_1: &SpinMutexGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: *mut T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).1: *mut T);
        _0 = &(*_2);
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:340:1: 340:55>::deref_mut(_1: &mut SpinMutexGuard<'_, T>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: *mut T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).1: *mut T);
        _0 = &mut (*_2);
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:347:1: 347:51>::drop(_1: &mut SpinMutexGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: core::sync::atomic::Ordering;
    let mut _4: &core::sync::atomic::AtomicBool;

    bb0: {
        _4 = deref_copy ((*_1).0: &core::sync::atomic::AtomicBool);
        _3 = Release;
        _2 = AtomicBool::store(_4, const false, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:355:1: 355:76>::INIT: SpinMutex<(), R> = {
    let mut _0: mutex::spin::SpinMutex<(), R>;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        ConstEvalCounter;
        _0 = SpinMutex::<(), R>::new(move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:355:1: 355:76>::lock(_1: &SpinMutex<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: mutex::spin::SpinMutexGuard<'_, ()>;

    bb0: {
        _3 = SpinMutex::<(), R>::lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = core::mem::forget::<SpinMutexGuard<'_, ()>>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:355:1: 355:76>::try_lock(_1: &SpinMutex<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::option::Option<()>;
    let _3: core::option::Option<()>;
    let mut _4: core::option::Option<mutex::spin::SpinMutexGuard<'_, ()>>;

    bb0: {
        _4 = SpinMutex::<(), R>::try_lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<SpinMutexGuard<'_, ()>>::map::<(), fn(SpinMutexGuard<'_, ()>) {core::mem::forget::<SpinMutexGuard<'_, ()>>}>(move _4, core::mem::forget::<SpinMutexGuard<'_, ()>>) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = &_3;
        _0 = Option::<()>::is_some(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:355:1: 355:76>::unlock(_1: &SpinMutex<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();

    bb0: {
        _2 = SpinMutex::<(), R>::force_unlock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn spin::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex/spin.rs:355:1: 355:76>::is_locked(_1: &SpinMutex<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = SpinMutex::<(), R>::is_locked(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:131:1: 131:23>::new(_1: T) -> mutex::Mutex<T, R> {
    debug value => _1;
    let mut _0: mutex::Mutex<T, R>;
    let mut _2: mutex::spin::SpinMutex<T, R>;

    bb0: {
        _2 = SpinMutex::<T, R>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mutex::Mutex::<T, R> { inner: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:131:1: 131:23>::new(_1: T) -> mutex::Mutex<T, R> {
    debug value => _1;
    let mut _0: mutex::Mutex<T, R>;
    let mut _2: mutex::spin::SpinMutex<T, R>;
    let mut _3: T;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = move _1;
        ConstEvalCounter;
        _2 = SpinMutex::<T, R>::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = mutex::Mutex::<T, R> { inner: move _2 };
        StorageDead(_2);
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:131:1: 131:23>::into_inner(_1: mutex::Mutex<T, R>) -> T {
    debug self => _1;
    let mut _0: T;
    let mut _2: mutex::spin::SpinMutex<T, R>;

    bb0: {
        _2 = move (_1.0: mutex::spin::SpinMutex<T, R>);
        _0 = SpinMutex::<T, R>::into_inner(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:168:1: 168:46>::lock(_1: &mutex::Mutex<T, R>) -> mutex::MutexGuard<'_, T> {
    debug self => _1;
    let mut _0: mutex::MutexGuard<'_, T>;
    let mut _2: mutex::spin::SpinMutexGuard<'_, T>;
    let mut _3: &mutex::spin::SpinMutex<T, R>;

    bb0: {
        _3 = &((*_1).0: mutex::spin::SpinMutex<T, R>);
        _2 = SpinMutex::<T, R>::lock(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mutex::MutexGuard::<'_, T> { inner: move _2 };
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:191:1: 191:31>::is_locked(_1: &mutex::Mutex<T, R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &mutex::spin::SpinMutex<T, R>;

    bb0: {
        _2 = &((*_1).0: mutex::spin::SpinMutex<T, R>);
        _0 = SpinMutex::<T, R>::is_locked(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:191:1: 191:31>::force_unlock(_1: &mutex::Mutex<T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: &mutex::spin::SpinMutex<T, R>;

    bb0: {
        _2 = &((*_1).0: mutex::spin::SpinMutex<T, R>);
        _0 = SpinMutex::<T, R>::force_unlock(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:191:1: 191:31>::try_lock(_1: &mutex::Mutex<T, R>) -> Option<mutex::MutexGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<mutex::MutexGuard<'_, T>>;
    let mut _2: core::option::Option<mutex::spin::SpinMutexGuard<'_, T>>;
    let mut _3: &mutex::spin::SpinMutex<T, R>;

    bb0: {
        _3 = &((*_1).0: mutex::spin::SpinMutex<T, R>);
        _2 = SpinMutex::<T, R>::try_lock(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Option::<SpinMutexGuard<'_, T>>::map::<mutex::MutexGuard<'_, T>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:233:18: 233:25}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:233:18: 233:25}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:191:1: 191:31>::try_lock::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:233:18: 233:25}, _2: SpinMutexGuard<'_, T>) -> mutex::MutexGuard<'_, T> {
    debug guard => _2;
    let mut _0: mutex::MutexGuard<'_, T>;

    bb0: {
        _0 = mutex::MutexGuard::<'_, T> { inner: move _2 };
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:191:1: 191:31>::get_mut(_1: &mut mutex::Mutex<T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: &mut mutex::spin::SpinMutex<T, R>;

    bb0: {
        _2 = &mut ((*_1).0: mutex::spin::SpinMutex<T, R>);
        _0 = SpinMutex::<T, R>::get_mut(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:255:1: 255:59>::fmt(_1: &mutex::Mutex<T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &mutex::spin::SpinMutex<T, R>;

    bb0: {
        _3 = &((*_1).0: mutex::spin::SpinMutex<T, R>);
        _0 = <SpinMutex<T, R> as Debug>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:261:1: 261:53>::default() -> mutex::Mutex<T, R> {
    let mut _0: mutex::Mutex<T, R>;
    let mut _1: T;

    bb0: {
        _1 = <T as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mutex::Mutex::<T, R>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:267:1: 267:35>::from(_1: T) -> mutex::Mutex<T, R> {
    debug data => _1;
    let mut _0: mutex::Mutex<T, R>;

    bb0: {
        _0 = mutex::Mutex::<T, R>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:273:1: 273:38>::leak(_1: mutex::MutexGuard<'_, T>) -> &mut T {
    debug this => _1;
    let mut _0: &mut T;
    let mut _2: mutex::spin::SpinMutexGuard<'_, T>;

    bb0: {
        _2 = move (_1.0: mutex::spin::SpinMutexGuard<'_, T>);
        _0 = SpinMutexGuard::<'_, T>::leak(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:292:1: 292:66>::fmt(_1: &mutex::MutexGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <mutex::MutexGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:298:1: 298:70>::fmt(_1: &mutex::MutexGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <mutex::MutexGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Display>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:304:1: 304:48>::deref(_1: &mutex::MutexGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: &mutex::spin::SpinMutexGuard<'_, T>;

    bb0: {
        _2 = &((*_1).0: mutex::spin::SpinMutexGuard<'_, T>);
        _0 = <SpinMutexGuard<'_, T> as Deref>::deref(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:311:1: 311:51>::deref_mut(_1: &mut mutex::MutexGuard<'_, T>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: &mut mutex::spin::SpinMutexGuard<'_, T>;

    bb0: {
        _2 = &mut ((*_1).0: mutex::spin::SpinMutexGuard<'_, T>);
        _0 = <SpinMutexGuard<'_, T> as DerefMut>::deref_mut(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:318:1: 318:72>::INIT: mutex::Mutex<(), R> = {
    let mut _0: mutex::Mutex<(), R>;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        ConstEvalCounter;
        _0 = mutex::Mutex::<(), R>::new(move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:318:1: 318:72>::lock(_1: &mutex::Mutex<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: mutex::MutexGuard<'_, ()>;

    bb0: {
        _3 = mutex::Mutex::<(), R>::lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = core::mem::forget::<mutex::MutexGuard<'_, ()>>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:318:1: 318:72>::try_lock(_1: &mutex::Mutex<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::option::Option<()>;
    let _3: core::option::Option<()>;
    let mut _4: core::option::Option<mutex::MutexGuard<'_, ()>>;

    bb0: {
        _4 = mutex::Mutex::<(), R>::try_lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<mutex::MutexGuard<'_, ()>>::map::<(), fn(mutex::MutexGuard<'_, ()>) {core::mem::forget::<mutex::MutexGuard<'_, ()>>}>(move _4, core::mem::forget::<mutex::MutexGuard<'_, ()>>) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = &_3;
        _0 = Option::<()>::is_some(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:318:1: 318:72>::unlock(_1: &mutex::Mutex<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();

    bb0: {
        _2 = mutex::Mutex::<(), R>::force_unlock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/mutex.rs:318:1: 318:72>::is_locked(_1: &mutex::Mutex<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &mutex::spin::SpinMutex<(), R>;

    bb0: {
        _2 = &((*_1).0: mutex::spin::SpinMutex<(), R>);
        _0 = SpinMutex::<(), R>::is_locked(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:34:1: 34:34>::default() -> once::Once<T, R> {
    let mut _0: once::Once<T, R>;

    bb0: {
        _0 = once::Once::<T, R>::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt(_1: &once::Once<T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<&T>;
    let mut _4: isize;
    let _5: &T;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:44:27: 44:31};
    let mut _12: &&T;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:45:27: 45:31};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug s => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = once::Once::<T, R>::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb8, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: &T);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:44:27: 44:31} { s: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:44:27: 44:31}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:45:27: 45:31} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:45:27: 45:31}>(move _6, move _14) -> [return: bb9, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Once { <uninitialized> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Once { data: "];
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:44:27: 44:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug s => (*(_1.0: &&T));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &&T;
    let mut _4: &T;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _3 = deref_copy (_1.0: &&T);
        _4 = deref_copy (*_3);
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_4, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:45:27: 45:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:40:1: 40:49>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

Status::Incomplete::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

Status::Running::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

Status::Complete::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

Status::Panicked::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:68:14: 68:19>::clone(_1: &Status) -> Status {
    debug self => _1;
    let mut _0: once::status::Status;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:68:27: 68:32>::fmt(_1: &Status, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Panicked";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Incomplete";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Running";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Complete";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:68:34: 68:43>::eq(_1: &Status, _2: &Status) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:75:5: 75:16>::new_unchecked(_1: u8) -> Status {
    debug inner => _1;
    let mut _0: once::status::Status;

    bb0: {
        _0 = _1 as once::status::Status (Transmute);
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::new(_1: Status) -> AtomicStatus {
    debug status => _1;
    let mut _0: once::status::AtomicStatus;
    let mut _2: core::sync::atomic::AtomicU8;
    let mut _3: u8;
    let mut _4: bool;

    bb0: {
        _3 = discriminant(_1);
        _4 = Le(_3, const 3_u8);
        assume(move _4);
        _2 = core::sync::atomic::AtomicU8::new(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = AtomicStatus(move _2);
        return;
    }
}

// MIR FOR CTFE
fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::new(_1: Status) -> AtomicStatus {
    debug status => _1;
    let mut _0: once::status::AtomicStatus;
    let mut _2: core::sync::atomic::AtomicU8;
    let mut _3: u8;
    let _4: once::status::Status;
    let mut _5: u8;
    let mut _6: u8;
    let mut _7: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        _5 = discriminant(_4);
        _6 = _5 as u8 (IntToInt);
        _7 = Le(_6, const 3_u8);
        assume(move _7);
        _3 = move _5 as u8 (IntToInt);
        StorageDead(_4);
        ConstEvalCounter;
        _2 = core::sync::atomic::AtomicU8::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = AtomicStatus(move _2);
        StorageDead(_2);
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::load(_1: &AtomicStatus, _2: core::sync::atomic::Ordering) -> Status {
    debug self => _1;
    debug ordering => _2;
    let mut _0: once::status::Status;
    let mut _3: u8;
    let mut _4: &core::sync::atomic::AtomicU8;
    scope 1 {
    }

    bb0: {
        _4 = &((*_1).0: core::sync::atomic::AtomicU8);
        _3 = core::sync::atomic::AtomicU8::load(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Status::new_unchecked(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::store(_1: &AtomicStatus, _2: Status, _3: core::sync::atomic::Ordering) -> () {
    debug self => _1;
    debug status => _2;
    debug ordering => _3;
    let mut _0: ();
    let _4: ();
    let mut _5: &core::sync::atomic::AtomicU8;
    let mut _6: u8;
    let mut _7: bool;

    bb0: {
        _5 = &((*_1).0: core::sync::atomic::AtomicU8);
        _6 = discriminant(_2);
        _7 = Le(_6, const 3_u8);
        assume(move _7);
        _4 = core::sync::atomic::AtomicU8::store(move _5, _6, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::compare_exchange(_1: &AtomicStatus, _2: Status, _3: Status, _4: core::sync::atomic::Ordering, _5: core::sync::atomic::Ordering) -> Result<Status, Status> {
    debug self => _1;
    debug old => _2;
    debug new => _3;
    debug success => _4;
    debug failure => _5;
    let mut _0: core::result::Result<once::status::Status, once::status::Status>;
    let mut _6: core::result::Result<u8, u8>;
    let mut _7: &core::sync::atomic::AtomicU8;
    let mut _8: u8;
    let mut _9: bool;
    let mut _10: u8;
    let mut _11: bool;
    let mut _12: isize;
    let _13: u8;
    let mut _14: once::status::Status;
    let _15: u8;
    let mut _16: once::status::Status;
    scope 1 {
        debug ok => _13;
        scope 2 {
        }
    }
    scope 3 {
        debug err => _15;
        scope 4 {
        }
    }

    bb0: {
        _7 = &((*_1).0: core::sync::atomic::AtomicU8);
        _8 = discriminant(_2);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _10 = discriminant(_3);
        _11 = Le(_10, const 3_u8);
        assume(move _11);
        _6 = core::sync::atomic::AtomicU8::compare_exchange(move _7, _8, _10, _4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _12 = discriminant(_6);
        switchInt(move _12) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _15 = ((_6 as Err).0: u8);
        _16 = Status::new_unchecked(_15) -> [return: bb6, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _13 = ((_6 as Ok).0: u8);
        _14 = Status::new_unchecked(_13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Result::<Status, Status>::Ok(move _14);
        goto -> bb7;
    }

    bb6: {
        _0 = Result::<Status, Status>::Err(move _16);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn status::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:86:5: 86:22>::get_mut(_1: &mut AtomicStatus) -> &mut Status {
    debug self => _1;
    let mut _0: &mut once::status::Status;
    let mut _2: *mut once::status::Status;
    let mut _3: *mut u8;
    let mut _4: &mut u8;
    let mut _5: &mut core::sync::atomic::AtomicU8;
    scope 1 {
    }

    bb0: {
        _5 = &mut ((*_1).0: core::sync::atomic::AtomicU8);
        _4 = core::sync::atomic::AtomicU8::get_mut(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &raw mut (*_4);
        _2 = ptr::mut_ptr::<impl *mut u8>::cast::<Status>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &mut (*_2);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::call_once(_1: &once::Once<T, R>, _2: F) -> &T {
    debug self => _1;
    debug f => _2;
    let mut _0: &T;
    let mut _3: core::result::Result<&T, core::convert::Infallible>;
    let mut _4: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:169:34: 169:36};
    let mut _5: isize;
    scope 1 {
        debug x => _0;
    }
    scope 2 {
        debug void => const ZeroSized: Infallible;
    }

    bb0: {
        _4 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:169:34: 169:36} { f: move _2 };
        _3 = once::Once::<T, R>::try_call_once::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:169:34: 169:36}, Infallible>(_1, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = ((_3 as Ok).0: &T);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::call_once::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:169:34: 169:36}) -> Result<T, Infallible> {
    debug f => (_1.0: F);
    let mut _0: core::result::Result<T, core::convert::Infallible>;
    let mut _2: T;
    let mut _3: F;

    bb0: {
        _3 = move (_1.0: F);
        _2 = <F as FnOnce<()>>::call_once(move _3, const ()) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<T, Infallible>::Ok(move _2);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::try_call_once(_1: &once::Once<T, R>, _2: F) -> Result<&T, E> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<&T, E>;
    let mut _3: core::option::Option<&T>;
    let mut _4: isize;
    let mut _6: F;
    let mut _7: bool;
    scope 1 {
        debug value => _5;
        let _5: &T;
    }

    bb0: {
        _7 = const false;
        _7 = const true;
        _3 = once::Once::<T, R>::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = ((_3 as Some).0: &T);
        _0 = Result::<&T, E>::Ok(_5);
        goto -> bb4;
    }

    bb3: {
        _7 = const false;
        _6 = move _2;
        _0 = once::Once::<T, R>::try_call_once_slow::<F, E>(_1, move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(_7) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        return;
    }

    bb6: {
        drop(_2) -> [return: bb5, unwind unreachable];
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::try_call_once_slow(_1: &once::Once<T, R>, _2: F) -> Result<&T, E> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<&T, E>;
    let _3: core::result::Result<once::status::Status, once::status::Status>;
    let mut _4: &once::status::AtomicStatus;
    let mut _5: once::status::Status;
    let mut _6: once::status::Status;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: u8;
    let mut _10: isize;
    let mut _12: !;
    let mut _13: core::option::Option<&T>;
    let mut _14: isize;
    let _16: &T;
    let _18: &once::status::AtomicStatus;
    let mut _19: core::result::Result<T, E>;
    let mut _20: F;
    let mut _21: isize;
    let _24: ();
    let _25: ();
    let mut _26: &once::status::AtomicStatus;
    let mut _27: once::status::Status;
    let mut _28: core::sync::atomic::Ordering;
    let _29: ();
    let mut _30: *mut T;
    let mut _31: &mut core::mem::MaybeUninit<T>;
    let mut _32: *mut core::mem::MaybeUninit<T>;
    let mut _33: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;
    let _34: ();
    let _35: ();
    let mut _36: &once::status::AtomicStatus;
    let mut _37: once::status::Status;
    let mut _38: core::sync::atomic::Ordering;
    let _39: &T;
    let mut _40: bool;
    scope 1 {
        debug xchg => _3;
        let _11: once::status::Status;
        let _15: &T;
        let _17: once::Finish<'_>;
        scope 2 {
            debug _must_be_state_incomplete => _11;
        }
        scope 3 {
            debug v => _15;
        }
        scope 4 {
        }
        scope 5 {
            debug finish => _17;
            let _22: T;
            let _23: E;
            scope 6 {
                debug val => _22;
                scope 9 {
                }
                scope 10 {
                }
            }
            scope 7 {
                debug val => _22;
            }
            scope 8 {
                debug err => _23;
            }
        }
    }

    bb0: {
        _40 = const false;
        _40 = const true;
        goto -> bb1;
    }

    bb1: {
        _4 = &((*_1).1: once::status::AtomicStatus);
        _5 = Status::Incomplete;
        _6 = Status::Running;
        _7 = Acquire;
        _8 = Acquire;
        _3 = AtomicStatus::compare_exchange(move _4, move _5, move _6, move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = discriminant(((_3 as Err).0: once::status::Status));
        switchInt(move _9) -> [0: bb1, 1: bb7, 2: bb10, 3: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _11 = ((_3 as Ok).0: once::status::Status);
        _18 = &((*_1).1: once::status::AtomicStatus);
        _17 = Finish::<'_> { status: _18 };
        _40 = const false;
        _20 = move _2;
        _19 = <F as FnOnce<()>>::call_once(move _20, const ()) -> [return: bb12, unwind unreachable];
    }

    bb6: {
        _12 = panic(const "Once panicked") -> unwind unreachable;
    }

    bb7: {
        _13 = once::Once::<T, R>::poll(_1) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = discriminant(_13);
        switchInt(move _14) -> [0: bb1, 1: bb9, otherwise: bb4];
    }

    bb9: {
        _15 = ((_13 as Some).0: &T);
        _0 = Result::<&T, E>::Ok(_15);
        goto -> bb23;
    }

    bb10: {
        _16 = once::Once::<T, R>::force_get(_1) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Result::<&T, E>::Ok(_16);
        goto -> bb23;
    }

    bb12: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb14, 1: bb13, otherwise: bb4];
    }

    bb13: {
        _23 = move ((_19 as Err).0: E);
        _24 = core::mem::forget::<Finish<'_>>(move _17) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _22 = move ((_19 as Ok).0: T);
        _33 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _32 = UnsafeCell::<MaybeUninit<T>>::get(move _33) -> [return: bb17, unwind unreachable];
    }

    bb15: {
        _26 = &((*_1).1: once::status::AtomicStatus);
        _27 = Status::Incomplete;
        _28 = Release;
        _25 = AtomicStatus::store(move _26, move _27, move _28) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Result::<&T, E>::Err(move _23);
        goto -> bb23;
    }

    bb17: {
        _31 = &mut (*_32);
        _30 = MaybeUninit::<T>::as_mut_ptr(move _31) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _29 = ptr::mut_ptr::<impl *mut T>::write(move _30, move _22) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _34 = core::mem::forget::<Finish<'_>>(move _17) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _36 = &((*_1).1: once::status::AtomicStatus);
        _37 = Status::Complete;
        _38 = Release;
        _35 = AtomicStatus::store(move _36, move _37, move _38) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _39 = once::Once::<T, R>::force_get(_1) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _0 = Result::<&T, E>::Ok(_39);
        goto -> bb23;
    }

    bb23: {
        switchInt(_40) -> [0: bb24, otherwise: bb25];
    }

    bb24: {
        return;
    }

    bb25: {
        drop(_2) -> [return: bb24, unwind unreachable];
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::wait(_1: &once::Once<T, R>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: ();
    let mut _3: core::option::Option<&T>;
    let mut _4: isize;
    scope 1 {
        debug x => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = once::Once::<T, R>::poll(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = ((_3 as Some).0: &T);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:133:1: 133:37>::poll(_1: &once::Once<T, R>) -> Option<&T> {
    debug self => _1;
    let mut _0: core::option::Option<&T>;
    let mut _2: ();
    let mut _3: once::status::Status;
    let mut _4: &once::status::AtomicStatus;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: u8;
    let _7: &T;
    let mut _8: !;
    scope 1 {
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _4 = &((*_1).1: once::status::AtomicStatus);
        _5 = Acquire;
        _3 = AtomicStatus::load(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb5, 1: bb6, 2: bb7, 3: bb3, otherwise: bb4];
    }

    bb3: {
        _8 = panic(const "Once previously poisoned by a panicked") -> unwind unreachable;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = Option::<&T>::None;
        goto -> bb9;
    }

    bb6: {
        _2 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb7: {
        _7 = once::Once::<T, R>::force_get(_1) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Option::<&T>::Some(_7);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

const once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::INIT: once::Once<T, R> = {
    let mut _0: once::Once<T, R>;
    let mut _1: core::marker::PhantomData<R>;
    let mut _2: once::status::AtomicStatus;
    let mut _3: once::status::Status;
    let mut _4: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;
    let mut _5: core::mem::MaybeUninit<T>;

    bb0: {
        StorageLive(_1);
        _1 = PhantomData::<R>;
        StorageLive(_2);
        StorageLive(_3);
        _3 = Status::Incomplete;
        ConstEvalCounter;
        _2 = AtomicStatus::new(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = MaybeUninit::<T>::uninit() -> [return: bb2, unwind: bb4];
    }

    bb2: {
        ConstEvalCounter;
        _4 = UnsafeCell::<MaybeUninit<T>>::new(move _5) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_5);
        _0 = once::Once::<T, R> { phantom: move _1, status: move _2, data: move _4 };
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::new() -> once::Once<T, R> {
    let mut _0: once::Once<T, R>;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::new() -> once::Once<T, R> {
    let mut _0: once::Once<T, R>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::initialized(_1: T) -> once::Once<T, R> {
    debug data => _1;
    let mut _0: once::Once<T, R>;
    let mut _2: once::status::AtomicStatus;
    let mut _3: once::status::Status;
    let mut _4: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;
    let mut _5: core::mem::MaybeUninit<T>;

    bb0: {
        _3 = Status::Complete;
        _2 = AtomicStatus::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = MaybeUninit::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = UnsafeCell::<MaybeUninit<T>>::new(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = once::Once::<T, R> { phantom: const ZeroSized: PhantomData<R>, status: move _2, data: move _4 };
        return;
    }
}

// MIR FOR CTFE
fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::initialized(_1: T) -> once::Once<T, R> {
    debug data => _1;
    let mut _0: once::Once<T, R>;
    let mut _2: core::marker::PhantomData<R>;
    let mut _3: once::status::AtomicStatus;
    let mut _4: once::status::Status;
    let mut _5: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;
    let mut _6: core::mem::MaybeUninit<T>;
    let mut _7: T;
    let mut _8: bool;

    bb0: {
        _8 = const false;
        _8 = const true;
        StorageLive(_2);
        _2 = PhantomData::<R>;
        StorageLive(_3);
        StorageLive(_4);
        _4 = Status::Complete;
        ConstEvalCounter;
        _3 = AtomicStatus::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _8 = const false;
        _7 = move _1;
        ConstEvalCounter;
        _6 = MaybeUninit::<T>::new(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = UnsafeCell::<MaybeUninit<T>>::new(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_6);
        _0 = once::Once::<T, R> { phantom: move _2, status: move _3, data: move _5 };
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::as_mut_ptr(_1: &once::Once<T, R>) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: *mut core::mem::MaybeUninit<T>;
    let mut _3: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;

    bb0: {
        _3 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _2 = UnsafeCell::<MaybeUninit<T>>::get(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = ptr::mut_ptr::<impl *mut MaybeUninit<T>>::cast::<T>(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::force_get(_1: &once::Once<T, R>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let _2: *const T;
    let mut _3: &core::mem::MaybeUninit<T>;
    let _4: *mut core::mem::MaybeUninit<T>;
    let mut _5: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;

    bb0: {
        _5 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _4 = UnsafeCell::<MaybeUninit<T>>::get(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &(*_4);
        _2 = MaybeUninit::<T>::as_ptr(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &(*_2);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::force_get_mut(_1: &mut once::Once<T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: *mut T;
    let mut _3: &mut core::mem::MaybeUninit<T>;
    let mut _4: *mut core::mem::MaybeUninit<T>;
    let mut _5: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;

    bb0: {
        _5 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _4 = UnsafeCell::<MaybeUninit<T>>::get(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &mut (*_4);
        _2 = MaybeUninit::<T>::as_mut_ptr(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &mut (*_2);
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::force_into_inner(_1: once::Once<T, R>) -> T {
    debug self => _1;
    let mut _0: T;
    let mut _2: *const T;
    let mut _3: &core::mem::MaybeUninit<T>;
    let _4: *mut core::mem::MaybeUninit<T>;
    let mut _5: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;

    bb0: {
        _5 = &(_1.2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _4 = UnsafeCell::<MaybeUninit<T>>::get(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &(*_4);
        _2 = MaybeUninit::<T>::as_ptr(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = ptr::const_ptr::<impl *const T>::read(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        drop(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get(_1: &once::Once<T, R>) -> Option<&T> {
    debug self => _1;
    let mut _0: core::option::Option<&T>;
    let mut _2: once::status::Status;
    let mut _3: &once::status::AtomicStatus;
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: u8;
    let _6: &T;
    scope 1 {
    }

    bb0: {
        _3 = &((*_1).1: once::status::AtomicStatus);
        _4 = Acquire;
        _2 = AtomicStatus::load(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [2: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<&T>::None;
        goto -> bb5;
    }

    bb3: {
        _6 = once::Once::<T, R>::force_get(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Option::<&T>::Some(_6);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_unchecked(_1: &once::Once<T, R>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: bool;
    let mut _3: (&once::status::Status, &once::status::Status);
    let mut _4: &once::status::Status;
    let _5: once::status::Status;
    let mut _6: &once::status::AtomicStatus;
    let mut _7: core::sync::atomic::Ordering;
    let _8: &once::status::Status;
    let _9: &once::status::Status;
    let mut _10: bool;
    let _12: !;
    let mut _13: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _14: core::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _17: &once::status::Status;
    scope 1 {
        debug left_val => _8;
        debug right_val => _9;
        let _11: core::panicking::AssertKind;
        scope 2 {
            debug kind => _11;
            let mut _16: &[&str; 1];
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb6, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).1: once::status::AtomicStatus);
        _7 = SeqCst;
        _5 = AtomicStatus::load(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _17 = const _;
        _3 = (move _4, _17);
        _8 = (_3.0: &once::status::Status);
        _9 = (_3.1: &once::status::Status);
        _10 = <Status as PartialEq>::eq(_8, _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _10) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _11 = core::panicking::AssertKind::Eq;
        _16 = const _;
        _15 = _16 as &[&str] (PointerCoercion(Unsize));
        _14 = Arguments::<'_>::new_const(move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Option::<Arguments<'_>>::Some(move _14);
        _12 = assert_failed::<Status, Status>(move _11, _8, _9, move _13) -> unwind unreachable;
    }

    bb6: {
        _0 = once::Once::<T, R>::force_get(_1) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_unchecked: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Attempted to access an uninitialized Once. If this was run without debug checks, this would be undefined behaviour. This is a serious bug and you must fix it."];
        _0 = &_1;
        return;
    }
}

promoted[1] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_unchecked: &Status = {
    let mut _0: &once::status::Status;
    let mut _1: once::status::Status;

    bb0: {
        _1 = Status::Complete;
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_mut(_1: &mut once::Once<T, R>) -> Option<&mut T> {
    debug self => _1;
    let mut _0: core::option::Option<&mut T>;
    let mut _2: &mut once::status::Status;
    let mut _3: &mut once::status::AtomicStatus;
    let mut _4: u8;
    let mut _5: &mut T;
    scope 1 {
    }

    bb0: {
        _3 = &mut ((*_1).1: once::status::AtomicStatus);
        _2 = AtomicStatus::get_mut(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant((*_2));
        switchInt(move _4) -> [2: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<&mut T>::None;
        goto -> bb5;
    }

    bb3: {
        _5 = once::Once::<T, R>::force_get_mut(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Option::<&mut T>::Some(_5);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_mut_unchecked(_1: &mut once::Once<T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: bool;
    let mut _3: (&once::status::Status, &once::status::Status);
    let mut _4: &once::status::Status;
    let _5: once::status::Status;
    let mut _6: &once::status::AtomicStatus;
    let mut _7: core::sync::atomic::Ordering;
    let _8: &once::status::Status;
    let _9: &once::status::Status;
    let mut _10: bool;
    let _12: !;
    let mut _13: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _14: core::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _17: &once::status::Status;
    scope 1 {
        debug left_val => _8;
        debug right_val => _9;
        let _11: core::panicking::AssertKind;
        scope 2 {
            debug kind => _11;
            let mut _16: &[&str; 1];
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb6, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).1: once::status::AtomicStatus);
        _7 = SeqCst;
        _5 = AtomicStatus::load(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _17 = const _;
        _3 = (move _4, _17);
        _8 = (_3.0: &once::status::Status);
        _9 = (_3.1: &once::status::Status);
        _10 = <Status as PartialEq>::eq(_8, _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _10) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _11 = core::panicking::AssertKind::Eq;
        _16 = const _;
        _15 = _16 as &[&str] (PointerCoercion(Unsize));
        _14 = Arguments::<'_>::new_const(move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Option::<Arguments<'_>>::Some(move _14);
        _12 = assert_failed::<Status, Status>(move _11, _8, _9, move _13) -> unwind unreachable;
    }

    bb6: {
        _0 = once::Once::<T, R>::force_get_mut(_1) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_mut_unchecked: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Attempted to access an unintialized Once.  If this was to run without debug checks, this would be undefined behavior.  This is a serious bug and you must fix it."];
        _0 = &_1;
        return;
    }
}

promoted[1] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::get_mut_unchecked: &Status = {
    let mut _0: &once::status::Status;
    let mut _1: once::status::Status;

    bb0: {
        _1 = Status::Complete;
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::try_into_inner(_1: once::Once<T, R>) -> Option<T> {
    debug self => _1;
    let mut _0: core::option::Option<T>;
    let mut _2: &mut once::status::Status;
    let mut _3: &mut once::status::AtomicStatus;
    let mut _4: u8;
    let mut _5: T;
    let mut _6: once::Once<T, R>;
    let mut _7: bool;
    scope 1 {
    }

    bb0: {
        _7 = const false;
        _7 = const true;
        _3 = &mut (_1.1: once::status::AtomicStatus);
        _2 = AtomicStatus::get_mut(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant((*_2));
        switchInt(move _4) -> [2: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<T>::None;
        goto -> bb5;
    }

    bb3: {
        _7 = const false;
        _6 = move _1;
        _5 = once::Once::<T, R>::force_into_inner(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Option::<T>::Some(move _5);
        goto -> bb5;
    }

    bb5: {
        switchInt(_7) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        return;
    }

    bb7: {
        drop(_1) -> [return: bb6, unwind unreachable];
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::into_inner_unchecked(_1: once::Once<T, R>) -> T {
    debug self => _1;
    let mut _0: T;
    let mut _2: bool;
    let mut _3: (&once::status::Status, &once::status::Status);
    let mut _4: &once::status::Status;
    let _5: once::status::Status;
    let mut _6: &once::status::AtomicStatus;
    let mut _7: core::sync::atomic::Ordering;
    let _8: &once::status::Status;
    let _9: &once::status::Status;
    let mut _10: bool;
    let _12: !;
    let mut _13: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _14: core::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: once::Once<T, R>;
    let mut _18: &once::status::Status;
    scope 1 {
        debug left_val => _8;
        debug right_val => _9;
        let _11: core::panicking::AssertKind;
        scope 2 {
            debug kind => _11;
            let mut _17: &[&str; 1];
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb6, otherwise: bb1];
    }

    bb1: {
        _6 = &(_1.1: once::status::AtomicStatus);
        _7 = SeqCst;
        _5 = AtomicStatus::load(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _18 = const _;
        _3 = (move _4, _18);
        _8 = (_3.0: &once::status::Status);
        _9 = (_3.1: &once::status::Status);
        _10 = <Status as PartialEq>::eq(_8, _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _10) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _11 = core::panicking::AssertKind::Eq;
        _17 = const _;
        _15 = _17 as &[&str] (PointerCoercion(Unsize));
        _14 = Arguments::<'_>::new_const(move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Option::<Arguments<'_>>::Some(move _14);
        _12 = assert_failed::<Status, Status>(move _11, _8, _9, move _13) -> unwind unreachable;
    }

    bb6: {
        _16 = move _1;
        _0 = once::Once::<T, R>::force_into_inner(move _16) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::into_inner_unchecked: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Attempted to access an unintialized Once.  If this was to run without debug checks, this would be undefined behavior.  This is a serious bug and you must fix it."];
        _0 = &_1;
        return;
    }
}

promoted[1] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::into_inner_unchecked: &Status = {
    let mut _0: &once::status::Status;
    let mut _1: once::status::Status;

    bb0: {
        _1 = Status::Complete;
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::is_completed(_1: &once::Once<T, R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &once::status::Status;
    let _3: once::status::Status;
    let mut _4: &once::status::AtomicStatus;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: &once::status::Status;

    bb0: {
        _4 = &((*_1).1: once::status::AtomicStatus);
        _5 = Acquire;
        _3 = AtomicStatus::load(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = &_3;
        _6 = const _;
        _0 = <Status as PartialEq>::eq(move _2, _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:340:1: 340:22>::is_completed: &Status = {
    let mut _0: &once::status::Status;
    let mut _1: once::status::Status;

    bb0: {
        _1 = Status::Complete;
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:491:1: 491:34>::from(_1: T) -> once::Once<T, R> {
    debug data => _1;
    let mut _0: once::Once<T, R>;

    bb0: {
        _0 = once::Once::<T, R>::initialized(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:497:1: 497:31>::drop(_1: &mut once::Once<T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: &once::status::Status;
    let _4: &mut once::status::Status;
    let mut _5: &mut once::status::AtomicStatus;
    let _6: ();
    let mut _7: *mut T;
    let mut _8: &mut core::mem::MaybeUninit<T>;
    let mut _9: *mut core::mem::MaybeUninit<T>;
    let mut _10: &core::cell::UnsafeCell<core::mem::MaybeUninit<T>>;
    let mut _11: &once::status::Status;
    scope 1 {
    }

    bb0: {
        _5 = &mut ((*_1).1: once::status::AtomicStatus);
        _4 = AtomicStatus::get_mut(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &(*_4);
        _11 = const _;
        _2 = <Status as PartialEq>::eq(move _3, _11) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _2) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _10 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<T>>);
        _9 = UnsafeCell::<MaybeUninit<T>>::get(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = &mut (*_9);
        _7 = MaybeUninit::<T>::as_mut_ptr(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = core::ptr::drop_in_place::<T>(move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:497:1: 497:31>::drop: &Status = {
    let mut _0: &once::status::Status;
    let mut _1: once::status::Status;

    bb0: {
        _1 = Status::Complete;
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/once.rs:513:1: 513:29>::drop(_1: &mut Finish<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: once::status::Status;
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: &once::status::AtomicStatus;

    bb0: {
        _5 = deref_copy ((*_1).0: &once::status::AtomicStatus);
        _3 = Status::Panicked;
        _4 = SeqCst;
        _2 = AtomicStatus::store(_5, move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn relax::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/relax.rs:23:1: 23:28>::relax() -> () {
    let mut _0: ();
    let _1: ();
    scope 1 {
    }

    bb0: {
        _1 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn relax::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/relax.rs:58:1: 58:28>::relax() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

const READER: usize = {
    let mut _0: usize;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 2_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_usize, const 2_i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const UPGRADED: usize = {
    let mut _0: usize;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 1_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_usize, const 1_i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const WRITER: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:123:1: 123:24>::new(_1: T) -> rwlock::RwLock<T, R> {
    debug data => _1;
    let mut _0: rwlock::RwLock<T, R>;
    let mut _2: core::sync::atomic::AtomicUsize;
    let mut _3: core::cell::UnsafeCell<T>;

    bb0: {
        _2 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = UnsafeCell::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rwlock::RwLock::<T, R> { phantom: const ZeroSized: PhantomData<R>, lock: move _2, data: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:123:1: 123:24>::new(_1: T) -> rwlock::RwLock<T, R> {
    debug data => _1;
    let mut _0: rwlock::RwLock<T, R>;
    let mut _2: core::marker::PhantomData<R>;
    let mut _3: core::sync::atomic::AtomicUsize;
    let mut _4: core::cell::UnsafeCell<T>;
    let mut _5: T;
    let mut _6: bool;

    bb0: {
        _6 = const false;
        _6 = const true;
        StorageLive(_2);
        _2 = PhantomData::<R>;
        StorageLive(_3);
        ConstEvalCounter;
        _3 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_4);
        StorageLive(_5);
        _6 = const false;
        _5 = move _1;
        ConstEvalCounter;
        _4 = UnsafeCell::<T>::new(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        _0 = rwlock::RwLock::<T, R> { phantom: move _2, lock: move _3, data: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:123:1: 123:24>::into_inner(_1: rwlock::RwLock<T, R>) -> T {
    debug self => _1;
    let mut _0: T;
    let _2: core::cell::UnsafeCell<T>;
    scope 1 {
        debug data => _2;
    }

    bb0: {
        _2 = move (_1.2: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::into_inner(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:123:1: 123:24>::as_mut_ptr(_1: &rwlock::RwLock<T, R>) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: &core::cell::UnsafeCell<T>;

    bb0: {
        _2 = &((*_1).2: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::get(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:186:1: 186:47>::read(_1: &rwlock::RwLock<T, R>) -> rwlock::RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rwlock::RwLockReadGuard<'_, T>;
    let mut _2: ();
    let mut _3: core::option::Option<rwlock::RwLockReadGuard<'_, T>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = rwlock::RwLock::<T, R>::try_read(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rwlock::RwLockReadGuard<'_, T>);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:186:1: 186:47>::write(_1: &rwlock::RwLock<T, R>) -> rwlock::RwLockWriteGuard<'_, T, R> {
    debug self => _1;
    let mut _0: rwlock::RwLockWriteGuard<'_, T, R>;
    let mut _2: ();
    let mut _3: core::option::Option<rwlock::RwLockWriteGuard<'_, T, R>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = rwlock::RwLock::<T, R>::try_write_internal(_1, const false) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rwlock::RwLockWriteGuard<'_, T, R>);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:186:1: 186:47>::upgradeable_read(_1: &rwlock::RwLock<T, R>) -> rwlock::RwLockUpgradableGuard<'_, T, R> {
    debug self => _1;
    let mut _0: rwlock::RwLockUpgradableGuard<'_, T, R>;
    let mut _2: ();
    let mut _3: core::option::Option<rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = rwlock::RwLock::<T, R>::try_upgradeable_read(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rwlock::RwLockUpgradableGuard<'_, T, R>);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::acquire_reader(_1: &rwlock::RwLock<T, R>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: &core::sync::atomic::AtomicUsize;
    let mut _3: core::sync::atomic::Ordering;
    let mut _4: bool;
    let mut _5: usize;
    let mut _6: (usize, bool);
    let _7: usize;
    let mut _8: &core::sync::atomic::AtomicUsize;
    let mut _9: core::sync::atomic::Ordering;
    let _10: !;
    scope 1 {
        debug value => _0;
    }

    bb0: {
        _2 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _3 = Acquire;
        _0 = AtomicUsize::fetch_add(move _2, const _, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(const _, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: usize);
        _4 = Gt(_0, move _5);
        switchInt(move _4) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _8 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _9 = Relaxed;
        _7 = AtomicUsize::fetch_sub(move _8, const _, move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = panic(const "Too many lock readers, cannot safely proceed") -> unwind unreachable;
    }

    bb5: {
        return;
    }
}

const MAX_READERS: usize = {
    let mut _0: usize;
    let mut _1: usize;
    let mut _2: bool;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = Eq(const _, const 0_usize);
        assert(!move _2, "attempt to divide `{}` by zero", const _) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Div(const _, const _);
        _3 = Eq(const 2_usize, const 0_usize);
        assert(!move _3, "attempt to divide `{}` by zero", _1) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = Div(move _1, const 2_usize);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::try_read(_1: &rwlock::RwLock<T, R>) -> Option<rwlock::RwLockReadGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<rwlock::RwLockReadGuard<'_, T>>;
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let _5: usize;
    let mut _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: rwlock::RwLockReadGuard<'_, T>;
    let _9: &core::sync::atomic::AtomicUsize;
    let mut _10: *const T;
    let _11: &T;
    let _12: *mut T;
    let mut _13: &core::cell::UnsafeCell<T>;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = rwlock::RwLock::<T, R>::acquire_reader(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = BitOr(const _, const _);
        _3 = BitAnd(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _7 = Release;
        _5 = AtomicUsize::fetch_sub(move _6, const _, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<rwlock::RwLockReadGuard<'_, T>>::None;
        goto -> bb6;
    }

    bb4: {
        _9 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _13 = &((*_1).2: core::cell::UnsafeCell<T>);
        _12 = UnsafeCell::<T>::get(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = &(*_12);
        _10 = &raw const (*_11);
        _8 = rwlock::RwLockReadGuard::<'_, T> { lock: _9, data: move _10 };
        _0 = Option::<rwlock::RwLockReadGuard<'_, T>>::Some(move _8);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::reader_count(_1: &rwlock::RwLock<T, R>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let _2: usize;
    let mut _3: &core::sync::atomic::AtomicUsize;
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: (usize, bool);
    scope 1 {
        debug state => _2;
    }

    bb0: {
        _3 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _4 = Relaxed;
        _2 = AtomicUsize::load(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Eq(const _, const 0_usize);
        assert(!move _6, "attempt to divide `{}` by zero", _2) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Div(_2, const _);
        _8 = BitAnd(_2, const _);
        _9 = Eq(const _, const 0_usize);
        assert(!move _9, "attempt to divide `{}` by zero", _8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Div(move _8, const _);
        _10 = CheckedAdd(_5, _7);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _5, move _7) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _0 = move (_10.0: usize);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::writer_count(_1: &rwlock::RwLock<T, R>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: &core::sync::atomic::AtomicUsize;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: bool;

    bb0: {
        _4 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _5 = Relaxed;
        _3 = AtomicUsize::load(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, const _);
        _6 = Eq(const _, const 0_usize);
        assert(!move _6, "attempt to divide `{}` by zero", _2) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Div(move _2, const _);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::force_read_decrement(_1: &rwlock::RwLock<T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: usize;
    let mut _9: !;
    let _10: usize;
    let mut _11: &core::sync::atomic::AtomicUsize;
    let mut _12: core::sync::atomic::Ordering;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _7 = Relaxed;
        _5 = AtomicUsize::load(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(const _);
        _4 = BitAnd(move _5, move _8);
        _3 = Gt(move _4, const 0_usize);
        switchInt(move _3) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = panic(const "assertion failed: self.lock.load(Ordering::Relaxed) & !WRITER > 0") -> unwind unreachable;
    }

    bb4: {
        _11 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _12 = Release;
        _10 = AtomicUsize::fetch_sub(move _11, const _, move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::force_write_unlock(_1: &rwlock::RwLock<T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: &core::sync::atomic::AtomicUsize;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: usize;
    let mut _10: usize;
    let _11: &usize;
    let _12: &usize;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: usize;
    let _17: !;
    let mut _18: core::option::Option<core::fmt::Arguments<'_>>;
    let _19: usize;
    let mut _20: &core::sync::atomic::AtomicUsize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: core::sync::atomic::Ordering;
    let mut _24: &usize;
    scope 1 {
        debug left_val => _11;
        debug right_val => _12;
        let _16: core::panicking::AssertKind;
        scope 2 {
            debug kind => _16;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _7 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _8 = Relaxed;
        _6 = AtomicUsize::load(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = BitOr(const _, const _);
        _9 = Not(move _10);
        _5 = BitAnd(move _6, move _9);
        _4 = &_5;
        _24 = const _;
        _3 = (move _4, _24);
        _11 = (_3.0: &usize);
        _12 = (_3.1: &usize);
        _14 = (*_11);
        _15 = (*_12);
        _13 = Eq(move _14, move _15);
        switchInt(move _13) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = assert_failed::<usize, usize>(move _16, _11, _12, move _18) -> unwind unreachable;
    }

    bb4: {
        _20 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _22 = BitOr(const _, const _);
        _21 = Not(move _22);
        _23 = Release;
        _19 = AtomicUsize::fetch_and(move _20, move _21, move _23) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::force_write_unlock: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::try_write_internal(_1: &rwlock::RwLock<T, R>, _2: bool) -> Option<rwlock::RwLockWriteGuard<'_, T, R>> {
    debug self => _1;
    debug strong => _2;
    let mut _0: core::option::Option<rwlock::RwLockWriteGuard<'_, T, R>>;
    let mut _3: bool;
    let mut _4: &core::result::Result<usize, usize>;
    let _5: core::result::Result<usize, usize>;
    let _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: rwlock::RwLockWriteGuard<'_, T, R>;
    let mut _10: *mut T;
    let mut _11: &mut T;
    let mut _12: *mut T;
    let mut _13: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _6 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _7 = Acquire;
        _8 = Relaxed;
        _5 = compare_exchange(_6, const 0_usize, const _, move _7, move _8, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = Result::<usize, usize>::is_ok(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _3) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _13 = &((*_1).2: core::cell::UnsafeCell<T>);
        _12 = UnsafeCell::<T>::get(move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = &mut (*_12);
        _10 = &raw mut (*_11);
        _9 = rwlock::RwLockWriteGuard::<'_, T, R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _10 };
        _0 = Option::<rwlock::RwLockWriteGuard<'_, T, R>>::Some(move _9);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<rwlock::RwLockWriteGuard<'_, T, R>>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::try_write(_1: &rwlock::RwLock<T, R>) -> Option<rwlock::RwLockWriteGuard<'_, T, R>> {
    debug self => _1;
    let mut _0: core::option::Option<rwlock::RwLockWriteGuard<'_, T, R>>;

    bb0: {
        _0 = rwlock::RwLock::<T, R>::try_write_internal(_1, const true) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::try_upgradeable_read(_1: &rwlock::RwLock<T, R>) -> Option<rwlock::RwLockUpgradableGuard<'_, T, R>> {
    debug self => _1;
    let mut _0: core::option::Option<rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: &core::sync::atomic::AtomicUsize;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: usize;
    let mut _7: rwlock::RwLockUpgradableGuard<'_, T, R>;
    let mut _8: *const T;
    let _9: &T;
    let _10: *mut T;
    let mut _11: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _4 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _5 = Acquire;
        _3 = AtomicUsize::fetch_or(move _4, const _, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = BitOr(const _, const _);
        _2 = BitAnd(move _3, move _6);
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _11 = &((*_1).2: core::cell::UnsafeCell<T>);
        _10 = UnsafeCell::<T>::get(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = &(*_10);
        _8 = &raw const (*_9);
        _7 = rwlock::RwLockUpgradableGuard::<'_, T, R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _8 };
        _0 = Option::<rwlock::RwLockUpgradableGuard<'_, T, R>>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<rwlock::RwLockUpgradableGuard<'_, T, R>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:259:1: 259:32>::get_mut(_1: &mut rwlock::RwLock<T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: *mut T;
    let mut _3: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _3 = &((*_1).2: core::cell::UnsafeCell<T>);
        _2 = UnsafeCell::<T>::get(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &mut (*_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt(_1: &rwlock::RwLock<T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<rwlock::RwLockReadGuard<'_, T>>;
    let mut _4: isize;
    let _5: rwlock::RwLockReadGuard<'_, T>;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:451:27: 451:31};
    let mut _12: &rwlock::RwLockReadGuard<'_, T>;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:452:27: 452:31};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug guard => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = rwlock::RwLock::<T, R>::try_read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb9, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Some).0: rwlock::RwLockReadGuard<'_, T>);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:451:27: 451:31} { guard: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:451:27: 451:31}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:452:27: 452:31} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:452:27: 452:31}>(move _6, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        drop(_5) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "RwLock { <locked> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "RwLock { data: "];
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:451:27: 451:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug guard => (*(_1.0: &rwlock::RwLockReadGuard<'_, T>));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;
    let mut _4: &rwlock::RwLockReadGuard<'_, T>;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _4 = deref_copy (_1.0: &rwlock::RwLockReadGuard<'_, T>);
        _3 = <rwlock::RwLockReadGuard<'_, T> as Deref>::deref(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_3, _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:452:27: 452:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:447:1: 447:60>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:458:1: 458:54>::default() -> rwlock::RwLock<T, R> {
    let mut _0: rwlock::RwLock<T, R>;
    let mut _1: T;

    bb0: {
        _1 = <T as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rwlock::RwLock::<T, R>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:464:1: 464:36>::from(_1: T) -> rwlock::RwLock<T, R> {
    debug data => _1;
    let mut _0: rwlock::RwLock<T, R>;

    bb0: {
        _0 = rwlock::RwLock::<T, R>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:470:1: 470:53>::leak(_1: rwlock::RwLockReadGuard<'_, T>) -> &T {
    debug this => _1;
    let mut _0: &T;
    let _2: core::mem::ManuallyDrop<rwlock::RwLockReadGuard<'_, T>>;
    let _3: &rwlock::RwLockReadGuard<'_, T>;
    let mut _4: &core::mem::ManuallyDrop<rwlock::RwLockReadGuard<'_, T>>;
    let mut _5: *const T;
    scope 1 {
        debug this => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = ManuallyDrop::<rwlock::RwLockReadGuard<'_, T>>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_2;
        _3 = <ManuallyDrop<rwlock::RwLockReadGuard<'_, T>> as Deref>::deref(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = deref_copy ((*_3).1: *const T);
        _0 = &(*_5);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:490:1: 490:81>::fmt(_1: &rwlock::RwLockReadGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockReadGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:496:1: 496:85>::fmt(_1: &rwlock::RwLockReadGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockReadGuard<'_, T> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Display>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:502:1: 502:80>::upgrade(_1: rwlock::RwLockUpgradableGuard<'_, T, R>) -> rwlock::RwLockWriteGuard<'_, T, R> {
    debug self => _1;
    let mut _0: rwlock::RwLockWriteGuard<'_, T, R>;
    let mut _2: core::result::Result<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let mut _3: rwlock::RwLockUpgradableGuard<'_, T, R>;
    let mut _4: isize;
    let _5: rwlock::RwLockUpgradableGuard<'_, T, R>;
    let _6: ();
    scope 1 {
        debug guard => _0;
    }
    scope 2 {
        debug e => _5;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = move _1;
        _2 = rwlock::RwLockUpgradableGuard::<'_, T, R>::try_upgrade_internal(move _3, const false) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _5 = move ((_2 as Err).0: rwlock::RwLockUpgradableGuard<'_, T, R>);
        _1 = move _5;
        _6 = <R as RelaxStrategy>::relax() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_2 as Ok).0: rwlock::RwLockWriteGuard<'_, T, R>);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:524:1: 524:65>::try_upgrade_internal(_1: rwlock::RwLockUpgradableGuard<'_, T, R>, _2: bool) -> Result<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>> {
    debug self => _1;
    debug strong => _2;
    let mut _0: core::result::Result<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let mut _3: bool;
    let mut _4: &core::result::Result<usize, usize>;
    let _5: core::result::Result<usize, usize>;
    let _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: core::sync::atomic::Ordering;
    let _9: &rwlock::RwLock<T, R>;
    let _10: ();
    let mut _11: rwlock::RwLockWriteGuard<'_, T, R>;
    let mut _12: *mut T;
    let mut _13: &mut T;
    let mut _14: *mut T;
    let mut _15: &core::cell::UnsafeCell<T>;
    let mut _16: &rwlock::RwLock<T, R>;
    scope 1 {
        debug inner => _9;
        scope 2 {
        }
    }

    bb0: {
        _16 = deref_copy (_1.1: &rwlock::RwLock<T, R>);
        _6 = &((*_16).1: core::sync::atomic::AtomicUsize);
        _7 = Acquire;
        _8 = Relaxed;
        _5 = compare_exchange(_6, const _, const _, move _7, move _8, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = Result::<usize, usize>::is_ok(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _3) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _9 = (_1.1: &rwlock::RwLock<T, R>);
        _10 = core::mem::forget::<rwlock::RwLockUpgradableGuard<'_, T, R>>(move _1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &((*_9).2: core::cell::UnsafeCell<T>);
        _14 = UnsafeCell::<T>::get(move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = &mut (*_14);
        _12 = &raw mut (*_13);
        _11 = rwlock::RwLockWriteGuard::<'_, T, R> { phantom: const ZeroSized: PhantomData<R>, inner: _9, data: move _12 };
        _0 = Result::<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>>::Ok(move _11);
        goto -> bb7;
    }

    bb6: {
        _0 = Result::<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>>::Err(move _1);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:524:1: 524:65>::try_upgrade(_1: rwlock::RwLockUpgradableGuard<'_, T, R>) -> Result<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>> {
    debug self => _1;
    let mut _0: core::result::Result<rwlock::RwLockWriteGuard<'_, T, R>, rwlock::RwLockUpgradableGuard<'_, T, R>>;

    bb0: {
        _0 = rwlock::RwLockUpgradableGuard::<'_, T, R>::try_upgrade_internal(move _1, const true) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:524:1: 524:65>::downgrade(_1: rwlock::RwLockUpgradableGuard<'_, T, R>) -> rwlock::RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rwlock::RwLockReadGuard<'_, T>;
    let _2: usize;
    let _3: &rwlock::RwLock<T, R>;
    let _4: ();
    let _5: &core::sync::atomic::AtomicUsize;
    let mut _6: *const T;
    let _7: &T;
    let _8: *mut T;
    let mut _9: &core::cell::UnsafeCell<T>;
    let mut _10: &rwlock::RwLock<T, R>;
    scope 1 {
        debug inner => _3;
        scope 2 {
        }
    }

    bb0: {
        _10 = deref_copy (_1.1: &rwlock::RwLock<T, R>);
        _2 = rwlock::RwLock::<T, R>::acquire_reader(_10) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_1.1: &rwlock::RwLock<T, R>);
        _4 = core::mem::drop::<rwlock::RwLockUpgradableGuard<'_, T, R>>(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &((*_3).1: core::sync::atomic::AtomicUsize);
        _9 = &((*_3).2: core::cell::UnsafeCell<T>);
        _8 = UnsafeCell::<T>::get(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = &(*_8);
        _6 = &raw const (*_7);
        _0 = rwlock::RwLockReadGuard::<'_, T> { lock: _5, data: move _6 };
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:524:1: 524:65>::leak(_1: rwlock::RwLockUpgradableGuard<'_, T, R>) -> &T {
    debug this => _1;
    let mut _0: &T;
    let _2: core::mem::ManuallyDrop<rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let _3: &rwlock::RwLockUpgradableGuard<'_, T, R>;
    let mut _4: &core::mem::ManuallyDrop<rwlock::RwLockUpgradableGuard<'_, T, R>>;
    let mut _5: *const T;
    scope 1 {
        debug this => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = ManuallyDrop::<rwlock::RwLockUpgradableGuard<'_, T, R>>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_2;
        _3 = <ManuallyDrop<rwlock::RwLockUpgradableGuard<'_, T, R>> as Deref>::deref(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = deref_copy ((*_3).2: *const T);
        _0 = &(*_5);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:617:1: 617:93>::fmt(_1: &rwlock::RwLockUpgradableGuard<'_, T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockUpgradableGuard<'_, T, R> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:623:1: 623:97>::fmt(_1: &rwlock::RwLockUpgradableGuard<'_, T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockUpgradableGuard<'_, T, R> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Display>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:629:1: 629:60>::downgrade(_1: rwlock::RwLockWriteGuard<'_, T, R>) -> rwlock::RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rwlock::RwLockReadGuard<'_, T>;
    let _2: usize;
    let _3: &rwlock::RwLock<T, R>;
    let _4: ();
    let _5: &core::sync::atomic::AtomicUsize;
    let mut _6: *const T;
    let _7: &T;
    let _8: *mut T;
    let mut _9: &core::cell::UnsafeCell<T>;
    let mut _10: &rwlock::RwLock<T, R>;
    scope 1 {
        debug inner => _3;
        scope 2 {
        }
    }

    bb0: {
        _10 = deref_copy (_1.1: &rwlock::RwLock<T, R>);
        _2 = rwlock::RwLock::<T, R>::acquire_reader(_10) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_1.1: &rwlock::RwLock<T, R>);
        _4 = core::mem::drop::<rwlock::RwLockWriteGuard<'_, T, R>>(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &((*_3).1: core::sync::atomic::AtomicUsize);
        _9 = &((*_3).2: core::cell::UnsafeCell<T>);
        _8 = UnsafeCell::<T>::get(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = &(*_8);
        _6 = &raw const (*_7);
        _0 = rwlock::RwLockReadGuard::<'_, T> { lock: _5, data: move _6 };
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:629:1: 629:60>::downgrade_to_upgradeable(_1: rwlock::RwLockWriteGuard<'_, T, R>) -> rwlock::RwLockUpgradableGuard<'_, T, R> {
    debug self => _1;
    let mut _0: rwlock::RwLockUpgradableGuard<'_, T, R>;
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: &core::sync::atomic::AtomicUsize;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: usize;
    let _10: &usize;
    let _11: &usize;
    let mut _12: bool;
    let mut _13: usize;
    let mut _14: usize;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let _18: ();
    let mut _19: &core::sync::atomic::AtomicUsize;
    let mut _20: core::sync::atomic::Ordering;
    let _21: &rwlock::RwLock<T, R>;
    let _22: ();
    let mut _23: *const T;
    let _24: &T;
    let _25: *mut T;
    let mut _26: &core::cell::UnsafeCell<T>;
    let mut _27: &usize;
    let mut _28: &rwlock::RwLock<T, R>;
    let mut _29: &rwlock::RwLock<T, R>;
    scope 1 {
        debug left_val => _10;
        debug right_val => _11;
        let _15: core::panicking::AssertKind;
        scope 2 {
            debug kind => _15;
        }
    }
    scope 3 {
        debug inner => _21;
        scope 4 {
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _28 = deref_copy (_1.1: &rwlock::RwLock<T, R>);
        _7 = &((*_28).1: core::sync::atomic::AtomicUsize);
        _8 = Acquire;
        _6 = AtomicUsize::load(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = BitOr(const _, const _);
        _5 = BitAnd(move _6, move _9);
        _4 = &_5;
        _27 = const _;
        _3 = (move _4, _27);
        _10 = (_3.0: &usize);
        _11 = (_3.1: &usize);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = assert_failed::<usize, usize>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb4: {
        _29 = deref_copy (_1.1: &rwlock::RwLock<T, R>);
        _19 = &((*_29).1: core::sync::atomic::AtomicUsize);
        _20 = Release;
        _18 = AtomicUsize::store(move _19, const _, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _21 = (_1.1: &rwlock::RwLock<T, R>);
        _22 = core::mem::forget::<rwlock::RwLockWriteGuard<'_, T, R>>(move _1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _26 = &((*_21).2: core::cell::UnsafeCell<T>);
        _25 = UnsafeCell::<T>::get(move _26) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _24 = &(*_25);
        _23 = &raw const (*_24);
        _0 = rwlock::RwLockUpgradableGuard::<'_, T, R> { phantom: const ZeroSized: PhantomData<R>, inner: _21, data: move _23 };
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:629:1: 629:60>::downgrade_to_upgradeable: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:629:1: 629:60>::leak(_1: rwlock::RwLockWriteGuard<'_, T, R>) -> &mut T {
    debug this => _1;
    let mut _0: &mut T;
    let mut _2: core::mem::ManuallyDrop<rwlock::RwLockWriteGuard<'_, T, R>>;
    let mut _3: &mut rwlock::RwLockWriteGuard<'_, T, R>;
    let mut _4: &mut core::mem::ManuallyDrop<rwlock::RwLockWriteGuard<'_, T, R>>;
    let mut _5: *mut T;
    scope 1 {
        debug this => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = ManuallyDrop::<rwlock::RwLockWriteGuard<'_, T, R>>::new(move _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <ManuallyDrop<rwlock::RwLockWriteGuard<'_, T, R>> as DerefMut>::deref_mut(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = deref_copy ((*_3).2: *mut T);
        _0 = &mut (*_5);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:711:1: 711:88>::fmt(_1: &rwlock::RwLockWriteGuard<'_, T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockWriteGuard<'_, T, R> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:717:1: 717:92>::fmt(_1: &rwlock::RwLockWriteGuard<'_, T, R>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;

    bb0: {
        _3 = <rwlock::RwLockWriteGuard<'_, T, R> as Deref>::deref(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <T as Display>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:723:1: 723:63>::deref(_1: &rwlock::RwLockReadGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: *const T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).1: *const T);
        _0 = &(*_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:732:1: 732:75>::deref(_1: &rwlock::RwLockUpgradableGuard<'_, T, R>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: *const T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).2: *const T);
        _0 = &(*_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:741:1: 741:70>::deref(_1: &rwlock::RwLockWriteGuard<'_, T, R>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: *mut T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).2: *mut T);
        _0 = &(*_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:750:1: 750:73>::deref_mut(_1: &mut rwlock::RwLockWriteGuard<'_, T, R>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: *mut T;
    scope 1 {
    }

    bb0: {
        _2 = deref_copy ((*_1).2: *mut T);
        _0 = &mut (*_2);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:757:1: 757:62>::drop(_1: &mut rwlock::RwLockReadGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: core::sync::atomic::Ordering;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: !;
    let _10: usize;
    let mut _11: core::sync::atomic::Ordering;
    let mut _12: &core::sync::atomic::AtomicUsize;
    let mut _13: &core::sync::atomic::AtomicUsize;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _12 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _6 = Relaxed;
        _5 = AtomicUsize::load(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = BitOr(const _, const _);
        _7 = Not(move _8);
        _4 = BitAnd(move _5, move _7);
        _3 = Gt(move _4, const 0_usize);
        switchInt(move _3) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = panic(const "assertion failed: self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0") -> unwind unreachable;
    }

    bb4: {
        _13 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _11 = Release;
        _10 = AtomicUsize::fetch_sub(_13, const _, move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:764:1: 764:74>::drop(_1: &mut rwlock::RwLockUpgradableGuard<'_, T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: &core::sync::atomic::AtomicUsize;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: usize;
    let _10: &usize;
    let _11: &usize;
    let mut _12: bool;
    let mut _13: usize;
    let mut _14: usize;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let _18: usize;
    let mut _19: &core::sync::atomic::AtomicUsize;
    let mut _20: core::sync::atomic::Ordering;
    let mut _21: &usize;
    let mut _22: &rwlock::RwLock<T, R>;
    let mut _23: &rwlock::RwLock<T, R>;
    scope 1 {
        debug left_val => _10;
        debug right_val => _11;
        let _15: core::panicking::AssertKind;
        scope 2 {
            debug kind => _15;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _22 = deref_copy ((*_1).1: &rwlock::RwLock<T, R>);
        _7 = &((*_22).1: core::sync::atomic::AtomicUsize);
        _8 = Relaxed;
        _6 = AtomicUsize::load(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = BitOr(const _, const _);
        _5 = BitAnd(move _6, move _9);
        _4 = &_5;
        _21 = const _;
        _3 = (move _4, _21);
        _10 = (_3.0: &usize);
        _11 = (_3.1: &usize);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _15 = core::panicking::AssertKind::Eq;
        _17 = Option::<Arguments<'_>>::None;
        _16 = assert_failed::<usize, usize>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb4: {
        _23 = deref_copy ((*_1).1: &rwlock::RwLock<T, R>);
        _19 = &((*_23).1: core::sync::atomic::AtomicUsize);
        _20 = AcqRel;
        _18 = AtomicUsize::fetch_sub(move _19, const _, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:764:1: 764:74>::drop: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:774:1: 774:69>::drop(_1: &mut rwlock::RwLockWriteGuard<'_, T, R>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: &core::sync::atomic::AtomicUsize;
    let mut _8: core::sync::atomic::Ordering;
    let _9: &usize;
    let _10: &usize;
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: usize;
    let _15: !;
    let mut _16: core::option::Option<core::fmt::Arguments<'_>>;
    let _17: usize;
    let mut _18: &core::sync::atomic::AtomicUsize;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: core::sync::atomic::Ordering;
    let mut _22: &usize;
    let mut _23: &rwlock::RwLock<T, R>;
    let mut _24: &rwlock::RwLock<T, R>;
    scope 1 {
        debug left_val => _9;
        debug right_val => _10;
        let _14: core::panicking::AssertKind;
        scope 2 {
            debug kind => _14;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _23 = deref_copy ((*_1).1: &rwlock::RwLock<T, R>);
        _7 = &((*_23).1: core::sync::atomic::AtomicUsize);
        _8 = Relaxed;
        _6 = AtomicUsize::load(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, const _);
        _4 = &_5;
        _22 = const _;
        _3 = (move _4, _22);
        _9 = (_3.0: &usize);
        _10 = (_3.1: &usize);
        _12 = (*_9);
        _13 = (*_10);
        _11 = Eq(move _12, move _13);
        switchInt(move _11) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _14 = core::panicking::AssertKind::Eq;
        _16 = Option::<Arguments<'_>>::None;
        _15 = assert_failed::<usize, usize>(move _14, _9, _10, move _16) -> unwind unreachable;
    }

    bb4: {
        _24 = deref_copy ((*_1).1: &rwlock::RwLock<T, R>);
        _18 = &((*_24).1: core::sync::atomic::AtomicUsize);
        _20 = BitOr(const _, const _);
        _19 = Not(move _20);
        _21 = Release;
        _17 = AtomicUsize::fetch_and(move _18, move _19, move _21) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:774:1: 774:69>::drop: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn compare_exchange(_1: &AtomicUsize, _2: usize, _3: usize, _4: core::sync::atomic::Ordering, _5: core::sync::atomic::Ordering, _6: bool) -> Result<usize, usize> {
    debug atomic => _1;
    debug current => _2;
    debug new => _3;
    debug success => _4;
    debug failure => _5;
    debug strong => _6;
    let mut _0: core::result::Result<usize, usize>;

    bb0: {
        switchInt(_6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = AtomicUsize::compare_exchange(_1, _2, _3, _4, _5) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = AtomicUsize::compare_exchange_weak(_1, _2, _3, _4, _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::INIT: rwlock::RwLock<(), R> = {
    let mut _0: rwlock::RwLock<(), R>;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        ConstEvalCounter;
        _0 = rwlock::RwLock::<(), R>::new(move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::lock_exclusive(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockWriteGuard<'_, (), R>;

    bb0: {
        _3 = rwlock::RwLock::<(), R>::write(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = core::mem::forget::<rwlock::RwLockWriteGuard<'_, (), R>>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::try_lock_exclusive(_1: &rwlock::RwLock<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::option::Option<()>;
    let _3: core::option::Option<()>;
    let mut _4: core::option::Option<rwlock::RwLockWriteGuard<'_, (), R>>;

    bb0: {
        _4 = rwlock::RwLock::<(), R>::try_write(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<rwlock::RwLockWriteGuard<'_, (), R>>::map::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:817:30: 817:33}>(move _4, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:817:30: 817:33}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = &_3;
        _0 = Option::<()>::is_some(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::try_lock_exclusive::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:817:30: 817:33}, _2: rwlock::RwLockWriteGuard<'_, (), R>) -> () {
    debug g => _2;
    let mut _0: ();

    bb0: {
        _0 = core::mem::forget::<rwlock::RwLockWriteGuard<'_, (), R>>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::unlock_exclusive(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockWriteGuard<'_, (), R>;
    let mut _4: *mut ();
    let mut _5: &mut ();
    let mut _6: ();

    bb0: {
        _5 = &mut _6;
        _4 = &raw mut (*_5);
        _3 = rwlock::RwLockWriteGuard::<'_, (), R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _4 };
        _2 = core::mem::drop::<rwlock::RwLockWriteGuard<'_, (), R>>(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::lock_shared(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockReadGuard<'_, ()>;

    bb0: {
        _3 = rwlock::RwLock::<(), R>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = core::mem::forget::<rwlock::RwLockReadGuard<'_, ()>>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::try_lock_shared(_1: &rwlock::RwLock<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::option::Option<()>;
    let _3: core::option::Option<()>;
    let mut _4: core::option::Option<rwlock::RwLockReadGuard<'_, ()>>;

    bb0: {
        _4 = rwlock::RwLock::<(), R>::try_read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<rwlock::RwLockReadGuard<'_, ()>>::map::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:838:29: 838:32}>(move _4, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:838:29: 838:32}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = &_3;
        _0 = Option::<()>::is_some(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::try_lock_shared::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:838:29: 838:32}, _2: rwlock::RwLockReadGuard<'_, ()>) -> () {
    debug g => _2;
    let mut _0: ();

    bb0: {
        _0 = core::mem::forget::<rwlock::RwLockReadGuard<'_, ()>>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::unlock_shared(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockReadGuard<'_, ()>;
    let _4: &core::sync::atomic::AtomicUsize;
    let mut _5: *const ();
    let mut _6: &();

    bb0: {
        _4 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _6 = const _;
        _5 = &raw const (*_6);
        _3 = rwlock::RwLockReadGuard::<'_, ()> { lock: _4, data: move _5 };
        _2 = core::mem::drop::<rwlock::RwLockReadGuard<'_, ()>>(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::unlock_shared: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:803:1: 803:74>::is_locked(_1: &rwlock::RwLock<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: usize;
    let mut _3: &core::sync::atomic::AtomicUsize;
    let mut _4: core::sync::atomic::Ordering;

    bb0: {
        _3 = &((*_1).1: core::sync::atomic::AtomicUsize);
        _4 = Relaxed;
        _2 = AtomicUsize::load(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Ne(move _2, const 0_usize);
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::lock_upgradable(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockUpgradableGuard<'_, (), R>;

    bb0: {
        _3 = rwlock::RwLock::<(), R>::upgradeable_read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = core::mem::forget::<rwlock::RwLockUpgradableGuard<'_, (), R>>(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::try_lock_upgradable(_1: &rwlock::RwLock<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &core::option::Option<()>;
    let _3: core::option::Option<()>;
    let mut _4: core::option::Option<rwlock::RwLockUpgradableGuard<'_, (), R>>;

    bb0: {
        _4 = rwlock::RwLock::<(), R>::try_upgradeable_read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<rwlock::RwLockUpgradableGuard<'_, (), R>>::map::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:867:18: 867:21}>(move _4, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:867:18: 867:21}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = &_3;
        _0 = Option::<()>::is_some(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::try_lock_upgradable::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:867:18: 867:21}, _2: rwlock::RwLockUpgradableGuard<'_, (), R>) -> () {
    debug g => _2;
    let mut _0: ();

    bb0: {
        _0 = core::mem::forget::<rwlock::RwLockUpgradableGuard<'_, (), R>>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::unlock_upgradable(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: rwlock::RwLockUpgradableGuard<'_, (), R>;
    let mut _4: *const ();
    let mut _5: &();

    bb0: {
        _5 = const _;
        _4 = &raw const (*_5);
        _3 = rwlock::RwLockUpgradableGuard::<'_, (), R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _4 };
        _2 = core::mem::drop::<rwlock::RwLockUpgradableGuard<'_, (), R>>(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::unlock_upgradable: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::upgrade(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: rwlock::RwLockUpgradableGuard<'_, (), R>;
    let mut _3: *const ();
    let _4: ();
    let mut _5: rwlock::RwLockWriteGuard<'_, (), R>;
    let mut _6: &();
    scope 1 {
        debug tmp_guard => _2;
    }

    bb0: {
        _6 = const _;
        _3 = &raw const (*_6);
        _2 = rwlock::RwLockUpgradableGuard::<'_, (), R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _3 };
        _5 = rwlock::RwLockUpgradableGuard::<'_, (), R>::upgrade(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = core::mem::forget::<rwlock::RwLockWriteGuard<'_, (), R>>(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::upgrade: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::try_upgrade(_1: &rwlock::RwLock<(), R>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: rwlock::RwLockUpgradableGuard<'_, (), R>;
    let mut _3: *const ();
    let mut _4: &core::result::Result<(), rwlock::RwLockUpgradableGuard<'_, (), R>>;
    let _5: core::result::Result<(), rwlock::RwLockUpgradableGuard<'_, (), R>>;
    let mut _6: core::result::Result<rwlock::RwLockWriteGuard<'_, (), R>, rwlock::RwLockUpgradableGuard<'_, (), R>>;
    let mut _7: &();
    scope 1 {
        debug tmp_guard => _2;
    }

    bb0: {
        _7 = const _;
        _3 = &raw const (*_7);
        _2 = rwlock::RwLockUpgradableGuard::<'_, (), R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _3 };
        _6 = rwlock::RwLockUpgradableGuard::<'_, (), R>::try_upgrade(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Result::<rwlock::RwLockWriteGuard<'_, (), R>, rwlock::RwLockUpgradableGuard<'_, (), R>>::map::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:899:18: 899:21}>(move _6, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:899:18: 899:21}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _0 = Result::<(), rwlock::RwLockUpgradableGuard<'_, (), R>>::is_ok(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        drop(_5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

promoted[0] in rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::try_upgrade: &() = {
    let mut _0: &();
    let mut _1: ();

    bb0: {
        _1 = ();
        _0 = &_1;
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:856:1: 856:81>::try_upgrade::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:899:18: 899:21}, _2: rwlock::RwLockWriteGuard<'_, (), R>) -> () {
    debug g => _2;
    let mut _0: ();

    bb0: {
        _0 = core::mem::forget::<rwlock::RwLockWriteGuard<'_, (), R>>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rwlock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.9.8/src/rwlock.rs:905:1: 905:83>::downgrade(_1: &rwlock::RwLock<(), R>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: rwlock::RwLockWriteGuard<'_, (), R>;
    let mut _3: *mut ();
    let mut _4: &mut ();
    let mut _5: ();
    let _6: ();
    let mut _7: rwlock::RwLockReadGuard<'_, ()>;
    scope 1 {
        debug tmp_guard => _2;
    }

    bb0: {
        _4 = &mut _5;
        _3 = &raw mut (*_4);
        _2 = rwlock::RwLockWriteGuard::<'_, (), R> { phantom: const ZeroSized: PhantomData<R>, inner: _1, data: move _3 };
        _7 = rwlock::RwLockWriteGuard::<'_, (), R>::downgrade(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = core::mem::forget::<rwlock::RwLockReadGuard<'_, ()>>(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn BarrierWaitResult(_1: bool) -> BarrierWaitResult {
    let mut _0: barrier::BarrierWaitResult;

    bb0: {
        _0 = BarrierWaitResult(move _1);
        return;
    }
}

// MIR FOR CTFE
fn BarrierWaitResult(_1: bool) -> BarrierWaitResult {
    let mut _0: barrier::BarrierWaitResult;

    bb0: {
        _0 = BarrierWaitResult(move _1);
        return;
    }
}

fn AtomicStatus(_1: core::sync::atomic::AtomicU8) -> AtomicStatus {
    let mut _0: once::status::AtomicStatus;

    bb0: {
        _0 = AtomicStatus(move _1);
        return;
    }
}

// MIR FOR CTFE
fn AtomicStatus(_1: core::sync::atomic::AtomicU8) -> AtomicStatus {
    let mut _0: once::status::AtomicStatus;

    bb0: {
        _0 = AtomicStatus(move _1);
        return;
    }
}
