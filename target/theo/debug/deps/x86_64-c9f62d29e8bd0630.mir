// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const ADDRESS_SPACE_SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 281474976710656_u64;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:10: 27:15>::clone(_1: &addr::VirtAddr) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:23: 27:32>::eq(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:34: 27:36>::assert_receiver_is_total_eq(_1: &addr::VirtAddr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:38: 27:48>::partial_cmp(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:50: 27:53>::cmp(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:27:55: 27:59>::hash(_1: &addr::VirtAddr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:10: 40:15>::clone(_1: &PhysAddr) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:23: 40:32>::eq(_1: &PhysAddr, _2: &PhysAddr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:34: 40:36>::assert_receiver_is_total_eq(_1: &PhysAddr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:38: 40:48>::partial_cmp(_1: &PhysAddr, _2: &PhysAddr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:50: 40:53>::cmp(_1: &PhysAddr, _2: &PhysAddr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:40:55: 40:59>::hash(_1: &PhysAddr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:54:1: 54:43>::fmt(_1: &VirtAddrNotValid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "VirtAddrNotValid";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:54:1: 54:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::new(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: core::result::Result<addr::VirtAddr, addr::VirtAddrNotValid>;
    let _3: &str;

    bb0: {
        _2 = addr::VirtAddr::try_new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = const "address passed to VirtAddr::new must not contain any data in bits 48 to 64";
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::expect(move _2, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::try_new(_1: u64) -> Result<addr::VirtAddr, VirtAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::VirtAddr, addr::VirtAddrNotValid>;
    let mut _2: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: addr::VirtAddr;
    let mut _8: u64;
    let mut _9: addr::VirtAddrNotValid;
    let mut _10: u64;

    bb0: {
        _3 = &_1;
        _4 = Range::<usize> { start: const 47_usize, end: const 64_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, 131071: bb3, 1: bb4, otherwise: bb2];
    }

    bb2: {
        _10 = _1;
        _9 = VirtAddrNotValid(move _10);
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Err(move _9);
        goto -> bb6;
    }

    bb3: {
        _6 = _1;
        _5 = addr::VirtAddr(move _6);
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Ok(move _5);
        goto -> bb6;
    }

    bb4: {
        _8 = _1;
        _7 = addr::VirtAddr::new_truncate(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Ok(move _7);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::new_truncate(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    let mut _3: i64;
    let mut _4: i64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shl(_1, const 16_i32);
        _4 = move _5 as i64 (IntToInt);
        _8 = const 16_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 16_i32);
        _2 = move _3 as u64 (IntToInt);
        _0 = addr::VirtAddr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::new_truncate(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    let mut _3: i64;
    let mut _4: i64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _7 = const 16_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shl(move _6, const 16_i32);
        StorageDead(_6);
        _4 = move _5 as i64 (IntToInt);
        StorageDead(_5);
        _9 = const 16_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 16_i32);
        StorageDead(_4);
        _2 = move _3 as u64 (IntToInt);
        StorageDead(_3);
        _0 = addr::VirtAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::new_unsafe(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(_1);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::new_unsafe(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = addr::VirtAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::zero() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::zero() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(const 0_u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_u64(_1: addr::VirtAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_u64(_1: addr::VirtAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::from_ptr(_1: *const T) -> addr::VirtAddr {
    debug ptr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;

    bb0: {
        _2 = _1 as u64 (PointerExposeAddress);
        _0 = addr::VirtAddr::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_ptr(_1: addr::VirtAddr) -> *const T {
    debug self => _1;
    let mut _0: *const T;
    let mut _2: u64;

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as *const T (PointerFromExposedAddress);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_ptr(_1: addr::VirtAddr) -> *const T {
    debug self => _1;
    let mut _0: *const T;
    let mut _2: u64;
    let mut _3: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = addr::VirtAddr::as_u64(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = move _2 as *const T (PointerFromExposedAddress);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_mut_ptr(_1: addr::VirtAddr) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: *const T;

    bb0: {
        _2 = addr::VirtAddr::as_ptr::<T>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as *mut T (PtrToPtr);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::as_mut_ptr(_1: addr::VirtAddr) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: *const T;
    let mut _3: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = addr::VirtAddr::as_ptr::<T>(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = move _2 as *mut T (PtrToPtr);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::is_null(_1: addr::VirtAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::is_null(_1: addr::VirtAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::align_up(_1: addr::VirtAddr, _2: U) -> addr::VirtAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_up(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new_truncate(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::align_down(_1: addr::VirtAddr, _2: U) -> addr::VirtAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_down(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new_truncate(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::is_aligned(_1: addr::VirtAddr, _2: U) -> bool {
    debug self => _1;
    debug align => _2;
    let mut _0: bool;
    let mut _3: &addr::VirtAddr;
    let _4: addr::VirtAddr;
    let mut _5: addr::VirtAddr;
    let mut _6: &addr::VirtAddr;

    bb0: {
        _5 = _1;
        _4 = addr::VirtAddr::align_down::<U>(move _5, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _6 = &_1;
        _0 = <addr::VirtAddr as PartialEq>::eq(move _3, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::page_offset(_1: addr::VirtAddr) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageOffset::new_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::page_offset(_1: addr::VirtAddr) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageOffset::new_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p1_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: u64);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shr(move _4, const 12_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p1_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shr(move _4, const 12_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p2_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        _5 = (_1.0: u64);
        _6 = const 12_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(move _5, const 12_i32);
        _8 = const 9_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p2_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = (_1.0: u64);
        _6 = const 12_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(move _5, const 12_i32);
        StorageDead(_5);
        _8 = const 9_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p3_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;

    bb0: {
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        _9 = const 9_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 9_i32);
        _11 = const 9_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p3_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        StorageDead(_6);
        _9 = const 9_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 9_i32);
        StorageDead(_5);
        _11 = const 9_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p4_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: bool;

    bb0: {
        _7 = (_1.0: u64);
        _8 = const 12_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shr(move _7, const 12_i32);
        _10 = const 9_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 9_i32);
        _12 = const 9_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Shr(move _5, const 9_i32);
        _14 = const 9_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::p4_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = (_1.0: u64);
        _8 = const 12_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shr(move _7, const 12_i32);
        StorageDead(_7);
        _10 = const 9_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 9_i32);
        StorageDead(_6);
        _12 = const 9_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Shr(move _5, const 9_i32);
        StorageDead(_5);
        _14 = const 9_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::page_table_index(_1: addr::VirtAddr, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: u16;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u8;
    let mut _10: u8;
    let mut _11: u8;
    let mut _12: isize;
    let mut _13: u8;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: (u8, bool);
    let mut _18: (u8, bool);
    let mut _19: bool;

    bb0: {
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        _12 = discriminant(_2);
        _13 = _12 as u8 (IntToInt);
        _14 = Ge(_13, const 1_u8);
        _15 = Le(_13, const 4_u8);
        _16 = BitAnd(move _14, move _15);
        assume(move _16);
        _11 = move _12 as u8 (IntToInt);
        _17 = CheckedSub(_11, const 1_u8);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", move _11, const 1_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _10 = move (_17.0: u8);
        _18 = CheckedMul(_10, const 9_u8);
        assert(!move (_18.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, const 9_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_18.0: u8);
        _19 = Lt(_9, const 64_u8);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", _9) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shr(move _5, move _9);
        _3 = move _4 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:62:1: 62:14>::page_table_index(_1: addr::VirtAddr, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: u16;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u8;
    let mut _10: u8;
    let mut _11: u8;
    let _12: structures::paging::page_table::PageTableLevel;
    let mut _13: isize;
    let mut _14: u8;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: (u8, bool);
    let mut _19: (u8, bool);
    let mut _20: bool;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        StorageDead(_6);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = _2;
        _13 = discriminant(_12);
        _14 = _13 as u8 (IntToInt);
        _15 = Ge(_14, const 1_u8);
        _16 = Le(_14, const 4_u8);
        _17 = BitAnd(move _15, move _16);
        assume(move _17);
        _11 = move _13 as u8 (IntToInt);
        StorageDead(_12);
        _18 = CheckedSub(_11, const 1_u8);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", move _11, const 1_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _10 = move (_18.0: u8);
        StorageDead(_11);
        _19 = CheckedMul(_10, const 9_u8);
        assert(!move (_19.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, const 9_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_19.0: u8);
        StorageDead(_10);
        _20 = Lt(_9, const 64_u8);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", _9) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shr(move _5, move _9);
        StorageDead(_9);
        StorageDead(_5);
        _3 = move _4 as u16 (IntToInt);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_3);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:231:1: 231:29>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "VirtAddr";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:231:1: 231:29>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:239:1: 239:30>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:246:1: 246:32>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:253:1: 253:29>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:260:1: 260:32>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:267:1: 267:31>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &*const ();
    let _4: *const ();
    let mut _5: u64;

    bb0: {
        _5 = ((*_1).0: u64);
        _4 = move _5 as *const () (PointerFromExposedAddress);
        _3 = &_4;
        _0 = <*const () as Pointer>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:274:1: 274:27>::add(_1: addr::VirtAddr, _2: u64) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: (u64, bool);

    bb0: {
        _4 = (_1.0: u64);
        _5 = CheckedAdd(_4, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_5.0: u64);
        _0 = addr::VirtAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:282:1: 282:33>::add_assign(_1: &mut addr::VirtAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;

    bb0: {
        _4 = (*_1);
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:290:1: 290:29>::add(_1: addr::VirtAddr, _2: usize) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as Add<u64>>::add(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:299:1: 299:35>::add_assign(_1: &mut addr::VirtAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as AddAssign<u64>>::add_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:306:1: 306:27>::sub(_1: addr::VirtAddr, _2: u64) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: core::option::Option<u64>;
    let mut _5: u64;

    bb0: {
        _5 = (_1.0: u64);
        _4 = num::<impl u64>::checked_sub(move _5, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<u64>::unwrap(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:314:1: 314:33>::sub_assign(_1: &mut addr::VirtAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;

    bb0: {
        _4 = (*_1);
        _3 = <addr::VirtAddr as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:322:1: 322:29>::sub(_1: addr::VirtAddr, _2: usize) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as Sub<u64>>::sub(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:331:1: 331:35>::sub_assign(_1: &mut addr::VirtAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as SubAssign<u64>>::sub_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:338:1: 338:32>::sub(_1: addr::VirtAddr, _2: addr::VirtAddr) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: core::option::Option<u64>;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = addr::VirtAddr::as_u64(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = num::<impl u64>::checked_sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<u64>::unwrap(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:347:1: 347:23>::steps_between(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;
    let mut _3: u64;
    let mut _4: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _5: core::option::Option<u64>;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: isize;
    let _9: u64;
    let mut _10: bool;
    let mut _11: &u64;
    let mut _12: bool;
    let mut _13: &u64;
    let mut _14: u64;
    let mut _15: core::option::Option<u64>;
    let mut _16: u64;
    let mut _17: core::result::Result<usize, core::num::TryFromIntError>;
    let mut _18: u64;
    scope 1 {
        debug steps => _3;
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = ((*_2).0: u64);
        _7 = ((*_1).0: u64);
        _5 = num::<impl u64>::checked_sub(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <Option<u64> as Try>::branch(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_4 as Continue).0: u64);
        _3 = _9;
        _11 = &((*_2).0: u64);
        _10 = <u64 as BitField>::get_bit(move _11, const 47_usize) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = <Option<usize> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb14, unwind unreachable];
    }

    bb6: {
        switchInt(move _10) -> [0: bb12, otherwise: bb7];
    }

    bb7: {
        _13 = &((*_1).0: u64);
        _12 = <u64 as BitField>::get_bit(move _13, const 47_usize) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _12) -> [0: bb9, otherwise: bb12];
    }

    bb9: {
        _16 = _3;
        _15 = num::<impl u64>::checked_sub(move _16, const 18446462598732840960_u64) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _14 = Option::<u64>::unwrap(move _15) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _3 = move _14;
        goto -> bb12;
    }

    bb12: {
        _18 = _3;
        _17 = <usize as TryFrom<u64>>::try_from(move _18) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<usize, TryFromIntError>::ok(move _17) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:347:1: 347:23>::forward_checked(_1: addr::VirtAddr, _2: usize) -> Option<addr::VirtAddr> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<addr::VirtAddr>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _4: core::option::Option<u64>;
    let mut _5: core::result::Result<u64, core::num::TryFromIntError>;
    let mut _6: isize;
    let _7: u64;
    let mut _8: bool;
    let mut _10: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _11: core::option::Option<u64>;
    let mut _12: u64;
    let mut _13: isize;
    let mut _15: u64;
    let mut _16: &u64;
    let mut _17: core::ops::RangeFrom<usize>;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::RangeFrom<usize>;
    let mut _21: addr::VirtAddr;
    let mut _22: u64;
    scope 1 {
        debug offset => _7;
        let mut _9: u64;
        let _14: u64;
        scope 6 {
            debug addr => _9;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _14;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = <u64 as TryFrom<usize>>::try_from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Result::<u64, TryFromIntError>::ok(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <Option<u64> as Try>::branch(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = ((_3 as Continue).0: u64);
        _8 = Gt(_7, const _);
        switchInt(move _8) -> [0: bb8, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb18, unwind unreachable];
    }

    bb7: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb18;
    }

    bb8: {
        _12 = (_1.0: u64);
        _11 = num::<impl u64>::checked_add(move _12, _7) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Option<u64> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb11, 1: bb12, otherwise: bb5];
    }

    bb11: {
        _14 = ((_10 as Continue).0: u64);
        _9 = _14;
        _16 = &_9;
        _17 = RangeFrom::<usize> { start: const 47_usize };
        _15 = <u64 as BitField>::get_bits::<RangeFrom<usize>>(move _16, move _17) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb18, unwind unreachable];
    }

    bb13: {
        switchInt(_15) -> [1: bb14, 2: bb15, otherwise: bb16];
    }

    bb14: {
        _19 = &mut _9;
        _20 = RangeFrom::<usize> { start: const 47_usize };
        _18 = <u64 as BitField>::set_bits::<RangeFrom<usize>>(move _19, move _20, const 131071_u64) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb18;
    }

    bb16: {
        _22 = _9;
        _21 = addr::VirtAddr::new(move _22) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = Option::<addr::VirtAddr>::Some(move _21);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:347:1: 347:23>::backward_checked(_1: addr::VirtAddr, _2: usize) -> Option<addr::VirtAddr> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<addr::VirtAddr>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _4: core::option::Option<u64>;
    let mut _5: core::result::Result<u64, core::num::TryFromIntError>;
    let mut _6: isize;
    let _7: u64;
    let mut _8: bool;
    let mut _10: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _11: core::option::Option<u64>;
    let mut _12: u64;
    let mut _13: isize;
    let mut _15: u64;
    let mut _16: &u64;
    let mut _17: core::ops::RangeFrom<usize>;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::RangeFrom<usize>;
    let mut _21: addr::VirtAddr;
    let mut _22: u64;
    scope 1 {
        debug offset => _7;
        let mut _9: u64;
        let _14: u64;
        scope 6 {
            debug addr => _9;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _14;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = <u64 as TryFrom<usize>>::try_from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Result::<u64, TryFromIntError>::ok(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <Option<u64> as Try>::branch(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = ((_3 as Continue).0: u64);
        _8 = Gt(_7, const _);
        switchInt(move _8) -> [0: bb8, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb18, unwind unreachable];
    }

    bb7: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb18;
    }

    bb8: {
        _12 = (_1.0: u64);
        _11 = num::<impl u64>::checked_sub(move _12, _7) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Option<u64> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb11, 1: bb12, otherwise: bb5];
    }

    bb11: {
        _14 = ((_10 as Continue).0: u64);
        _9 = _14;
        _16 = &_9;
        _17 = RangeFrom::<usize> { start: const 47_usize };
        _15 = <u64 as BitField>::get_bits::<RangeFrom<usize>>(move _16, move _17) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb18, unwind unreachable];
    }

    bb13: {
        switchInt(_15) -> [131070: bb14, 131069: bb15, otherwise: bb16];
    }

    bb14: {
        _19 = &mut _9;
        _20 = RangeFrom::<usize> { start: const 47_usize };
        _18 = <u64 as BitField>::set_bits::<RangeFrom<usize>>(move _19, move _20, const 0_u64) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb18;
    }

    bb16: {
        _22 = _9;
        _21 = addr::VirtAddr::new(move _22) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = Option::<addr::VirtAddr>::Some(move _21);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:413:1: 413:43>::fmt(_1: &PhysAddrNotValid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "PhysAddrNotValid";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:413:1: 413:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let mut _3: isize;
    let mut _4: !;
    scope 1 {
        debug p => _0;
    }

    bb0: {
        _2 = PhysAddr::try_new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = panic(const "physical addresses must not have any bits in the range 52 to 64 set") -> unwind unreachable;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = ((_2 as Ok).0: addr::PhysAddr);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let mut _3: u64;
    let mut _4: isize;
    let _5: addr::PhysAddr;
    let mut _6: !;
    scope 1 {
        debug p => _5;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = PhysAddr::try_new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "physical addresses must not have any bits in the range 52 to 64 set") -> unwind unreachable;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_5);
        _5 = ((_2 as Ok).0: addr::PhysAddr);
        _0 = _5;
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new_truncate(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: bool;

    bb0: {
        _4 = const 52_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 64_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u64, const 52_i32);
        _6 = Eq(_3, const 0_u64);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(_1, move _3);
        _0 = PhysAddr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new_truncate(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _5 = const 52_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(const 1_u64, const 52_i32);
        _7 = Eq(_4, const 0_u64);
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PhysAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new_unsafe(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(_1);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::new_unsafe(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = PhysAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::try_new(_1: u64) -> Result<PhysAddr, PhysAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let _2: addr::PhysAddr;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: addr::PhysAddrNotValid;
    scope 1 {
        debug p => _2;
    }

    bb0: {
        _2 = PhysAddr::new_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_2.0: u64);
        _3 = Eq(move _4, _1);
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Ok(_2);
        goto -> bb4;
    }

    bb3: {
        _5 = PhysAddrNotValid(_1);
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Err(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::try_new(_1: u64) -> Result<PhysAddr, PhysAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let _2: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: addr::PhysAddr;
    let mut _8: addr::PhysAddrNotValid;
    let mut _9: u64;
    scope 1 {
        debug p => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = PhysAddr::new_truncate(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = (_2.0: u64);
        StorageLive(_6);
        _6 = _1;
        _4 = Eq(move _5, move _6);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        _7 = _2;
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Ok(move _7);
        StorageDead(_7);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _8 = PhysAddrNotValid(move _9);
        StorageDead(_9);
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Err(move _8);
        StorageDead(_8);
        goto -> bb4;
    }

    bb4: {
        StorageDead(_4);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::zero() -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::zero() -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(const 0_u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::as_u64(_1: PhysAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::as_u64(_1: PhysAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::is_null(_1: PhysAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::is_null(_1: PhysAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::align_up(_1: PhysAddr, _2: U) -> PhysAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_up(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::align_down(_1: PhysAddr, _2: U) -> PhysAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_down(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr(move _3);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:421:1: 421:14>::is_aligned(_1: PhysAddr, _2: U) -> bool {
    debug self => _1;
    debug align => _2;
    let mut _0: bool;
    let mut _3: &addr::PhysAddr;
    let _4: addr::PhysAddr;
    let mut _5: addr::PhysAddr;
    let mut _6: &addr::PhysAddr;

    bb0: {
        _5 = _1;
        _4 = PhysAddr::align_down::<U>(move _5, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _6 = &_1;
        _0 = <PhysAddr as PartialEq>::eq(move _3, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:520:1: 520:29>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "PhysAddr";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:520:1: 520:29>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:528:1: 528:30>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:535:1: 535:32>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:542:1: 542:29>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:549:1: 549:32>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:556:1: 556:31>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &*const ();
    let _4: *const ();
    let mut _5: u64;

    bb0: {
        _5 = ((*_1).0: u64);
        _4 = move _5 as *const () (PointerFromExposedAddress);
        _3 = &_4;
        _0 = <*const () as Pointer>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:563:1: 563:27>::add(_1: PhysAddr, _2: u64) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: (u64, bool);

    bb0: {
        _4 = (_1.0: u64);
        _5 = CheckedAdd(_4, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_5.0: u64);
        _0 = PhysAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:571:1: 571:33>::add_assign(_1: &mut PhysAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;

    bb0: {
        _4 = (*_1);
        _3 = <PhysAddr as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:579:1: 579:29>::add(_1: PhysAddr, _2: usize) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as Add<u64>>::add(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:588:1: 588:35>::add_assign(_1: &mut PhysAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as AddAssign<u64>>::add_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:595:1: 595:27>::sub(_1: PhysAddr, _2: u64) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: core::option::Option<u64>;
    let mut _5: u64;

    bb0: {
        _5 = (_1.0: u64);
        _4 = num::<impl u64>::checked_sub(move _5, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<u64>::unwrap(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:603:1: 603:33>::sub_assign(_1: &mut PhysAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;

    bb0: {
        _4 = (*_1);
        _3 = <PhysAddr as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:611:1: 611:29>::sub(_1: PhysAddr, _2: usize) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as Sub<u64>>::sub(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:620:1: 620:35>::sub_assign(_1: &mut PhysAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as SubAssign<u64>>::sub_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/addr.rs:627:1: 627:32>::sub(_1: PhysAddr, _2: PhysAddr) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: core::option::Option<u64>;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = PhysAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = num::<impl u64>::checked_sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<u64>::unwrap(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn align_down(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let mut _3: bool;
    let mut _4: !;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: (u64, bool);

    bb0: {
        _3 = num::<impl u64>::is_power_of_two(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _7 = CheckedSub(_2, const 1_u64);
        assert(!move (_7.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        _4 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _6 = move (_7.0: u64);
        _5 = Not(move _6);
        _0 = BitAnd(_1, move _5);
        return;
    }
}

// MIR FOR CTFE
fn align_down(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let _3: ();
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: !;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: (u64, bool);

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = num::<impl u64>::is_power_of_two(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_5);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_7);
        _7 = _1;
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _11 = CheckedSub(_10, const 1_u64);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _10, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _9 = move (_11.0: u64);
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _0 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        return;
    }
}

fn align_up(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let mut _3: bool;
    let mut _4: !;
    let _5: u64;
    let mut _6: (u64, bool);
    let mut _7: u64;
    let mut _8: core::option::Option<u64>;
    let mut _9: u64;
    let mut _10: isize;
    let mut _12: !;
    scope 1 {
        debug align_mask => _5;
        scope 2 {
            debug aligned => _11;
            let _11: u64;
        }
    }

    bb0: {
        _3 = num::<impl u64>::is_power_of_two(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = CheckedSub(_2, const 1_u64);
        assert(!move (_6.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        _4 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _5 = move (_6.0: u64);
        _7 = BitAnd(_1, _5);
        switchInt(move _7) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = _1;
        goto -> bb10;
    }

    bb6: {
        _9 = BitOr(_1, _5);
        _8 = num::<impl u64>::checked_add(move _9, const 1_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _11 = ((_8 as Some).0: u64);
        _0 = _11;
        goto -> bb10;
    }

    bb9: {
        _12 = panic(const "attempt to add with overflow") -> unwind unreachable;
    }

    bb10: {
        return;
    }
}

// MIR FOR CTFE
fn align_up(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let _3: ();
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: !;
    let _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: core::option::Option<u64>;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: isize;
    let mut _20: !;
    scope 1 {
        debug align_mask => _7;
        scope 2 {
            debug aligned => _19;
            let _19: u64;
        }
    }

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = num::<impl u64>::is_power_of_two(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_5);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _2;
        _9 = CheckedSub(_8, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _8, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _7 = move (_9.0: u64);
        StorageDead(_8);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _7;
        _11 = BitAnd(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _10 = Eq(move _11, const 0_u64);
        switchInt(move _10) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        StorageDead(_11);
        _0 = _1;
        goto -> bb10;
    }

    bb6: {
        StorageDead(_11);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        _16 = _1;
        StorageLive(_17);
        _17 = _7;
        _15 = BitOr(move _16, move _17);
        StorageDead(_17);
        StorageDead(_16);
        ConstEvalCounter;
        _14 = num::<impl u64>::checked_add(move _15, const 1_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_15);
        _18 = discriminant(_14);
        switchInt(move _18) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        StorageLive(_19);
        _19 = ((_14 as Some).0: u64);
        _0 = _19;
        StorageDead(_19);
        StorageDead(_14);
        goto -> bb10;
    }

    bb9: {
        StorageLive(_20);
        ConstEvalCounter;
        _20 = panic(const "attempt to add with overflow") -> unwind unreachable;
    }

    bb10: {
        StorageDead(_10);
        StorageDead(_7);
        return;
    }
}

fn are_enabled() -> bool {
    let mut _0: bool;
    let mut _1: &registers::rflags::RFlags;
    let _2: registers::rflags::RFlags;

    bb0: {
        _2 = rflags::x86_64::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = &_2;
        _0 = rflags::RFlags::contains(move _1, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn enable() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("sti", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn disable() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("cli", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn without_interrupts(_1: F) -> R {
    debug f => _1;
    let mut _0: R;
    let _2: bool;
    let _3: ();
    let _4: ();
    scope 1 {
        debug saved_intpt_flag => _2;
        scope 2 {
            debug ret => _0;
        }
    }

    bb0: {
        _2 = are_enabled() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = disable() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <F as FnOnce<()>>::call_once(move _1, const ()) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(_2) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _4 = enable() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn enable_and_hlt() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("sti; hlt", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int3() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("int3", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:9:1: 9:21>::read_from_port(_1: u16) -> u8 {
    debug port => _1;
    let mut _0: u8;
    let _2: u8;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in al, dx", out("al") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:20:1: 20:22>::read_from_port(_1: u16) -> u16 {
    debug port => _1;
    let mut _0: u16;
    let _2: u16;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in ax, dx", out("ax") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:31:1: 31:22>::read_from_port(_1: u16) -> u32 {
    debug port => _1;
    let mut _0: u32;
    let _2: u32;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in eax, dx", out("ax") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:42:1: 42:22>::write_to_port(_1: u16, _2: u8) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, al", in("dx") _1, in("al") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:51:1: 51:23>::write_to_port(_1: u16, _2: u16) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, ax", in("dx") _1, in("ax") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:60:1: 60:23>::write_to_port(_1: u16, _2: u32) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, eax", in("dx") _1, in("ax") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:82:10: 82:15>::fmt(_1: &ReadOnlyAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "ReadOnlyAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:85:1: 85:39>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "ReadOnly";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:91:10: 91:15>::fmt(_1: &WriteOnlyAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "WriteOnlyAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:94:1: 94:40>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "WriteOnly";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:100:10: 100:15>::fmt(_1: &ReadWriteAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "ReadWriteAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:103:1: 103:40>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "ReadWrite";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:131:1: 131:29>::new(_1: u16) -> PortGeneric<T, A> {
    debug port => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;

    bb0: {
        _0 = PortGeneric::<T, A> { port: _1, phantom: const ZeroSized: PhantomData<(T, A)> };
        return;
    }
}

// MIR FOR CTFE
fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:131:1: 131:29>::new(_1: u16) -> PortGeneric<T, A> {
    debug port => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;
    let mut _2: u16;
    let mut _3: core::marker::PhantomData<(T, A)>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<(T, A)>;
        _0 = PortGeneric::<T, A> { port: move _2, phantom: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:142:1: 142:55>::read(_1: &mut PortGeneric<T, A>) -> T {
    debug self => _1;
    let mut _0: T;
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = ((*_1).0: u16);
        _0 = <T as PortRead>::read_from_port(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:155:1: 155:57>::write(_1: &mut PortGeneric<T, A>, _2: T) -> () {
    debug self => _1;
    debug value => _2;
    let mut _0: ();
    let mut _3: u16;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: u16);
        _0 = <T as PortWrite>::write_to_port(move _3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:168:1: 168:60>::fmt(_1: &PortGeneric<T, A>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _7: core::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &u16;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &str;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &core::fmt::Arguments<'_>;
    let _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[core::fmt::rt::Argument<'_>];
    let _20: &[core::fmt::rt::Argument<'_>; 1];
    let _21: [core::fmt::rt::Argument<'_>; 1];
    let mut _22: core::fmt::rt::Argument<'_>;
    let mut _23: &&str;
    let mut _24: &[&str; 1];
    let mut _25: &usize;

    bb0: {
        _8 = const "PortGeneric";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "port";
        _11 = &((*_1).0: u16);
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = const "size";
        _25 = const _;
        _13 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _12, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _14 = const "access";
        _24 = const _;
        _18 = _24 as &[&str] (PointerCoercion(Unsize));
        _23 = const _;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_23) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _21 = [move _22];
        _20 = &_21;
        _19 = _20 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_v1(move _18, move _19) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _14, move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:168:1: 168:60>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:168:1: 168:60>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[2] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:168:1: 168:60>::fmt: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:178:1: 178:39>::clone(_1: &PortGeneric<T, A>) -> PortGeneric<T, A> {
    debug self => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;
    let mut _2: u16;

    bb0: {
        _2 = ((*_1).0: u16);
        _0 = PortGeneric::<T, A> { port: move _2, phantom: const ZeroSized: PhantomData<(T, A)> };
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/port.rs:187:1: 187:43>::eq(_1: &PortGeneric<T, A>, _2: &PortGeneric<T, A>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:3:16: 3:21>::clone(_1: &RdRand) -> RdRand {
    debug self => _1;
    let mut _0: instructions::random::RdRand;
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:3:23: 3:28>::fmt(_1: &RdRand, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "RdRand";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::new() -> Option<RdRand> {
    let mut _0: core::option::Option<instructions::random::RdRand>;
    let _1: core::arch::x86_64::CpuidResult;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    scope 1 {
        debug cpuid => _1;
    }
    scope 2 {
    }

    bb0: {
        _1 = __cpuid(const 1_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_1.2: u32);
        _5 = const 30_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 30_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 1_u32, const 30_i32);
        _2 = BitAnd(move _3, move _4);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Option::<RdRand>::Some(const RdRand(()));
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<RdRand>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u64(_1: RdRand) -> Option<u64> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u64>;
    let mut _2: u64;
    let mut _3: i32;
    let mut _4: &mut u64;
    let mut _5: u64;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _4 = &mut _2;
        _3 = _rdrand64_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u64>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u64>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u64: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand64 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u64: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u32(_1: RdRand) -> Option<u32> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u32>;
    let mut _2: u32;
    let mut _3: i32;
    let mut _4: &mut u32;
    let mut _5: u32;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u32;
        _4 = &mut _2;
        _3 = _rdrand32_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u32>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u32>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u32: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand32 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u32: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u16(_1: RdRand) -> Option<u16> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u16>;
    let mut _2: u16;
    let mut _3: i32;
    let mut _4: &mut u16;
    let mut _5: u16;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u16;
        _4 = &mut _2;
        _3 = _rdrand16_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u16>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u16>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u16: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand16 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/random.rs:7:1: 7:12>::get_u16: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:58:1: 58:20>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, cs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:58:1: 58:20>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u64;
    let mut _3: u16;
    scope 1 {
    }

    bb0: {
        _3 = (_1.0: u16);
        _2 = <u64 as From<u16>>::from(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("push {0}
lea {1}, [1f + rip]
push {1}
retfq
1:", in(reg) move _2, lateout(reg) _, options(PRESERVES_FLAGS)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, ss", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov ss, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, ds", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov ds, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, es", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov es, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, fs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov fs, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::BASE: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = const _;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::read_base() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    scope 1 {
        let _1: u64;
        scope 2 {
            debug val => _1;
        }
    }

    bb0: {
        asm!("rdfsbase {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new_unsafe(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::write_base(_1: addr::VirtAddr) -> () {
    debug base => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("wrfsbase {0}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, gs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:25:9: 25:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov gs, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::BASE: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = const _;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::read_base() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    scope 1 {
        let _1: u64;
        scope 2 {
            debug val => _1;
        }
    }

    bb0: {
        asm!("rdgsbase {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new_unsafe(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:39:9: 39:33>::write_base(_1: addr::VirtAddr) -> () {
    debug base => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("wrgsbase {0}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/segmentation.rs:93:1: 93:8>::swap() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("swapgs", options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn set_cs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <CS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_ss(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <SS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_ds(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <DS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_es(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <ES as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_fs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <FS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_gs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <GS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn swap_gs() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = instructions::segmentation::<impl GS>::swap() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn cs() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = <CS as Segment>::get_reg() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn wrfsbase(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    let mut _2: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <FS as Segment64>::write_base(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rdfsbase() -> u64 {
    let mut _0: u64;
    let mut _1: addr::VirtAddr;

    bb0: {
        _1 = <FS as Segment64>::read_base() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::as_u64(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn wrgsbase(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    let mut _2: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <GS as Segment64>::write_base(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rdgsbase() -> u64 {
    let mut _0: u64;
    let mut _1: addr::VirtAddr;

    bb0: {
        _1 = <GS as Segment64>::read_base() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::as_u64(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn lgdt(_1: &DescriptorTablePointer) -> () {
    debug gdt => _1;
    let mut _0: ();
    let mut _2: *const structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _2 = &raw const (*_1);
        asm!("lgdt [{0}]", in(reg) move _2, options(READONLY | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lidt(_1: &DescriptorTablePointer) -> () {
    debug idt => _1;
    let mut _0: ();
    let mut _2: *const structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _2 = &raw const (*_1);
        asm!("lidt [{0}]", in(reg) move _2, options(READONLY | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sgdt() -> DescriptorTablePointer {
    let mut _0: structures::DescriptorTablePointer;
    let mut _1: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: *mut structures::DescriptorTablePointer;
    let mut _4: &mut structures::DescriptorTablePointer;
    scope 1 {
        debug gdt => _1;
        scope 2 {
        }
    }

    bb0: {
        _2 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = DescriptorTablePointer { limit: const 0_u16, base: move _2 };
        _4 = &mut _1;
        _3 = &raw mut (*_4);
        asm!("sgdt [{0}]", in(reg) move _3, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn sidt() -> DescriptorTablePointer {
    let mut _0: structures::DescriptorTablePointer;
    let mut _1: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: *mut structures::DescriptorTablePointer;
    let mut _4: &mut structures::DescriptorTablePointer;
    scope 1 {
        debug idt => _1;
        scope 2 {
        }
    }

    bb0: {
        _2 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = DescriptorTablePointer { limit: const 0_u16, base: move _2 };
        _4 = &mut _1;
        _3 = &raw mut (*_4);
        asm!("sidt [{0}]", in(reg) move _3, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn load_tss(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("ltr {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn flush(_1: addr::VirtAddr) -> () {
    debug addr => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("invlpg [{0}]", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn flush_all() -> () {
    let mut _0: ();
    let _1: structures::paging::frame::PhysFrame;
    let _2: registers::control::Cr3Flags;
    let mut _3: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    scope 1 {
        debug frame => _1;
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: registers::control::Cr3Flags);
        _0 = control::x86_64::<impl control::Cr3>::write(_1, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:23:10: 23:15>::fmt(_1: &InvPicdCommand, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &addr::VirtAddr;
    let _5: &instructions::tlb::Pcid;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&instructions::tlb::Pcid;
    let _10: &instructions::tlb::Pcid;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &&instructions::tlb::Pcid;
    let _14: &str;
    let _15: &str;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
    }
    scope 2 {
        debug __self_0 => _10;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _15 = const "AllExceptGlobal";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb6, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Address).0: addr::VirtAddr);
        _5 = &(((*_1) as Address).1: instructions::tlb::Pcid);
        _6 = const "Address";
        _7 = _4 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _9 = &_5;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _6, move _7, move _8) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        _10 = &(((*_1) as Single).0: instructions::tlb::Pcid);
        _11 = const "Single";
        _13 = &_10;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _11, move _12) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _14 = const "All";
        _0 = Formatter::<'_>::write_str(_2, _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:41:10: 41:15>::fmt(_1: &InvpcidDescriptor, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u64;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&u64;
    let _10: &u64;

    bb0: {
        _3 = const "InvpcidDescriptor";
        _4 = const "address";
        _6 = &((*_1).0: u64);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "pcid";
        _10 = &((*_1).1: u64);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:10: 49:15>::fmt(_1: &Pcid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "Pcid";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:17: 49:22>::clone(_1: &Pcid) -> Pcid {
    debug self => _1;
    let mut _0: instructions::tlb::Pcid;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:30: 49:39>::eq(_1: &Pcid, _2: &Pcid) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:41: 49:43>::assert_receiver_is_total_eq(_1: &Pcid) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:45: 49:55>::partial_cmp(_1: &Pcid, _2: &Pcid) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:57: 49:60>::cmp(_1: &Pcid, _2: &Pcid) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:49:62: 49:66>::hash(_1: &Pcid, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:52:1: 52:10>::new(_1: u16) -> Result<Pcid, &str> {
    debug pcid => _1;
    let mut _0: core::result::Result<instructions::tlb::Pcid, &str>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: instructions::tlb::Pcid;

    bb0: {
        _2 = Ge(_1, const 4096_u16);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = const "PCID should be < 4096.";
        _0 = Result::<Pcid, &str>::Err(_3);
        goto -> bb3;
    }

    bb2: {
        _4 = Pcid(_1);
        _0 = Result::<Pcid, &str>::Ok(move _4);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:52:1: 52:10>::new(_1: u16) -> Result<Pcid, &str> {
    debug pcid => _1;
    let mut _0: core::result::Result<instructions::tlb::Pcid, &str>;
    let mut _2: bool;
    let mut _3: u16;
    let mut _4: &str;
    let _5: &str;
    let mut _6: instructions::tlb::Pcid;
    let mut _7: u16;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        _2 = Ge(move _3, const 4096_u16);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const "PCID should be < 4096.";
        _4 = &(*_5);
        _0 = Result::<Pcid, &str>::Err(move _4);
        StorageDead(_4);
        StorageDead(_5);
        goto -> bb3;
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        _6 = Pcid(move _7);
        StorageDead(_7);
        _0 = Result::<Pcid, &str>::Ok(move _6);
        StorageDead(_6);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:52:1: 52:10>::value(_1: &Pcid) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = ((*_1).0: u16);
        return;
    }
}

// MIR FOR CTFE
fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/instructions/tlb.rs:52:1: 52:10>::value(_1: &Pcid) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = ((*_1).0: u16);
        return;
    }
}

fn flush_pcid(_1: InvPicdCommand) -> () {
    debug command => _1;
    let mut _0: ();
    let mut _2: instructions::tlb::InvpcidDescriptor;
    let mut _4: isize;
    let mut _7: u64;
    let mut _8: u16;
    let mut _9: &instructions::tlb::Pcid;
    let mut _10: u64;
    let mut _12: u64;
    let mut _13: u16;
    let mut _14: u64;
    let mut _15: *const instructions::tlb::InvpcidDescriptor;
    let _16: &instructions::tlb::InvpcidDescriptor;
    scope 1 {
        debug desc => _2;
        let _3: u64;
        scope 2 {
            debug kind => _3;
            let _5: addr::VirtAddr;
            let _6: instructions::tlb::Pcid;
            let _11: instructions::tlb::Pcid;
            scope 3 {
                debug addr => _5;
                debug pcid => _6;
            }
            scope 4 {
                debug pcid => _11;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _2 = InvpcidDescriptor { address: const 0_u64, pcid: const 0_u64 };
        _4 = discriminant(_1);
        switchInt(move _4) -> [0: bb3, 1: bb7, 2: bb9, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = const 3_u64;
        goto -> bb10;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = ((_1 as Address).0: addr::VirtAddr);
        _6 = ((_1 as Address).1: instructions::tlb::Pcid);
        _3 = const 0_u64;
        _9 = &_6;
        _8 = Pcid::value(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <u16 as Into<u64>>::into(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        (_2.1: u64) = move _7;
        _10 = addr::VirtAddr::as_u64(_5) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        (_2.0: u64) = move _10;
        goto -> bb10;
    }

    bb7: {
        _11 = ((_1 as Single).0: instructions::tlb::Pcid);
        _3 = const 1_u64;
        _13 = (_11.0: u16);
        _12 = <u16 as Into<u64>>::into(move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        (_2.1: u64) = move _12;
        goto -> bb10;
    }

    bb9: {
        _3 = const 2_u64;
        goto -> bb10;
    }

    bb10: {
        _14 = _3;
        _16 = &_2;
        _15 = &raw const (*_16);
        asm!("invpcid {0}, [{1}]", in(reg) move _14, in(reg) move _15, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        return;
    }
}

fn hlt() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("hlt", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn nop() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("nop", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn bochs_breakpoint() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("xchg bx, bx", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn read_rip() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let _1: u64;
    let mut _2: u64;
    scope 1 {
        debug rip => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("lea {0}, [rip]", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:7:10: 7:15>::fmt(_1: &control::Cr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &control::Cr0Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &control::Cr0Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _115: u64;
    let mut _116: u64;
    let mut _117: u64;
    let mut _118: &registers::control::Cr0Flags;
    let _119: registers::control::Cr0Flags;
    let mut _120: u64;
    let mut _121: bool;
    let mut _122: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _123: core::result::Result<(), core::fmt::Error>;
    let _124: &str;
    let mut _125: isize;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &u64;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _136: core::result::Result<(), core::fmt::Error>;
    let _137: &str;
    let mut _138: isize;
    scope 1 {
        debug first => _3;
        let _114: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug extra_bits => _114;
            scope 91 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 92 {
                }
            }
            scope 93 {
                debug val => const ();
                scope 94 {
                }
            }
            scope 95 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 96 {
                }
            }
            scope 97 {
                debug val => const ();
                scope 98 {
                }
            }
            scope 99 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 100 {
                }
            }
            scope 101 {
                debug val => const ();
                scope 102 {
                }
            }
            scope 103 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 104 {
                }
            }
            scope 105 {
                debug val => const ();
                scope 106 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::PROTECTED_MODE_ENABLE(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "PROTECTED_MODE_ENABLE";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb12: {
        _14 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::MONITOR_COPROCESSOR(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "MONITOR_COPROCESSOR";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb23: {
        _24 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::EMULATE_COPROCESSOR(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "EMULATE_COPROCESSOR";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb34: {
        _34 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::TASK_SWITCHED(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "TASK_SWITCHED";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb45: {
        _44 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::EXTENSION_TYPE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "EXTENSION_TYPE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb56: {
        _54 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::NUMERIC_ERROR(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "NUMERIC_ERROR";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb67: {
        _64 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::WRITE_PROTECT(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "WRITE_PROTECT";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb78: {
        _74 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::ALIGNMENT_MASK(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "ALIGNMENT_MASK";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb89: {
        _84 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::NOT_WRITE_THROUGH(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "NOT_WRITE_THROUGH";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb100: {
        _94 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::CACHE_DISABLE(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "CACHE_DISABLE";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb111: {
        _104 = <control::Cr0Flags as <control::Cr0Flags as Debug>::fmt::__BitFlags>::PAGING(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "PAGING";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb122: {
        _115 = ((*_1).0: u64);
        _119 = control::Cr0Flags::all() -> [return: bb123, unwind unreachable];
    }

    bb123: {
        _118 = &_119;
        _117 = control::Cr0Flags::bits(move _118) -> [return: bb124, unwind unreachable];
    }

    bb124: {
        _116 = Not(move _117);
        _114 = BitAnd(move _115, move _116);
        _120 = _114;
        switchInt(move _120) -> [0: bb138, otherwise: bb125];
    }

    bb125: {
        _121 = _3;
        switchInt(move _121) -> [0: bb126, otherwise: bb130];
    }

    bb126: {
        _124 = const " | ";
        _123 = Formatter::<'_>::write_str(_2, _124) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _122 = <Result<(), core::fmt::Error> as Try>::branch(move _123) -> [return: bb128, unwind unreachable];
    }

    bb128: {
        _125 = discriminant(_122);
        switchInt(move _125) -> [0: bb130, 1: bb129, otherwise: bb6];
    }

    bb129: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb130: {
        _3 = const false;
        _128 = const "0x";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb133, 1: bb134, otherwise: bb6];
    }

    bb133: {
        _132 = &_114;
        _131 = <u64 as LowerHex>::fmt(_132, _2) -> [return: bb135, unwind unreachable];
    }

    bb134: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb135: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb136, unwind unreachable];
    }

    bb136: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb138, 1: bb137, otherwise: bb6];
    }

    bb137: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb138: {
        _134 = _3;
        switchInt(move _134) -> [0: bb143, otherwise: bb139];
    }

    bb139: {
        _137 = const "(empty)";
        _136 = Formatter::<'_>::write_str(_2, _137) -> [return: bb140, unwind unreachable];
    }

    bb140: {
        _135 = <Result<(), core::fmt::Error> as Try>::branch(move _136) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _138 = discriminant(_135);
        switchInt(move _138) -> [0: bb143, 1: bb142, otherwise: bb6];
    }

    bb142: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb143: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb144;
    }

    bb144: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTED_MODE_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::MONITOR_COPROCESSOR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::EMULATE_COPROCESSOR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TASK_SWITCHED(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::EXTENSION_TYPE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NUMERIC_ERROR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::WRITE_PROTECT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ALIGNMENT_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NOT_WRITE_THROUGH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::CACHE_DISABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PAGING(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTED_MODE_ENABLE(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::MONITOR_COPROCESSOR(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::EMULATE_COPROCESSOR(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TASK_SWITCHED(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::EXTENSION_TYPE(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NUMERIC_ERROR(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::WRITE_PROTECT(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ALIGNMENT_MASK(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NOT_WRITE_THROUGH(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::CACHE_DISABLE(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PAGING(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTED_MODE_ENABLE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags { bits: const 1_u64 };
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::MONITOR_COPROCESSOR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::EMULATE_COPROCESSOR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TASK_SWITCHED: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::EXTENSION_TYPE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NUMERIC_ERROR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::WRITE_PROTECT: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ALIGNMENT_MASK: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NOT_WRITE_THROUGH: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 29_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 29_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 29_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::CACHE_DISABLE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 30_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 30_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 30_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PAGING: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 31_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 31_i32);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags { bits: const 0_u64 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;

    bb0: {
        _10 = BitOr(const _, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = control::Cr0Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = BitOr(const _, const _);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = control::Cr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTED_MODE_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::MONITOR_COPROCESSOR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::EMULATE_COPROCESSOR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TASK_SWITCHED: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::EXTENSION_TYPE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NUMERIC_ERROR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::WRITE_PROTECT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ALIGNMENT_MASK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NOT_WRITE_THROUGH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::CACHE_DISABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PAGING: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTED_MODE_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::MONITOR_COPROCESSOR: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::EMULATE_COPROCESSOR: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TASK_SWITCHED: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::EXTENSION_TYPE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NUMERIC_ERROR: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::WRITE_PROTECT: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ALIGNMENT_MASK: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NOT_WRITE_THROUGH: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::CACHE_DISABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PAGING: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr0Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::Cr0Flags;
    let _6: registers::control::Cr0Flags;
    let mut _7: registers::control::Cr0Flags;

    bb0: {
        _6 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = control::Cr0Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = control::Cr0Flags { bits: _1 };
        _0 = Option::<control::Cr0Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<control::Cr0Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr0Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::Cr0Flags;
    let _8: registers::control::Cr0Flags;
    let mut _9: registers::control::Cr0Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = control::Cr0Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = control::Cr0Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<control::Cr0Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<control::Cr0Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;

    bb0: {
        _4 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = control::Cr0Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = control::Cr0Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = control::Cr0Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::Cr0Flags;
    let _5: registers::control::Cr0Flags;

    bb0: {
        _2 = control::Cr0Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = control::Cr0Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = control::Cr0Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::control::Cr0Flags;
    let mut _4: u64;
    let mut _5: &registers::control::Cr0Flags;
    let _6: registers::control::Cr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = control::Cr0Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::Cr0Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::Cr0Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr0Flags;
    let _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = control::Cr0Flags { bits: move _6 };
        _4 = &_5;
        _3 = control::Cr0Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr0Flags;
    let _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = control::Cr0Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = control::Cr0Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut control::Cr0Flags, _2: control::Cr0Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::Cr0Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::Cr0Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = control::Cr0Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = control::Cr0Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr0Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr0Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = control::Cr0Flags { bits: move _3 };
        _5 = control::Cr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <control::Cr0Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut control::Cr0Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr0Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr0Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr0Flags);
        _5 = control::Cr0Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> control::Cr0Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::Cr0Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr0Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::Cr0Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr0Flags as Extend<control::Cr0Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:55:10: 55:15>::fmt(_1: &control::Cr2, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr2";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:59:10: 59:15>::fmt(_1: &control::Cr3, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr3";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &control::Cr3Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &control::Cr3Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _25: u64;
    let mut _26: u64;
    let mut _27: u64;
    let mut _28: &registers::control::Cr3Flags;
    let _29: registers::control::Cr3Flags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _33: core::result::Result<(), core::fmt::Error>;
    let _34: &str;
    let mut _35: isize;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &u64;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _46: core::result::Result<(), core::fmt::Error>;
    let _47: &str;
    let mut _48: isize;
    scope 1 {
        debug first => _3;
        let _24: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug extra_bits => _24;
            scope 19 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 20 {
                }
            }
            scope 21 {
                debug val => const ();
                scope 22 {
                }
            }
            scope 23 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 24 {
                }
            }
            scope 25 {
                debug val => const ();
                scope 26 {
                }
            }
            scope 27 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 28 {
                }
            }
            scope 29 {
                debug val => const ();
                scope 30 {
                }
            }
            scope 31 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 32 {
                }
            }
            scope 33 {
                debug val => const ();
                scope 34 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <control::Cr3Flags as <control::Cr3Flags as Debug>::fmt::__BitFlags>::PAGE_LEVEL_WRITETHROUGH(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "PAGE_LEVEL_WRITETHROUGH";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb12: {
        _14 = <control::Cr3Flags as <control::Cr3Flags as Debug>::fmt::__BitFlags>::PAGE_LEVEL_CACHE_DISABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "PAGE_LEVEL_CACHE_DISABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb23: {
        _25 = ((*_1).0: u64);
        _29 = control::Cr3Flags::all() -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _28 = &_29;
        _27 = control::Cr3Flags::bits(move _28) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _26 = Not(move _27);
        _24 = BitAnd(move _25, move _26);
        _30 = _24;
        switchInt(move _30) -> [0: bb39, otherwise: bb26];
    }

    bb26: {
        _31 = _3;
        switchInt(move _31) -> [0: bb27, otherwise: bb31];
    }

    bb27: {
        _34 = const " | ";
        _33 = Formatter::<'_>::write_str(_2, _34) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _32 = <Result<(), core::fmt::Error> as Try>::branch(move _33) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _35 = discriminant(_32);
        switchInt(move _35) -> [0: bb31, 1: bb30, otherwise: bb6];
    }

    bb30: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb31: {
        _3 = const false;
        _38 = const "0x";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb34, 1: bb35, otherwise: bb6];
    }

    bb34: {
        _42 = &_24;
        _41 = <u64 as LowerHex>::fmt(_42, _2) -> [return: bb36, unwind unreachable];
    }

    bb35: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb36: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb39, 1: bb38, otherwise: bb6];
    }

    bb38: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb39: {
        _44 = _3;
        switchInt(move _44) -> [0: bb44, otherwise: bb40];
    }

    bb40: {
        _47 = const "(empty)";
        _46 = Formatter::<'_>::write_str(_2, _47) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _45 = <Result<(), core::fmt::Error> as Try>::branch(move _46) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _48 = discriminant(_45);
        switchInt(move _48) -> [0: bb44, 1: bb43, otherwise: bb6];
    }

    bb43: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb45, unwind unreachable];
    }

    bb44: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb45;
    }

    bb45: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PAGE_LEVEL_WRITETHROUGH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PAGE_LEVEL_CACHE_DISABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PAGE_LEVEL_WRITETHROUGH(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr3Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr3Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr3Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PAGE_LEVEL_CACHE_DISABLE(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr3Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr3Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr3Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PAGE_LEVEL_WRITETHROUGH: control::Cr3Flags = {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = control::Cr3Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PAGE_LEVEL_CACHE_DISABLE: control::Cr3Flags = {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = control::Cr3Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::Cr3Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::Cr3Flags { bits: const 0_u64 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;

    bb0: {
        _1 = BitOr(const _, const _);
        _0 = control::Cr3Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;

    bb0: {
        StorageLive(_1);
        _1 = BitOr(const _, const _);
        _0 = control::Cr3Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PAGE_LEVEL_WRITETHROUGH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PAGE_LEVEL_CACHE_DISABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PAGE_LEVEL_WRITETHROUGH: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr3Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PAGE_LEVEL_CACHE_DISABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr3Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr3Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr3Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr3Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr3Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::Cr3Flags;
    let _6: registers::control::Cr3Flags;
    let mut _7: registers::control::Cr3Flags;

    bb0: {
        _6 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = control::Cr3Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = control::Cr3Flags { bits: _1 };
        _0 = Option::<control::Cr3Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<control::Cr3Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr3Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr3Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::Cr3Flags;
    let _8: registers::control::Cr3Flags;
    let mut _9: registers::control::Cr3Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = control::Cr3Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = control::Cr3Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<control::Cr3Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<control::Cr3Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;

    bb0: {
        _4 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = control::Cr3Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr3Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = control::Cr3Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::Cr3Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = control::Cr3Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::Cr3Flags;
    let _5: registers::control::Cr3Flags;

    bb0: {
        _2 = control::Cr3Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = control::Cr3Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = control::Cr3Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::control::Cr3Flags;
    let mut _4: u64;
    let mut _5: &registers::control::Cr3Flags;
    let _6: registers::control::Cr3Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = control::Cr3Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::Cr3Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::Cr3Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr3Flags;
    let _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = control::Cr3Flags { bits: move _6 };
        _4 = &_5;
        _3 = control::Cr3Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr3Flags;
    let _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = control::Cr3Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = control::Cr3Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut control::Cr3Flags, _2: control::Cr3Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::Cr3Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::Cr3Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr3Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr3Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr3Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr3Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = control::Cr3Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = control::Cr3Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr3Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr3Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = control::Cr3Flags { bits: move _3 };
        _5 = control::Cr3Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <control::Cr3Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut control::Cr3Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr3Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr3Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr3Flags);
        _5 = control::Cr3Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> control::Cr3Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::Cr3Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr3Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::Cr3Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr3Flags as Extend<control::Cr3Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:76:10: 76:15>::fmt(_1: &control::Cr4, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr4";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &control::Cr4Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &control::Cr4Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &str;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &str;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _147: core::result::Result<(), core::fmt::Error>;
    let _148: &str;
    let mut _149: isize;
    let mut _150: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _151: core::result::Result<(), core::fmt::Error>;
    let _152: &str;
    let mut _153: isize;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _157: core::result::Result<(), core::fmt::Error>;
    let _158: &str;
    let mut _159: isize;
    let mut _160: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _161: core::result::Result<(), core::fmt::Error>;
    let _162: &str;
    let mut _163: isize;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _167: core::result::Result<(), core::fmt::Error>;
    let _168: &str;
    let mut _169: isize;
    let mut _170: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _171: core::result::Result<(), core::fmt::Error>;
    let _172: &str;
    let mut _173: isize;
    let mut _174: bool;
    let mut _175: bool;
    let mut _176: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _177: core::result::Result<(), core::fmt::Error>;
    let _178: &str;
    let mut _179: isize;
    let mut _180: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _181: core::result::Result<(), core::fmt::Error>;
    let _182: &str;
    let mut _183: isize;
    let mut _184: bool;
    let mut _185: bool;
    let mut _186: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _187: core::result::Result<(), core::fmt::Error>;
    let _188: &str;
    let mut _189: isize;
    let mut _190: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _191: core::result::Result<(), core::fmt::Error>;
    let _192: &str;
    let mut _193: isize;
    let mut _194: bool;
    let mut _195: bool;
    let mut _196: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _197: core::result::Result<(), core::fmt::Error>;
    let _198: &str;
    let mut _199: isize;
    let mut _200: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _201: core::result::Result<(), core::fmt::Error>;
    let _202: &str;
    let mut _203: isize;
    let mut _204: bool;
    let mut _205: bool;
    let mut _206: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _207: core::result::Result<(), core::fmt::Error>;
    let _208: &str;
    let mut _209: isize;
    let mut _210: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _211: core::result::Result<(), core::fmt::Error>;
    let _212: &str;
    let mut _213: isize;
    let mut _214: bool;
    let mut _215: bool;
    let mut _216: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _217: core::result::Result<(), core::fmt::Error>;
    let _218: &str;
    let mut _219: isize;
    let mut _220: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _221: core::result::Result<(), core::fmt::Error>;
    let _222: &str;
    let mut _223: isize;
    let mut _224: bool;
    let mut _225: bool;
    let mut _226: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _227: core::result::Result<(), core::fmt::Error>;
    let _228: &str;
    let mut _229: isize;
    let mut _230: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _231: core::result::Result<(), core::fmt::Error>;
    let _232: &str;
    let mut _233: isize;
    let mut _234: bool;
    let mut _235: bool;
    let mut _236: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _237: core::result::Result<(), core::fmt::Error>;
    let _238: &str;
    let mut _239: isize;
    let mut _240: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _241: core::result::Result<(), core::fmt::Error>;
    let _242: &str;
    let mut _243: isize;
    let mut _244: bool;
    let mut _245: bool;
    let mut _246: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _247: core::result::Result<(), core::fmt::Error>;
    let _248: &str;
    let mut _249: isize;
    let mut _250: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _251: core::result::Result<(), core::fmt::Error>;
    let _252: &str;
    let mut _253: isize;
    let mut _255: u64;
    let mut _256: u64;
    let mut _257: u64;
    let mut _258: &registers::control::Cr4Flags;
    let _259: registers::control::Cr4Flags;
    let mut _260: u64;
    let mut _261: bool;
    let mut _262: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _263: core::result::Result<(), core::fmt::Error>;
    let _264: &str;
    let mut _265: isize;
    let mut _266: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _267: core::result::Result<(), core::fmt::Error>;
    let _268: &str;
    let mut _269: isize;
    let mut _270: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _271: core::result::Result<(), core::fmt::Error>;
    let _272: &u64;
    let mut _273: isize;
    let mut _274: bool;
    let mut _275: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _276: core::result::Result<(), core::fmt::Error>;
    let _277: &str;
    let mut _278: isize;
    scope 1 {
        debug first => _3;
        let _254: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 99 {
            }
        }
        scope 100 {
            debug val => const ();
            scope 101 {
            }
        }
        scope 102 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 103 {
            }
        }
        scope 104 {
            debug val => const ();
            scope 105 {
            }
        }
        scope 106 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 107 {
            }
        }
        scope 108 {
            debug val => const ();
            scope 109 {
            }
        }
        scope 110 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 111 {
            }
        }
        scope 112 {
            debug val => const ();
            scope 113 {
            }
        }
        scope 114 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 115 {
            }
        }
        scope 116 {
            debug val => const ();
            scope 117 {
            }
        }
        scope 118 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 119 {
            }
        }
        scope 120 {
            debug val => const ();
            scope 121 {
            }
        }
        scope 122 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 123 {
            }
        }
        scope 124 {
            debug val => const ();
            scope 125 {
            }
        }
        scope 126 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 127 {
            }
        }
        scope 128 {
            debug val => const ();
            scope 129 {
            }
        }
        scope 130 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 131 {
            }
        }
        scope 132 {
            debug val => const ();
            scope 133 {
            }
        }
        scope 134 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 135 {
            }
        }
        scope 136 {
            debug val => const ();
            scope 137 {
            }
        }
        scope 138 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 139 {
            }
        }
        scope 140 {
            debug val => const ();
            scope 141 {
            }
        }
        scope 142 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 143 {
            }
        }
        scope 144 {
            debug val => const ();
            scope 145 {
            }
        }
        scope 146 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 147 {
            }
        }
        scope 148 {
            debug val => const ();
            scope 149 {
            }
        }
        scope 150 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 151 {
            }
        }
        scope 152 {
            debug val => const ();
            scope 153 {
            }
        }
        scope 154 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 155 {
            }
        }
        scope 156 {
            debug val => const ();
            scope 157 {
            }
        }
        scope 158 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 159 {
            }
        }
        scope 160 {
            debug val => const ();
            scope 161 {
            }
        }
        scope 162 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 163 {
            }
        }
        scope 164 {
            debug val => const ();
            scope 165 {
            }
        }
        scope 166 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 167 {
            }
        }
        scope 168 {
            debug val => const ();
            scope 169 {
            }
        }
        scope 170 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 171 {
            }
        }
        scope 172 {
            debug val => const ();
            scope 173 {
            }
        }
        scope 174 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 175 {
            }
        }
        scope 176 {
            debug val => const ();
            scope 177 {
            }
        }
        scope 178 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 179 {
            }
        }
        scope 180 {
            debug val => const ();
            scope 181 {
            }
        }
        scope 182 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 183 {
            }
        }
        scope 184 {
            debug val => const ();
            scope 185 {
            }
        }
        scope 186 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 187 {
            }
        }
        scope 188 {
            debug val => const ();
            scope 189 {
            }
        }
        scope 190 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 191 {
            }
        }
        scope 192 {
            debug val => const ();
            scope 193 {
            }
        }
        scope 194 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 195 {
            }
        }
        scope 196 {
            debug val => const ();
            scope 197 {
            }
        }
        scope 198 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 199 {
            }
        }
        scope 200 {
            debug val => const ();
            scope 201 {
            }
        }
        scope 202 {
            debug extra_bits => _254;
            scope 203 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 204 {
                }
            }
            scope 205 {
                debug val => const ();
                scope 206 {
                }
            }
            scope 207 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 208 {
                }
            }
            scope 209 {
                debug val => const ();
                scope 210 {
                }
            }
            scope 211 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 212 {
                }
            }
            scope 213 {
                debug val => const ();
                scope 214 {
                }
            }
            scope 215 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 216 {
                }
            }
            scope 217 {
                debug val => const ();
                scope 218 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::VIRTUAL_8086_MODE_EXTENSIONS(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "VIRTUAL_8086_MODE_EXTENSIONS";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb12: {
        _14 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PROTECTED_MODE_VIRTUAL_INTERRUPTS(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "PROTECTED_MODE_VIRTUAL_INTERRUPTS";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb23: {
        _24 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::TIMESTAMP_DISABLE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "TIMESTAMP_DISABLE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb34: {
        _34 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::DEBUGGING_EXTENSIONS(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "DEBUGGING_EXTENSIONS";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb45: {
        _44 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PAGE_SIZE_EXTENSION(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "PAGE_SIZE_EXTENSION";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb56: {
        _54 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PHYSICAL_ADDRESS_EXTENSION(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "PHYSICAL_ADDRESS_EXTENSION";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb67: {
        _64 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::MACHINE_CHECK_EXCEPTION(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "MACHINE_CHECK_EXCEPTION";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb78: {
        _74 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PAGE_GLOBAL(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "PAGE_GLOBAL";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb89: {
        _84 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PERFORMANCE_MONITOR_COUNTER(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "PERFORMANCE_MONITOR_COUNTER";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb100: {
        _94 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::OSFXSR(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "OSFXSR";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb111: {
        _104 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::OSXMMEXCPT_ENABLE(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "OSXMMEXCPT_ENABLE";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb122: {
        _114 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::USER_MODE_INSTRUCTION_PREVENTION(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "USER_MODE_INSTRUCTION_PREVENTION";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb133: {
        _124 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::L5_PAGING(_1) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        switchInt(move _124) -> [0: bb144, otherwise: bb135];
    }

    bb135: {
        _125 = _3;
        switchInt(move _125) -> [0: bb136, otherwise: bb140];
    }

    bb136: {
        _128 = const " | ";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb140, 1: bb139, otherwise: bb6];
    }

    bb139: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb140: {
        _3 = const false;
        _132 = const "L5_PAGING";
        _131 = Formatter::<'_>::write_str(_2, _132) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb144, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb144: {
        _134 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::VIRTUAL_MACHINE_EXTENSIONS(_1) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        switchInt(move _134) -> [0: bb155, otherwise: bb146];
    }

    bb146: {
        _135 = _3;
        switchInt(move _135) -> [0: bb147, otherwise: bb151];
    }

    bb147: {
        _138 = const " | ";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb151, 1: bb150, otherwise: bb6];
    }

    bb150: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb151: {
        _3 = const false;
        _142 = const "VIRTUAL_MACHINE_EXTENSIONS";
        _141 = Formatter::<'_>::write_str(_2, _142) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb155, 1: bb154, otherwise: bb6];
    }

    bb154: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb155: {
        _144 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::SAFER_MODE_EXTENSIONS(_1) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        switchInt(move _144) -> [0: bb166, otherwise: bb157];
    }

    bb157: {
        _145 = _3;
        switchInt(move _145) -> [0: bb158, otherwise: bb162];
    }

    bb158: {
        _148 = const " | ";
        _147 = Formatter::<'_>::write_str(_2, _148) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _146 = <Result<(), core::fmt::Error> as Try>::branch(move _147) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _149 = discriminant(_146);
        switchInt(move _149) -> [0: bb162, 1: bb161, otherwise: bb6];
    }

    bb161: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb162: {
        _3 = const false;
        _152 = const "SAFER_MODE_EXTENSIONS";
        _151 = Formatter::<'_>::write_str(_2, _152) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _150 = <Result<(), core::fmt::Error> as Try>::branch(move _151) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _153 = discriminant(_150);
        switchInt(move _153) -> [0: bb166, 1: bb165, otherwise: bb6];
    }

    bb165: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb166: {
        _154 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::FSGSBASE(_1) -> [return: bb167, unwind unreachable];
    }

    bb167: {
        switchInt(move _154) -> [0: bb177, otherwise: bb168];
    }

    bb168: {
        _155 = _3;
        switchInt(move _155) -> [0: bb169, otherwise: bb173];
    }

    bb169: {
        _158 = const " | ";
        _157 = Formatter::<'_>::write_str(_2, _158) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _156 = <Result<(), core::fmt::Error> as Try>::branch(move _157) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _159 = discriminant(_156);
        switchInt(move _159) -> [0: bb173, 1: bb172, otherwise: bb6];
    }

    bb172: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb173: {
        _3 = const false;
        _162 = const "FSGSBASE";
        _161 = Formatter::<'_>::write_str(_2, _162) -> [return: bb174, unwind unreachable];
    }

    bb174: {
        _160 = <Result<(), core::fmt::Error> as Try>::branch(move _161) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _163 = discriminant(_160);
        switchInt(move _163) -> [0: bb177, 1: bb176, otherwise: bb6];
    }

    bb176: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb177: {
        _164 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PCID(_1) -> [return: bb178, unwind unreachable];
    }

    bb178: {
        switchInt(move _164) -> [0: bb188, otherwise: bb179];
    }

    bb179: {
        _165 = _3;
        switchInt(move _165) -> [0: bb180, otherwise: bb184];
    }

    bb180: {
        _168 = const " | ";
        _167 = Formatter::<'_>::write_str(_2, _168) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _166 = <Result<(), core::fmt::Error> as Try>::branch(move _167) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _169 = discriminant(_166);
        switchInt(move _169) -> [0: bb184, 1: bb183, otherwise: bb6];
    }

    bb183: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb184: {
        _3 = const false;
        _172 = const "PCID";
        _171 = Formatter::<'_>::write_str(_2, _172) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _170 = <Result<(), core::fmt::Error> as Try>::branch(move _171) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _173 = discriminant(_170);
        switchInt(move _173) -> [0: bb188, 1: bb187, otherwise: bb6];
    }

    bb187: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb188: {
        _174 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::OSXSAVE(_1) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        switchInt(move _174) -> [0: bb199, otherwise: bb190];
    }

    bb190: {
        _175 = _3;
        switchInt(move _175) -> [0: bb191, otherwise: bb195];
    }

    bb191: {
        _178 = const " | ";
        _177 = Formatter::<'_>::write_str(_2, _178) -> [return: bb192, unwind unreachable];
    }

    bb192: {
        _176 = <Result<(), core::fmt::Error> as Try>::branch(move _177) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _179 = discriminant(_176);
        switchInt(move _179) -> [0: bb195, 1: bb194, otherwise: bb6];
    }

    bb194: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb195: {
        _3 = const false;
        _182 = const "OSXSAVE";
        _181 = Formatter::<'_>::write_str(_2, _182) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _180 = <Result<(), core::fmt::Error> as Try>::branch(move _181) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        _183 = discriminant(_180);
        switchInt(move _183) -> [0: bb199, 1: bb198, otherwise: bb6];
    }

    bb198: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb199: {
        _184 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::KEY_LOCKER(_1) -> [return: bb200, unwind unreachable];
    }

    bb200: {
        switchInt(move _184) -> [0: bb210, otherwise: bb201];
    }

    bb201: {
        _185 = _3;
        switchInt(move _185) -> [0: bb202, otherwise: bb206];
    }

    bb202: {
        _188 = const " | ";
        _187 = Formatter::<'_>::write_str(_2, _188) -> [return: bb203, unwind unreachable];
    }

    bb203: {
        _186 = <Result<(), core::fmt::Error> as Try>::branch(move _187) -> [return: bb204, unwind unreachable];
    }

    bb204: {
        _189 = discriminant(_186);
        switchInt(move _189) -> [0: bb206, 1: bb205, otherwise: bb6];
    }

    bb205: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb206: {
        _3 = const false;
        _192 = const "KEY_LOCKER";
        _191 = Formatter::<'_>::write_str(_2, _192) -> [return: bb207, unwind unreachable];
    }

    bb207: {
        _190 = <Result<(), core::fmt::Error> as Try>::branch(move _191) -> [return: bb208, unwind unreachable];
    }

    bb208: {
        _193 = discriminant(_190);
        switchInt(move _193) -> [0: bb210, 1: bb209, otherwise: bb6];
    }

    bb209: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb210: {
        _194 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::SUPERVISOR_MODE_EXECUTION_PROTECTION(_1) -> [return: bb211, unwind unreachable];
    }

    bb211: {
        switchInt(move _194) -> [0: bb221, otherwise: bb212];
    }

    bb212: {
        _195 = _3;
        switchInt(move _195) -> [0: bb213, otherwise: bb217];
    }

    bb213: {
        _198 = const " | ";
        _197 = Formatter::<'_>::write_str(_2, _198) -> [return: bb214, unwind unreachable];
    }

    bb214: {
        _196 = <Result<(), core::fmt::Error> as Try>::branch(move _197) -> [return: bb215, unwind unreachable];
    }

    bb215: {
        _199 = discriminant(_196);
        switchInt(move _199) -> [0: bb217, 1: bb216, otherwise: bb6];
    }

    bb216: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb217: {
        _3 = const false;
        _202 = const "SUPERVISOR_MODE_EXECUTION_PROTECTION";
        _201 = Formatter::<'_>::write_str(_2, _202) -> [return: bb218, unwind unreachable];
    }

    bb218: {
        _200 = <Result<(), core::fmt::Error> as Try>::branch(move _201) -> [return: bb219, unwind unreachable];
    }

    bb219: {
        _203 = discriminant(_200);
        switchInt(move _203) -> [0: bb221, 1: bb220, otherwise: bb6];
    }

    bb220: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb221: {
        _204 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::SUPERVISOR_MODE_ACCESS_PREVENTION(_1) -> [return: bb222, unwind unreachable];
    }

    bb222: {
        switchInt(move _204) -> [0: bb232, otherwise: bb223];
    }

    bb223: {
        _205 = _3;
        switchInt(move _205) -> [0: bb224, otherwise: bb228];
    }

    bb224: {
        _208 = const " | ";
        _207 = Formatter::<'_>::write_str(_2, _208) -> [return: bb225, unwind unreachable];
    }

    bb225: {
        _206 = <Result<(), core::fmt::Error> as Try>::branch(move _207) -> [return: bb226, unwind unreachable];
    }

    bb226: {
        _209 = discriminant(_206);
        switchInt(move _209) -> [0: bb228, 1: bb227, otherwise: bb6];
    }

    bb227: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb228: {
        _3 = const false;
        _212 = const "SUPERVISOR_MODE_ACCESS_PREVENTION";
        _211 = Formatter::<'_>::write_str(_2, _212) -> [return: bb229, unwind unreachable];
    }

    bb229: {
        _210 = <Result<(), core::fmt::Error> as Try>::branch(move _211) -> [return: bb230, unwind unreachable];
    }

    bb230: {
        _213 = discriminant(_210);
        switchInt(move _213) -> [0: bb232, 1: bb231, otherwise: bb6];
    }

    bb231: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb232: {
        _214 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PROTECTION_KEY_USER(_1) -> [return: bb233, unwind unreachable];
    }

    bb233: {
        switchInt(move _214) -> [0: bb243, otherwise: bb234];
    }

    bb234: {
        _215 = _3;
        switchInt(move _215) -> [0: bb235, otherwise: bb239];
    }

    bb235: {
        _218 = const " | ";
        _217 = Formatter::<'_>::write_str(_2, _218) -> [return: bb236, unwind unreachable];
    }

    bb236: {
        _216 = <Result<(), core::fmt::Error> as Try>::branch(move _217) -> [return: bb237, unwind unreachable];
    }

    bb237: {
        _219 = discriminant(_216);
        switchInt(move _219) -> [0: bb239, 1: bb238, otherwise: bb6];
    }

    bb238: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb239: {
        _3 = const false;
        _222 = const "PROTECTION_KEY_USER";
        _221 = Formatter::<'_>::write_str(_2, _222) -> [return: bb240, unwind unreachable];
    }

    bb240: {
        _220 = <Result<(), core::fmt::Error> as Try>::branch(move _221) -> [return: bb241, unwind unreachable];
    }

    bb241: {
        _223 = discriminant(_220);
        switchInt(move _223) -> [0: bb243, 1: bb242, otherwise: bb6];
    }

    bb242: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb243: {
        _224 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PROTECTION_KEY(_1) -> [return: bb244, unwind unreachable];
    }

    bb244: {
        switchInt(move _224) -> [0: bb254, otherwise: bb245];
    }

    bb245: {
        _225 = _3;
        switchInt(move _225) -> [0: bb246, otherwise: bb250];
    }

    bb246: {
        _228 = const " | ";
        _227 = Formatter::<'_>::write_str(_2, _228) -> [return: bb247, unwind unreachable];
    }

    bb247: {
        _226 = <Result<(), core::fmt::Error> as Try>::branch(move _227) -> [return: bb248, unwind unreachable];
    }

    bb248: {
        _229 = discriminant(_226);
        switchInt(move _229) -> [0: bb250, 1: bb249, otherwise: bb6];
    }

    bb249: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb250: {
        _3 = const false;
        _232 = const "PROTECTION_KEY";
        _231 = Formatter::<'_>::write_str(_2, _232) -> [return: bb251, unwind unreachable];
    }

    bb251: {
        _230 = <Result<(), core::fmt::Error> as Try>::branch(move _231) -> [return: bb252, unwind unreachable];
    }

    bb252: {
        _233 = discriminant(_230);
        switchInt(move _233) -> [0: bb254, 1: bb253, otherwise: bb6];
    }

    bb253: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb254: {
        _234 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::CONTROL_FLOW_ENFORCEMENT(_1) -> [return: bb255, unwind unreachable];
    }

    bb255: {
        switchInt(move _234) -> [0: bb265, otherwise: bb256];
    }

    bb256: {
        _235 = _3;
        switchInt(move _235) -> [0: bb257, otherwise: bb261];
    }

    bb257: {
        _238 = const " | ";
        _237 = Formatter::<'_>::write_str(_2, _238) -> [return: bb258, unwind unreachable];
    }

    bb258: {
        _236 = <Result<(), core::fmt::Error> as Try>::branch(move _237) -> [return: bb259, unwind unreachable];
    }

    bb259: {
        _239 = discriminant(_236);
        switchInt(move _239) -> [0: bb261, 1: bb260, otherwise: bb6];
    }

    bb260: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb261: {
        _3 = const false;
        _242 = const "CONTROL_FLOW_ENFORCEMENT";
        _241 = Formatter::<'_>::write_str(_2, _242) -> [return: bb262, unwind unreachable];
    }

    bb262: {
        _240 = <Result<(), core::fmt::Error> as Try>::branch(move _241) -> [return: bb263, unwind unreachable];
    }

    bb263: {
        _243 = discriminant(_240);
        switchInt(move _243) -> [0: bb265, 1: bb264, otherwise: bb6];
    }

    bb264: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb265: {
        _244 = <control::Cr4Flags as <control::Cr4Flags as Debug>::fmt::__BitFlags>::PROTECTION_KEY_SUPERVISOR(_1) -> [return: bb266, unwind unreachable];
    }

    bb266: {
        switchInt(move _244) -> [0: bb276, otherwise: bb267];
    }

    bb267: {
        _245 = _3;
        switchInt(move _245) -> [0: bb268, otherwise: bb272];
    }

    bb268: {
        _248 = const " | ";
        _247 = Formatter::<'_>::write_str(_2, _248) -> [return: bb269, unwind unreachable];
    }

    bb269: {
        _246 = <Result<(), core::fmt::Error> as Try>::branch(move _247) -> [return: bb270, unwind unreachable];
    }

    bb270: {
        _249 = discriminant(_246);
        switchInt(move _249) -> [0: bb272, 1: bb271, otherwise: bb6];
    }

    bb271: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb272: {
        _3 = const false;
        _252 = const "PROTECTION_KEY_SUPERVISOR";
        _251 = Formatter::<'_>::write_str(_2, _252) -> [return: bb273, unwind unreachable];
    }

    bb273: {
        _250 = <Result<(), core::fmt::Error> as Try>::branch(move _251) -> [return: bb274, unwind unreachable];
    }

    bb274: {
        _253 = discriminant(_250);
        switchInt(move _253) -> [0: bb276, 1: bb275, otherwise: bb6];
    }

    bb275: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb276: {
        _255 = ((*_1).0: u64);
        _259 = control::Cr4Flags::all() -> [return: bb277, unwind unreachable];
    }

    bb277: {
        _258 = &_259;
        _257 = control::Cr4Flags::bits(move _258) -> [return: bb278, unwind unreachable];
    }

    bb278: {
        _256 = Not(move _257);
        _254 = BitAnd(move _255, move _256);
        _260 = _254;
        switchInt(move _260) -> [0: bb292, otherwise: bb279];
    }

    bb279: {
        _261 = _3;
        switchInt(move _261) -> [0: bb280, otherwise: bb284];
    }

    bb280: {
        _264 = const " | ";
        _263 = Formatter::<'_>::write_str(_2, _264) -> [return: bb281, unwind unreachable];
    }

    bb281: {
        _262 = <Result<(), core::fmt::Error> as Try>::branch(move _263) -> [return: bb282, unwind unreachable];
    }

    bb282: {
        _265 = discriminant(_262);
        switchInt(move _265) -> [0: bb284, 1: bb283, otherwise: bb6];
    }

    bb283: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb284: {
        _3 = const false;
        _268 = const "0x";
        _267 = Formatter::<'_>::write_str(_2, _268) -> [return: bb285, unwind unreachable];
    }

    bb285: {
        _266 = <Result<(), core::fmt::Error> as Try>::branch(move _267) -> [return: bb286, unwind unreachable];
    }

    bb286: {
        _269 = discriminant(_266);
        switchInt(move _269) -> [0: bb287, 1: bb288, otherwise: bb6];
    }

    bb287: {
        _272 = &_254;
        _271 = <u64 as LowerHex>::fmt(_272, _2) -> [return: bb289, unwind unreachable];
    }

    bb288: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb289: {
        _270 = <Result<(), core::fmt::Error> as Try>::branch(move _271) -> [return: bb290, unwind unreachable];
    }

    bb290: {
        _273 = discriminant(_270);
        switchInt(move _273) -> [0: bb292, 1: bb291, otherwise: bb6];
    }

    bb291: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb292: {
        _274 = _3;
        switchInt(move _274) -> [0: bb297, otherwise: bb293];
    }

    bb293: {
        _277 = const "(empty)";
        _276 = Formatter::<'_>::write_str(_2, _277) -> [return: bb294, unwind unreachable];
    }

    bb294: {
        _275 = <Result<(), core::fmt::Error> as Try>::branch(move _276) -> [return: bb295, unwind unreachable];
    }

    bb295: {
        _278 = discriminant(_275);
        switchInt(move _278) -> [0: bb297, 1: bb296, otherwise: bb6];
    }

    bb296: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb298, unwind unreachable];
    }

    bb297: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb298;
    }

    bb298: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::VIRTUAL_8086_MODE_EXTENSIONS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTED_MODE_VIRTUAL_INTERRUPTS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TIMESTAMP_DISABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DEBUGGING_EXTENSIONS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PAGE_SIZE_EXTENSION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PHYSICAL_ADDRESS_EXTENSION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::MACHINE_CHECK_EXCEPTION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PAGE_GLOBAL(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PERFORMANCE_MONITOR_COUNTER(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OSFXSR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OSXMMEXCPT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::USER_MODE_INSTRUCTION_PREVENTION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::L5_PAGING(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::VIRTUAL_MACHINE_EXTENSIONS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SAFER_MODE_EXTENSIONS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::FSGSBASE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PCID(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OSXSAVE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::KEY_LOCKER(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SUPERVISOR_MODE_EXECUTION_PROTECTION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SUPERVISOR_MODE_ACCESS_PREVENTION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTION_KEY_USER(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTION_KEY(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::CONTROL_FLOW_ENFORCEMENT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTION_KEY_SUPERVISOR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::VIRTUAL_8086_MODE_EXTENSIONS(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTED_MODE_VIRTUAL_INTERRUPTS(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TIMESTAMP_DISABLE(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DEBUGGING_EXTENSIONS(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PAGE_SIZE_EXTENSION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PHYSICAL_ADDRESS_EXTENSION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::MACHINE_CHECK_EXCEPTION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PAGE_GLOBAL(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PERFORMANCE_MONITOR_COUNTER(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OSFXSR(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OSXMMEXCPT_ENABLE(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::USER_MODE_INSTRUCTION_PREVENTION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::L5_PAGING(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::VIRTUAL_MACHINE_EXTENSIONS(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SAFER_MODE_EXTENSIONS(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::FSGSBASE(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PCID(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OSXSAVE(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::KEY_LOCKER(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SUPERVISOR_MODE_EXECUTION_PROTECTION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SUPERVISOR_MODE_ACCESS_PREVENTION(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTION_KEY_USER(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTION_KEY(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::CONTROL_FLOW_ENFORCEMENT(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTION_KEY_SUPERVISOR(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: registers::control::Cr4Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::VIRTUAL_8086_MODE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags { bits: const 1_u64 };
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTED_MODE_VIRTUAL_INTERRUPTS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TIMESTAMP_DISABLE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DEBUGGING_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PAGE_SIZE_EXTENSION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PHYSICAL_ADDRESS_EXTENSION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::MACHINE_CHECK_EXCEPTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PAGE_GLOBAL: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PERFORMANCE_MONITOR_COUNTER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OSFXSR: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OSXMMEXCPT_ENABLE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::USER_MODE_INSTRUCTION_PREVENTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::L5_PAGING: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::VIRTUAL_MACHINE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SAFER_MODE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::FSGSBASE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PCID: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 17_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 17_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 17_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OSXSAVE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::KEY_LOCKER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 19_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 19_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 19_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SUPERVISOR_MODE_EXECUTION_PROTECTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 20_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 20_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SUPERVISOR_MODE_ACCESS_PREVENTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 21_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 21_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 21_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTION_KEY_USER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 22_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 22_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 22_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTION_KEY: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 22_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 22_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 22_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::CONTROL_FLOW_ENFORCEMENT: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 23_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 23_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTION_KEY_SUPERVISOR: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 24_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 24_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 24_i32);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags { bits: const 0_u64 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u64;
    let mut _24: u64;

    bb0: {
        _24 = BitOr(const _, const _);
        _23 = BitOr(move _24, const _);
        _22 = BitOr(move _23, const _);
        _21 = BitOr(move _22, const _);
        _20 = BitOr(move _21, const _);
        _19 = BitOr(move _20, const _);
        _18 = BitOr(move _19, const _);
        _17 = BitOr(move _18, const _);
        _16 = BitOr(move _17, const _);
        _15 = BitOr(move _16, const _);
        _14 = BitOr(move _15, const _);
        _13 = BitOr(move _14, const _);
        _12 = BitOr(move _13, const _);
        _11 = BitOr(move _12, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = control::Cr4Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u64;
    let mut _24: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        StorageLive(_24);
        _24 = BitOr(const _, const _);
        _23 = BitOr(move _24, const _);
        StorageDead(_24);
        _22 = BitOr(move _23, const _);
        StorageDead(_23);
        _21 = BitOr(move _22, const _);
        StorageDead(_22);
        _20 = BitOr(move _21, const _);
        StorageDead(_21);
        _19 = BitOr(move _20, const _);
        StorageDead(_20);
        _18 = BitOr(move _19, const _);
        StorageDead(_19);
        _17 = BitOr(move _18, const _);
        StorageDead(_18);
        _16 = BitOr(move _17, const _);
        StorageDead(_17);
        _15 = BitOr(move _16, const _);
        StorageDead(_16);
        _14 = BitOr(move _15, const _);
        StorageDead(_15);
        _13 = BitOr(move _14, const _);
        StorageDead(_14);
        _12 = BitOr(move _13, const _);
        StorageDead(_13);
        _11 = BitOr(move _12, const _);
        StorageDead(_12);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = control::Cr4Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::VIRTUAL_8086_MODE_EXTENSIONS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTED_MODE_VIRTUAL_INTERRUPTS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TIMESTAMP_DISABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DEBUGGING_EXTENSIONS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PAGE_SIZE_EXTENSION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PHYSICAL_ADDRESS_EXTENSION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::MACHINE_CHECK_EXCEPTION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PAGE_GLOBAL: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PERFORMANCE_MONITOR_COUNTER: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OSFXSR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OSXMMEXCPT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::USER_MODE_INSTRUCTION_PREVENTION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::L5_PAGING: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::VIRTUAL_MACHINE_EXTENSIONS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SAFER_MODE_EXTENSIONS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::FSGSBASE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PCID: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OSXSAVE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::KEY_LOCKER: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SUPERVISOR_MODE_EXECUTION_PROTECTION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SUPERVISOR_MODE_ACCESS_PREVENTION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTION_KEY_USER: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTION_KEY: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::CONTROL_FLOW_ENFORCEMENT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTION_KEY_SUPERVISOR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::VIRTUAL_8086_MODE_EXTENSIONS: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTED_MODE_VIRTUAL_INTERRUPTS: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TIMESTAMP_DISABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DEBUGGING_EXTENSIONS: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PAGE_SIZE_EXTENSION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PHYSICAL_ADDRESS_EXTENSION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::MACHINE_CHECK_EXCEPTION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PAGE_GLOBAL: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PERFORMANCE_MONITOR_COUNTER: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OSFXSR: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OSXMMEXCPT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::USER_MODE_INSTRUCTION_PREVENTION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::L5_PAGING: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::VIRTUAL_MACHINE_EXTENSIONS: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SAFER_MODE_EXTENSIONS: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::FSGSBASE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PCID: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OSXSAVE: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::KEY_LOCKER: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SUPERVISOR_MODE_EXECUTION_PROTECTION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SUPERVISOR_MODE_ACCESS_PREVENTION: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTION_KEY_USER: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTION_KEY: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::CONTROL_FLOW_ENFORCEMENT: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTION_KEY_SUPERVISOR: u64 = {
    let mut _0: u64;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr4Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &control::Cr4Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr4Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr4Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::Cr4Flags;
    let _6: registers::control::Cr4Flags;
    let mut _7: registers::control::Cr4Flags;

    bb0: {
        _6 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = control::Cr4Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = control::Cr4Flags { bits: _1 };
        _0 = Option::<control::Cr4Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<control::Cr4Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<control::Cr4Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr4Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::Cr4Flags;
    let _8: registers::control::Cr4Flags;
    let mut _9: registers::control::Cr4Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = control::Cr4Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = control::Cr4Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<control::Cr4Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<control::Cr4Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;

    bb0: {
        _4 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = control::Cr4Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = control::Cr4Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = control::Cr4Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::Cr4Flags;
    let _5: registers::control::Cr4Flags;

    bb0: {
        _2 = control::Cr4Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = control::Cr4Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = control::Cr4Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::control::Cr4Flags;
    let mut _4: u64;
    let mut _5: &registers::control::Cr4Flags;
    let _6: registers::control::Cr4Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = control::Cr4Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::Cr4Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::Cr4Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr4Flags;
    let _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = control::Cr4Flags { bits: move _6 };
        _4 = &_5;
        _3 = control::Cr4Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::control::Cr4Flags;
    let _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = control::Cr4Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = control::Cr4Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut control::Cr4Flags, _2: control::Cr4Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::Cr4Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::Cr4Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr4Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr4Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr4Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::Cr4Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = control::Cr4Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = control::Cr4Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = control::Cr4Flags { bits: move _3 };
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::control::Cr4Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = control::Cr4Flags { bits: move _3 };
        _5 = control::Cr4Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <control::Cr4Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut control::Cr4Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr4Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr4Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr4Flags);
        _5 = control::Cr4Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> control::Cr4Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::Cr4Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr4Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::Cr4Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr4Flags as Extend<control::Cr4Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:166:5: 166:13>::read() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:166:5: 166:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr0", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:166:5: 166:13>::write(_1: control::Cr0Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::Cr0Flags;
    let _7: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: &registers::control::Cr0Flags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = control::Cr0Flags::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = control::Cr0Flags::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = control::Cr0Flags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = control::x86_64::<impl control::Cr0>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:166:5: 166:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov cr0, {0}", in(reg) _1, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:166:5: 166:13>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::control::Cr0Flags;
    let _3: ();
    let mut _4: (&mut registers::control::Cr0Flags,);
    let mut _5: &mut registers::control::Cr0Flags;
    let _6: ();
    let mut _7: registers::control::Cr0Flags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr0>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut control::Cr0Flags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = control::x86_64::<impl control::Cr0>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:240:5: 240:13>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr2>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:240:5: 240:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr2", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::read() -> (PhysFrame, control::Cr3Flags) {
    let mut _0: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    let _1: structures::paging::frame::PhysFrame;
    let _2: u16;
    let mut _3: (structures::paging::frame::PhysFrame, u16);
    let mut _5: u64;
    scope 1 {
        debug frame => _1;
        debug value => _2;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug flags => _4;
        }
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: u16);
        _5 = <u16 as Into<u64>>::into(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = control::Cr3Flags::from_bits_truncate(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = (_1, _4);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::read_raw() -> (PhysFrame, u16) {
    let mut _0: (structures::paging::frame::PhysFrame, u16);
    let _1: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _6: u16;
    let mut _7: u64;
    let mut _8: u64;
    scope 1 {
        debug value => _1;
        let _2: addr::PhysAddr;
        scope 2 {
        }
        scope 3 {
            debug addr => _2;
            let _5: structures::paging::frame::PhysFrame;
            scope 4 {
                debug frame => _5;
            }
        }
    }

    bb0: {
        asm!("mov {0}, cr3", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = BitAnd(move _4, const 4503599627366400_u64);
        _2 = PhysAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PhysFrame::containing_address(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = _1;
        _7 = BitAnd(move _8, const 4095_u64);
        _6 = move _7 as u16 (IntToInt);
        _0 = (_5, move _6);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::read_pcid() -> (PhysFrame, Pcid) {
    let mut _0: (structures::paging::frame::PhysFrame, instructions::tlb::Pcid);
    let _1: structures::paging::frame::PhysFrame;
    let _2: u16;
    let mut _3: (structures::paging::frame::PhysFrame, u16);
    let mut _4: instructions::tlb::Pcid;
    let mut _5: core::result::Result<instructions::tlb::Pcid, &str>;
    scope 1 {
        debug frame => _1;
        debug value => _2;
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: u16);
        _5 = Pcid::new(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Pcid, &str>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = (_1, move _4);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::write(_1: PhysFrame, _2: control::Cr3Flags) -> () {
    debug frame => _1;
    debug flags => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u16;
    let mut _5: u64;
    let mut _6: &registers::control::Cr3Flags;
    scope 1 {
    }

    bb0: {
        _6 = &_2;
        _5 = control::Cr3Flags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _5 as u16 (IntToInt);
        _3 = control::x86_64::<impl control::Cr3>::write_raw(_1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::write_pcid(_1: PhysFrame, _2: Pcid) -> () {
    debug frame => _1;
    debug pcid => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u16;
    let mut _5: &instructions::tlb::Pcid;
    scope 1 {
    }

    bb0: {
        _5 = &_2;
        _4 = Pcid::value(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = control::x86_64::<impl control::Cr3>::write_raw(_1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:260:5: 260:13>::write_raw(_1: PhysFrame, _2: u16) -> () {
    debug frame => _1;
    debug val => _2;
    let mut _0: ();
    let _3: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: u64;
    scope 1 {
        debug addr => _3;
        let _4: u64;
        scope 2 {
            debug value => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = PhysFrame::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = _2 as u64 (IntToInt);
        _4 = BitOr(move _5, move _6);
        asm!("mov cr3, {0}", in(reg) _4, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:336:5: 336:13>::read() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr4>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:336:5: 336:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr4", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:336:5: 336:13>::write(_1: control::Cr4Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::Cr4Flags;
    let _7: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: &registers::control::Cr4Flags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr4>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = control::Cr4Flags::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = control::Cr4Flags::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = control::Cr4Flags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = control::x86_64::<impl control::Cr4>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:336:5: 336:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov cr4, {0}", in(reg) _1, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/control.rs:336:5: 336:13>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::control::Cr4Flags;
    let _3: ();
    let mut _4: (&mut registers::control::Cr4Flags,);
    let mut _5: &mut registers::control::Cr4Flags;
    let _6: ();
    let mut _7: registers::control::Cr4Flags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr4>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut control::Cr4Flags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = control::x86_64::<impl control::Cr4>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr0;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr0", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr0, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr1, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr1";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr1", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr1, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr2, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr2";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr2;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr2", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr2, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr3, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr3";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr3;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr3", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr3, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:63:10: 63:15>::clone(_1: &DebugAddressRegisterNumber) -> DebugAddressRegisterNumber {
    debug self => _1;
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:63:23: 63:28>::fmt(_1: &DebugAddressRegisterNumber, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Dr3";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Dr0";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Dr1";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Dr2";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:63:30: 63:39>::eq(_1: &DebugAddressRegisterNumber, _2: &DebugAddressRegisterNumber) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:63:41: 63:43>::assert_receiver_is_total_eq(_1: &DebugAddressRegisterNumber) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:81:1: 81:32>::new(_1: u8) -> Option<DebugAddressRegisterNumber> {
    debug n => _1;
    let mut _0: core::option::Option<registers::debug::DebugAddressRegisterNumber>;
    let mut _2: registers::debug::DebugAddressRegisterNumber;
    let mut _3: registers::debug::DebugAddressRegisterNumber;
    let mut _4: registers::debug::DebugAddressRegisterNumber;
    let mut _5: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<DebugAddressRegisterNumber>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = DebugAddressRegisterNumber::Dr0;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = DebugAddressRegisterNumber::Dr1;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = DebugAddressRegisterNumber::Dr2;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = DebugAddressRegisterNumber::Dr3;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:81:1: 81:32>::new(_1: u8) -> Option<DebugAddressRegisterNumber> {
    debug n => _1;
    let mut _0: core::option::Option<registers::debug::DebugAddressRegisterNumber>;
    let mut _2: registers::debug::DebugAddressRegisterNumber;
    let mut _3: registers::debug::DebugAddressRegisterNumber;
    let mut _4: registers::debug::DebugAddressRegisterNumber;
    let mut _5: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<DebugAddressRegisterNumber>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = DebugAddressRegisterNumber::Dr0;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = DebugAddressRegisterNumber::Dr1;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = DebugAddressRegisterNumber::Dr2;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = DebugAddressRegisterNumber::Dr3;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:81:1: 81:32>::get(_1: DebugAddressRegisterNumber) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 3_u8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const 0_u8;
        goto -> bb6;
    }

    bb4: {
        _0 = const 1_u8;
        goto -> bb6;
    }

    bb5: {
        _0 = const 2_u8;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:81:1: 81:32>::get(_1: DebugAddressRegisterNumber) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 3_u8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const 0_u8;
        goto -> bb6;
    }

    bb4: {
        _0 = const 1_u8;
        goto -> bb6;
    }

    bb5: {
        _0 = const 2_u8;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:107:10: 107:15>::fmt(_1: &debug::Dr6, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr6";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &debug::Dr6Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &debug::Dr6Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _95: u64;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: &registers::debug::Dr6Flags;
    let _99: registers::debug::Dr6Flags;
    let mut _100: u64;
    let mut _101: bool;
    let mut _102: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _103: core::result::Result<(), core::fmt::Error>;
    let _104: &str;
    let mut _105: isize;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &u64;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _116: core::result::Result<(), core::fmt::Error>;
    let _117: &str;
    let mut _118: isize;
    scope 1 {
        debug first => _3;
        let _94: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug extra_bits => _94;
            scope 75 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 76 {
                }
            }
            scope 77 {
                debug val => const ();
                scope 78 {
                }
            }
            scope 79 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 80 {
                }
            }
            scope 81 {
                debug val => const ();
                scope 82 {
                }
            }
            scope 83 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 84 {
                }
            }
            scope 85 {
                debug val => const ();
                scope 86 {
                }
            }
            scope 87 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 88 {
                }
            }
            scope 89 {
                debug val => const ();
                scope 90 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::TRAP0(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "TRAP0";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb12: {
        _14 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::TRAP1(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "TRAP1";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb23: {
        _24 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::TRAP2(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "TRAP2";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb34: {
        _34 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::TRAP3(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "TRAP3";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb45: {
        _44 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::TRAP(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "TRAP";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb56: {
        _54 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::ACCESS_DETECTED(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "ACCESS_DETECTED";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb67: {
        _64 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::STEP(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "STEP";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb78: {
        _74 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::SWITCH(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "SWITCH";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb89: {
        _84 = <debug::Dr6Flags as <debug::Dr6Flags as Debug>::fmt::__BitFlags>::RTM(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "RTM";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb100: {
        _95 = ((*_1).0: u64);
        _99 = debug::Dr6Flags::all() -> [return: bb101, unwind unreachable];
    }

    bb101: {
        _98 = &_99;
        _97 = debug::Dr6Flags::bits(move _98) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _96 = Not(move _97);
        _94 = BitAnd(move _95, move _96);
        _100 = _94;
        switchInt(move _100) -> [0: bb116, otherwise: bb103];
    }

    bb103: {
        _101 = _3;
        switchInt(move _101) -> [0: bb104, otherwise: bb108];
    }

    bb104: {
        _104 = const " | ";
        _103 = Formatter::<'_>::write_str(_2, _104) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _102 = <Result<(), core::fmt::Error> as Try>::branch(move _103) -> [return: bb106, unwind unreachable];
    }

    bb106: {
        _105 = discriminant(_102);
        switchInt(move _105) -> [0: bb108, 1: bb107, otherwise: bb6];
    }

    bb107: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb108: {
        _3 = const false;
        _108 = const "0x";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb110, unwind unreachable];
    }

    bb110: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb111, 1: bb112, otherwise: bb6];
    }

    bb111: {
        _112 = &_94;
        _111 = <u64 as LowerHex>::fmt(_112, _2) -> [return: bb113, unwind unreachable];
    }

    bb112: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb113: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb116, 1: bb115, otherwise: bb6];
    }

    bb115: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb116: {
        _114 = _3;
        switchInt(move _114) -> [0: bb121, otherwise: bb117];
    }

    bb117: {
        _117 = const "(empty)";
        _116 = Formatter::<'_>::write_str(_2, _117) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _115 = <Result<(), core::fmt::Error> as Try>::branch(move _116) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _118 = discriminant(_115);
        switchInt(move _118) -> [0: bb121, 1: bb120, otherwise: bb6];
    }

    bb120: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb121: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb122;
    }

    bb122: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP0(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP1(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP2(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP3(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ACCESS_DETECTED(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::STEP(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SWITCH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::RTM(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP0(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP1(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP2(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP3(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ACCESS_DETECTED(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::STEP(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SWITCH(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::RTM(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr6Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr6Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP0: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags { bits: const 1_u64 };
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP1: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP2: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP3: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: registers::debug::Dr6Flags;
    let mut _8: u64;
    let mut _9: registers::debug::Dr6Flags;
    let mut _10: u64;
    let mut _11: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = (_5.0: u64);
        StorageLive(_6);
        StorageLive(_7);
        _7 = const _;
        _6 = (_7.0: u64);
        _3 = BitOr(move _4, move _6);
        StorageDead(_6);
        StorageDead(_4);
        StorageLive(_8);
        StorageLive(_9);
        _9 = const _;
        _8 = (_9.0: u64);
        _2 = BitOr(move _3, move _8);
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_10);
        StorageLive(_11);
        _11 = const _;
        _10 = (_11.0: u64);
        _1 = BitOr(move _2, move _10);
        StorageDead(_10);
        StorageDead(_2);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_11);
        StorageDead(_9);
        StorageDead(_7);
        StorageDead(_5);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ACCESS_DETECTED: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::STEP: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SWITCH: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::RTM: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags { bits: const 0_u64 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _8 = BitOr(const _, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = debug::Dr6Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = BitOr(const _, const _);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = debug::Dr6Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP0: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP1: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP2: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP3: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ACCESS_DETECTED: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::STEP: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SWITCH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::RTM: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP0: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP1: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP2: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP3: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ACCESS_DETECTED: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::STEP: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SWITCH: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::RTM: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &debug::Dr6Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &debug::Dr6Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<debug::Dr6Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr6Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr6Flags;
    let _6: registers::debug::Dr6Flags;
    let mut _7: registers::debug::Dr6Flags;

    bb0: {
        _6 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = debug::Dr6Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = debug::Dr6Flags { bits: _1 };
        _0 = Option::<debug::Dr6Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<debug::Dr6Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<debug::Dr6Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr6Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr6Flags;
    let _8: registers::debug::Dr6Flags;
    let mut _9: registers::debug::Dr6Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = debug::Dr6Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = debug::Dr6Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<debug::Dr6Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<debug::Dr6Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;

    bb0: {
        _4 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = debug::Dr6Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = debug::Dr6Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = debug::Dr6Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr6Flags;
    let _5: registers::debug::Dr6Flags;

    bb0: {
        _2 = debug::Dr6Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = debug::Dr6Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = debug::Dr6Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::debug::Dr6Flags;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr6Flags;
    let _6: registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = debug::Dr6Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = debug::Dr6Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = debug::Dr6Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::debug::Dr6Flags;
    let _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = debug::Dr6Flags { bits: move _6 };
        _4 = &_5;
        _3 = debug::Dr6Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::debug::Dr6Flags;
    let _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = debug::Dr6Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = debug::Dr6Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = debug::Dr6Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = debug::Dr6Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::Dr6Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::Dr6Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::Dr6Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::Dr6Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = debug::Dr6Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = debug::Dr6Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = debug::Dr6Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr6Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = debug::Dr6Flags { bits: move _3 };
        _5 = debug::Dr6Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <debug::Dr6Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut debug::Dr6Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::Dr6Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::Dr6Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::Dr6Flags);
        _5 = debug::Dr6Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> debug::Dr6Flags {
    debug iterator => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::Dr6Flags;
    let _3: ();
    let mut _4: &mut registers::debug::Dr6Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = debug::Dr6Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <debug::Dr6Flags as Extend<debug::Dr6Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:151:1: 151:14>::trap(_1: DebugAddressRegisterNumber) -> debug::Dr6Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb6;
    }

    bb4: {
        _0 = const _;
        goto -> bb6;
    }

    bb5: {
        _0 = const _;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &Dr7Flags, _2: &Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &Dr7Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &Dr7Flags, _2: &Dr7Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &Dr7Flags, _2: &Dr7Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &Dr7Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _125: u64;
    let mut _126: u64;
    let mut _127: u64;
    let mut _128: &registers::debug::Dr7Flags;
    let _129: registers::debug::Dr7Flags;
    let mut _130: u64;
    let mut _131: bool;
    let mut _132: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _133: core::result::Result<(), core::fmt::Error>;
    let _134: &str;
    let mut _135: isize;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &u64;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _146: core::result::Result<(), core::fmt::Error>;
    let _147: &str;
    let mut _148: isize;
    scope 1 {
        debug first => _3;
        let _124: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug extra_bits => _124;
            scope 99 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 100 {
                }
            }
            scope 101 {
                debug val => const ();
                scope 102 {
                }
            }
            scope 103 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 104 {
                }
            }
            scope 105 {
                debug val => const ();
                scope 106 {
                }
            }
            scope 107 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 108 {
                }
            }
            scope 109 {
                debug val => const ();
                scope 110 {
                }
            }
            scope 111 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 112 {
                }
            }
            scope 113 {
                debug val => const ();
                scope 114 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::LOCAL_BREAKPOINT_0_ENABLE(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "LOCAL_BREAKPOINT_0_ENABLE";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb12: {
        _14 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::LOCAL_BREAKPOINT_1_ENABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "LOCAL_BREAKPOINT_1_ENABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb23: {
        _24 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::LOCAL_BREAKPOINT_2_ENABLE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "LOCAL_BREAKPOINT_2_ENABLE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb34: {
        _34 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::LOCAL_BREAKPOINT_3_ENABLE(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "LOCAL_BREAKPOINT_3_ENABLE";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb45: {
        _44 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GLOBAL_BREAKPOINT_0_ENABLE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "GLOBAL_BREAKPOINT_0_ENABLE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb56: {
        _54 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GLOBAL_BREAKPOINT_1_ENABLE(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "GLOBAL_BREAKPOINT_1_ENABLE";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb67: {
        _64 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GLOBAL_BREAKPOINT_2_ENABLE(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "GLOBAL_BREAKPOINT_2_ENABLE";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb78: {
        _74 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GLOBAL_BREAKPOINT_3_ENABLE(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "GLOBAL_BREAKPOINT_3_ENABLE";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb89: {
        _84 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::LOCAL_EXACT_BREAKPOINT_ENABLE(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "LOCAL_EXACT_BREAKPOINT_ENABLE";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb100: {
        _94 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GLOBAL_EXACT_BREAKPOINT_ENABLE(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "GLOBAL_EXACT_BREAKPOINT_ENABLE";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb111: {
        _104 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::RESTRICTED_TRANSACTIONAL_MEMORY(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "RESTRICTED_TRANSACTIONAL_MEMORY";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb122: {
        _114 = <Dr7Flags as <Dr7Flags as Debug>::fmt::__BitFlags>::GENERAL_DETECT_ENABLE(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "GENERAL_DETECT_ENABLE";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb133: {
        _125 = ((*_1).0: u64);
        _129 = Dr7Flags::all() -> [return: bb134, unwind unreachable];
    }

    bb134: {
        _128 = &_129;
        _127 = Dr7Flags::bits(move _128) -> [return: bb135, unwind unreachable];
    }

    bb135: {
        _126 = Not(move _127);
        _124 = BitAnd(move _125, move _126);
        _130 = _124;
        switchInt(move _130) -> [0: bb149, otherwise: bb136];
    }

    bb136: {
        _131 = _3;
        switchInt(move _131) -> [0: bb137, otherwise: bb141];
    }

    bb137: {
        _134 = const " | ";
        _133 = Formatter::<'_>::write_str(_2, _134) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _132 = <Result<(), core::fmt::Error> as Try>::branch(move _133) -> [return: bb139, unwind unreachable];
    }

    bb139: {
        _135 = discriminant(_132);
        switchInt(move _135) -> [0: bb141, 1: bb140, otherwise: bb6];
    }

    bb140: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb141: {
        _3 = const false;
        _138 = const "0x";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb143, unwind unreachable];
    }

    bb143: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb144, 1: bb145, otherwise: bb6];
    }

    bb144: {
        _142 = &_124;
        _141 = <u64 as LowerHex>::fmt(_142, _2) -> [return: bb146, unwind unreachable];
    }

    bb145: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb146: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb147, unwind unreachable];
    }

    bb147: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb149, 1: bb148, otherwise: bb6];
    }

    bb148: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb149: {
        _144 = _3;
        switchInt(move _144) -> [0: bb154, otherwise: bb150];
    }

    bb150: {
        _147 = const "(empty)";
        _146 = Formatter::<'_>::write_str(_2, _147) -> [return: bb151, unwind unreachable];
    }

    bb151: {
        _145 = <Result<(), core::fmt::Error> as Try>::branch(move _146) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _148 = discriminant(_145);
        switchInt(move _148) -> [0: bb154, 1: bb153, otherwise: bb6];
    }

    bb153: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb155, unwind unreachable];
    }

    bb154: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb155;
    }

    bb155: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LOCAL_BREAKPOINT_0_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LOCAL_BREAKPOINT_1_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LOCAL_BREAKPOINT_2_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LOCAL_BREAKPOINT_3_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL_BREAKPOINT_0_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL_BREAKPOINT_1_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL_BREAKPOINT_2_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL_BREAKPOINT_3_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LOCAL_EXACT_BREAKPOINT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL_EXACT_BREAKPOINT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::RESTRICTED_TRANSACTIONAL_MEMORY(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GENERAL_DETECT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LOCAL_BREAKPOINT_0_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LOCAL_BREAKPOINT_1_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LOCAL_BREAKPOINT_2_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LOCAL_BREAKPOINT_3_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL_BREAKPOINT_0_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL_BREAKPOINT_1_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL_BREAKPOINT_2_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL_BREAKPOINT_3_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LOCAL_EXACT_BREAKPOINT_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL_EXACT_BREAKPOINT_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::RESTRICTED_TRANSACTIONAL_MEMORY(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GENERAL_DETECT_ENABLE(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::debug::Dr7Flags;
    let mut _9: u64;
    let mut _10: registers::debug::Dr7Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LOCAL_BREAKPOINT_0_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags { bits: const 1_u64 };
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LOCAL_BREAKPOINT_1_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LOCAL_BREAKPOINT_2_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LOCAL_BREAKPOINT_3_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL_BREAKPOINT_0_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL_BREAKPOINT_1_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL_BREAKPOINT_2_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL_BREAKPOINT_3_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LOCAL_EXACT_BREAKPOINT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL_EXACT_BREAKPOINT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::RESTRICTED_TRANSACTIONAL_MEMORY: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GENERAL_DETECT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags { bits: const 0_u64 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;

    bb0: {
        _11 = BitOr(const _, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = Dr7Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        _11 = BitOr(const _, const _);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = Dr7Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LOCAL_BREAKPOINT_0_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LOCAL_BREAKPOINT_1_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LOCAL_BREAKPOINT_2_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LOCAL_BREAKPOINT_3_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL_BREAKPOINT_0_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL_BREAKPOINT_1_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL_BREAKPOINT_2_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL_BREAKPOINT_3_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LOCAL_EXACT_BREAKPOINT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL_EXACT_BREAKPOINT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::RESTRICTED_TRANSACTIONAL_MEMORY: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GENERAL_DETECT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LOCAL_BREAKPOINT_0_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LOCAL_BREAKPOINT_1_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LOCAL_BREAKPOINT_2_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LOCAL_BREAKPOINT_3_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL_BREAKPOINT_0_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL_BREAKPOINT_1_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL_BREAKPOINT_2_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL_BREAKPOINT_3_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LOCAL_EXACT_BREAKPOINT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL_EXACT_BREAKPOINT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::RESTRICTED_TRANSACTIONAL_MEMORY: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GENERAL_DETECT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &Dr7Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &Dr7Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<Dr7Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr7Flags;
    let _6: registers::debug::Dr7Flags;
    let mut _7: registers::debug::Dr7Flags;

    bb0: {
        _6 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = Dr7Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = Dr7Flags { bits: _1 };
        _0 = Option::<Dr7Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<Dr7Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<Dr7Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr7Flags;
    let _8: registers::debug::Dr7Flags;
    let mut _9: registers::debug::Dr7Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = Dr7Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = Dr7Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<Dr7Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<Dr7Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;

    bb0: {
        _4 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = Dr7Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = Dr7Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = Dr7Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;
    let _5: registers::debug::Dr7Flags;

    bb0: {
        _2 = Dr7Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Dr7Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = Dr7Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::debug::Dr7Flags;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr7Flags;
    let _6: registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = Dr7Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = Dr7Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = Dr7Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::debug::Dr7Flags;
    let _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = Dr7Flags { bits: move _6 };
        _4 = &_5;
        _3 = Dr7Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::debug::Dr7Flags;
    let _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = Dr7Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = Dr7Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut Dr7Flags, _2: Dr7Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = Dr7Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = Dr7Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = Dr7Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = Dr7Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = Dr7Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = Dr7Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = Dr7Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = Dr7Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = Dr7Flags { bits: move _3 };
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr7Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = Dr7Flags { bits: move _3 };
        _5 = Dr7Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <Dr7Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut Dr7Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::Dr7Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::Dr7Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::Dr7Flags);
        _5 = Dr7Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> Dr7Flags {
    debug iterator => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::Dr7Flags;
    let _3: ();
    let mut _4: &mut registers::debug::Dr7Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = Dr7Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <Dr7Flags as Extend<Dr7Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:213:1: 213:14>::local_breakpoint_enable(_1: DebugAddressRegisterNumber) -> Dr7Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb6;
    }

    bb4: {
        _0 = const _;
        goto -> bb6;
    }

    bb5: {
        _0 = const _;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:213:1: 213:14>::global_breakpoint_enable(_1: DebugAddressRegisterNumber) -> Dr7Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb6;
    }

    bb4: {
        _0 = const _;
        goto -> bb6;
    }

    bb5: {
        _0 = const _;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

BreakpointCondition::InstructionExecution::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

BreakpointCondition::DataWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

BreakpointCondition::IoReadsWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

BreakpointCondition::DataReadsWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:236:10: 236:15>::clone(_1: &BreakpointCondition) -> BreakpointCondition {
    debug self => _1;
    let mut _0: registers::debug::BreakpointCondition;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:236:23: 236:28>::fmt(_1: &BreakpointCondition, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "DataReadsWrites";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "InstructionExecution";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "DataWrites";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "IoReadsWrites";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:236:30: 236:39>::eq(_1: &BreakpointCondition, _2: &BreakpointCondition) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:236:41: 236:43>::assert_receiver_is_total_eq(_1: &BreakpointCondition) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:252:1: 252:25>::from_bits(_1: u64) -> Option<BreakpointCondition> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointCondition>;
    let mut _2: registers::debug::BreakpointCondition;
    let mut _3: registers::debug::BreakpointCondition;
    let mut _4: registers::debug::BreakpointCondition;
    let mut _5: registers::debug::BreakpointCondition;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointCondition>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointCondition::InstructionExecution;
        _0 = Option::<BreakpointCondition>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointCondition::DataWrites;
        _0 = Option::<BreakpointCondition>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointCondition::IoReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointCondition::DataReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:252:1: 252:25>::from_bits(_1: u64) -> Option<BreakpointCondition> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointCondition>;
    let mut _2: registers::debug::BreakpointCondition;
    let mut _3: registers::debug::BreakpointCondition;
    let mut _4: registers::debug::BreakpointCondition;
    let mut _5: registers::debug::BreakpointCondition;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointCondition>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointCondition::InstructionExecution;
        _0 = Option::<BreakpointCondition>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointCondition::DataWrites;
        _0 = Option::<BreakpointCondition>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointCondition::IoReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointCondition::DataReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:252:1: 252:25>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: (u8, bool);
    let mut _7: (u8, bool);
    let mut _8: usize;
    let mut _9: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        _5 = DebugAddressRegisterNumber::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(const 4_u8, _5);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_6.0: u8);
        _7 = CheckedAdd(const 16_u8, _4);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", const 16_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_7.0: u8);
        _2 = move _3 as usize (IntToInt);
        _9 = CheckedAdd(_2, const 2_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: usize);
        _0 = Range::<usize> { start: _2, end: move _8 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:252:1: 252:25>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: registers::debug::DebugAddressRegisterNumber;
    let mut _7: (u8, bool);
    let mut _8: (u8, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        ConstEvalCounter;
        _5 = DebugAddressRegisterNumber::get(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        _7 = CheckedMul(const 4_u8, _5);
        assert(!move (_7.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_7.0: u8);
        StorageDead(_5);
        _8 = CheckedAdd(const 16_u8, _4);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", const 16_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_8.0: u8);
        StorageDead(_4);
        _2 = move _3 as usize (IntToInt);
        StorageDead(_3);
        StorageLive(_9);
        _9 = _2;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _2;
        _12 = CheckedAdd(_11, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = move (_12.0: usize);
        StorageDead(_11);
        _0 = Range::<usize> { start: move _9, end: move _10 };
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_2);
        return;
    }
}

BreakpointSize::Length1B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

BreakpointSize::Length2B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

BreakpointSize::Length8B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

BreakpointSize::Length4B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:271:10: 271:15>::clone(_1: &BreakpointSize) -> BreakpointSize {
    debug self => _1;
    let mut _0: registers::debug::BreakpointSize;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:271:23: 271:28>::fmt(_1: &BreakpointSize, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Length4B";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Length1B";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Length2B";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Length8B";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:271:30: 271:39>::eq(_1: &BreakpointSize, _2: &BreakpointSize) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:271:41: 271:43>::assert_receiver_is_total_eq(_1: &BreakpointSize) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::new(_1: usize) -> Option<BreakpointSize> {
    debug size => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [1: bb2, 2: bb3, 8: bb4, 4: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::new(_1: usize) -> Option<BreakpointSize> {
    debug size => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [1: bb2, 2: bb3, 8: bb4, 4: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::from_bits(_1: u64) -> Option<BreakpointSize> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::from_bits(_1: u64) -> Option<BreakpointSize> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: (u8, bool);
    let mut _7: (u8, bool);
    let mut _8: usize;
    let mut _9: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        _5 = DebugAddressRegisterNumber::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(const 4_u8, _5);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_6.0: u8);
        _7 = CheckedAdd(const 18_u8, _4);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", const 18_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_7.0: u8);
        _2 = move _3 as usize (IntToInt);
        _9 = CheckedAdd(_2, const 2_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: usize);
        _0 = Range::<usize> { start: _2, end: move _8 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:287:1: 287:20>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: registers::debug::DebugAddressRegisterNumber;
    let mut _7: (u8, bool);
    let mut _8: (u8, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        ConstEvalCounter;
        _5 = DebugAddressRegisterNumber::get(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        _7 = CheckedMul(const 4_u8, _5);
        assert(!move (_7.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_7.0: u8);
        StorageDead(_5);
        _8 = CheckedAdd(const 18_u8, _4);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", const 18_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_8.0: u8);
        StorageDead(_4);
        _2 = move _3 as usize (IntToInt);
        StorageDead(_3);
        StorageLive(_9);
        _9 = _2;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _2;
        _12 = CheckedAdd(_11, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = move (_12.0: usize);
        StorageDead(_11);
        _0 = Range::<usize> { start: move _9, end: move _10 };
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:319:10: 319:15>::clone(_1: &debug::Dr7Value) -> debug::Dr7Value {
    debug self => _1;
    let mut _0: registers::debug::Dr7Value;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:319:23: 319:28>::fmt(_1: &debug::Dr7Value, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&u64;
    let _7: &u64;

    bb0: {
        _3 = const "Dr7Value";
        _4 = const "bits";
        _7 = &((*_1).0: u64);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:319:30: 319:39>::eq(_1: &debug::Dr7Value, _2: &debug::Dr7Value) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:319:41: 319:43>::assert_receiver_is_total_eq(_1: &debug::Dr7Value) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:325:1: 325:33>::from(_1: Dr7Flags) -> debug::Dr7Value {
    debug dr7_flags => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: &registers::debug::Dr7Flags;

    bb0: {
        _3 = &_1;
        _2 = Dr7Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr7Value::from_bits_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::valid_bits() -> u64 {
    let mut _0: u64;
    let _1: u64;
    let mut _2: u64;
    let mut _3: u32;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: (u64, bool);
    let mut _10: &registers::debug::Dr7Flags;
    let _11: registers::debug::Dr7Flags;
    scope 1 {
        debug field_valid_bits => _1;
        let _9: u64;
        scope 2 {
            debug flag_valid_bits => _9;
        }
    }

    bb0: {
        _3 = const 32_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 64_u32);
        assert(move _4, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shl(const 1_u64, const 32_i32);
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const 1_u64, const 16_i32);
        _8 = CheckedSub(_2, _5);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2, move _5) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move (_8.0: u64);
        _11 = Dr7Flags::all() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = &_11;
        _9 = Dr7Flags::bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = BitOr(_1, _9);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::valid_bits() -> u64 {
    let mut _0: u64;
    let _1: u64;
    let mut _2: u64;
    let mut _3: u32;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: (u64, bool);
    let mut _10: &registers::debug::Dr7Flags;
    let _11: registers::debug::Dr7Flags;
    let mut _12: u64;
    let mut _13: u64;
    scope 1 {
        debug field_valid_bits => _1;
        let _9: u64;
        scope 2 {
            debug flag_valid_bits => _9;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _3 = const 32_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 64_u32);
        assert(move _4, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shl(const 1_u64, const 32_i32);
        StorageLive(_5);
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const 1_u64, const 16_i32);
        _8 = CheckedSub(_2, _5);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2, move _5) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move (_8.0: u64);
        StorageDead(_5);
        StorageDead(_2);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        ConstEvalCounter;
        _11 = Dr7Flags::all() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = &_11;
        ConstEvalCounter;
        _9 = Dr7Flags::bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_10);
        StorageDead(_11);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _9;
        _0 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_9);
        StorageDead(_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits(_1: u64) -> Option<debug::Dr7Value> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Value>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr7Value;

    bb0: {
        _4 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = debug::Dr7Value { bits: _1 };
        _0 = Option::<debug::Dr7Value>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<debug::Dr7Value>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits(_1: u64) -> Option<debug::Dr7Value> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Value>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: registers::debug::Dr7Value;
    let mut _8: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _1;
        _7 = debug::Dr7Value { bits: move _8 };
        StorageDead(_8);
        _0 = Option::<debug::Dr7Value>::Some(move _7);
        StorageDead(_7);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_3);
        _0 = Option::<debug::Dr7Value>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits_truncate(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(_1, move _3);
        _0 = debug::Dr7Value { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits_truncate(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        ConstEvalCounter;
        _4 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = debug::Dr7Value { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits_unchecked(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;

    bb0: {
        _0 = debug::Dr7Value { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::from_bits_unchecked(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = debug::Dr7Value { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::bits(_1: &debug::Dr7Value) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::bits(_1: &debug::Dr7Value) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::flags(_1: debug::Dr7Value) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = Dr7Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::flags(_1: debug::Dr7Value) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        ConstEvalCounter;
        _0 = Dr7Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::insert_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;

    bb0: {
        _4 = &_2;
        _3 = Dr7Flags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::remove_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr7Flags;

    bb0: {
        _5 = &_2;
        _4 = Dr7Flags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::toggle_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;

    bb0: {
        _4 = &_2;
        _3 = Dr7Flags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::set_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags, _3: bool) -> () {
    debug self => _1;
    debug flags => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = debug::Dr7Value::insert_flags(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = debug::Dr7Value::remove_flags(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::condition(_1: &debug::Dr7Value, _2: DebugAddressRegisterNumber) -> BreakpointCondition {
    debug self => _1;
    debug n => _2;
    let mut _0: registers::debug::BreakpointCondition;
    let _3: u64;
    let mut _4: &u64;
    let mut _5: core::ops::Range<usize>;
    let mut _6: core::option::Option<registers::debug::BreakpointCondition>;
    let _7: &str;
    scope 1 {
        debug condition => _3;
    }

    bb0: {
        _4 = &((*_1).0: u64);
        _5 = BreakpointCondition::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u64 as BitField>::get_bits::<Range<usize>>(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = BreakpointCondition::from_bits(_3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = const "condition should be always valid";
        _0 = Option::<BreakpointCondition>::expect(move _6, _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::set_condition(_1: &mut debug::Dr7Value, _2: DebugAddressRegisterNumber, _3: BreakpointCondition) -> () {
    debug self => _1;
    debug n => _2;
    debug condition => _3;
    let mut _0: ();
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = &mut ((*_1).0: u64);
        _6 = BreakpointCondition::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = discriminant(_3);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u64 (IntToInt);
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::size(_1: &debug::Dr7Value, _2: DebugAddressRegisterNumber) -> BreakpointSize {
    debug self => _1;
    debug n => _2;
    let mut _0: registers::debug::BreakpointSize;
    let _3: u64;
    let mut _4: &u64;
    let mut _5: core::ops::Range<usize>;
    let mut _6: core::option::Option<registers::debug::BreakpointSize>;
    let _7: &str;
    scope 1 {
        debug size => _3;
    }

    bb0: {
        _4 = &((*_1).0: u64);
        _5 = BreakpointSize::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u64 as BitField>::get_bits::<Range<usize>>(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = BreakpointSize::from_bits(_3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = const "condition should be always valid";
        _0 = Option::<BreakpointSize>::expect(move _6, _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:331:1: 331:14>::set_size(_1: &mut debug::Dr7Value, _2: DebugAddressRegisterNumber, _3: BreakpointSize) -> () {
    debug self => _1;
    debug n => _2;
    debug size => _3;
    let mut _0: ();
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = &mut ((*_1).0: u64);
        _6 = BreakpointSize::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = discriminant(_3);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u64 (IntToInt);
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:434:10: 434:15>::fmt(_1: &debug::Dr7, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr7";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:441:5: 441:13>::read() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;

    bb0: {
        _1 = debug::x86_64::<impl debug::Dr6>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:441:5: 441:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr6", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:461:5: 461:13>::read() -> debug::Dr7Value {
    let mut _0: registers::debug::Dr7Value;
    let mut _1: u64;

    bb0: {
        _1 = debug::x86_64::<impl debug::Dr7>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr7Value::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:461:5: 461:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr7", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:461:5: 461:13>::write(_1: debug::Dr7Value) -> () {
    debug value => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _7: u64;
    let mut _8: &registers::debug::Dr7Value;
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _6: u64;
            scope 3 {
                debug new_value => _6;
            }
        }
    }

    bb0: {
        _2 = debug::x86_64::<impl debug::Dr7>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = debug::Dr7Value::valid_bits() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _8 = &_1;
        _7 = debug::Dr7Value::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = BitOr(_3, move _7);
        _0 = debug::x86_64::<impl debug::Dr7>::write_raw(_6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/debug.rs:461:5: 461:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr7, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:9:10: 9:15>::fmt(_1: &model_specific::Msr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u32;
    let _6: &u32;

    bb0: {
        _3 = const "Msr";
        _6 = &((*_1).0: u32);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:12:1: 12:9>::new(_1: u32) -> model_specific::Msr {
    debug reg => _1;
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(_1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:12:1: 12:9>::new(_1: u32) -> model_specific::Msr {
    debug reg => _1;
    let mut _0: registers::model_specific::Msr;
    let mut _2: u32;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = model_specific::Msr(move _2);
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:21:10: 21:15>::fmt(_1: &model_specific::Efer, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Efer";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:25:10: 25:15>::fmt(_1: &model_specific::FsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "FsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:34:10: 34:15>::fmt(_1: &model_specific::GsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "GsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:43:10: 43:15>::fmt(_1: &model_specific::KernelGsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "KernelGsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:47:10: 47:15>::fmt(_1: &model_specific::Star, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Star";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:51:10: 51:15>::fmt(_1: &model_specific::LStar, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "LStar";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:55:10: 55:15>::fmt(_1: &model_specific::SFMask, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SFMask";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:59:10: 59:15>::fmt(_1: &model_specific::UCet, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "UCet";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:63:10: 63:15>::fmt(_1: &model_specific::SCet, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SCet";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:66:1: 66:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225600_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:71:1: 71:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225728_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:76:1: 76:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225729_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:81:1: 81:18>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225730_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:86:1: 86:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225601_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:91:1: 91:11>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225602_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:96:1: 96:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225604_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:101:1: 101:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 1696_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:106:1: 106:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 1698_u32);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &model_specific::EferFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &model_specific::EferFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _85: u64;
    let mut _86: u64;
    let mut _87: u64;
    let mut _88: &registers::model_specific::EferFlags;
    let _89: registers::model_specific::EferFlags;
    let mut _90: u64;
    let mut _91: bool;
    let mut _92: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _93: core::result::Result<(), core::fmt::Error>;
    let _94: &str;
    let mut _95: isize;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &u64;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _106: core::result::Result<(), core::fmt::Error>;
    let _107: &str;
    let mut _108: isize;
    scope 1 {
        debug first => _3;
        let _84: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug extra_bits => _84;
            scope 67 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 68 {
                }
            }
            scope 69 {
                debug val => const ();
                scope 70 {
                }
            }
            scope 71 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 72 {
                }
            }
            scope 73 {
                debug val => const ();
                scope 74 {
                }
            }
            scope 75 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 76 {
                }
            }
            scope 77 {
                debug val => const ();
                scope 78 {
                }
            }
            scope 79 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 80 {
                }
            }
            scope 81 {
                debug val => const ();
                scope 82 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::SYSTEM_CALL_EXTENSIONS(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "SYSTEM_CALL_EXTENSIONS";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb12: {
        _14 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::LONG_MODE_ENABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "LONG_MODE_ENABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb23: {
        _24 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::LONG_MODE_ACTIVE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "LONG_MODE_ACTIVE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb34: {
        _34 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::NO_EXECUTE_ENABLE(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "NO_EXECUTE_ENABLE";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb45: {
        _44 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::SECURE_VIRTUAL_MACHINE_ENABLE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "SECURE_VIRTUAL_MACHINE_ENABLE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb56: {
        _54 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::LONG_MODE_SEGMENT_LIMIT_ENABLE(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "LONG_MODE_SEGMENT_LIMIT_ENABLE";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb67: {
        _64 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::FAST_FXSAVE_FXRSTOR(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "FAST_FXSAVE_FXRSTOR";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb78: {
        _74 = <model_specific::EferFlags as <model_specific::EferFlags as Debug>::fmt::__BitFlags>::TRANSLATION_CACHE_EXTENSION(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "TRANSLATION_CACHE_EXTENSION";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb89: {
        _85 = ((*_1).0: u64);
        _89 = model_specific::EferFlags::all() -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _88 = &_89;
        _87 = model_specific::EferFlags::bits(move _88) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _86 = Not(move _87);
        _84 = BitAnd(move _85, move _86);
        _90 = _84;
        switchInt(move _90) -> [0: bb105, otherwise: bb92];
    }

    bb92: {
        _91 = _3;
        switchInt(move _91) -> [0: bb93, otherwise: bb97];
    }

    bb93: {
        _94 = const " | ";
        _93 = Formatter::<'_>::write_str(_2, _94) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _92 = <Result<(), core::fmt::Error> as Try>::branch(move _93) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _95 = discriminant(_92);
        switchInt(move _95) -> [0: bb97, 1: bb96, otherwise: bb6];
    }

    bb96: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb97: {
        _3 = const false;
        _98 = const "0x";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb100, 1: bb101, otherwise: bb6];
    }

    bb100: {
        _102 = &_84;
        _101 = <u64 as LowerHex>::fmt(_102, _2) -> [return: bb102, unwind unreachable];
    }

    bb101: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb102: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb105, 1: bb104, otherwise: bb6];
    }

    bb104: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb105: {
        _104 = _3;
        switchInt(move _104) -> [0: bb110, otherwise: bb106];
    }

    bb106: {
        _107 = const "(empty)";
        _106 = Formatter::<'_>::write_str(_2, _107) -> [return: bb107, unwind unreachable];
    }

    bb107: {
        _105 = <Result<(), core::fmt::Error> as Try>::branch(move _106) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _108 = discriminant(_105);
        switchInt(move _108) -> [0: bb110, 1: bb109, otherwise: bb6];
    }

    bb109: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb110: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb111;
    }

    bb111: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SYSTEM_CALL_EXTENSIONS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LONG_MODE_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LONG_MODE_ACTIVE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NO_EXECUTE_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SECURE_VIRTUAL_MACHINE_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LONG_MODE_SEGMENT_LIMIT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::FAST_FXSAVE_FXRSTOR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRANSLATION_CACHE_EXTENSION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SYSTEM_CALL_EXTENSIONS(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LONG_MODE_ENABLE(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LONG_MODE_ACTIVE(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NO_EXECUTE_ENABLE(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SECURE_VIRTUAL_MACHINE_ENABLE(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LONG_MODE_SEGMENT_LIMIT_ENABLE(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::FAST_FXSAVE_FXRSTOR(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRANSLATION_CACHE_EXTENSION(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::EferFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SYSTEM_CALL_EXTENSIONS: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags { bits: const 1_u64 };
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LONG_MODE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LONG_MODE_ACTIVE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NO_EXECUTE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SECURE_VIRTUAL_MACHINE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LONG_MODE_SEGMENT_LIMIT_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::FAST_FXSAVE_FXRSTOR: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRANSLATION_CACHE_EXTENSION: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags { bits: const 0_u64 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;

    bb0: {
        _7 = BitOr(const _, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = model_specific::EferFlags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = BitOr(const _, const _);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = model_specific::EferFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SYSTEM_CALL_EXTENSIONS: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LONG_MODE_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LONG_MODE_ACTIVE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NO_EXECUTE_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SECURE_VIRTUAL_MACHINE_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LONG_MODE_SEGMENT_LIMIT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::FAST_FXSAVE_FXRSTOR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRANSLATION_CACHE_EXTENSION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SYSTEM_CALL_EXTENSIONS: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LONG_MODE_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LONG_MODE_ACTIVE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NO_EXECUTE_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SECURE_VIRTUAL_MACHINE_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LONG_MODE_SEGMENT_LIMIT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::FAST_FXSAVE_FXRSTOR: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRANSLATION_CACHE_EXTENSION: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &model_specific::EferFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &model_specific::EferFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<model_specific::EferFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::EferFlags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::EferFlags;
    let _6: registers::model_specific::EferFlags;
    let mut _7: registers::model_specific::EferFlags;

    bb0: {
        _6 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = model_specific::EferFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = model_specific::EferFlags { bits: _1 };
        _0 = Option::<model_specific::EferFlags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<model_specific::EferFlags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<model_specific::EferFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::EferFlags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::EferFlags;
    let _8: registers::model_specific::EferFlags;
    let mut _9: registers::model_specific::EferFlags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = model_specific::EferFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = model_specific::EferFlags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<model_specific::EferFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<model_specific::EferFlags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;

    bb0: {
        _4 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = model_specific::EferFlags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = model_specific::EferFlags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = model_specific::EferFlags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::EferFlags;
    let _5: registers::model_specific::EferFlags;

    bb0: {
        _2 = model_specific::EferFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = model_specific::EferFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = model_specific::EferFlags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::model_specific::EferFlags;
    let mut _4: u64;
    let mut _5: &registers::model_specific::EferFlags;
    let _6: registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = model_specific::EferFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = model_specific::EferFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = model_specific::EferFlags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::model_specific::EferFlags;
    let _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = model_specific::EferFlags { bits: move _6 };
        _4 = &_5;
        _3 = model_specific::EferFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::model_specific::EferFlags;
    let _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = model_specific::EferFlags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = model_specific::EferFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = model_specific::EferFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::EferFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::EferFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::EferFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::EferFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::EferFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = model_specific::EferFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = model_specific::EferFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::EferFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::model_specific::EferFlags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = model_specific::EferFlags { bits: move _3 };
        _5 = model_specific::EferFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <model_specific::EferFlags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut model_specific::EferFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::EferFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::EferFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::EferFlags);
        _5 = model_specific::EferFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> model_specific::EferFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::EferFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::EferFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::EferFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::EferFlags as Extend<model_specific::EferFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &model_specific::CetFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &model_specific::CetFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _85: u64;
    let mut _86: u64;
    let mut _87: u64;
    let mut _88: &registers::model_specific::CetFlags;
    let _89: registers::model_specific::CetFlags;
    let mut _90: u64;
    let mut _91: bool;
    let mut _92: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _93: core::result::Result<(), core::fmt::Error>;
    let _94: &str;
    let mut _95: isize;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &u64;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _106: core::result::Result<(), core::fmt::Error>;
    let _107: &str;
    let mut _108: isize;
    scope 1 {
        debug first => _3;
        let _84: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug extra_bits => _84;
            scope 67 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 68 {
                }
            }
            scope 69 {
                debug val => const ();
                scope 70 {
                }
            }
            scope 71 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 72 {
                }
            }
            scope 73 {
                debug val => const ();
                scope 74 {
                }
            }
            scope 75 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 76 {
                }
            }
            scope 77 {
                debug val => const ();
                scope 78 {
                }
            }
            scope 79 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 80 {
                }
            }
            scope 81 {
                debug val => const ();
                scope 82 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::SS_ENABLE(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "SS_ENABLE";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb12: {
        _14 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::SS_WRITE_ENABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "SS_WRITE_ENABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb23: {
        _24 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_ENABLE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "IBT_ENABLE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb34: {
        _34 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_LEGACY_ENABLE(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "IBT_LEGACY_ENABLE";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb45: {
        _44 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_NO_TRACK_ENABLE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "IBT_NO_TRACK_ENABLE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb56: {
        _54 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_LEGACY_SUPPRESS_ENABLE(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "IBT_LEGACY_SUPPRESS_ENABLE";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb67: {
        _64 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_SUPPRESS_ENABLE(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "IBT_SUPPRESS_ENABLE";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb78: {
        _74 = <model_specific::CetFlags as <model_specific::CetFlags as Debug>::fmt::__BitFlags>::IBT_TRACKED(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "IBT_TRACKED";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb89: {
        _85 = ((*_1).0: u64);
        _89 = model_specific::CetFlags::all() -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _88 = &_89;
        _87 = model_specific::CetFlags::bits(move _88) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _86 = Not(move _87);
        _84 = BitAnd(move _85, move _86);
        _90 = _84;
        switchInt(move _90) -> [0: bb105, otherwise: bb92];
    }

    bb92: {
        _91 = _3;
        switchInt(move _91) -> [0: bb93, otherwise: bb97];
    }

    bb93: {
        _94 = const " | ";
        _93 = Formatter::<'_>::write_str(_2, _94) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _92 = <Result<(), core::fmt::Error> as Try>::branch(move _93) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _95 = discriminant(_92);
        switchInt(move _95) -> [0: bb97, 1: bb96, otherwise: bb6];
    }

    bb96: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb97: {
        _3 = const false;
        _98 = const "0x";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb100, 1: bb101, otherwise: bb6];
    }

    bb100: {
        _102 = &_84;
        _101 = <u64 as LowerHex>::fmt(_102, _2) -> [return: bb102, unwind unreachable];
    }

    bb101: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb102: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb105, 1: bb104, otherwise: bb6];
    }

    bb104: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb105: {
        _104 = _3;
        switchInt(move _104) -> [0: bb110, otherwise: bb106];
    }

    bb106: {
        _107 = const "(empty)";
        _106 = Formatter::<'_>::write_str(_2, _107) -> [return: bb107, unwind unreachable];
    }

    bb107: {
        _105 = <Result<(), core::fmt::Error> as Try>::branch(move _106) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _108 = discriminant(_105);
        switchInt(move _108) -> [0: bb110, 1: bb109, otherwise: bb6];
    }

    bb109: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb111, unwind unreachable];
    }

    bb110: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb111;
    }

    bb111: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SS_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SS_WRITE_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_LEGACY_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_NO_TRACK_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_LEGACY_SUPPRESS_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_SUPPRESS_ENABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IBT_TRACKED(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SS_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SS_WRITE_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_LEGACY_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_NO_TRACK_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_LEGACY_SUPPRESS_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_SUPPRESS_ENABLE(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IBT_TRACKED(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::model_specific::CetFlags;
    let mut _9: u64;
    let mut _10: registers::model_specific::CetFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 0_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 0_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 0_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SS_WRITE_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_LEGACY_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_NO_TRACK_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_LEGACY_SUPPRESS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_SUPPRESS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IBT_TRACKED: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::CetFlags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::CetFlags { bits: const 0_u64 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;

    bb0: {
        _7 = BitOr(const _, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = model_specific::CetFlags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = BitOr(const _, const _);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = model_specific::CetFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SS_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SS_WRITE_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_LEGACY_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_NO_TRACK_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_LEGACY_SUPPRESS_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_SUPPRESS_ENABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IBT_TRACKED: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SS_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SS_WRITE_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_LEGACY_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_NO_TRACK_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_LEGACY_SUPPRESS_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_SUPPRESS_ENABLE: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IBT_TRACKED: u64 = {
    let mut _0: u64;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &model_specific::CetFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &model_specific::CetFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<model_specific::CetFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::CetFlags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::CetFlags;
    let _6: registers::model_specific::CetFlags;
    let mut _7: registers::model_specific::CetFlags;

    bb0: {
        _6 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = model_specific::CetFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = model_specific::CetFlags { bits: _1 };
        _0 = Option::<model_specific::CetFlags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<model_specific::CetFlags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<model_specific::CetFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::CetFlags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::CetFlags;
    let _8: registers::model_specific::CetFlags;
    let mut _9: registers::model_specific::CetFlags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = model_specific::CetFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = model_specific::CetFlags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<model_specific::CetFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<model_specific::CetFlags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;

    bb0: {
        _4 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = model_specific::CetFlags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = model_specific::CetFlags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::CetFlags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = model_specific::CetFlags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::CetFlags;
    let _5: registers::model_specific::CetFlags;

    bb0: {
        _2 = model_specific::CetFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = model_specific::CetFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = model_specific::CetFlags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::model_specific::CetFlags;
    let mut _4: u64;
    let mut _5: &registers::model_specific::CetFlags;
    let _6: registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = model_specific::CetFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = model_specific::CetFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = model_specific::CetFlags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::model_specific::CetFlags;
    let _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = model_specific::CetFlags { bits: move _6 };
        _4 = &_5;
        _3 = model_specific::CetFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::model_specific::CetFlags;
    let _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = model_specific::CetFlags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = model_specific::CetFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = model_specific::CetFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::CetFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::CetFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::CetFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::CetFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::CetFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = model_specific::CetFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = model_specific::CetFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = model_specific::CetFlags { bits: move _3 };
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::model_specific::CetFlags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = model_specific::CetFlags { bits: move _3 };
        _5 = model_specific::CetFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <model_specific::CetFlags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut model_specific::CetFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::CetFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::CetFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::CetFlags);
        _5 = model_specific::CetFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> model_specific::CetFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::CetFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::CetFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::CetFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::CetFlags as Extend<model_specific::CetFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:175:5: 175:13>::read(_1: &model_specific::Msr) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: u32;
    let _3: u32;
    let mut _4: u32;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: u32;
    scope 1 {
        debug high => _2;
        debug low => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = ((*_1).0: u32);
        asm!("rdmsr", in("cx") move _4, out("ax") _3, out("dx") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _2;
        _6 = move _7 as u64 (IntToInt);
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(move _6, const 32_i32);
        _11 = _3;
        _10 = move _11 as u64 (IntToInt);
        _0 = BitOr(move _5, move _10);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:175:5: 175:13>::write(_1: &mut model_specific::Msr, _2: u64) -> () {
    debug self => _1;
    debug value => _2;
    let mut _0: ();
    let _3: u32;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    scope 1 {
        debug low => _3;
        let _4: u32;
        scope 2 {
            debug high => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = _2 as u32 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(_2, const 32_i32);
        _4 = move _5 as u32 (IntToInt);
        _8 = ((*_1).0: u32);
        asm!("wrmsr", in("cx") move _8, in("ax") _3, in("dx") _4, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::read() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::Efer>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::write(_1: model_specific::EferFlags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::EferFlags;
    let _7: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: &registers::model_specific::EferFlags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = model_specific::x86_64::<impl model_specific::Efer>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = model_specific::EferFlags::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = model_specific::EferFlags::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = model_specific::EferFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = model_specific::x86_64::<impl model_specific::Efer>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::write_raw(_1: u64) -> () {
    debug flags => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:218:5: 218:14>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::EferFlags;
    let _3: ();
    let mut _4: (&mut registers::model_specific::EferFlags,);
    let mut _5: &mut registers::model_specific::EferFlags;
    let _6: ();
    let mut _7: registers::model_specific::EferFlags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = model_specific::x86_64::<impl model_specific::Efer>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut model_specific::EferFlags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = model_specific::x86_64::<impl model_specific::Efer>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:287:5: 287:16>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:287:5: 287:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:287:5: 287:16>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:308:5: 308:16>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:308:5: 308:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:308:5: 308:16>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:329:5: 329:22>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:329:5: 329:22>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:329:5: 329:22>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::read_raw() -> (u16, u16) {
    let mut _0: (u16, u16);
    let _1: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _6: &u64;
    let mut _7: core::ops::Range<usize>;
    let mut _8: u16;
    let mut _9: core::result::Result<u16, core::num::TryFromIntError>;
    let mut _10: u16;
    let mut _11: core::result::Result<u16, core::num::TryFromIntError>;
    scope 1 {
        debug msr_value => _1;
        let _2: u64;
        scope 3 {
            debug sysret => _2;
            let _5: u64;
            scope 4 {
                debug syscall => _5;
            }
        }
    }
    scope 2 {
        let mut _12: &registers::model_specific::Msr;
    }

    bb0: {
        _12 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_12) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_1;
        _4 = Range::<usize> { start: const 48_usize, end: const 64_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_1;
        _7 = Range::<usize> { start: const 32_usize, end: const 48_usize };
        _5 = <u64 as BitField>::get_bits::<Range<usize>>(move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = <u64 as TryInto<u16>>::try_into(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Result::<u16, TryFromIntError>::unwrap(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = <u64 as TryInto<u16>>::try_into(_5) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = Result::<u16, TryFromIntError>::unwrap(move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = (move _8, move _10);
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::read() -> (SegmentSelector, SegmentSelector, SegmentSelector, SegmentSelector) {
    let mut _0: (registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector);
    let _1: (u16, u16);
    let mut _2: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: (u16, bool);
    let mut _6: registers::segmentation::SegmentSelector;
    let mut _7: u16;
    let mut _8: u16;
    let mut _9: (u16, bool);
    let mut _10: registers::segmentation::SegmentSelector;
    let mut _11: u16;
    let mut _12: registers::segmentation::SegmentSelector;
    let mut _13: u16;
    let mut _14: u16;
    let mut _15: (u16, bool);
    scope 1 {
        debug raw => _1;
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::Star>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_1.0: u16);
        _5 = CheckedAdd(_4, const 16_u16);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 16_u16) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_5.0: u16);
        _2 = SegmentSelector(move _3);
        _8 = (_1.0: u16);
        _9 = CheckedAdd(_8, const 8_u16);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 8_u16) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = move (_9.0: u16);
        _6 = SegmentSelector(move _7);
        _11 = (_1.1: u16);
        _10 = SegmentSelector(move _11);
        _14 = (_1.1: u16);
        _15 = CheckedAdd(_14, const 8_u16);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", move _14, const 8_u16) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = move (_15.0: u16);
        _12 = SegmentSelector(move _13);
        _0 = (move _2, move _6, move _10, move _12);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::write_raw(_1: u16, _2: u16) -> () {
    debug sysret => _1;
    debug syscall => _2;
    let mut _0: ();
    let mut _3: u64;
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let _8: &mut u64;
    let mut _9: &mut u64;
    let mut _10: core::ops::Range<usize>;
    let mut _11: u64;
    let _13: ();
    let mut _14: &mut registers::model_specific::Msr;
    let mut _15: u64;
    scope 1 {
        debug msr_value => _3;
        let mut _12: registers::model_specific::Msr;
        scope 2 {
            debug msr => _12;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = const 0_u64;
        _5 = &mut _3;
        _6 = Range::<usize> { start: const 48_usize, end: const 64_usize };
        _7 = <u16 as Into<u64>>::into(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &mut _3;
        _10 = Range::<usize> { start: const 32_usize, end: const 48_usize };
        _11 = <u16 as Into<u64>>::into(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <u64 as BitField>::set_bits::<Range<usize>>(move _9, move _10, move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = const _;
        _14 = &mut _12;
        _15 = _3;
        _13 = model_specific::x86_64::<impl model_specific::Msr>::write(move _14, move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::write(_1: SegmentSelector, _2: SegmentSelector, _3: SegmentSelector, _4: SegmentSelector) -> Result<(), &str> {
    debug cs_sysret => _1;
    debug ss_sysret => _2;
    debug cs_syscall => _3;
    debug ss_syscall => _4;
    let mut _0: core::result::Result<(), &str>;
    let mut _5: bool;
    let mut _6: u16;
    let mut _7: u16;
    let mut _8: (u16, bool);
    let mut _9: u16;
    let mut _10: u16;
    let mut _11: (u16, bool);
    let _12: &str;
    let mut _13: bool;
    let mut _14: u16;
    let mut _15: u16;
    let mut _16: u16;
    let mut _17: (u16, bool);
    let _18: &str;
    let mut _19: bool;
    let mut _20: &PrivilegeLevel;
    let _21: PrivilegeLevel;
    let _22: &str;
    let mut _23: bool;
    let mut _24: &PrivilegeLevel;
    let _25: PrivilegeLevel;
    let _26: &str;
    let _27: ();
    let mut _28: u16;
    let mut _29: u16;
    let mut _30: (u16, bool);
    let mut _31: u16;
    let mut _32: &PrivilegeLevel;
    let mut _33: &PrivilegeLevel;
    scope 1 {
    }

    bb0: {
        _7 = (_1.0: u16);
        _8 = CheckedSub(_7, const 16_u16);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _7, const 16_u16) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move (_8.0: u16);
        _10 = (_2.0: u16);
        _11 = CheckedSub(_10, const 8_u16);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _10, const 8_u16) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = move (_11.0: u16);
        _5 = Ne(move _6, move _9);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _12 = const "Sysret CS and SS is not offset by 8.";
        _0 = Result::<(), &str>::Err(_12);
        goto -> bb18;
    }

    bb4: {
        _14 = (_3.0: u16);
        _16 = (_4.0: u16);
        _17 = CheckedSub(_16, const 8_u16);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", move _16, const 8_u16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _15 = move (_17.0: u16);
        _13 = Ne(move _14, move _15);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _18 = const "Syscall CS and SS is not offset by 8.";
        _0 = Result::<(), &str>::Err(_18);
        goto -> bb18;
    }

    bb7: {
        _21 = SegmentSelector::rpl(_2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _20 = &_21;
        _33 = const _;
        _19 = <PrivilegeLevel as PartialEq>::ne(move _20, _33) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _19) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _22 = const "Sysret's segment must be a Ring3 segment.";
        _0 = Result::<(), &str>::Err(_22);
        goto -> bb18;
    }

    bb11: {
        _25 = SegmentSelector::rpl(_4) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _24 = &_25;
        _32 = const _;
        _23 = <PrivilegeLevel as PartialEq>::ne(move _24, _32) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _23) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _26 = const "Syscall's segment must be a Ring0 segment.";
        _0 = Result::<(), &str>::Err(_26);
        goto -> bb18;
    }

    bb15: {
        _29 = (_2.0: u16);
        _30 = CheckedSub(_29, const 8_u16);
        assert(!move (_30.1: bool), "attempt to compute `{} - {}`, which would overflow", move _29, const 8_u16) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _28 = move (_30.0: u16);
        _31 = (_3.0: u16);
        _27 = model_specific::x86_64::<impl model_specific::Star>::write_raw(move _28, move _31) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = Result::<(), &str>::Ok(const ());
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::write: &PrivilegeLevel = {
    let mut _0: &PrivilegeLevel;
    let mut _1: PrivilegeLevel;

    bb0: {
        _1 = PrivilegeLevel::Ring0;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:344:5: 344:14>::write: &PrivilegeLevel = {
    let mut _0: &PrivilegeLevel;
    let mut _1: PrivilegeLevel;

    bb0: {
        _1 = PrivilegeLevel::Ring3;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:448:5: 448:15>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:448:5: 448:15>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:448:5: 448:15>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:465:5: 465:16>::read() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: core::option::Option<registers::rflags::RFlags>;
    let mut _2: u64;
    scope 1 {
        let mut _3: &registers::model_specific::Msr;
    }

    bb0: {
        _3 = const _;
        _2 = model_specific::x86_64::<impl model_specific::Msr>::read(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = rflags::RFlags::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Option::<rflags::RFlags>::unwrap(move _1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:465:5: 465:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:465:5: 465:16>::write(_1: rflags::RFlags) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    let mut _6: &registers::rflags::RFlags;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _6 = &_1;
        _5 = rflags::RFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:492:5: 492:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:492:5: 492:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:492:5: 492:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:492:5: 492:14>::read() -> (model_specific::CetFlags, Page) {
    let mut _0: (registers::model_specific::CetFlags, structures::paging::page::Page);
    let _1: u64;
    let mut _4: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    scope 1 {
        debug value => _1;
        let _2: registers::model_specific::CetFlags;
        scope 2 {
            debug cet_flags => _2;
            let _3: structures::paging::page::Page;
            scope 3 {
                debug legacy_bitmap => _3;
            }
        }
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::UCet>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::CetFlags::from_bits_truncate(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = move (_9.0: u64);
        _7 = Not(move _8);
        _6 = BitAnd(_1, move _7);
        _5 = addr::VirtAddr::new(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Page::from_start_address(move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Result::<Page, AddressNotAligned>::unwrap(move _4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = (_2, _3);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:492:5: 492:14>::write(_1: model_specific::CetFlags, _2: Page) -> () {
    debug flags => _1;
    debug legacy_bitmap => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::CetFlags;
    let mut _7: u64;
    let mut _8: addr::VirtAddr;

    bb0: {
        _6 = &_1;
        _5 = model_specific::CetFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Page::start_address(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = addr::VirtAddr::as_u64(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = BitOr(move _5, move _7);
        _3 = model_specific::x86_64::<impl model_specific::UCet>::write_raw(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:527:5: 527:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:527:5: 527:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:527:5: 527:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:527:5: 527:14>::read() -> (model_specific::CetFlags, Page) {
    let mut _0: (registers::model_specific::CetFlags, structures::paging::page::Page);
    let _1: u64;
    let mut _4: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    scope 1 {
        debug value => _1;
        let _2: registers::model_specific::CetFlags;
        scope 2 {
            debug cet_flags => _2;
            let _3: structures::paging::page::Page;
            scope 3 {
                debug legacy_bitmap => _3;
            }
        }
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::SCet>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::CetFlags::from_bits_truncate(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = move (_9.0: u64);
        _7 = Not(move _8);
        _6 = BitAnd(_1, move _7);
        _5 = addr::VirtAddr::new(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Page::from_start_address(move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Result::<Page, AddressNotAligned>::unwrap(move _4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = (_2, _3);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/model_specific.rs:527:5: 527:14>::write(_1: model_specific::CetFlags, _2: Page) -> () {
    debug flags => _1;
    debug legacy_bitmap => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::CetFlags;
    let mut _7: u64;
    let mut _8: addr::VirtAddr;

    bb0: {
        _6 = &_1;
        _5 = model_specific::CetFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Page::start_address(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = addr::VirtAddr::as_u64(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = BitOr(move _5, move _7);
        _3 = model_specific::x86_64::<impl model_specific::SCet>::write_raw(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _3 = ((*_1).0: u32);
        _4 = ((*_2).0: u32);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &mxcsr::MxCsr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u32;
    let _4: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _4 = &((*_2).0: u32);
        _0 = <u32 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u32;
    let _4: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _4 = &((*_2).0: u32);
        _0 = <u32 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &mxcsr::MxCsr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &str;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &str;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _147: core::result::Result<(), core::fmt::Error>;
    let _148: &str;
    let mut _149: isize;
    let mut _150: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _151: core::result::Result<(), core::fmt::Error>;
    let _152: &str;
    let mut _153: isize;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _157: core::result::Result<(), core::fmt::Error>;
    let _158: &str;
    let mut _159: isize;
    let mut _160: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _161: core::result::Result<(), core::fmt::Error>;
    let _162: &str;
    let mut _163: isize;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _167: core::result::Result<(), core::fmt::Error>;
    let _168: &str;
    let mut _169: isize;
    let mut _170: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _171: core::result::Result<(), core::fmt::Error>;
    let _172: &str;
    let mut _173: isize;
    let mut _175: u32;
    let mut _176: u32;
    let mut _177: u32;
    let mut _178: &registers::mxcsr::MxCsr;
    let _179: registers::mxcsr::MxCsr;
    let mut _180: u32;
    let mut _181: bool;
    let mut _182: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _183: core::result::Result<(), core::fmt::Error>;
    let _184: &str;
    let mut _185: isize;
    let mut _186: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _187: core::result::Result<(), core::fmt::Error>;
    let _188: &str;
    let mut _189: isize;
    let mut _190: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _191: core::result::Result<(), core::fmt::Error>;
    let _192: &u32;
    let mut _193: isize;
    let mut _194: bool;
    let mut _195: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _196: core::result::Result<(), core::fmt::Error>;
    let _197: &str;
    let mut _198: isize;
    scope 1 {
        debug first => _3;
        let _174: u32;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 99 {
            }
        }
        scope 100 {
            debug val => const ();
            scope 101 {
            }
        }
        scope 102 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 103 {
            }
        }
        scope 104 {
            debug val => const ();
            scope 105 {
            }
        }
        scope 106 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 107 {
            }
        }
        scope 108 {
            debug val => const ();
            scope 109 {
            }
        }
        scope 110 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 111 {
            }
        }
        scope 112 {
            debug val => const ();
            scope 113 {
            }
        }
        scope 114 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 115 {
            }
        }
        scope 116 {
            debug val => const ();
            scope 117 {
            }
        }
        scope 118 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 119 {
            }
        }
        scope 120 {
            debug val => const ();
            scope 121 {
            }
        }
        scope 122 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 123 {
            }
        }
        scope 124 {
            debug val => const ();
            scope 125 {
            }
        }
        scope 126 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 127 {
            }
        }
        scope 128 {
            debug val => const ();
            scope 129 {
            }
        }
        scope 130 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 131 {
            }
        }
        scope 132 {
            debug val => const ();
            scope 133 {
            }
        }
        scope 134 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 135 {
            }
        }
        scope 136 {
            debug val => const ();
            scope 137 {
            }
        }
        scope 138 {
            debug extra_bits => _174;
            scope 139 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 140 {
                }
            }
            scope 141 {
                debug val => const ();
                scope 142 {
                }
            }
            scope 143 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 144 {
                }
            }
            scope 145 {
                debug val => const ();
                scope 146 {
                }
            }
            scope 147 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 148 {
                }
            }
            scope 149 {
                debug val => const ();
                scope 150 {
                }
            }
            scope 151 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 152 {
                }
            }
            scope 153 {
                debug val => const ();
                scope 154 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::INVALID_OPERATION(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "INVALID_OPERATION";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb12: {
        _14 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::DENORMAL(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "DENORMAL";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb23: {
        _24 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::DIVIDE_BY_ZERO(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "DIVIDE_BY_ZERO";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb34: {
        _34 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::OVERFLOW(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "OVERFLOW";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb45: {
        _44 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::UNDERFLOW(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "UNDERFLOW";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb56: {
        _54 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::PRECISION(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "PRECISION";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb67: {
        _64 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::DENORMALS_ARE_ZEROS(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "DENORMALS_ARE_ZEROS";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb78: {
        _74 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::INVALID_OPERATION_MASK(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "INVALID_OPERATION_MASK";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb89: {
        _84 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::DENORMAL_MASK(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "DENORMAL_MASK";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb100: {
        _94 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::DIVIDE_BY_ZERO_MASK(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "DIVIDE_BY_ZERO_MASK";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb111: {
        _104 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::OVERFLOW_MASK(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "OVERFLOW_MASK";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb122: {
        _114 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::UNDERFLOW_MASK(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "UNDERFLOW_MASK";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb133: {
        _124 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::PRECISION_MASK(_1) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        switchInt(move _124) -> [0: bb144, otherwise: bb135];
    }

    bb135: {
        _125 = _3;
        switchInt(move _125) -> [0: bb136, otherwise: bb140];
    }

    bb136: {
        _128 = const " | ";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb140, 1: bb139, otherwise: bb6];
    }

    bb139: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb140: {
        _3 = const false;
        _132 = const "PRECISION_MASK";
        _131 = Formatter::<'_>::write_str(_2, _132) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb144, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb144: {
        _134 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::ROUNDING_CONTROL_NEGATIVE(_1) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        switchInt(move _134) -> [0: bb155, otherwise: bb146];
    }

    bb146: {
        _135 = _3;
        switchInt(move _135) -> [0: bb147, otherwise: bb151];
    }

    bb147: {
        _138 = const " | ";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb151, 1: bb150, otherwise: bb6];
    }

    bb150: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb151: {
        _3 = const false;
        _142 = const "ROUNDING_CONTROL_NEGATIVE";
        _141 = Formatter::<'_>::write_str(_2, _142) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb155, 1: bb154, otherwise: bb6];
    }

    bb154: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb155: {
        _144 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::ROUNDING_CONTROL_POSITIVE(_1) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        switchInt(move _144) -> [0: bb166, otherwise: bb157];
    }

    bb157: {
        _145 = _3;
        switchInt(move _145) -> [0: bb158, otherwise: bb162];
    }

    bb158: {
        _148 = const " | ";
        _147 = Formatter::<'_>::write_str(_2, _148) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _146 = <Result<(), core::fmt::Error> as Try>::branch(move _147) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _149 = discriminant(_146);
        switchInt(move _149) -> [0: bb162, 1: bb161, otherwise: bb6];
    }

    bb161: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb162: {
        _3 = const false;
        _152 = const "ROUNDING_CONTROL_POSITIVE";
        _151 = Formatter::<'_>::write_str(_2, _152) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _150 = <Result<(), core::fmt::Error> as Try>::branch(move _151) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _153 = discriminant(_150);
        switchInt(move _153) -> [0: bb166, 1: bb165, otherwise: bb6];
    }

    bb165: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb166: {
        _154 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::ROUNDING_CONTROL_ZERO(_1) -> [return: bb167, unwind unreachable];
    }

    bb167: {
        switchInt(move _154) -> [0: bb177, otherwise: bb168];
    }

    bb168: {
        _155 = _3;
        switchInt(move _155) -> [0: bb169, otherwise: bb173];
    }

    bb169: {
        _158 = const " | ";
        _157 = Formatter::<'_>::write_str(_2, _158) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _156 = <Result<(), core::fmt::Error> as Try>::branch(move _157) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _159 = discriminant(_156);
        switchInt(move _159) -> [0: bb173, 1: bb172, otherwise: bb6];
    }

    bb172: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb173: {
        _3 = const false;
        _162 = const "ROUNDING_CONTROL_ZERO";
        _161 = Formatter::<'_>::write_str(_2, _162) -> [return: bb174, unwind unreachable];
    }

    bb174: {
        _160 = <Result<(), core::fmt::Error> as Try>::branch(move _161) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _163 = discriminant(_160);
        switchInt(move _163) -> [0: bb177, 1: bb176, otherwise: bb6];
    }

    bb176: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb177: {
        _164 = <mxcsr::MxCsr as <mxcsr::MxCsr as Debug>::fmt::__BitFlags>::FLUSH_TO_ZERO(_1) -> [return: bb178, unwind unreachable];
    }

    bb178: {
        switchInt(move _164) -> [0: bb188, otherwise: bb179];
    }

    bb179: {
        _165 = _3;
        switchInt(move _165) -> [0: bb180, otherwise: bb184];
    }

    bb180: {
        _168 = const " | ";
        _167 = Formatter::<'_>::write_str(_2, _168) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _166 = <Result<(), core::fmt::Error> as Try>::branch(move _167) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _169 = discriminant(_166);
        switchInt(move _169) -> [0: bb184, 1: bb183, otherwise: bb6];
    }

    bb183: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb184: {
        _3 = const false;
        _172 = const "FLUSH_TO_ZERO";
        _171 = Formatter::<'_>::write_str(_2, _172) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _170 = <Result<(), core::fmt::Error> as Try>::branch(move _171) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _173 = discriminant(_170);
        switchInt(move _173) -> [0: bb188, 1: bb187, otherwise: bb6];
    }

    bb187: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb188: {
        _175 = ((*_1).0: u32);
        _179 = mxcsr::MxCsr::all() -> [return: bb189, unwind unreachable];
    }

    bb189: {
        _178 = &_179;
        _177 = mxcsr::MxCsr::bits(move _178) -> [return: bb190, unwind unreachable];
    }

    bb190: {
        _176 = Not(move _177);
        _174 = BitAnd(move _175, move _176);
        _180 = _174;
        switchInt(move _180) -> [0: bb204, otherwise: bb191];
    }

    bb191: {
        _181 = _3;
        switchInt(move _181) -> [0: bb192, otherwise: bb196];
    }

    bb192: {
        _184 = const " | ";
        _183 = Formatter::<'_>::write_str(_2, _184) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _182 = <Result<(), core::fmt::Error> as Try>::branch(move _183) -> [return: bb194, unwind unreachable];
    }

    bb194: {
        _185 = discriminant(_182);
        switchInt(move _185) -> [0: bb196, 1: bb195, otherwise: bb6];
    }

    bb195: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb196: {
        _3 = const false;
        _188 = const "0x";
        _187 = Formatter::<'_>::write_str(_2, _188) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        _186 = <Result<(), core::fmt::Error> as Try>::branch(move _187) -> [return: bb198, unwind unreachable];
    }

    bb198: {
        _189 = discriminant(_186);
        switchInt(move _189) -> [0: bb199, 1: bb200, otherwise: bb6];
    }

    bb199: {
        _192 = &_174;
        _191 = <u32 as LowerHex>::fmt(_192, _2) -> [return: bb201, unwind unreachable];
    }

    bb200: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb201: {
        _190 = <Result<(), core::fmt::Error> as Try>::branch(move _191) -> [return: bb202, unwind unreachable];
    }

    bb202: {
        _193 = discriminant(_190);
        switchInt(move _193) -> [0: bb204, 1: bb203, otherwise: bb6];
    }

    bb203: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb204: {
        _194 = _3;
        switchInt(move _194) -> [0: bb209, otherwise: bb205];
    }

    bb205: {
        _197 = const "(empty)";
        _196 = Formatter::<'_>::write_str(_2, _197) -> [return: bb206, unwind unreachable];
    }

    bb206: {
        _195 = <Result<(), core::fmt::Error> as Try>::branch(move _196) -> [return: bb207, unwind unreachable];
    }

    bb207: {
        _198 = discriminant(_195);
        switchInt(move _198) -> [0: bb209, 1: bb208, otherwise: bb6];
    }

    bb208: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb210, unwind unreachable];
    }

    bb209: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb210;
    }

    bb210: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::INVALID_OPERATION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DENORMAL(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DIVIDE_BY_ZERO(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OVERFLOW(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::UNDERFLOW(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PRECISION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DENORMALS_ARE_ZEROS(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::INVALID_OPERATION_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DENORMAL_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DIVIDE_BY_ZERO_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OVERFLOW_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::UNDERFLOW_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PRECISION_MASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ROUNDING_CONTROL_NEGATIVE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ROUNDING_CONTROL_POSITIVE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ROUNDING_CONTROL_ZERO(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::FLUSH_TO_ZERO(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::INVALID_OPERATION(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DENORMAL(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DIVIDE_BY_ZERO(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OVERFLOW(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::UNDERFLOW(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PRECISION(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DENORMALS_ARE_ZEROS(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::INVALID_OPERATION_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DENORMAL_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DIVIDE_BY_ZERO_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OVERFLOW_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::UNDERFLOW_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PRECISION_MASK(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ROUNDING_CONTROL_NEGATIVE(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ROUNDING_CONTROL_POSITIVE(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ROUNDING_CONTROL_ZERO(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::FLUSH_TO_ZERO(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: registers::mxcsr::MxCsr;
    let mut _9: u32;
    let mut _10: registers::mxcsr::MxCsr;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u32);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u32);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u32);
        _8 = const _;
        _7 = (_8.0: u32);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u32);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::INVALID_OPERATION: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 0_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 0_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 0_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DENORMAL: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 1_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DIVIDE_BY_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 2_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OVERFLOW: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 3_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::UNDERFLOW: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 4_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PRECISION: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 5_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DENORMALS_ARE_ZEROS: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 6_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::INVALID_OPERATION_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 7_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DENORMAL_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 8_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DIVIDE_BY_ZERO_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 9_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OVERFLOW_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 10_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::UNDERFLOW_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 11_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PRECISION_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 12_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ROUNDING_CONTROL_NEGATIVE: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 13_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ROUNDING_CONTROL_POSITIVE: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 14_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ROUNDING_CONTROL_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 3_u32, const 13_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::FLUSH_TO_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 15_i32);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::MxCsr { bits: const 0_u32 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::MxCsr { bits: const 0_u32 };
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;

    bb0: {
        _16 = BitOr(const _, const _);
        _15 = BitOr(move _16, const _);
        _14 = BitOr(move _15, const _);
        _13 = BitOr(move _14, const _);
        _12 = BitOr(move _13, const _);
        _11 = BitOr(move _12, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = mxcsr::MxCsr { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        _16 = BitOr(const _, const _);
        _15 = BitOr(move _16, const _);
        StorageDead(_16);
        _14 = BitOr(move _15, const _);
        StorageDead(_15);
        _13 = BitOr(move _14, const _);
        StorageDead(_14);
        _12 = BitOr(move _13, const _);
        StorageDead(_13);
        _11 = BitOr(move _12, const _);
        StorageDead(_12);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = mxcsr::MxCsr { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::INVALID_OPERATION: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DENORMAL: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DIVIDE_BY_ZERO: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OVERFLOW: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::UNDERFLOW: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PRECISION: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DENORMALS_ARE_ZEROS: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::INVALID_OPERATION_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DENORMAL_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DIVIDE_BY_ZERO_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OVERFLOW_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::UNDERFLOW_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PRECISION_MASK: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ROUNDING_CONTROL_NEGATIVE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ROUNDING_CONTROL_POSITIVE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ROUNDING_CONTROL_ZERO: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::FLUSH_TO_ZERO: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::INVALID_OPERATION: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DENORMAL: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DIVIDE_BY_ZERO: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OVERFLOW: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::UNDERFLOW: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PRECISION: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DENORMALS_ARE_ZEROS: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::INVALID_OPERATION_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DENORMAL_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DIVIDE_BY_ZERO_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OVERFLOW_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::UNDERFLOW_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PRECISION_MASK: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ROUNDING_CONTROL_NEGATIVE: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ROUNDING_CONTROL_POSITIVE: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ROUNDING_CONTROL_ZERO: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::FLUSH_TO_ZERO: u32 = {
    let mut _0: u32;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u32);
        StorageDead(_1);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &mxcsr::MxCsr) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = ((*_1).0: u32);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &mxcsr::MxCsr) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = ((*_1).0: u32);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u32) -> Option<mxcsr::MxCsr> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: &registers::mxcsr::MxCsr;
    let _6: registers::mxcsr::MxCsr;
    let mut _7: registers::mxcsr::MxCsr;

    bb0: {
        _6 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = mxcsr::MxCsr::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = mxcsr::MxCsr { bits: _1 };
        _0 = Option::<mxcsr::MxCsr>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<mxcsr::MxCsr>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u32) -> Option<mxcsr::MxCsr> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _2: bool;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::MxCsr;
    let _8: registers::mxcsr::MxCsr;
    let mut _9: registers::mxcsr::MxCsr;
    let mut _10: u32;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = mxcsr::MxCsr::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u32);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = mxcsr::MxCsr { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<mxcsr::MxCsr>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<mxcsr::MxCsr>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;

    bb0: {
        _4 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u32);
        _2 = BitAnd(_1, move _3);
        _0 = mxcsr::MxCsr { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u32);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = mxcsr::MxCsr { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::MxCsr { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = mxcsr::MxCsr { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::MxCsr;
    let _5: registers::mxcsr::MxCsr;

    bb0: {
        _2 = mxcsr::MxCsr::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = mxcsr::MxCsr::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = mxcsr::MxCsr::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: &registers::mxcsr::MxCsr;
    let mut _4: u32;
    let mut _5: &registers::mxcsr::MxCsr;
    let _6: registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = mxcsr::MxCsr::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = mxcsr::MxCsr::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = mxcsr::MxCsr::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        _4 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u32);
        _5 = ((*_1).0: u32);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u32);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u32);
        StorageLive(_5);
        _5 = ((*_1).0: u32);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u32);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::mxcsr::MxCsr;
    let _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;

    bb0: {
        _7 = ((*_1).0: u32);
        _8 = (_2.0: u32);
        _6 = BitAnd(move _7, move _8);
        _5 = mxcsr::MxCsr { bits: move _6 };
        _4 = &_5;
        _3 = mxcsr::MxCsr::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::mxcsr::MxCsr;
    let _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u32);
        StorageLive(_8);
        _8 = (_2.0: u32);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = mxcsr::MxCsr { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = mxcsr::MxCsr::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        _4 = ((*_1).0: u32);
        _5 = (_2.0: u32);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u32);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u32);
        StorageLive(_5);
        _5 = (_2.0: u32);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u32);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;

    bb0: {
        _3 = (_2.0: u32);
        ((*_1).0: u32) = BitOr(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _4 = (_2.0: u32);
        _3 = Not(move _4);
        ((*_1).0: u32) = BitAnd(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;

    bb0: {
        _3 = (_2.0: u32);
        ((*_1).0: u32) = BitXor(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = mxcsr::MxCsr::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::MxCsr::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitAnd(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u32);
        StorageLive(_5);
        _5 = (_2.0: u32);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = mxcsr::MxCsr { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitOr(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u32);
        StorageLive(_5);
        _5 = (_2.0: u32);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = mxcsr::MxCsr { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        _4 = (_1.0: u32);
        _6 = (_2.0: u32);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u32);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u32);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = mxcsr::MxCsr { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitXor(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u32);
        StorageLive(_5);
        _5 = (_2.0: u32);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = mxcsr::MxCsr { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;
    let mut _3: u32;

    bb0: {
        _3 = (_1.0: u32);
        _2 = Not(move _3);
        _0 = mxcsr::MxCsr::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;
    let mut _3: u32;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u32);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = mxcsr::MxCsr::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitOr(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;

    bb0: {
        _3 = (_2.0: u32);
        ((*_1).0: u32) = BitOr(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitXor(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;

    bb0: {
        _3 = (_2.0: u32);
        ((*_1).0: u32) = BitXor(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _4 = (_1.0: u32);
        _5 = (_2.0: u32);
        _3 = BitAnd(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;

    bb0: {
        _3 = (_2.0: u32);
        ((*_1).0: u32) = BitAnd(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        _4 = (_1.0: u32);
        _6 = (_2.0: u32);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = mxcsr::MxCsr { bits: move _3 };
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _4 = (_2.0: u32);
        _3 = Not(move _4);
        ((*_1).0: u32) = BitAnd(((*_1).0: u32), move _3);
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: registers::mxcsr::MxCsr;

    bb0: {
        _4 = (_1.0: u32);
        _3 = Not(move _4);
        _2 = mxcsr::MxCsr { bits: move _3 };
        _5 = mxcsr::MxCsr::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <mxcsr::MxCsr as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut mxcsr::MxCsr, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::mxcsr::MxCsr;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::mxcsr::MxCsr);
        _5 = mxcsr::MxCsr::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> mxcsr::MxCsr {
    debug iterator => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::MxCsr;
    let _3: ();
    let mut _4: &mut registers::mxcsr::MxCsr;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = mxcsr::MxCsr::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <mxcsr::MxCsr as Extend<mxcsr::MxCsr>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/mxcsr.rs:49:1: 49:23>::default() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: registers::mxcsr::MxCsr;

    bb0: {
        _4 = <mxcsr::MxCsr as BitOr>::bitor(const _, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <mxcsr::MxCsr as BitOr>::bitor(move _4, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = <mxcsr::MxCsr as BitOr>::bitor(move _3, const _) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = <mxcsr::MxCsr as BitOr>::bitor(move _2, const _) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <mxcsr::MxCsr as BitOr>::bitor(move _1, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mxcsr::x86_64::read() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: *mut u32;
    let mut _3: &mut u32;
    let mut _4: u32;
    scope 1 {
        debug mxcsr => _1;
        scope 2 {
        }
    }

    bb0: {
        _1 = const 0_u32;
        _3 = &mut _1;
        _2 = &raw mut (*_3);
        asm!("stmxcsr [{0}]", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _0 = mxcsr::MxCsr::from_bits_truncate(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mxcsr::x86_64::write(_1: mxcsr::MxCsr) -> () {
    debug mxcsr => _1;
    let mut _0: ();
    let mut _2: *const registers::mxcsr::MxCsr;
    let _3: &registers::mxcsr::MxCsr;
    scope 1 {
    }

    bb0: {
        _3 = &_1;
        _2 = &raw const (*_3);
        asm!("ldmxcsr [{0}]", in(reg) move _2, options(READONLY | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &rflags::RFlags, _2: &rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &rflags::RFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &rflags::RFlags, _2: &rflags::RFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &rflags::RFlags, _2: &rflags::RFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &rflags::RFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &str;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &str;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _147: core::result::Result<(), core::fmt::Error>;
    let _148: &str;
    let mut _149: isize;
    let mut _150: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _151: core::result::Result<(), core::fmt::Error>;
    let _152: &str;
    let mut _153: isize;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _157: core::result::Result<(), core::fmt::Error>;
    let _158: &str;
    let mut _159: isize;
    let mut _160: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _161: core::result::Result<(), core::fmt::Error>;
    let _162: &str;
    let mut _163: isize;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _167: core::result::Result<(), core::fmt::Error>;
    let _168: &str;
    let mut _169: isize;
    let mut _170: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _171: core::result::Result<(), core::fmt::Error>;
    let _172: &str;
    let mut _173: isize;
    let mut _174: bool;
    let mut _175: bool;
    let mut _176: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _177: core::result::Result<(), core::fmt::Error>;
    let _178: &str;
    let mut _179: isize;
    let mut _180: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _181: core::result::Result<(), core::fmt::Error>;
    let _182: &str;
    let mut _183: isize;
    let mut _185: u64;
    let mut _186: u64;
    let mut _187: u64;
    let mut _188: &registers::rflags::RFlags;
    let _189: registers::rflags::RFlags;
    let mut _190: u64;
    let mut _191: bool;
    let mut _192: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _193: core::result::Result<(), core::fmt::Error>;
    let _194: &str;
    let mut _195: isize;
    let mut _196: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _197: core::result::Result<(), core::fmt::Error>;
    let _198: &str;
    let mut _199: isize;
    let mut _200: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _201: core::result::Result<(), core::fmt::Error>;
    let _202: &u64;
    let mut _203: isize;
    let mut _204: bool;
    let mut _205: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _206: core::result::Result<(), core::fmt::Error>;
    let _207: &str;
    let mut _208: isize;
    scope 1 {
        debug first => _3;
        let _184: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 99 {
            }
        }
        scope 100 {
            debug val => const ();
            scope 101 {
            }
        }
        scope 102 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 103 {
            }
        }
        scope 104 {
            debug val => const ();
            scope 105 {
            }
        }
        scope 106 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 107 {
            }
        }
        scope 108 {
            debug val => const ();
            scope 109 {
            }
        }
        scope 110 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 111 {
            }
        }
        scope 112 {
            debug val => const ();
            scope 113 {
            }
        }
        scope 114 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 115 {
            }
        }
        scope 116 {
            debug val => const ();
            scope 117 {
            }
        }
        scope 118 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 119 {
            }
        }
        scope 120 {
            debug val => const ();
            scope 121 {
            }
        }
        scope 122 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 123 {
            }
        }
        scope 124 {
            debug val => const ();
            scope 125 {
            }
        }
        scope 126 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 127 {
            }
        }
        scope 128 {
            debug val => const ();
            scope 129 {
            }
        }
        scope 130 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 131 {
            }
        }
        scope 132 {
            debug val => const ();
            scope 133 {
            }
        }
        scope 134 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 135 {
            }
        }
        scope 136 {
            debug val => const ();
            scope 137 {
            }
        }
        scope 138 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 139 {
            }
        }
        scope 140 {
            debug val => const ();
            scope 141 {
            }
        }
        scope 142 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 143 {
            }
        }
        scope 144 {
            debug val => const ();
            scope 145 {
            }
        }
        scope 146 {
            debug extra_bits => _184;
            scope 147 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 148 {
                }
            }
            scope 149 {
                debug val => const ();
                scope 150 {
                }
            }
            scope 151 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 152 {
                }
            }
            scope 153 {
                debug val => const ();
                scope 154 {
                }
            }
            scope 155 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 156 {
                }
            }
            scope 157 {
                debug val => const ();
                scope 158 {
                }
            }
            scope 159 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 160 {
                }
            }
            scope 161 {
                debug val => const ();
                scope 162 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::ID(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "ID";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb12: {
        _14 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::VIRTUAL_INTERRUPT_PENDING(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "VIRTUAL_INTERRUPT_PENDING";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb23: {
        _24 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::VIRTUAL_INTERRUPT(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "VIRTUAL_INTERRUPT";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb34: {
        _34 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::ALIGNMENT_CHECK(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "ALIGNMENT_CHECK";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb45: {
        _44 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::VIRTUAL_8086_MODE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "VIRTUAL_8086_MODE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb56: {
        _54 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::RESUME_FLAG(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "RESUME_FLAG";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb67: {
        _64 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::NESTED_TASK(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "NESTED_TASK";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb78: {
        _74 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::IOPL_HIGH(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "IOPL_HIGH";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb89: {
        _84 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::IOPL_LOW(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "IOPL_LOW";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb100: {
        _94 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::OVERFLOW_FLAG(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "OVERFLOW_FLAG";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb111: {
        _104 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::DIRECTION_FLAG(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "DIRECTION_FLAG";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb122: {
        _114 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::INTERRUPT_FLAG(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "INTERRUPT_FLAG";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb133: {
        _124 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::TRAP_FLAG(_1) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        switchInt(move _124) -> [0: bb144, otherwise: bb135];
    }

    bb135: {
        _125 = _3;
        switchInt(move _125) -> [0: bb136, otherwise: bb140];
    }

    bb136: {
        _128 = const " | ";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb140, 1: bb139, otherwise: bb6];
    }

    bb139: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb140: {
        _3 = const false;
        _132 = const "TRAP_FLAG";
        _131 = Formatter::<'_>::write_str(_2, _132) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb144, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb144: {
        _134 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::SIGN_FLAG(_1) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        switchInt(move _134) -> [0: bb155, otherwise: bb146];
    }

    bb146: {
        _135 = _3;
        switchInt(move _135) -> [0: bb147, otherwise: bb151];
    }

    bb147: {
        _138 = const " | ";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb151, 1: bb150, otherwise: bb6];
    }

    bb150: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb151: {
        _3 = const false;
        _142 = const "SIGN_FLAG";
        _141 = Formatter::<'_>::write_str(_2, _142) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb155, 1: bb154, otherwise: bb6];
    }

    bb154: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb155: {
        _144 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::ZERO_FLAG(_1) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        switchInt(move _144) -> [0: bb166, otherwise: bb157];
    }

    bb157: {
        _145 = _3;
        switchInt(move _145) -> [0: bb158, otherwise: bb162];
    }

    bb158: {
        _148 = const " | ";
        _147 = Formatter::<'_>::write_str(_2, _148) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _146 = <Result<(), core::fmt::Error> as Try>::branch(move _147) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _149 = discriminant(_146);
        switchInt(move _149) -> [0: bb162, 1: bb161, otherwise: bb6];
    }

    bb161: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb162: {
        _3 = const false;
        _152 = const "ZERO_FLAG";
        _151 = Formatter::<'_>::write_str(_2, _152) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _150 = <Result<(), core::fmt::Error> as Try>::branch(move _151) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _153 = discriminant(_150);
        switchInt(move _153) -> [0: bb166, 1: bb165, otherwise: bb6];
    }

    bb165: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb166: {
        _154 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::AUXILIARY_CARRY_FLAG(_1) -> [return: bb167, unwind unreachable];
    }

    bb167: {
        switchInt(move _154) -> [0: bb177, otherwise: bb168];
    }

    bb168: {
        _155 = _3;
        switchInt(move _155) -> [0: bb169, otherwise: bb173];
    }

    bb169: {
        _158 = const " | ";
        _157 = Formatter::<'_>::write_str(_2, _158) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _156 = <Result<(), core::fmt::Error> as Try>::branch(move _157) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _159 = discriminant(_156);
        switchInt(move _159) -> [0: bb173, 1: bb172, otherwise: bb6];
    }

    bb172: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb173: {
        _3 = const false;
        _162 = const "AUXILIARY_CARRY_FLAG";
        _161 = Formatter::<'_>::write_str(_2, _162) -> [return: bb174, unwind unreachable];
    }

    bb174: {
        _160 = <Result<(), core::fmt::Error> as Try>::branch(move _161) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _163 = discriminant(_160);
        switchInt(move _163) -> [0: bb177, 1: bb176, otherwise: bb6];
    }

    bb176: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb177: {
        _164 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::PARITY_FLAG(_1) -> [return: bb178, unwind unreachable];
    }

    bb178: {
        switchInt(move _164) -> [0: bb188, otherwise: bb179];
    }

    bb179: {
        _165 = _3;
        switchInt(move _165) -> [0: bb180, otherwise: bb184];
    }

    bb180: {
        _168 = const " | ";
        _167 = Formatter::<'_>::write_str(_2, _168) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _166 = <Result<(), core::fmt::Error> as Try>::branch(move _167) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _169 = discriminant(_166);
        switchInt(move _169) -> [0: bb184, 1: bb183, otherwise: bb6];
    }

    bb183: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb184: {
        _3 = const false;
        _172 = const "PARITY_FLAG";
        _171 = Formatter::<'_>::write_str(_2, _172) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _170 = <Result<(), core::fmt::Error> as Try>::branch(move _171) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _173 = discriminant(_170);
        switchInt(move _173) -> [0: bb188, 1: bb187, otherwise: bb6];
    }

    bb187: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb188: {
        _174 = <rflags::RFlags as <rflags::RFlags as Debug>::fmt::__BitFlags>::CARRY_FLAG(_1) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        switchInt(move _174) -> [0: bb199, otherwise: bb190];
    }

    bb190: {
        _175 = _3;
        switchInt(move _175) -> [0: bb191, otherwise: bb195];
    }

    bb191: {
        _178 = const " | ";
        _177 = Formatter::<'_>::write_str(_2, _178) -> [return: bb192, unwind unreachable];
    }

    bb192: {
        _176 = <Result<(), core::fmt::Error> as Try>::branch(move _177) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _179 = discriminant(_176);
        switchInt(move _179) -> [0: bb195, 1: bb194, otherwise: bb6];
    }

    bb194: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb195: {
        _3 = const false;
        _182 = const "CARRY_FLAG";
        _181 = Formatter::<'_>::write_str(_2, _182) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _180 = <Result<(), core::fmt::Error> as Try>::branch(move _181) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        _183 = discriminant(_180);
        switchInt(move _183) -> [0: bb199, 1: bb198, otherwise: bb6];
    }

    bb198: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb199: {
        _185 = ((*_1).0: u64);
        _189 = rflags::RFlags::all() -> [return: bb200, unwind unreachable];
    }

    bb200: {
        _188 = &_189;
        _187 = rflags::RFlags::bits(move _188) -> [return: bb201, unwind unreachable];
    }

    bb201: {
        _186 = Not(move _187);
        _184 = BitAnd(move _185, move _186);
        _190 = _184;
        switchInt(move _190) -> [0: bb215, otherwise: bb202];
    }

    bb202: {
        _191 = _3;
        switchInt(move _191) -> [0: bb203, otherwise: bb207];
    }

    bb203: {
        _194 = const " | ";
        _193 = Formatter::<'_>::write_str(_2, _194) -> [return: bb204, unwind unreachable];
    }

    bb204: {
        _192 = <Result<(), core::fmt::Error> as Try>::branch(move _193) -> [return: bb205, unwind unreachable];
    }

    bb205: {
        _195 = discriminant(_192);
        switchInt(move _195) -> [0: bb207, 1: bb206, otherwise: bb6];
    }

    bb206: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb207: {
        _3 = const false;
        _198 = const "0x";
        _197 = Formatter::<'_>::write_str(_2, _198) -> [return: bb208, unwind unreachable];
    }

    bb208: {
        _196 = <Result<(), core::fmt::Error> as Try>::branch(move _197) -> [return: bb209, unwind unreachable];
    }

    bb209: {
        _199 = discriminant(_196);
        switchInt(move _199) -> [0: bb210, 1: bb211, otherwise: bb6];
    }

    bb210: {
        _202 = &_184;
        _201 = <u64 as LowerHex>::fmt(_202, _2) -> [return: bb212, unwind unreachable];
    }

    bb211: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb212: {
        _200 = <Result<(), core::fmt::Error> as Try>::branch(move _201) -> [return: bb213, unwind unreachable];
    }

    bb213: {
        _203 = discriminant(_200);
        switchInt(move _203) -> [0: bb215, 1: bb214, otherwise: bb6];
    }

    bb214: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb215: {
        _204 = _3;
        switchInt(move _204) -> [0: bb220, otherwise: bb216];
    }

    bb216: {
        _207 = const "(empty)";
        _206 = Formatter::<'_>::write_str(_2, _207) -> [return: bb217, unwind unreachable];
    }

    bb217: {
        _205 = <Result<(), core::fmt::Error> as Try>::branch(move _206) -> [return: bb218, unwind unreachable];
    }

    bb218: {
        _208 = discriminant(_205);
        switchInt(move _208) -> [0: bb220, 1: bb219, otherwise: bb6];
    }

    bb219: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb221, unwind unreachable];
    }

    bb220: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb221;
    }

    bb221: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ID(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::VIRTUAL_INTERRUPT_PENDING(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::VIRTUAL_INTERRUPT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ALIGNMENT_CHECK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::VIRTUAL_8086_MODE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::RESUME_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NESTED_TASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IOPL_HIGH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::IOPL_LOW(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OVERFLOW_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DIRECTION_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::INTERRUPT_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::TRAP_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SIGN_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ZERO_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::AUXILIARY_CARRY_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PARITY_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::CARRY_FLAG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ID(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::VIRTUAL_INTERRUPT_PENDING(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::VIRTUAL_INTERRUPT(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ALIGNMENT_CHECK(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::VIRTUAL_8086_MODE(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::RESUME_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NESTED_TASK(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IOPL_HIGH(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::IOPL_LOW(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OVERFLOW_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DIRECTION_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::INTERRUPT_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::TRAP_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SIGN_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ZERO_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::AUXILIARY_CARRY_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PARITY_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::CARRY_FLAG(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: registers::rflags::RFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ID: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 21_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 21_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 21_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::VIRTUAL_INTERRUPT_PENDING: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 20_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 20_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::VIRTUAL_INTERRUPT: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 19_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 19_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 19_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ALIGNMENT_CHECK: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::VIRTUAL_8086_MODE: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 17_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 17_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 17_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::RESUME_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NESTED_TASK: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IOPL_HIGH: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::IOPL_LOW: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OVERFLOW_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DIRECTION_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::INTERRUPT_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::TRAP_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SIGN_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ZERO_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::AUXILIARY_CARRY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PARITY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::CARRY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags { bits: const 1_u64 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags { bits: const 0_u64 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;

    bb0: {
        _17 = BitOr(const _, const _);
        _16 = BitOr(move _17, const _);
        _15 = BitOr(move _16, const _);
        _14 = BitOr(move _15, const _);
        _13 = BitOr(move _14, const _);
        _12 = BitOr(move _13, const _);
        _11 = BitOr(move _12, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = rflags::RFlags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        _17 = BitOr(const _, const _);
        _16 = BitOr(move _17, const _);
        StorageDead(_17);
        _15 = BitOr(move _16, const _);
        StorageDead(_16);
        _14 = BitOr(move _15, const _);
        StorageDead(_15);
        _13 = BitOr(move _14, const _);
        StorageDead(_14);
        _12 = BitOr(move _13, const _);
        StorageDead(_13);
        _11 = BitOr(move _12, const _);
        StorageDead(_12);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = rflags::RFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ID: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::VIRTUAL_INTERRUPT_PENDING: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::VIRTUAL_INTERRUPT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ALIGNMENT_CHECK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::VIRTUAL_8086_MODE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::RESUME_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NESTED_TASK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IOPL_HIGH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::IOPL_LOW: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OVERFLOW_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DIRECTION_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::INTERRUPT_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::TRAP_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SIGN_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ZERO_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::AUXILIARY_CARRY_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PARITY_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::CARRY_FLAG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ID: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::VIRTUAL_INTERRUPT_PENDING: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::VIRTUAL_INTERRUPT: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ALIGNMENT_CHECK: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::VIRTUAL_8086_MODE: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::RESUME_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NESTED_TASK: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IOPL_HIGH: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::IOPL_LOW: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OVERFLOW_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DIRECTION_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::INTERRUPT_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::TRAP_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SIGN_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ZERO_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::AUXILIARY_CARRY_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PARITY_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::CARRY_FLAG: u64 = {
    let mut _0: u64;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &rflags::RFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &rflags::RFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<rflags::RFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::RFlags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::rflags::RFlags;
    let _6: registers::rflags::RFlags;
    let mut _7: registers::rflags::RFlags;

    bb0: {
        _6 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = rflags::RFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = rflags::RFlags { bits: _1 };
        _0 = Option::<rflags::RFlags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<rflags::RFlags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<rflags::RFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::RFlags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::RFlags;
    let _8: registers::rflags::RFlags;
    let mut _9: registers::rflags::RFlags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = rflags::RFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = rflags::RFlags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<rflags::RFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<rflags::RFlags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;

    bb0: {
        _4 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = rflags::RFlags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::rflags::RFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = rflags::RFlags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = rflags::RFlags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::rflags::RFlags;
    let _5: registers::rflags::RFlags;

    bb0: {
        _2 = rflags::RFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = rflags::RFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = rflags::RFlags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::rflags::RFlags;
    let mut _4: u64;
    let mut _5: &registers::rflags::RFlags;
    let _6: registers::rflags::RFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = rflags::RFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = rflags::RFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = rflags::RFlags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::rflags::RFlags;
    let _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = rflags::RFlags { bits: move _6 };
        _4 = &_5;
        _3 = rflags::RFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::rflags::RFlags;
    let _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = rflags::RFlags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = rflags::RFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut rflags::RFlags, _2: rflags::RFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = rflags::RFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = rflags::RFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = rflags::RFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = rflags::RFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = rflags::RFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = rflags::RFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = rflags::RFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = rflags::RFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = rflags::RFlags { bits: move _3 };
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::rflags::RFlags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = rflags::RFlags { bits: move _3 };
        _5 = rflags::RFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <rflags::RFlags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut rflags::RFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::rflags::RFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::rflags::RFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::rflags::RFlags);
        _5 = rflags::RFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> rflags::RFlags {
    debug iterator => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::RFlags;
    let _3: ();
    let mut _4: &mut registers::rflags::RFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = rflags::RFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <rflags::RFlags as Extend<rflags::RFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn rflags::x86_64::read() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;

    bb0: {
        _1 = read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug r => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("pushfq; pop {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn rflags::x86_64::write(_1: rflags::RFlags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::rflags::RFlags;
    let _7: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: &registers::rflags::RFlags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = rflags::RFlags::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = rflags::RFlags::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = rflags::RFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn write_raw(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("push {0}; popfq", in(reg) _1, options(NOMEM | PRESERVES_FLAGS)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:10: 67:15>::clone(_1: &SegmentSelector) -> SegmentSelector {
    debug self => _1;
    let mut _0: registers::segmentation::SegmentSelector;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:23: 67:32>::eq(_1: &SegmentSelector, _2: &SegmentSelector) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:34: 67:36>::assert_receiver_is_total_eq(_1: &SegmentSelector) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:38: 67:48>::partial_cmp(_1: &SegmentSelector, _2: &SegmentSelector) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:50: 67:53>::cmp(_1: &SegmentSelector, _2: &SegmentSelector) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:67:55: 67:59>::hash(_1: &SegmentSelector, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::new(_1: u16, _2: PrivilegeLevel) -> SegmentSelector {
    debug index => _1;
    debug rpl => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u16;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = const 3_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 16_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(_1, const 3_i32);
        _8 = discriminant(_2);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u16 (IntToInt);
        _3 = BitOr(move _4, move _7);
        _0 = SegmentSelector(move _3);
        return;
    }
}

// MIR FOR CTFE
fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::new(_1: u16, _2: PrivilegeLevel) -> SegmentSelector {
    debug index => _1;
    debug rpl => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u16;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u16;
    let _9: PrivilegeLevel;
    let mut _10: u8;
    let mut _11: u8;
    let mut _12: bool;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        _6 = const 3_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 16_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(move _5, const 3_i32);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _2;
        _10 = discriminant(_9);
        _11 = _10 as u8 (IntToInt);
        _12 = Le(_11, const 3_u8);
        assume(move _12);
        _8 = move _10 as u16 (IntToInt);
        StorageDead(_9);
        _3 = BitOr(move _4, move _8);
        StorageDead(_8);
        StorageDead(_4);
        _0 = SegmentSelector(move _3);
        StorageDead(_3);
        return;
    }
}

const registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::NULL: SegmentSelector = {
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _1: PrivilegeLevel;

    bb0: {
        StorageLive(_1);
        _1 = PrivilegeLevel::Ring0;
        ConstEvalCounter;
        _0 = SegmentSelector::new(const 0_u16, move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::index(_1: SegmentSelector) -> u16 {
    debug self => _1;
    let mut _0: u16;
    let mut _2: u16;
    let mut _3: u32;
    let mut _4: bool;

    bb0: {
        _2 = (_1.0: u16);
        _3 = const 3_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 16_u32);
        assert(move _4, "attempt to shift right by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shr(move _2, const 3_i32);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::rpl(_1: SegmentSelector) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;
    let mut _2: u16;
    let mut _3: &u16;
    let mut _4: core::ops::Range<usize>;

    bb0: {
        _3 = &(_1.0: u16);
        _4 = Range::<usize> { start: const 0_usize, end: const 2_usize };
        _2 = <u16 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PrivilegeLevel::from_u16(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:71:1: 71:21>::set_rpl(_1: &mut SegmentSelector, _2: PrivilegeLevel) -> () {
    debug self => _1;
    debug rpl => _2;
    let mut _0: ();
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: u8;
    let mut _8: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 0_usize, end: const 2_usize };
        _7 = discriminant(_2);
        _8 = Le(_7, const 3_u8);
        assume(move _8);
        _6 = _7 as u16 (IntToInt);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:105:1: 105:36>::fmt(_1: &SegmentSelector, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &u16;
    let _10: u16;
    let mut _11: registers::segmentation::SegmentSelector;
    let _12: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _13: &mut core::fmt::DebugStruct<'_, '_>;
    let _14: &str;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &PrivilegeLevel;
    let _17: PrivilegeLevel;
    let mut _18: registers::segmentation::SegmentSelector;
    let mut _19: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "SegmentSelector";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "index";
        _11 = (*_1);
        _10 = SegmentSelector::index(move _11) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = &mut _3;
        _14 = const "rpl";
        _18 = (*_1);
        _17 = SegmentSelector::rpl(move _18) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _12 = DebugStruct::<'_, '_>::field(move _13, _14, move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:129:10: 129:15>::fmt(_1: &CS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "CS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:143:10: 143:15>::fmt(_1: &SS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:149:10: 149:15>::fmt(_1: &DS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "DS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:155:10: 155:15>::fmt(_1: &ES, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "ES";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:162:10: 162:15>::fmt(_1: &FS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "FS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/segmentation.rs:169:10: 169:15>::fmt(_1: &GS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "GS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/xcontrol.rs:5:10: 5:15>::fmt(_1: &xcontrol::XCr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "XCr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &xcontrol::XCr0Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &xcontrol::XCr0Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _115: u64;
    let mut _116: u64;
    let mut _117: u64;
    let mut _118: &registers::xcontrol::XCr0Flags;
    let _119: registers::xcontrol::XCr0Flags;
    let mut _120: u64;
    let mut _121: bool;
    let mut _122: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _123: core::result::Result<(), core::fmt::Error>;
    let _124: &str;
    let mut _125: isize;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &u64;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _136: core::result::Result<(), core::fmt::Error>;
    let _137: &str;
    let mut _138: isize;
    scope 1 {
        debug first => _3;
        let _114: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug extra_bits => _114;
            scope 91 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 92 {
                }
            }
            scope 93 {
                debug val => const ();
                scope 94 {
                }
            }
            scope 95 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 96 {
                }
            }
            scope 97 {
                debug val => const ();
                scope 98 {
                }
            }
            scope 99 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 100 {
                }
            }
            scope 101 {
                debug val => const ();
                scope 102 {
                }
            }
            scope 103 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 104 {
                }
            }
            scope 105 {
                debug val => const ();
                scope 106 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::X87(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "X87";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb12: {
        _14 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::SSE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "SSE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb23: {
        _24 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::AVX(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "AVX";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb34: {
        _34 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::YMM(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "YMM";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb45: {
        _44 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::BNDREG(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "BNDREG";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb56: {
        _54 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::BNDCSR(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "BNDCSR";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb67: {
        _64 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::OPMASK(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "OPMASK";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb78: {
        _74 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::ZMM_HI256(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "ZMM_HI256";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb89: {
        _84 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::HI16_ZMM(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "HI16_ZMM";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb100: {
        _94 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::MPK(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "MPK";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb111: {
        _104 = <xcontrol::XCr0Flags as <xcontrol::XCr0Flags as Debug>::fmt::__BitFlags>::LWP(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "LWP";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb122: {
        _115 = ((*_1).0: u64);
        _119 = xcontrol::XCr0Flags::all() -> [return: bb123, unwind unreachable];
    }

    bb123: {
        _118 = &_119;
        _117 = xcontrol::XCr0Flags::bits(move _118) -> [return: bb124, unwind unreachable];
    }

    bb124: {
        _116 = Not(move _117);
        _114 = BitAnd(move _115, move _116);
        _120 = _114;
        switchInt(move _120) -> [0: bb138, otherwise: bb125];
    }

    bb125: {
        _121 = _3;
        switchInt(move _121) -> [0: bb126, otherwise: bb130];
    }

    bb126: {
        _124 = const " | ";
        _123 = Formatter::<'_>::write_str(_2, _124) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _122 = <Result<(), core::fmt::Error> as Try>::branch(move _123) -> [return: bb128, unwind unreachable];
    }

    bb128: {
        _125 = discriminant(_122);
        switchInt(move _125) -> [0: bb130, 1: bb129, otherwise: bb6];
    }

    bb129: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb130: {
        _3 = const false;
        _128 = const "0x";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb133, 1: bb134, otherwise: bb6];
    }

    bb133: {
        _132 = &_114;
        _131 = <u64 as LowerHex>::fmt(_132, _2) -> [return: bb135, unwind unreachable];
    }

    bb134: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb135: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb136, unwind unreachable];
    }

    bb136: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb138, 1: bb137, otherwise: bb6];
    }

    bb137: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb138: {
        _134 = _3;
        switchInt(move _134) -> [0: bb143, otherwise: bb139];
    }

    bb139: {
        _137 = const "(empty)";
        _136 = Formatter::<'_>::write_str(_2, _137) -> [return: bb140, unwind unreachable];
    }

    bb140: {
        _135 = <Result<(), core::fmt::Error> as Try>::branch(move _136) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _138 = discriminant(_135);
        switchInt(move _138) -> [0: bb143, 1: bb142, otherwise: bb6];
    }

    bb142: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb144, unwind unreachable];
    }

    bb143: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb144;
    }

    bb144: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::X87(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SSE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::AVX(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::YMM(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BNDREG(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BNDCSR(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::OPMASK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ZMM_HI256(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::HI16_ZMM(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::MPK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LWP(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::X87(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SSE(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::AVX(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::YMM(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BNDREG(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BNDCSR(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::OPMASK(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ZMM_HI256(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::HI16_ZMM(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::MPK(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LWP(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: registers::xcontrol::XCr0Flags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::X87: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags { bits: const 1_u64 };
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SSE: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::AVX: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::YMM: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BNDREG: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BNDCSR: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::OPMASK: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ZMM_HI256: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::HI16_ZMM: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::MPK: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LWP: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 62_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 62_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 62_i32);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags { bits: const 0_u64 };
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;

    bb0: {
        _10 = BitOr(const _, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = BitOr(const _, const _);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = xcontrol::XCr0Flags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::X87: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SSE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::AVX: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::YMM: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BNDREG: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BNDCSR: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::OPMASK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ZMM_HI256: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::HI16_ZMM: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::MPK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LWP: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::X87: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SSE: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::AVX: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::YMM: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BNDREG: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BNDCSR: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::OPMASK: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ZMM_HI256: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::HI16_ZMM: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::MPK: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LWP: u64 = {
    let mut _0: u64;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &xcontrol::XCr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &xcontrol::XCr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<xcontrol::XCr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::xcontrol::XCr0Flags;
    let _6: registers::xcontrol::XCr0Flags;
    let mut _7: registers::xcontrol::XCr0Flags;

    bb0: {
        _6 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = xcontrol::XCr0Flags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = xcontrol::XCr0Flags { bits: _1 };
        _0 = Option::<xcontrol::XCr0Flags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<xcontrol::XCr0Flags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<xcontrol::XCr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::XCr0Flags;
    let _8: registers::xcontrol::XCr0Flags;
    let mut _9: registers::xcontrol::XCr0Flags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = xcontrol::XCr0Flags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = xcontrol::XCr0Flags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<xcontrol::XCr0Flags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<xcontrol::XCr0Flags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;

    bb0: {
        _4 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = xcontrol::XCr0Flags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = xcontrol::XCr0Flags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = xcontrol::XCr0Flags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::XCr0Flags;
    let _5: registers::xcontrol::XCr0Flags;

    bb0: {
        _2 = xcontrol::XCr0Flags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = xcontrol::XCr0Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = xcontrol::XCr0Flags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &registers::xcontrol::XCr0Flags;
    let mut _4: u64;
    let mut _5: &registers::xcontrol::XCr0Flags;
    let _6: registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = xcontrol::XCr0Flags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = xcontrol::XCr0Flags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = xcontrol::XCr0Flags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::xcontrol::XCr0Flags;
    let _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = xcontrol::XCr0Flags { bits: move _6 };
        _4 = &_5;
        _3 = xcontrol::XCr0Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &registers::xcontrol::XCr0Flags;
    let _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = xcontrol::XCr0Flags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = xcontrol::XCr0Flags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = xcontrol::XCr0Flags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::XCr0Flags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = xcontrol::XCr0Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = xcontrol::XCr0Flags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = xcontrol::XCr0Flags { bits: move _3 };
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::xcontrol::XCr0Flags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = xcontrol::XCr0Flags { bits: move _3 };
        _5 = xcontrol::XCr0Flags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <xcontrol::XCr0Flags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut xcontrol::XCr0Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::xcontrol::XCr0Flags);
        _5 = xcontrol::XCr0Flags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> xcontrol::XCr0Flags {
    debug iterator => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::XCr0Flags;
    let _3: ();
    let mut _4: &mut registers::xcontrol::XCr0Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = xcontrol::XCr0Flags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <xcontrol::XCr0Flags as Extend<xcontrol::XCr0Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/xcontrol.rs:59:5: 59:14>::read() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;

    bb0: {
        _1 = xcontrol::x86_64::<impl xcontrol::XCr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/xcontrol.rs:59:5: 59:14>::read_raw() -> u64 {
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u64;
    let mut _9: u32;
    scope 1 {
        let _1: u32;
        let _2: u32;
        scope 2 {
            debug low => _1;
            debug high => _2;
        }
    }

    bb0: {
        asm!("xgetbv", in("cx") const 0_i32, out("ax") _1, out("dx") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = _2;
        _4 = move _5 as u64 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shl(move _4, const 32_i32);
        _9 = _1;
        _8 = move _9 as u64 (IntToInt);
        _0 = BitOr(move _3, move _8);
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/xcontrol.rs:59:5: 59:14>::write(_1: xcontrol::XCr0Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::XCr0Flags;
    let _7: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: &registers::xcontrol::XCr0Flags;
    let mut _11: bool;
    let mut _12: &registers::xcontrol::XCr0Flags;
    let mut _13: !;
    let mut _14: bool;
    let mut _15: &registers::xcontrol::XCr0Flags;
    let mut _16: bool;
    let mut _17: &registers::xcontrol::XCr0Flags;
    let mut _18: !;
    let mut _20: bool;
    let mut _21: &registers::xcontrol::XCr0Flags;
    let mut _22: bool;
    let mut _23: &registers::xcontrol::XCr0Flags;
    let mut _24: !;
    let mut _26: registers::xcontrol::XCr0Flags;
    let mut _27: bool;
    let mut _28: &registers::xcontrol::XCr0Flags;
    let mut _29: bool;
    let mut _30: &registers::xcontrol::XCr0Flags;
    let mut _31: !;
    let mut _32: bool;
    let mut _33: &registers::xcontrol::XCr0Flags;
    let mut _34: !;
    let _35: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                let _19: registers::xcontrol::XCr0Flags;
                scope 4 {
                    debug mpx => _19;
                    let _25: registers::xcontrol::XCr0Flags;
                    scope 5 {
                        debug avx512 => _25;
                        scope 6 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = xcontrol::x86_64::<impl xcontrol::XCr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = xcontrol::XCr0Flags::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = xcontrol::XCr0Flags::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = xcontrol::XCr0Flags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _12 = &_1;
        _11 = xcontrol::XCr0Flags::contains(move _12, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _11) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _15 = &_1;
        _14 = xcontrol::XCr0Flags::contains(move _15, const _) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _13 = panic(const "The X87 flag must be set") -> unwind unreachable;
    }

    bb8: {
        switchInt(move _14) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _17 = &_1;
        _16 = xcontrol::XCr0Flags::contains(move _17, const _) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb11, otherwise: bb12];
    }

    bb11: {
        _18 = panic(const "AVX cannot be enabled without enabling SSE") -> unwind unreachable;
    }

    bb12: {
        _19 = <xcontrol::XCr0Flags as BitOr>::bitor(const _, const _) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = &_1;
        _20 = xcontrol::XCr0Flags::intersects(move _21, _19) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        switchInt(move _20) -> [0: bb18, otherwise: bb15];
    }

    bb15: {
        _23 = &_1;
        _22 = xcontrol::XCr0Flags::contains(move _23, _19) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _22) -> [0: bb17, otherwise: bb18];
    }

    bb17: {
        _24 = panic(const "MPX flags XCr0.BNDREG and XCr0.BNDCSR must be set and unset together") -> unwind unreachable;
    }

    bb18: {
        _26 = <xcontrol::XCr0Flags as BitOr>::bitor(const _, const _) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = <xcontrol::XCr0Flags as BitOr>::bitor(move _26, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _28 = &_1;
        _27 = xcontrol::XCr0Flags::intersects(move _28, _25) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _27) -> [0: bb28, otherwise: bb22];
    }

    bb22: {
        _30 = &_1;
        _29 = xcontrol::XCr0Flags::contains(move _30, const _) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        switchInt(move _29) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _33 = &_1;
        _32 = xcontrol::XCr0Flags::contains(move _33, _25) -> [return: bb26, unwind unreachable];
    }

    bb25: {
        _31 = panic(const "AVX-512 cannot be enabled without enabling AVX") -> unwind unreachable;
    }

    bb26: {
        switchInt(move _32) -> [0: bb27, otherwise: bb28];
    }

    bb27: {
        _34 = panic(const "AVX-512 flags XCR0.opmask, XCR0.ZMM_Hi256, and XCR0.Hi16_ZMM must be set and unset together") -> unwind unreachable;
    }

    bb28: {
        _35 = xcontrol::x86_64::<impl xcontrol::XCr0>::write_raw(_8) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/registers/xcontrol.rs:59:5: 59:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let _2: u32;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    scope 1 {
        debug low => _2;
        let _3: u32;
        scope 2 {
            debug high => _3;
            scope 3 {
            }
        }
    }

    bb0: {
        _2 = _1 as u32 (IntToInt);
        _5 = const 32_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 32_i32);
        _3 = move _4 as u32 (IntToInt);
        asm!("xsetbv", in("cx") const 0_i32, in("ax") _2, in("dx") _3, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

GlobalDescriptorTable::table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:47:10: 47:15>::fmt(_1: &GlobalDescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &[u64; 8];
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&usize;
    let _10: &usize;

    bb0: {
        _3 = const "GlobalDescriptorTable";
        _4 = const "table";
        _6 = &((*_1).0: [u64; 8]);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "len";
        _10 = &((*_1).1: usize);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:47:17: 47:22>::clone(_1: &GlobalDescriptorTable) -> GlobalDescriptorTable {
    debug self => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _2: [u64; 8];
    let _3: &[u64; 8];
    let mut _4: usize;
    let _5: &usize;

    bb0: {
        _3 = &((*_1).0: [u64; 8]);
        _2 = (*_3);
        _5 = &((*_1).1: usize);
        _4 = (*_5);
        _0 = GlobalDescriptorTable { table: move _2, len: move _4 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::new() -> GlobalDescriptorTable {
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _1: [u64; 8];

    bb0: {
        _1 = [const 0_u64; 8];
        _0 = GlobalDescriptorTable { table: move _1, len: const 1_usize };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::new() -> GlobalDescriptorTable {
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _1: [u64; 8];

    bb0: {
        StorageLive(_1);
        _1 = [const 0_u64; 8];
        _0 = GlobalDescriptorTable { table: move _1, len: const 1_usize };
        StorageDead(_1);
        return;
    }
}

gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice(_1: &[u64]) -> GlobalDescriptorTable {
    debug slice => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let _2: usize;
    let mut _5: bool;
    let mut _6: !;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: u64;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let _13: usize;
    let mut _14: usize;
    let mut _15: bool;
    let mut _16: (usize, bool);
    let mut _17: [u64; 8];
    scope 1 {
        debug len => _2;
        let mut _3: [u64; 8];
        scope 2 {
            debug table => _3;
            let mut _4: usize;
            scope 3 {
                debug idx => _4;
            }
        }
    }

    bb0: {
        _2 = Len((*_1));
        _3 = [const 0_u64; 8];
        _4 = const 0_usize;
        _5 = Le(_2, const 8_usize);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = panic(const "initializing a GDT from a slice requires it to be **at most** 8 elements.") -> unwind unreachable;
    }

    bb2: {
        _8 = _4;
        _7 = Lt(move _8, _2);
        switchInt(move _7) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _10 = _4;
        _11 = Len((*_1));
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _9 = (*_1)[_10];
        _13 = _4;
        _14 = const 8_usize;
        _15 = Lt(_13, _14);
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _13) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3[_13] = move _9;
        _16 = CheckedAdd(_4, const 1_usize);
        assert(!move (_16.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _4 = move (_16.0: usize);
        goto -> bb2;
    }

    bb7: {
        _17 = _3;
        _0 = GlobalDescriptorTable { table: move _17, len: _2 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice(_1: &[u64]) -> GlobalDescriptorTable {
    debug slice => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let _2: usize;
    let mut _3: &[u64];
    let _6: ();
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: !;
    let _10: ();
    let mut _11: ();
    let mut _12: bool;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: u64;
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: (usize, bool);
    let mut _23: !;
    let _24: ();
    let mut _25: !;
    let mut _26: [u64; 8];
    let mut _27: usize;
    scope 1 {
        debug len => _2;
        let mut _4: [u64; 8];
        scope 2 {
            debug table => _4;
            let mut _5: usize;
            scope 3 {
                debug idx => _5;
            }
        }
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = slice::<impl [u64]>::len(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        _4 = [const 0_u64; 8];
        StorageLive(_5);
        _5 = const 0_usize;
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _2;
        _7 = Le(move _8, const 8_usize);
        switchInt(move _7) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        _6 = const ();
        StorageDead(_7);
        StorageDead(_6);
        StorageLive(_10);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageLive(_9);
        ConstEvalCounter;
        _9 = panic(const "initializing a GDT from a slice requires it to be **at most** 8 elements.") -> unwind unreachable;
    }

    bb4: {
        StorageLive(_12);
        StorageLive(_13);
        _13 = _5;
        StorageLive(_14);
        _14 = _2;
        _12 = Lt(move _13, move _14);
        switchInt(move _12) -> [0: bb9, otherwise: bb5];
    }

    bb5: {
        StorageDead(_14);
        StorageDead(_13);
        StorageLive(_15);
        StorageLive(_16);
        _16 = _5;
        _17 = Len((*_1));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _15 = (*_1)[_16];
        StorageLive(_19);
        _19 = _5;
        _20 = Len(_4);
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _4[_19] = move _15;
        StorageDead(_15);
        StorageDead(_19);
        StorageDead(_16);
        _22 = CheckedAdd(_5, const 1_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _5 = move (_22.0: usize);
        _11 = const ();
        StorageDead(_12);
        ConstEvalCounter;
        goto -> bb4;
    }

    bb9: {
        StorageDead(_14);
        StorageDead(_13);
        StorageLive(_24);
        _10 = const ();
        StorageDead(_24);
        StorageDead(_12);
        StorageDead(_10);
        StorageLive(_26);
        _26 = _4;
        StorageLive(_27);
        _27 = _2;
        _0 = GlobalDescriptorTable { table: move _26, len: move _27 };
        StorageDead(_27);
        StorageDead(_26);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_2);
        return;
    }
}

gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::as_raw_slice(_1: &GlobalDescriptorTable) -> &[u64] {
    debug self => _1;
    let mut _0: &[u64];
    let mut _2: &[u64; 8];
    let mut _3: core::ops::RangeTo<usize>;
    let mut _4: usize;

    bb0: {
        _2 = &((*_1).0: [u64; 8]);
        _4 = ((*_1).1: usize);
        _3 = RangeTo::<usize> { end: move _4 };
        _0 = <[u64; 8] as Index<RangeTo<usize>>>::index(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::add_entry(_1: &mut GlobalDescriptorTable, _2: Descriptor) -> SegmentSelector {
    debug self => _1;
    debug entry => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let _3: usize;
    let mut _4: isize;
    let _5: u64;
    let mut _6: bool;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &[u64];
    let mut _11: &[u64; 8];
    let mut _12: !;
    let _13: u64;
    let _14: u64;
    let mut _15: bool;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: &[u64];
    let mut _20: &[u64; 8];
    let mut _21: !;
    let _23: usize;
    let mut _25: isize;
    let mut _27: bool;
    let mut _28: &structures::gdt::DescriptorFlags;
    let _29: structures::gdt::DescriptorFlags;
    let mut _30: u16;
    let mut _31: usize;
    let mut _32: PrivilegeLevel;
    scope 1 {
        debug index => _3;
        let _24: PrivilegeLevel;
        let _26: u64;
        scope 5 {
            debug rpl => _24;
        }
        scope 6 {
            debug value => _26;
        }
    }
    scope 2 {
        debug value => _5;
    }
    scope 3 {
        debug value_low => _13;
        debug value_high => _14;
        let _22: usize;
        scope 4 {
            debug index => _22;
        }
    }

    bb0: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _13 = ((_2 as SystemSegment).0: u64);
        _14 = ((_2 as SystemSegment).1: u64);
        _16 = ((*_1).1: usize);
        _20 = &((*_1).0: [u64; 8]);
        _19 = move _20 as &[u64] (PointerCoercion(Unsize));
        _18 = Len((*_19));
        _17 = num::<impl usize>::saturating_sub(move _18, const 2_usize) -> [return: bb7, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = ((_2 as UserSegment).0: u64);
        _7 = ((*_1).1: usize);
        _11 = &((*_1).0: [u64; 8]);
        _10 = move _11 as &[u64] (PointerCoercion(Unsize));
        _9 = Len((*_10));
        _8 = num::<impl usize>::saturating_sub(move _9, const 1_usize) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = Gt(move _7, move _8);
        switchInt(move _6) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _12 = panic(const "GDT full") -> unwind unreachable;
    }

    bb6: {
        _3 = GlobalDescriptorTable::push(_1, _5) -> [return: bb12, unwind unreachable];
    }

    bb7: {
        _15 = Gt(move _16, move _17);
        switchInt(move _15) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _21 = panic(const "GDT requires two free spaces to hold a SystemSegment") -> unwind unreachable;
    }

    bb9: {
        _22 = GlobalDescriptorTable::push(_1, _13) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _23 = GlobalDescriptorTable::push(_1, _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _3 = _22;
        goto -> bb12;
    }

    bb12: {
        _25 = discriminant(_2);
        switchInt(move _25) -> [0: bb14, 1: bb13, otherwise: bb2];
    }

    bb13: {
        _24 = PrivilegeLevel::Ring0;
        goto -> bb19;
    }

    bb14: {
        _26 = ((_2 as UserSegment).0: u64);
        _29 = DescriptorFlags::from_bits_truncate(_26) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _28 = &_29;
        _27 = DescriptorFlags::contains(move _28, const _) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _27) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _24 = PrivilegeLevel::Ring3;
        goto -> bb19;
    }

    bb18: {
        _24 = PrivilegeLevel::Ring0;
        goto -> bb19;
    }

    bb19: {
        _31 = _3;
        _30 = move _31 as u16 (IntToInt);
        _32 = _24;
        _0 = SegmentSelector::new(move _30, move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::add_entry(_1: &mut GlobalDescriptorTable, _2: Descriptor) -> SegmentSelector {
    debug self => _1;
    debug entry => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let _3: usize;
    let mut _4: isize;
    let _5: u64;
    let _6: ();
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &[u64];
    let mut _12: &[u64; 8];
    let mut _13: !;
    let mut _14: &mut structures::gdt::GlobalDescriptorTable;
    let mut _15: u64;
    let _16: u64;
    let _17: u64;
    let _18: ();
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: &[u64];
    let mut _24: &[u64; 8];
    let mut _25: !;
    let mut _27: &mut structures::gdt::GlobalDescriptorTable;
    let mut _28: u64;
    let _29: usize;
    let mut _30: &mut structures::gdt::GlobalDescriptorTable;
    let mut _31: u64;
    let mut _33: isize;
    let mut _35: bool;
    let mut _36: &structures::gdt::DescriptorFlags;
    let _37: structures::gdt::DescriptorFlags;
    let mut _38: u64;
    let mut _39: u16;
    let mut _40: usize;
    let mut _41: PrivilegeLevel;
    scope 1 {
        debug index => _3;
        let _32: PrivilegeLevel;
        let _34: u64;
        scope 5 {
            debug rpl => _32;
        }
        scope 6 {
            debug value => _34;
        }
    }
    scope 2 {
        debug value => _5;
    }
    scope 3 {
        debug value_low => _16;
        debug value_high => _17;
        let _26: usize;
        scope 4 {
            debug index => _26;
        }
    }

    bb0: {
        StorageLive(_3);
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        StorageLive(_16);
        _16 = ((_2 as SystemSegment).0: u64);
        StorageLive(_17);
        _17 = ((_2 as SystemSegment).1: u64);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = ((*_1).1: usize);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        StorageLive(_24);
        _24 = &((*_1).0: [u64; 8]);
        _23 = move _24 as &[u64] (PointerCoercion(Unsize));
        StorageDead(_24);
        ConstEvalCounter;
        _22 = slice::<impl [u64]>::len(move _23) -> [return: bb9, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_5);
        _5 = ((_2 as UserSegment).0: u64);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = ((*_1).1: usize);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = &((*_1).0: [u64; 8]);
        _11 = move _12 as &[u64] (PointerCoercion(Unsize));
        StorageDead(_12);
        ConstEvalCounter;
        _10 = slice::<impl [u64]>::len(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_11);
        ConstEvalCounter;
        _9 = num::<impl usize>::saturating_sub(move _10, const 1_usize) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_10);
        _7 = Gt(move _8, move _9);
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_9);
        StorageDead(_8);
        StorageLive(_13);
        ConstEvalCounter;
        _13 = panic(const "GDT full") -> unwind unreachable;
    }

    bb7: {
        StorageDead(_9);
        StorageDead(_8);
        _6 = const ();
        StorageDead(_7);
        StorageDead(_6);
        StorageLive(_14);
        _14 = &mut (*_1);
        StorageLive(_15);
        _15 = _5;
        ConstEvalCounter;
        _3 = GlobalDescriptorTable::push(move _14, move _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        StorageDead(_15);
        StorageDead(_14);
        StorageDead(_5);
        goto -> bb15;
    }

    bb9: {
        StorageDead(_23);
        ConstEvalCounter;
        _21 = num::<impl usize>::saturating_sub(move _22, const 2_usize) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        StorageDead(_22);
        _19 = Gt(move _20, move _21);
        switchInt(move _19) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        StorageDead(_21);
        StorageDead(_20);
        StorageLive(_25);
        ConstEvalCounter;
        _25 = panic(const "GDT requires two free spaces to hold a SystemSegment") -> unwind unreachable;
    }

    bb12: {
        StorageDead(_21);
        StorageDead(_20);
        _18 = const ();
        StorageDead(_19);
        StorageDead(_18);
        StorageLive(_26);
        StorageLive(_27);
        _27 = &mut (*_1);
        StorageLive(_28);
        _28 = _16;
        ConstEvalCounter;
        _26 = GlobalDescriptorTable::push(move _27, move _28) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_29);
        StorageLive(_30);
        _30 = &mut (*_1);
        StorageLive(_31);
        _31 = _17;
        ConstEvalCounter;
        _29 = GlobalDescriptorTable::push(move _30, move _31) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        StorageDead(_31);
        StorageDead(_30);
        StorageDead(_29);
        _3 = _26;
        StorageDead(_26);
        StorageDead(_17);
        StorageDead(_16);
        goto -> bb15;
    }

    bb15: {
        StorageLive(_32);
        _33 = discriminant(_2);
        switchInt(move _33) -> [0: bb17, 1: bb16, otherwise: bb2];
    }

    bb16: {
        _32 = PrivilegeLevel::Ring0;
        goto -> bb23;
    }

    bb17: {
        StorageLive(_34);
        _34 = ((_2 as UserSegment).0: u64);
        StorageLive(_35);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _34;
        ConstEvalCounter;
        _37 = DescriptorFlags::from_bits_truncate(move _38) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _36 = &_37;
        StorageDead(_38);
        ConstEvalCounter;
        _35 = DescriptorFlags::contains(move _36, const _) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        switchInt(move _35) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        _32 = PrivilegeLevel::Ring3;
        goto -> bb22;
    }

    bb21: {
        StorageDead(_37);
        StorageDead(_36);
        _32 = PrivilegeLevel::Ring0;
        goto -> bb22;
    }

    bb22: {
        StorageDead(_35);
        StorageDead(_34);
        goto -> bb23;
    }

    bb23: {
        StorageLive(_39);
        StorageLive(_40);
        _40 = _3;
        _39 = move _40 as u16 (IntToInt);
        StorageDead(_40);
        StorageLive(_41);
        _41 = _32;
        ConstEvalCounter;
        _0 = SegmentSelector::new(move _39, move _41) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        StorageDead(_41);
        StorageDead(_39);
        StorageDead(_32);
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::load(_1: &GlobalDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    scope 1 {
    }

    bb0: {
        _2 = GlobalDescriptorTable::load_unsafe(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::load_unsafe(_1: &GlobalDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let _3: &structures::DescriptorTablePointer;
    let _4: structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _4 = GlobalDescriptorTable::pointer(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = lgdt(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::push(_1: &mut GlobalDescriptorTable, _2: u64) -> usize {
    debug self => _1;
    debug value => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: bool;
    let mut _5: (usize, bool);
    scope 1 {
        debug index => _0;
    }

    bb0: {
        _0 = ((*_1).1: usize);
        _3 = const 8_usize;
        _4 = Lt(_0, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _0) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: [u64; 8])[_0] = _2;
        _5 = CheckedAdd(((*_1).1: usize), const 1_usize);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).1: usize), const 1_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        ((*_1).1: usize) = move (_5.0: usize);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::push(_1: &mut GlobalDescriptorTable, _2: u64) -> usize {
    debug self => _1;
    debug value => _2;
    let mut _0: usize;
    let _3: usize;
    let mut _4: u64;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: (usize, bool);
    scope 1 {
        debug index => _3;
    }

    bb0: {
        StorageLive(_3);
        _3 = ((*_1).1: usize);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = _3;
        _6 = Len(((*_1).0: [u64; 8]));
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: [u64; 8])[_5] = move _4;
        StorageDead(_4);
        StorageDead(_5);
        _8 = CheckedAdd(((*_1).1: usize), const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).1: usize), const 1_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        ((*_1).1: usize) = move (_8.0: usize);
        _0 = _3;
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:53:1: 53:27>::pointer(_1: &GlobalDescriptorTable) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: *const u64;
    let mut _5: &[u64];
    let mut _6: &[u64; 8];
    let mut _7: u16;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    let mut _13: (usize, bool);

    bb0: {
        _6 = &((*_1).0: [u64; 8]);
        _5 = move _6 as &[u64] (PointerCoercion(Unsize));
        _4 = slice::<impl [u64]>::as_ptr(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _4 as u64 (PointerExposeAddress);
        _2 = addr::VirtAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = ((*_1).1: usize);
        _11 = core::mem::size_of::<u64>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = CheckedMul(_10, _11);
        assert(!move (_12.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, move _11) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _9 = move (_12.0: usize);
        _13 = CheckedSub(_9, const 1_usize);
        assert(!move (_13.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = move (_13.0: usize);
        _7 = move _8 as u16 (IntToInt);
        _0 = DescriptorTablePointer { limit: move _7, base: move _2 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:190:10: 190:15>::fmt(_1: &Descriptor, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &u64;
    let _5: &str;
    let mut _6: &dyn core::fmt::Debug;
    let _7: &&u64;
    let _8: &u64;
    let _9: &u64;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &&u64;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
        debug __self_1 => _9;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as SystemSegment).0: u64);
        _9 = &(((*_1) as SystemSegment).1: u64);
        _10 = const "SystemSegment";
        _11 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = &_9;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _10, move _11, move _12) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as UserSegment).0: u64);
        _5 = const "UserSegment";
        _7 = &_4;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:190:17: 190:22>::clone(_1: &Descriptor) -> Descriptor {
    debug self => _1;
    let mut _0: structures::gdt::Descriptor;
    let mut _2: isize;
    let _3: &u64;
    let mut _4: u64;
    let _5: &u64;
    let _6: &u64;
    let mut _7: u64;
    let mut _8: u64;
    scope 1 {
        debug __self_0 => _3;
    }
    scope 2 {
        debug __self_0 => _5;
        debug __self_1 => _6;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as SystemSegment).0: u64);
        _6 = &(((*_1) as SystemSegment).1: u64);
        _7 = (*_5);
        _8 = (*_6);
        _0 = Descriptor::SystemSegment(move _7, move _8);
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as UserSegment).0: u64);
        _4 = (*_3);
        _0 = Descriptor::UserSegment(move _4);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &DescriptorFlags, _2: &DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &DescriptorFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &DescriptorFlags, _2: &DescriptorFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &DescriptorFlags, _2: &DescriptorFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &DescriptorFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &str;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &str;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _147: core::result::Result<(), core::fmt::Error>;
    let _148: &str;
    let mut _149: isize;
    let mut _150: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _151: core::result::Result<(), core::fmt::Error>;
    let _152: &str;
    let mut _153: isize;
    let mut _155: u64;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: &structures::gdt::DescriptorFlags;
    let _159: structures::gdt::DescriptorFlags;
    let mut _160: u64;
    let mut _161: bool;
    let mut _162: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _163: core::result::Result<(), core::fmt::Error>;
    let _164: &str;
    let mut _165: isize;
    let mut _166: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _167: core::result::Result<(), core::fmt::Error>;
    let _168: &str;
    let mut _169: isize;
    let mut _170: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _171: core::result::Result<(), core::fmt::Error>;
    let _172: &u64;
    let mut _173: isize;
    let mut _174: bool;
    let mut _175: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _176: core::result::Result<(), core::fmt::Error>;
    let _177: &str;
    let mut _178: isize;
    scope 1 {
        debug first => _3;
        let _154: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 99 {
            }
        }
        scope 100 {
            debug val => const ();
            scope 101 {
            }
        }
        scope 102 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 103 {
            }
        }
        scope 104 {
            debug val => const ();
            scope 105 {
            }
        }
        scope 106 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 107 {
            }
        }
        scope 108 {
            debug val => const ();
            scope 109 {
            }
        }
        scope 110 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 111 {
            }
        }
        scope 112 {
            debug val => const ();
            scope 113 {
            }
        }
        scope 114 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 115 {
            }
        }
        scope 116 {
            debug val => const ();
            scope 117 {
            }
        }
        scope 118 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 119 {
            }
        }
        scope 120 {
            debug val => const ();
            scope 121 {
            }
        }
        scope 122 {
            debug extra_bits => _154;
            scope 123 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 124 {
                }
            }
            scope 125 {
                debug val => const ();
                scope 126 {
                }
            }
            scope 127 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 128 {
                }
            }
            scope 129 {
                debug val => const ();
                scope 130 {
                }
            }
            scope 131 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 132 {
                }
            }
            scope 133 {
                debug val => const ();
                scope 134 {
                }
            }
            scope 135 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 136 {
                }
            }
            scope 137 {
                debug val => const ();
                scope 138 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::ACCESSED(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "ACCESSED";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb12: {
        _14 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::WRITABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "WRITABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb23: {
        _24 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::CONFORMING(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "CONFORMING";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb34: {
        _34 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::EXECUTABLE(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "EXECUTABLE";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb45: {
        _44 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::USER_SEGMENT(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "USER_SEGMENT";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb56: {
        _54 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::DPL_RING_3(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "DPL_RING_3";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb67: {
        _64 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::PRESENT(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "PRESENT";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb78: {
        _74 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::AVAILABLE(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "AVAILABLE";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb89: {
        _84 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::LONG_MODE(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "LONG_MODE";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb100: {
        _94 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::DEFAULT_SIZE(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "DEFAULT_SIZE";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb111: {
        _104 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::GRANULARITY(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "GRANULARITY";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb122: {
        _114 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::LIMIT_0_15(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "LIMIT_0_15";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb133: {
        _124 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::LIMIT_16_19(_1) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        switchInt(move _124) -> [0: bb144, otherwise: bb135];
    }

    bb135: {
        _125 = _3;
        switchInt(move _125) -> [0: bb136, otherwise: bb140];
    }

    bb136: {
        _128 = const " | ";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb140, 1: bb139, otherwise: bb6];
    }

    bb139: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb140: {
        _3 = const false;
        _132 = const "LIMIT_16_19";
        _131 = Formatter::<'_>::write_str(_2, _132) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb144, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb144: {
        _134 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::BASE_0_23(_1) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        switchInt(move _134) -> [0: bb155, otherwise: bb146];
    }

    bb146: {
        _135 = _3;
        switchInt(move _135) -> [0: bb147, otherwise: bb151];
    }

    bb147: {
        _138 = const " | ";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb151, 1: bb150, otherwise: bb6];
    }

    bb150: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb151: {
        _3 = const false;
        _142 = const "BASE_0_23";
        _141 = Formatter::<'_>::write_str(_2, _142) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb155, 1: bb154, otherwise: bb6];
    }

    bb154: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb155: {
        _144 = <DescriptorFlags as <DescriptorFlags as Debug>::fmt::__BitFlags>::BASE_24_31(_1) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        switchInt(move _144) -> [0: bb166, otherwise: bb157];
    }

    bb157: {
        _145 = _3;
        switchInt(move _145) -> [0: bb158, otherwise: bb162];
    }

    bb158: {
        _148 = const " | ";
        _147 = Formatter::<'_>::write_str(_2, _148) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _146 = <Result<(), core::fmt::Error> as Try>::branch(move _147) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _149 = discriminant(_146);
        switchInt(move _149) -> [0: bb162, 1: bb161, otherwise: bb6];
    }

    bb161: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb162: {
        _3 = const false;
        _152 = const "BASE_24_31";
        _151 = Formatter::<'_>::write_str(_2, _152) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _150 = <Result<(), core::fmt::Error> as Try>::branch(move _151) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _153 = discriminant(_150);
        switchInt(move _153) -> [0: bb166, 1: bb165, otherwise: bb6];
    }

    bb165: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb166: {
        _155 = ((*_1).0: u64);
        _159 = DescriptorFlags::all() -> [return: bb167, unwind unreachable];
    }

    bb167: {
        _158 = &_159;
        _157 = DescriptorFlags::bits(move _158) -> [return: bb168, unwind unreachable];
    }

    bb168: {
        _156 = Not(move _157);
        _154 = BitAnd(move _155, move _156);
        _160 = _154;
        switchInt(move _160) -> [0: bb182, otherwise: bb169];
    }

    bb169: {
        _161 = _3;
        switchInt(move _161) -> [0: bb170, otherwise: bb174];
    }

    bb170: {
        _164 = const " | ";
        _163 = Formatter::<'_>::write_str(_2, _164) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _162 = <Result<(), core::fmt::Error> as Try>::branch(move _163) -> [return: bb172, unwind unreachable];
    }

    bb172: {
        _165 = discriminant(_162);
        switchInt(move _165) -> [0: bb174, 1: bb173, otherwise: bb6];
    }

    bb173: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb174: {
        _3 = const false;
        _168 = const "0x";
        _167 = Formatter::<'_>::write_str(_2, _168) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _166 = <Result<(), core::fmt::Error> as Try>::branch(move _167) -> [return: bb176, unwind unreachable];
    }

    bb176: {
        _169 = discriminant(_166);
        switchInt(move _169) -> [0: bb177, 1: bb178, otherwise: bb6];
    }

    bb177: {
        _172 = &_154;
        _171 = <u64 as LowerHex>::fmt(_172, _2) -> [return: bb179, unwind unreachable];
    }

    bb178: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb179: {
        _170 = <Result<(), core::fmt::Error> as Try>::branch(move _171) -> [return: bb180, unwind unreachable];
    }

    bb180: {
        _173 = discriminant(_170);
        switchInt(move _173) -> [0: bb182, 1: bb181, otherwise: bb6];
    }

    bb181: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb182: {
        _174 = _3;
        switchInt(move _174) -> [0: bb187, otherwise: bb183];
    }

    bb183: {
        _177 = const "(empty)";
        _176 = Formatter::<'_>::write_str(_2, _177) -> [return: bb184, unwind unreachable];
    }

    bb184: {
        _175 = <Result<(), core::fmt::Error> as Try>::branch(move _176) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _178 = discriminant(_175);
        switchInt(move _178) -> [0: bb187, 1: bb186, otherwise: bb6];
    }

    bb186: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb188, unwind unreachable];
    }

    bb187: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb188;
    }

    bb188: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ACCESSED(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::WRITABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::CONFORMING(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::EXECUTABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::USER_SEGMENT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DPL_RING_3(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PRESENT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::AVAILABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LONG_MODE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DEFAULT_SIZE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GRANULARITY(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LIMIT_0_15(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::LIMIT_16_19(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BASE_0_23(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BASE_24_31(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ACCESSED(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::WRITABLE(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::CONFORMING(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::EXECUTABLE(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::USER_SEGMENT(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DPL_RING_3(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PRESENT(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::AVAILABLE(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LONG_MODE(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DEFAULT_SIZE(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GRANULARITY(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LIMIT_0_15(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::LIMIT_16_19(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BASE_0_23(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BASE_24_31(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: structures::gdt::DescriptorFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ACCESSED: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 40_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 40_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 40_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::WRITABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 41_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 41_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 41_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::CONFORMING: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 42_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 42_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 42_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::EXECUTABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 43_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 43_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 43_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::USER_SEGMENT: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 44_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 44_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 44_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DPL_RING_3: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 45_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 45_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 3_u64, const 45_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PRESENT: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 47_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 47_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 47_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::AVAILABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 52_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 52_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LONG_MODE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 53_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 53_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DEFAULT_SIZE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 54_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 54_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 54_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GRANULARITY: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 55_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 55_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 55_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LIMIT_0_15: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags { bits: const 65535_u64 };
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::LIMIT_16_19: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 48_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 48_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 15_u64, const 48_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BASE_0_23: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 16777215_u64, const 16_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BASE_24_31: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 56_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 56_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 255_u64, const 56_i32);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags { bits: const 0_u64 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;

    bb0: {
        _14 = BitOr(const _, const _);
        _13 = BitOr(move _14, const _);
        _12 = BitOr(move _13, const _);
        _11 = BitOr(move _12, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = DescriptorFlags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        StorageLive(_14);
        _14 = BitOr(const _, const _);
        _13 = BitOr(move _14, const _);
        StorageDead(_14);
        _12 = BitOr(move _13, const _);
        StorageDead(_13);
        _11 = BitOr(move _12, const _);
        StorageDead(_12);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = DescriptorFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ACCESSED: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::WRITABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::CONFORMING: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::EXECUTABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::USER_SEGMENT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DPL_RING_3: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PRESENT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::AVAILABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LONG_MODE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DEFAULT_SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GRANULARITY: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LIMIT_0_15: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::LIMIT_16_19: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BASE_0_23: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BASE_24_31: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ACCESSED: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::WRITABLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::CONFORMING: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::EXECUTABLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::USER_SEGMENT: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DPL_RING_3: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PRESENT: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::AVAILABLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LONG_MODE: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DEFAULT_SIZE: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GRANULARITY: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LIMIT_0_15: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::LIMIT_16_19: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BASE_0_23: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BASE_24_31: u64 = {
    let mut _0: u64;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &DescriptorFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &DescriptorFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<DescriptorFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::gdt::DescriptorFlags;
    let _6: structures::gdt::DescriptorFlags;
    let mut _7: structures::gdt::DescriptorFlags;

    bb0: {
        _6 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = DescriptorFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = DescriptorFlags { bits: _1 };
        _0 = Option::<DescriptorFlags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<DescriptorFlags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<DescriptorFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;
    let _8: structures::gdt::DescriptorFlags;
    let mut _9: structures::gdt::DescriptorFlags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = DescriptorFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = DescriptorFlags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<DescriptorFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<DescriptorFlags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;

    bb0: {
        _4 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = DescriptorFlags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = DescriptorFlags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = DescriptorFlags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;

    bb0: {
        _2 = DescriptorFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = DescriptorFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = DescriptorFlags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let mut _4: u64;
    let mut _5: &structures::gdt::DescriptorFlags;
    let _6: structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = DescriptorFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = DescriptorFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = DescriptorFlags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = DescriptorFlags { bits: move _6 };
        _4 = &_5;
        _3 = DescriptorFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = DescriptorFlags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = DescriptorFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut DescriptorFlags, _2: DescriptorFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = DescriptorFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = DescriptorFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = DescriptorFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = DescriptorFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = DescriptorFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = DescriptorFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = DescriptorFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = DescriptorFlags { bits: move _3 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::gdt::DescriptorFlags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = DescriptorFlags { bits: move _3 };
        _5 = DescriptorFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <DescriptorFlags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut DescriptorFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::gdt::DescriptorFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::gdt::DescriptorFlags);
        _5 = DescriptorFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> DescriptorFlags {
    debug iterator => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::DescriptorFlags;
    let _3: ();
    let mut _4: &mut structures::gdt::DescriptorFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = DescriptorFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <DescriptorFlags as Extend<DescriptorFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: &structures::gdt::DescriptorFlags;
    let _9: structures::gdt::DescriptorFlags;
    let mut _10: u64;
    let mut _11: &structures::gdt::DescriptorFlags;
    let _12: structures::gdt::DescriptorFlags;
    let mut _13: u64;
    let mut _14: &structures::gdt::DescriptorFlags;
    let _15: structures::gdt::DescriptorFlags;
    let mut _16: u64;
    let mut _17: &structures::gdt::DescriptorFlags;
    let _18: structures::gdt::DescriptorFlags;
    let mut _19: u64;
    let mut _20: &structures::gdt::DescriptorFlags;
    let _21: structures::gdt::DescriptorFlags;
    let mut _22: u64;
    let mut _23: &structures::gdt::DescriptorFlags;
    let _24: structures::gdt::DescriptorFlags;
    let mut _25: u64;
    let mut _26: &structures::gdt::DescriptorFlags;
    let _27: structures::gdt::DescriptorFlags;
    let mut _28: &structures::gdt::DescriptorFlags;
    let mut _29: &structures::gdt::DescriptorFlags;
    let mut _30: &structures::gdt::DescriptorFlags;
    let mut _31: &structures::gdt::DescriptorFlags;
    let mut _32: &structures::gdt::DescriptorFlags;
    let mut _33: &structures::gdt::DescriptorFlags;
    let mut _34: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _34 = const _;
        _8 = &(*_34);
        ConstEvalCounter;
        _7 = DescriptorFlags::bits(move _8) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        StorageDead(_8);
        StorageLive(_10);
        StorageLive(_11);
        _33 = const _;
        _11 = &(*_33);
        ConstEvalCounter;
        _10 = DescriptorFlags::bits(move _11) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_11);
        _6 = BitOr(move _7, move _10);
        StorageDead(_10);
        StorageDead(_7);
        StorageLive(_13);
        StorageLive(_14);
        _32 = const _;
        _14 = &(*_32);
        ConstEvalCounter;
        _13 = DescriptorFlags::bits(move _14) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        StorageDead(_14);
        _5 = BitOr(move _6, move _13);
        StorageDead(_13);
        StorageDead(_6);
        StorageLive(_16);
        StorageLive(_17);
        _31 = const _;
        _17 = &(*_31);
        ConstEvalCounter;
        _16 = DescriptorFlags::bits(move _17) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        StorageDead(_17);
        _4 = BitOr(move _5, move _16);
        StorageDead(_16);
        StorageDead(_5);
        StorageLive(_19);
        StorageLive(_20);
        _30 = const _;
        _20 = &(*_30);
        ConstEvalCounter;
        _19 = DescriptorFlags::bits(move _20) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        StorageDead(_20);
        _3 = BitOr(move _4, move _19);
        StorageDead(_19);
        StorageDead(_4);
        StorageLive(_22);
        StorageLive(_23);
        _29 = const _;
        _23 = &(*_29);
        ConstEvalCounter;
        _22 = DescriptorFlags::bits(move _23) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        StorageDead(_23);
        _2 = BitOr(move _3, move _22);
        StorageDead(_22);
        StorageDead(_3);
        StorageLive(_25);
        StorageLive(_26);
        _28 = const _;
        _26 = &(*_28);
        ConstEvalCounter;
        _25 = DescriptorFlags::bits(move _26) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        StorageDead(_26);
        _1 = BitOr(move _2, move _25);
        StorageDead(_25);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb8, unwind: bb9];
    }

    bb8: {
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_DATA: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = DescriptorFlags::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = DescriptorFlags::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE32: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;
    let _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: &structures::gdt::DescriptorFlags;
    let _11: structures::gdt::DescriptorFlags;
    let mut _12: &structures::gdt::DescriptorFlags;
    let mut _13: &structures::gdt::DescriptorFlags;
    let mut _14: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _14 = const _;
        _4 = &(*_14);
        ConstEvalCounter;
        _3 = DescriptorFlags::bits(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _13 = const _;
        _7 = &(*_13);
        ConstEvalCounter;
        _6 = DescriptorFlags::bits(move _7) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        StorageDead(_7);
        _2 = BitOr(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _12 = const _;
        _10 = &(*_12);
        ConstEvalCounter;
        _9 = DescriptorFlags::bits(move _10) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        StorageDead(_10);
        _1 = BitOr(move _2, move _9);
        StorageDead(_9);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        StorageDead(_1);
        return;
    }

    bb5 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE64: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;
    let _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: &structures::gdt::DescriptorFlags;
    let _11: structures::gdt::DescriptorFlags;
    let mut _12: &structures::gdt::DescriptorFlags;
    let mut _13: &structures::gdt::DescriptorFlags;
    let mut _14: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _14 = const _;
        _4 = &(*_14);
        ConstEvalCounter;
        _3 = DescriptorFlags::bits(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _13 = const _;
        _7 = &(*_13);
        ConstEvalCounter;
        _6 = DescriptorFlags::bits(move _7) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        StorageDead(_7);
        _2 = BitOr(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _12 = const _;
        _10 = &(*_12);
        ConstEvalCounter;
        _9 = DescriptorFlags::bits(move _10) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        StorageDead(_10);
        _1 = BitOr(move _2, move _9);
        StorageDead(_9);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        StorageDead(_1);
        return;
    }

    bb5 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_DATA: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = DescriptorFlags::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = DescriptorFlags::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE32: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = DescriptorFlags::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = DescriptorFlags::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE64: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = DescriptorFlags::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = DescriptorFlags::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = DescriptorFlags::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:252:1: 252:21>::USER_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = DescriptorFlags::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_code_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = DescriptorFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = DescriptorFlags::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_data_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::kernel_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = DescriptorFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = DescriptorFlags::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_data_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = DescriptorFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = DescriptorFlags::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_code_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::user_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = DescriptorFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::tss_segment(_1: &TaskStateSegment) -> Descriptor {
    debug tss => _1;
    let mut _0: structures::gdt::Descriptor;
    let _2: u64;
    let mut _3: *const structures::tss::TaskStateSegment;
    let _5: &mut u64;
    let mut _6: &mut u64;
    let mut _7: core::ops::Range<usize>;
    let mut _8: u64;
    let mut _9: &u64;
    let mut _10: core::ops::Range<usize>;
    let _11: &mut u64;
    let mut _12: &mut u64;
    let mut _13: core::ops::Range<usize>;
    let mut _14: u64;
    let mut _15: &u64;
    let mut _16: core::ops::Range<usize>;
    let _17: &mut u64;
    let mut _18: &mut u64;
    let mut _19: core::ops::Range<usize>;
    let mut _20: u64;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: (usize, bool);
    let _24: &mut u64;
    let mut _25: &mut u64;
    let mut _26: core::ops::Range<usize>;
    let _28: &mut u64;
    let mut _29: &mut u64;
    let mut _30: core::ops::Range<usize>;
    let mut _31: u64;
    let mut _32: &u64;
    let mut _33: core::ops::Range<usize>;
    let mut _34: u64;
    let mut _35: u64;
    scope 1 {
        debug ptr => _2;
        let mut _4: u64;
        let mut _36: &structures::gdt::DescriptorFlags;
        scope 2 {
            debug low => _4;
            let mut _27: u64;
            scope 3 {
                debug high => _27;
            }
        }
    }

    bb0: {
        _3 = &raw const (*_1);
        _2 = _3 as u64 (PointerExposeAddress);
        _36 = const _;
        _4 = DescriptorFlags::bits(_36) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _4;
        _7 = Range::<usize> { start: const 16_usize, end: const 40_usize };
        _9 = &_2;
        _10 = Range::<usize> { start: const 0_usize, end: const 24_usize };
        _8 = <u64 as BitField>::get_bits::<Range<usize>>(move _9, move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = <u64 as BitField>::set_bits::<Range<usize>>(move _6, move _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &mut _4;
        _13 = Range::<usize> { start: const 56_usize, end: const 64_usize };
        _15 = &_2;
        _16 = Range::<usize> { start: const 24_usize, end: const 32_usize };
        _14 = <u64 as BitField>::get_bits::<Range<usize>>(move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = <u64 as BitField>::set_bits::<Range<usize>>(move _12, move _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _18 = &mut _4;
        _19 = Range::<usize> { start: const 0_usize, end: const 16_usize };
        _22 = core::mem::size_of::<TaskStateSegment>() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _23 = CheckedSub(_22, const 1_usize);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", move _22, const 1_usize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _21 = move (_23.0: usize);
        _20 = move _21 as u64 (IntToInt);
        _17 = <u64 as BitField>::set_bits::<Range<usize>>(move _18, move _19, move _20) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _25 = &mut _4;
        _26 = Range::<usize> { start: const 40_usize, end: const 44_usize };
        _24 = <u64 as BitField>::set_bits::<Range<usize>>(move _25, move _26, const 9_u64) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _27 = const 0_u64;
        _29 = &mut _27;
        _30 = Range::<usize> { start: const 0_usize, end: const 32_usize };
        _32 = &_2;
        _33 = Range::<usize> { start: const 32_usize, end: const 64_usize };
        _31 = <u64 as BitField>::get_bits::<Range<usize>>(move _32, move _33) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _28 = <u64 as BitField>::set_bits::<Range<usize>>(move _29, move _30, move _31) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _34 = _4;
        _35 = _27;
        _0 = Descriptor::SystemSegment(move _34, move _35);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/gdt.rs:285:1: 285:16>::tss_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

InterruptDescriptorTable::reserved_2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

InterruptDescriptorTable::interrupts::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const 256_usize, const 32_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const 256_usize, const 32_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:47:10: 47:15>::clone(_1: &InterruptDescriptorTable) -> InterruptDescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _3: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _5: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _7: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _9: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _23: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _25: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _27: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _29: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _30: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let _31: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _32: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _33: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _34: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _35: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _36: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _37: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _38: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let _39: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _40: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _41: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _42: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _43: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _44: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8];
    let _45: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8];
    let mut _46: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _47: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _48: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _49: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _50: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _51: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _52: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _53: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];

    bb0: {
        _3 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _2 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _4 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _6 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _8 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _10 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _12 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _15 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _14 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _17 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _16 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _19 = &((*_1).8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>);
        _18 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !> as Clone>::clone(_19) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _20 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _23 = &((*_1).10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _22 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_23) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _25 = &((*_1).11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _24 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _27 = &((*_1).12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _26 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_27) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _29 = &((*_1).13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _28 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_29) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _31 = &((*_1).14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>);
        _30 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)> as Clone>::clone(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _33 = &((*_1).15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _32 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_33) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _35 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _34 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_35) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _37 = &((*_1).17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _36 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_37) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = &((*_1).18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>);
        _38 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame) -> !> as Clone>::clone(_39) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _41 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _40 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_41) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _43 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _42 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_43) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _45 = &((*_1).21: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8]);
        _44 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 8] as Clone>::clone(_45) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _47 = &((*_1).22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _46 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_47) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _49 = &((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _48 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_49) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _51 = &((*_1).24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _50 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_51) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _53 = &((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _52 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as Clone>::clone(_53) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _0 = InterruptDescriptorTable { divide_error: move _2, debug: move _4, non_maskable_interrupt: move _6, breakpoint: move _8, overflow: move _10, bound_range_exceeded: move _12, invalid_opcode: move _14, device_not_available: move _16, double_fault: move _18, coprocessor_segment_overrun: move _20, invalid_tss: move _22, segment_not_present: move _24, stack_segment_fault: move _26, general_protection_fault: move _28, page_fault: move _30, reserved_1: move _32, x87_floating_point: move _34, alignment_check: move _36, machine_check: move _38, simd_floating_point: move _40, virtualization: move _42, reserved_2: move _44, vmm_communication_exception: move _46, security_exception: move _48, reserved_3: move _50, interrupts: move _52 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:47:17: 47:22>::fmt(_1: &InterruptDescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _4: &[&dyn core::fmt::Debug; 26];
    let _5: [&dyn core::fmt::Debug; 26];
    let mut _6: &dyn core::fmt::Debug;
    let _7: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: &dyn core::fmt::Debug;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _20: &dyn core::fmt::Debug;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: &dyn core::fmt::Debug;
    let _23: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _24: &dyn core::fmt::Debug;
    let _25: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _26: &dyn core::fmt::Debug;
    let _27: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: &dyn core::fmt::Debug;
    let _29: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _30: &dyn core::fmt::Debug;
    let _31: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _32: &dyn core::fmt::Debug;
    let _33: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _34: &dyn core::fmt::Debug;
    let _35: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _36: &dyn core::fmt::Debug;
    let _37: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _38: &dyn core::fmt::Debug;
    let _39: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _40: &dyn core::fmt::Debug;
    let _41: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _42: &dyn core::fmt::Debug;
    let _43: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _44: &dyn core::fmt::Debug;
    let _45: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _46: &dyn core::fmt::Debug;
    let _47: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _48: &dyn core::fmt::Debug;
    let _49: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8];
    let mut _50: &dyn core::fmt::Debug;
    let _51: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _52: &dyn core::fmt::Debug;
    let _53: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _54: &dyn core::fmt::Debug;
    let _55: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _56: &dyn core::fmt::Debug;
    let _57: &&[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _58: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _59: &str;
    let mut _60: &[&str];
    let mut _61: &[&str; 26];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn core::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _61 = const _;
        _7 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _16 = _17 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _20 = _21 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>);
        _22 = _23 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _25 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _24 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = &((*_1).10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _26 = _27 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _29 = &((*_1).11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _28 = _29 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _31 = &((*_1).12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _30 = _31 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _33 = &((*_1).13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _32 = _33 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _35 = &((*_1).14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>);
        _34 = _35 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _37 = &((*_1).15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _36 = _37 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _39 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _38 = _39 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _41 = &((*_1).17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _40 = _41 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _43 = &((*_1).18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>);
        _42 = _43 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _45 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _44 = _45 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _47 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _46 = _47 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _49 = &((*_1).21: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8]);
        _48 = _49 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _51 = &((*_1).22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _50 = _51 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _53 = &((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _52 = _53 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _55 = &((*_1).24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _54 = _55 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _58 = &((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _57 = &_58;
        _56 = _57 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50, move _52, move _54, move _56];
        _4 = &_5;
        _3 = _4 as &[&dyn core::fmt::Debug] (PointerCoercion(Unsize));
        _59 = const "InterruptDescriptorTable";
        _60 = _61 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _59, move _60, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:47:17: 47:22>::fmt: &[&str; 26] = {
    let mut _0: &[&str; 26];
    let mut _1: [&str; 26];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;
    let mut _40: &str;
    let mut _41: &str;
    let mut _42: &str;
    let mut _43: &str;
    let mut _44: &str;
    let mut _45: &str;
    let mut _46: &str;
    let mut _47: &str;
    let mut _48: &str;
    let mut _49: &str;
    let mut _50: &str;
    let mut _51: &str;

    bb0: {
        _3 = const "debug";
        _2 = &(*_3);
        _5 = const "non_maskable_interrupt";
        _4 = &(*_5);
        _7 = const "breakpoint";
        _6 = &(*_7);
        _9 = const "overflow";
        _8 = &(*_9);
        _11 = const "bound_range_exceeded";
        _10 = &(*_11);
        _13 = const "invalid_opcode";
        _12 = &(*_13);
        _15 = const "device_not_available";
        _14 = &(*_15);
        _17 = const "double_fault";
        _16 = &(*_17);
        _19 = const "coprocessor_segment_overrun";
        _18 = &(*_19);
        _21 = const "invalid_tss";
        _20 = &(*_21);
        _23 = const "segment_not_present";
        _22 = &(*_23);
        _25 = const "stack_segment_fault";
        _24 = &(*_25);
        _27 = const "general_protection_fault";
        _26 = &(*_27);
        _29 = const "page_fault";
        _28 = &(*_29);
        _31 = const "reserved_1";
        _30 = &(*_31);
        _33 = const "x87_floating_point";
        _32 = &(*_33);
        _35 = const "alignment_check";
        _34 = &(*_35);
        _37 = const "machine_check";
        _36 = &(*_37);
        _39 = const "simd_floating_point";
        _38 = &(*_39);
        _41 = const "virtualization";
        _40 = &(*_41);
        _43 = const "reserved_2";
        _42 = &(*_43);
        _45 = const "vmm_communication_exception";
        _44 = &(*_45);
        _47 = const "security_exception";
        _46 = &(*_47);
        _49 = const "reserved_3";
        _48 = &(*_49);
        _51 = const "interrupts";
        _50 = &(*_51);
        _1 = [const "divide_error", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::new() -> InterruptDescriptorTable {
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8];
    let mut _23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;

    bb0: {
        _1 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _5 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _7 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _8 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _9 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::missing() -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _11 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _12 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _13 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _14 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _15 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::missing() -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _16 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _17 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _18 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _19 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::missing() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _20 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _21 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _22 = [move _23; 8];
        _24 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _26 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _28 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _27 = [move _28; 224];
        _0 = InterruptDescriptorTable { divide_error: move _1, debug: move _2, non_maskable_interrupt: move _3, breakpoint: move _4, overflow: move _5, bound_range_exceeded: move _6, invalid_opcode: move _7, device_not_available: move _8, double_fault: move _9, coprocessor_segment_overrun: move _10, invalid_tss: move _11, segment_not_present: move _12, stack_segment_fault: move _13, general_protection_fault: move _14, page_fault: move _15, reserved_1: move _16, x87_floating_point: move _17, alignment_check: move _18, machine_check: move _19, simd_floating_point: move _20, virtualization: move _21, reserved_2: move _22, vmm_communication_exception: move _24, security_exception: move _25, reserved_3: move _26, interrupts: move _27 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::new() -> InterruptDescriptorTable {
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 8];
    let mut _23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_2);
        ConstEvalCounter;
        _2 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageLive(_3);
        ConstEvalCounter;
        _3 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageLive(_4);
        ConstEvalCounter;
        _4 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageLive(_5);
        ConstEvalCounter;
        _5 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageLive(_6);
        ConstEvalCounter;
        _6 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        StorageLive(_7);
        ConstEvalCounter;
        _7 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageLive(_8);
        ConstEvalCounter;
        _8 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb8, unwind unreachable];
    }

    bb8: {
        StorageLive(_9);
        ConstEvalCounter;
        _9 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::missing() -> [return: bb9, unwind unreachable];
    }

    bb9: {
        StorageLive(_10);
        ConstEvalCounter;
        _10 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb10, unwind unreachable];
    }

    bb10: {
        StorageLive(_11);
        ConstEvalCounter;
        _11 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageLive(_12);
        ConstEvalCounter;
        _12 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb12, unwind unreachable];
    }

    bb12: {
        StorageLive(_13);
        ConstEvalCounter;
        _13 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        StorageLive(_14);
        ConstEvalCounter;
        _14 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        StorageLive(_15);
        ConstEvalCounter;
        _15 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::missing() -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageLive(_16);
        ConstEvalCounter;
        _16 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb16, unwind unreachable];
    }

    bb16: {
        StorageLive(_17);
        ConstEvalCounter;
        _17 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb17, unwind unreachable];
    }

    bb17: {
        StorageLive(_18);
        ConstEvalCounter;
        _18 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb18, unwind unreachable];
    }

    bb18: {
        StorageLive(_19);
        ConstEvalCounter;
        _19 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::missing() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageLive(_20);
        ConstEvalCounter;
        _20 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb20, unwind unreachable];
    }

    bb20: {
        StorageLive(_21);
        ConstEvalCounter;
        _21 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb21, unwind unreachable];
    }

    bb21: {
        StorageLive(_22);
        StorageLive(_23);
        ConstEvalCounter;
        _23 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _22 = [move _23; 8];
        StorageDead(_23);
        StorageLive(_24);
        ConstEvalCounter;
        _24 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageLive(_25);
        ConstEvalCounter;
        _25 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb24, unwind unreachable];
    }

    bb24: {
        StorageLive(_26);
        ConstEvalCounter;
        _26 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb25, unwind unreachable];
    }

    bb25: {
        StorageLive(_27);
        StorageLive(_28);
        ConstEvalCounter;
        _28 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _27 = [move _28; 224];
        StorageDead(_28);
        _0 = InterruptDescriptorTable { divide_error: move _1, debug: move _2, non_maskable_interrupt: move _3, breakpoint: move _4, overflow: move _5, bound_range_exceeded: move _6, invalid_opcode: move _7, device_not_available: move _8, double_fault: move _9, coprocessor_segment_overrun: move _10, invalid_tss: move _11, segment_not_present: move _12, stack_segment_fault: move _13, general_protection_fault: move _14, page_fault: move _15, reserved_1: move _16, x87_floating_point: move _17, alignment_check: move _18, machine_check: move _19, simd_floating_point: move _20, virtualization: move _21, reserved_2: move _22, vmm_communication_exception: move _24, security_exception: move _25, reserved_3: move _26, interrupts: move _27 };
        StorageDead(_27);
        StorageDead(_26);
        StorageDead(_25);
        StorageDead(_24);
        StorageDead(_22);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_19);
        StorageDead(_18);
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_15);
        StorageDead(_14);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_11);
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_7);
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::new::{constant#1}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const 256_usize, const 32_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const 256_usize, const 32_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::reset(_1: &mut InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: structures::idt::InterruptDescriptorTable;

    bb0: {
        _2 = InterruptDescriptorTable::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _2;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::load(_1: &InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = InterruptDescriptorTable::load_unsafe(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::load_unsafe(_1: &InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let _3: &structures::DescriptorTablePointer;
    let _4: structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _4 = InterruptDescriptorTable::pointer(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = lidt(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::pointer(_1: &InterruptDescriptorTable) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: *const structures::idt::InterruptDescriptorTable;
    let mut _5: u16;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: (usize, bool);

    bb0: {
        _4 = &raw const (*_1);
        _3 = _4 as u64 (PointerExposeAddress);
        _2 = addr::VirtAddr::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = core::mem::size_of::<InterruptDescriptorTable>() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = CheckedSub(_7, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _7, const 1_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = move (_8.0: usize);
        _5 = move _6 as u16 (IntToInt);
        _0 = DescriptorTablePointer { limit: move _5, base: move _2 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::condition_slice_bounds(_1: &InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> (usize, usize) {
    debug self => _1;
    debug bounds => _2;
    let mut _0: (usize, usize);
    let _3: usize;
    let mut _4: core::ops::Bound<&usize>;
    let mut _5: &impl RangeBounds<usize>;
    let mut _6: isize;
    let _7: &usize;
    let _8: &usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _12: core::ops::Bound<&usize>;
    let mut _13: &impl RangeBounds<usize>;
    let mut _14: isize;
    let mut _16: usize;
    let mut _17: (usize, bool);
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: usize;
    let _23: !;
    let mut _24: core::fmt::Arguments<'_>;
    let mut _25: &[&str];
    let mut _26: &[core::fmt::rt::Argument<'_>];
    let _27: &[core::fmt::rt::Argument<'_>; 2];
    let _28: [core::fmt::rt::Argument<'_>; 2];
    let mut _29: core::fmt::rt::Argument<'_>;
    let _30: &usize;
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &usize;
    let mut _33: bool;
    let mut _34: usize;
    let _35: !;
    let mut _36: usize;
    let mut _37: usize;
    scope 1 {
        debug lower_idx => _3;
        let _11: usize;
        let _15: &usize;
        let _18: &usize;
        scope 4 {
            debug upper_idx => _11;
            let mut _38: &[&str; 3];
        }
        scope 5 {
            debug end => _15;
        }
        scope 6 {
            debug end => _18;
        }
    }
    scope 2 {
        debug start => _7;
    }
    scope 3 {
        debug start => _8;
    }

    bb0: {
        _5 = &_2;
        _4 = <impl RangeBounds<usize> as RangeBounds<usize>>::start_bound(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb5, 2: bb2, otherwise: bb3];
    }

    bb2: {
        _3 = const 0_usize;
        goto -> bb7;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _7 = ((_4 as Included).0: &usize);
        _3 = (*_7);
        goto -> bb7;
    }

    bb5: {
        _8 = ((_4 as Excluded).0: &usize);
        _9 = (*_8);
        _10 = CheckedAdd(_9, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _9, const 1_usize) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _3 = move (_10.0: usize);
        goto -> bb7;
    }

    bb7: {
        _13 = &_2;
        _12 = <impl RangeBounds<usize> as RangeBounds<usize>>::end_bound(move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb10, 1: bb12, 2: bb9, otherwise: bb3];
    }

    bb9: {
        _11 = const 256_usize;
        goto -> bb13;
    }

    bb10: {
        _15 = ((_12 as Included).0: &usize);
        _16 = (*_15);
        _17 = CheckedAdd(_16, const 1_usize);
        assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", move _16, const 1_usize) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _11 = move (_17.0: usize);
        goto -> bb13;
    }

    bb12: {
        _18 = ((_12 as Excluded).0: &usize);
        _11 = (*_18);
        goto -> bb13;
    }

    bb13: {
        _20 = _3;
        _19 = Gt(move _20, const 256_usize);
        switchInt(move _19) -> [0: bb14, otherwise: bb15];
    }

    bb14: {
        _22 = _11;
        _21 = Gt(move _22, const 256_usize);
        switchInt(move _21) -> [0: bb19, otherwise: bb15];
    }

    bb15: {
        _38 = const _;
        _25 = _38 as &[&str] (PointerCoercion(Unsize));
        _30 = &_3;
        _29 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_30) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _32 = &_11;
        _31 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_32) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = [move _29, move _31];
        _27 = &_28;
        _26 = _27 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _24 = Arguments::<'_>::new_v1(move _25, move _26) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _23 = panic_fmt(move _24) -> unwind unreachable;
    }

    bb19: {
        _34 = _3;
        _33 = Lt(move _34, const 32_usize);
        switchInt(move _33) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _35 = panic(const "Cannot return slice from traps, faults, and exception handlers") -> unwind unreachable;
    }

    bb21: {
        _36 = _3;
        _37 = _11;
        _0 = (move _36, move _37);
        drop(_2) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::condition_slice_bounds: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Index out of range [", const "..", const "]"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::slice(_1: &InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> &[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>] {
    debug self => _1;
    debug bounds => _2;
    let mut _0: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>];
    let _3: usize;
    let _4: usize;
    let mut _5: (usize, usize);
    let mut _6: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _7: core::ops::Range<usize>;
    let mut _8: usize;
    let mut _9: (usize, bool);
    let mut _10: usize;
    let mut _11: (usize, bool);
    scope 1 {
        debug lower_idx => _3;
        debug upper_idx => _4;
    }

    bb0: {
        _5 = InterruptDescriptorTable::condition_slice_bounds::<impl RangeBounds<usize>>(_1, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_5.0: usize);
        _4 = (_5.1: usize);
        _6 = &((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _9 = CheckedSub(_3, const 32_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 32_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = move (_9.0: usize);
        _11 = CheckedSub(_4, const 32_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 32_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _10 = move (_11.0: usize);
        _7 = Range::<usize> { start: move _8, end: move _10 };
        _0 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as Index<Range<usize>>>::index(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:412:1: 412:30>::slice_mut(_1: &mut InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> &mut [Entry<extern "x86-interrupt" fn(InterruptStackFrame)>] {
    debug self => _1;
    debug bounds => _2;
    let mut _0: &mut [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>];
    let _3: usize;
    let _4: usize;
    let mut _5: (usize, usize);
    let mut _6: &structures::idt::InterruptDescriptorTable;
    let mut _7: &mut [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _8: core::ops::Range<usize>;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lower_idx => _3;
        debug upper_idx => _4;
    }

    bb0: {
        _6 = &(*_1);
        _5 = InterruptDescriptorTable::condition_slice_bounds::<impl RangeBounds<usize>>(move _6, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_5.0: usize);
        _4 = (_5.1: usize);
        _7 = &mut ((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _10 = CheckedSub(_3, const 32_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 32_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = move (_10.0: usize);
        _12 = CheckedSub(_4, const 32_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 32_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _11 = move (_12.0: usize);
        _8 = Range::<usize> { start: move _9, end: move _11 };
        _0 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as IndexMut<Range<usize>>>::index_mut(move _7, move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:536:1: 536:47>::index(_1: &InterruptDescriptorTable, _2: usize) -> &Entry<extern "x86-interrupt" fn(InterruptStackFrame)> {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _3: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let _10: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _12: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _14: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _16: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _18: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _20: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _22: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _23: usize;
    let mut _24: (usize, bool);
    let mut _25: usize;
    let mut _26: bool;
    let _27: usize;
    let _28: !;
    let mut _29: core::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 1];
    let _33: [core::fmt::rt::Argument<'_>; 1];
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &usize;
    let _36: usize;
    let _37: !;
    let mut _38: core::fmt::Arguments<'_>;
    let mut _39: &[&str];
    let mut _40: &[core::fmt::rt::Argument<'_>];
    let _41: &[core::fmt::rt::Argument<'_>; 1];
    let _42: [core::fmt::rt::Argument<'_>; 1];
    let mut _43: core::fmt::rt::Argument<'_>;
    let _44: &usize;
    let _45: usize;
    let _46: !;
    let mut _47: core::fmt::Arguments<'_>;
    let mut _48: &[&str];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 1];
    let _51: [core::fmt::rt::Argument<'_>; 1];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &usize;
    let _54: usize;
    let _55: !;
    let mut _56: core::fmt::Arguments<'_>;
    let mut _57: &[&str];
    let mut _58: &[core::fmt::rt::Argument<'_>];
    let _59: &[core::fmt::rt::Argument<'_>; 1];
    let _60: [core::fmt::rt::Argument<'_>; 1];
    let mut _61: core::fmt::rt::Argument<'_>;
    let _62: &usize;
    scope 1 {
        debug i => _2;
    }
    scope 2 {
        debug i => _27;
        let mut _66: &[&str; 2];
    }
    scope 3 {
        debug i => _36;
        let mut _65: &[&str; 2];
    }
    scope 4 {
        debug i => _45;
        let mut _64: &[&str; 2];
    }
    scope 5 {
        debug i => _54;
        let mut _63: &[&str; 1];
    }

    bb0: {
        switchInt(_2) -> [0: bb8, 1: bb9, 2: bb10, 3: bb11, 4: bb12, 5: bb13, 6: bb14, 7: bb15, 9: bb16, 16: bb17, 19: bb18, 20: bb19, 15: bb24, 31: bb25, 8: bb30, 17: bb32, 29: bb33, 30: bb34, 18: bb37, otherwise: bb1];
    }

    bb1: {
        _8 = Le(const 32_usize, _2);
        switchInt(move _8) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _9 = Le(_2, const 255_usize);
        switchInt(move _9) -> [0: bb3, otherwise: bb20];
    }

    bb3: {
        _6 = Le(const 21_usize, _2);
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _7 = Le(_2, const 28_usize);
        switchInt(move _7) -> [0: bb5, otherwise: bb26];
    }

    bb5: {
        _4 = Le(const 10_usize, _2);
        switchInt(move _4) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _5 = Le(_2, const 14_usize);
        switchInt(move _5) -> [0: bb7, otherwise: bb31];
    }

    bb7: {
        _54 = _2;
        _63 = const _;
        _57 = _63 as &[&str] (PointerCoercion(Unsize));
        _62 = &_54;
        _61 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_62) -> [return: bb40, unwind unreachable];
    }

    bb8: {
        _10 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _10;
        goto -> bb42;
    }

    bb9: {
        _11 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _11;
        goto -> bb42;
    }

    bb10: {
        _12 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _12;
        goto -> bb42;
    }

    bb11: {
        _13 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _13;
        goto -> bb42;
    }

    bb12: {
        _14 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _14;
        goto -> bb42;
    }

    bb13: {
        _15 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _15;
        goto -> bb42;
    }

    bb14: {
        _16 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _16;
        goto -> bb42;
    }

    bb15: {
        _17 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _17;
        goto -> bb42;
    }

    bb16: {
        _18 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _18;
        goto -> bb42;
    }

    bb17: {
        _19 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _19;
        goto -> bb42;
    }

    bb18: {
        _20 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _20;
        goto -> bb42;
    }

    bb19: {
        _21 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _21;
        goto -> bb42;
    }

    bb20: {
        _24 = CheckedSub(_2, const 32_usize);
        assert(!move (_24.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 32_usize) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _23 = move (_24.0: usize);
        _25 = const 224_usize;
        _26 = Lt(_23, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _23) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _22 = &((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224])[_23];
        _3 = _22;
        goto -> bb42;
    }

    bb23: {
        _66 = const _;
        _30 = _66 as &[&str] (PointerCoercion(Unsize));
        _35 = &_27;
        _34 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_35) -> [return: bb27, unwind unreachable];
    }

    bb24: {
        _27 = _2;
        goto -> bb23;
    }

    bb25: {
        _27 = _2;
        goto -> bb23;
    }

    bb26: {
        _27 = _2;
        goto -> bb23;
    }

    bb27: {
        _33 = [move _34];
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _29 = Arguments::<'_>::new_v1(move _30, move _31) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _28 = panic_fmt(move _29) -> unwind unreachable;
    }

    bb29: {
        _65 = const _;
        _39 = _65 as &[&str] (PointerCoercion(Unsize));
        _44 = &_36;
        _43 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_44) -> [return: bb35, unwind unreachable];
    }

    bb30: {
        _36 = _2;
        goto -> bb29;
    }

    bb31: {
        _36 = _2;
        goto -> bb29;
    }

    bb32: {
        _36 = _2;
        goto -> bb29;
    }

    bb33: {
        _36 = _2;
        goto -> bb29;
    }

    bb34: {
        _36 = _2;
        goto -> bb29;
    }

    bb35: {
        _42 = [move _43];
        _41 = &_42;
        _40 = _41 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _38 = Arguments::<'_>::new_v1(move _39, move _40) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _37 = panic_fmt(move _38) -> unwind unreachable;
    }

    bb37: {
        _45 = _2;
        _64 = const _;
        _48 = _64 as &[&str] (PointerCoercion(Unsize));
        _53 = &_45;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_53) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _51 = [move _52];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _47 = Arguments::<'_>::new_v1(move _48, move _49) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _46 = panic_fmt(move _47) -> unwind unreachable;
    }

    bb40: {
        _60 = [move _61];
        _59 = &_60;
        _58 = _59 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _56 = Arguments::<'_>::new_v1(move _57, move _58) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _55 = panic_fmt(move _56) -> unwind unreachable;
    }

    bb42: {
        _0 = _3;
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:536:1: 536:47>::index: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "no entry with index "];
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:536:1: 536:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an diverging exception (must not return)"];
        _0 = &_1;
        return;
    }
}

promoted[2] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:536:1: 536:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an exception with error code"];
        _0 = &_1;
        return;
    }
}

promoted[3] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:536:1: 536:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is reserved"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:569:1: 569:50>::index_mut(_1: &mut InterruptDescriptorTable, _2: usize) -> &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame)> {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _13: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _15: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _19: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _20: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _23: usize;
    let mut _24: (usize, bool);
    let mut _25: usize;
    let mut _26: bool;
    let _27: usize;
    let _28: !;
    let mut _29: core::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 1];
    let _33: [core::fmt::rt::Argument<'_>; 1];
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &usize;
    let _36: usize;
    let _37: !;
    let mut _38: core::fmt::Arguments<'_>;
    let mut _39: &[&str];
    let mut _40: &[core::fmt::rt::Argument<'_>];
    let _41: &[core::fmt::rt::Argument<'_>; 1];
    let _42: [core::fmt::rt::Argument<'_>; 1];
    let mut _43: core::fmt::rt::Argument<'_>;
    let _44: &usize;
    let _45: usize;
    let _46: !;
    let mut _47: core::fmt::Arguments<'_>;
    let mut _48: &[&str];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 1];
    let _51: [core::fmt::rt::Argument<'_>; 1];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &usize;
    let _54: usize;
    let _55: !;
    let mut _56: core::fmt::Arguments<'_>;
    let mut _57: &[&str];
    let mut _58: &[core::fmt::rt::Argument<'_>];
    let _59: &[core::fmt::rt::Argument<'_>; 1];
    let _60: [core::fmt::rt::Argument<'_>; 1];
    let mut _61: core::fmt::rt::Argument<'_>;
    let _62: &usize;
    scope 1 {
        debug i => _2;
    }
    scope 2 {
        debug i => _27;
        let mut _66: &[&str; 2];
    }
    scope 3 {
        debug i => _36;
        let mut _65: &[&str; 2];
    }
    scope 4 {
        debug i => _45;
        let mut _64: &[&str; 2];
    }
    scope 5 {
        debug i => _54;
        let mut _63: &[&str; 1];
    }

    bb0: {
        switchInt(_2) -> [0: bb8, 1: bb9, 2: bb10, 3: bb11, 4: bb12, 5: bb13, 6: bb14, 7: bb15, 9: bb16, 16: bb17, 19: bb18, 20: bb19, 15: bb24, 31: bb25, 8: bb30, 17: bb32, 29: bb33, 30: bb34, 18: bb37, otherwise: bb1];
    }

    bb1: {
        _8 = Le(const 32_usize, _2);
        switchInt(move _8) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _9 = Le(_2, const 255_usize);
        switchInt(move _9) -> [0: bb3, otherwise: bb20];
    }

    bb3: {
        _6 = Le(const 21_usize, _2);
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _7 = Le(_2, const 28_usize);
        switchInt(move _7) -> [0: bb5, otherwise: bb26];
    }

    bb5: {
        _4 = Le(const 10_usize, _2);
        switchInt(move _4) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _5 = Le(_2, const 14_usize);
        switchInt(move _5) -> [0: bb7, otherwise: bb31];
    }

    bb7: {
        _54 = _2;
        _63 = const _;
        _57 = _63 as &[&str] (PointerCoercion(Unsize));
        _62 = &_54;
        _61 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_62) -> [return: bb40, unwind unreachable];
    }

    bb8: {
        _10 = &mut ((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _10;
        goto -> bb42;
    }

    bb9: {
        _11 = &mut ((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _11;
        goto -> bb42;
    }

    bb10: {
        _12 = &mut ((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _12;
        goto -> bb42;
    }

    bb11: {
        _13 = &mut ((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _13;
        goto -> bb42;
    }

    bb12: {
        _14 = &mut ((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _14;
        goto -> bb42;
    }

    bb13: {
        _15 = &mut ((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _15;
        goto -> bb42;
    }

    bb14: {
        _16 = &mut ((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _16;
        goto -> bb42;
    }

    bb15: {
        _17 = &mut ((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _17;
        goto -> bb42;
    }

    bb16: {
        _18 = &mut ((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _18;
        goto -> bb42;
    }

    bb17: {
        _19 = &mut ((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _19;
        goto -> bb42;
    }

    bb18: {
        _20 = &mut ((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _20;
        goto -> bb42;
    }

    bb19: {
        _21 = &mut ((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _21;
        goto -> bb42;
    }

    bb20: {
        _24 = CheckedSub(_2, const 32_usize);
        assert(!move (_24.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 32_usize) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _23 = move (_24.0: usize);
        _25 = const 224_usize;
        _26 = Lt(_23, _25);
        assert(move _26, "index out of bounds: the length is {} but the index is {}", move _25, _23) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _22 = &mut ((*_1).25: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224])[_23];
        _3 = _22;
        goto -> bb42;
    }

    bb23: {
        _66 = const _;
        _30 = _66 as &[&str] (PointerCoercion(Unsize));
        _35 = &_27;
        _34 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_35) -> [return: bb27, unwind unreachable];
    }

    bb24: {
        _27 = _2;
        goto -> bb23;
    }

    bb25: {
        _27 = _2;
        goto -> bb23;
    }

    bb26: {
        _27 = _2;
        goto -> bb23;
    }

    bb27: {
        _33 = [move _34];
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _29 = Arguments::<'_>::new_v1(move _30, move _31) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _28 = panic_fmt(move _29) -> unwind unreachable;
    }

    bb29: {
        _65 = const _;
        _39 = _65 as &[&str] (PointerCoercion(Unsize));
        _44 = &_36;
        _43 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_44) -> [return: bb35, unwind unreachable];
    }

    bb30: {
        _36 = _2;
        goto -> bb29;
    }

    bb31: {
        _36 = _2;
        goto -> bb29;
    }

    bb32: {
        _36 = _2;
        goto -> bb29;
    }

    bb33: {
        _36 = _2;
        goto -> bb29;
    }

    bb34: {
        _36 = _2;
        goto -> bb29;
    }

    bb35: {
        _42 = [move _43];
        _41 = &_42;
        _40 = _41 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _38 = Arguments::<'_>::new_v1(move _39, move _40) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _37 = panic_fmt(move _38) -> unwind unreachable;
    }

    bb37: {
        _45 = _2;
        _64 = const _;
        _48 = _64 as &[&str] (PointerCoercion(Unsize));
        _53 = &_45;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_53) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _51 = [move _52];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _47 = Arguments::<'_>::new_v1(move _48, move _49) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _46 = panic_fmt(move _47) -> unwind unreachable;
    }

    bb40: {
        _60 = [move _61];
        _59 = &_60;
        _58 = _59 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _56 = Arguments::<'_>::new_v1(move _57, move _58) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _55 = panic_fmt(move _56) -> unwind unreachable;
    }

    bb42: {
        _0 = _3;
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:569:1: 569:50>::index_mut: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "no entry with index "];
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:569:1: 569:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an diverging exception (must not return)"];
        _0 = &_1;
        return;
    }
}

promoted[2] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:569:1: 569:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an exception with error code"];
        _0 = &_1;
        return;
    }
}

promoted[3] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:569:1: 569:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is reserved"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:604:10: 604:15>::clone(_1: &Entry<F>) -> Entry<F> {
    debug self => _1;
    let mut _0: structures::idt::Entry<F>;
    let mut _2: u16;
    let _3: &u16;
    let mut _4: u16;
    let _5: &u16;
    let mut _6: structures::idt::EntryOptions;
    let _7: &structures::idt::EntryOptions;
    let mut _8: u16;
    let _9: &u16;
    let mut _10: u32;
    let _11: &u32;
    let mut _12: u32;
    let _13: &u32;
    let mut _14: core::marker::PhantomData<F>;
    let _15: &core::marker::PhantomData<F>;

    bb0: {
        _3 = &((*_1).0: u16);
        _2 = (*_3);
        _5 = &((*_1).1: u16);
        _4 = (*_5);
        _7 = &((*_1).2: structures::idt::EntryOptions);
        _6 = <EntryOptions as Clone>::clone(_7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &((*_1).3: u16);
        _8 = (*_9);
        _11 = &((*_1).4: u32);
        _10 = (*_11);
        _13 = &((*_1).5: u32);
        _12 = (*_13);
        _15 = &((*_1).6: core::marker::PhantomData<F>);
        _14 = <PhantomData<F> as Clone>::clone(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Entry::<F> { pointer_low: move _2, gdt_selector: move _4, options: move _6, pointer_middle: move _8, pointer_high: move _10, reserved: move _12, phantom: const ZeroSized: PhantomData<F> };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:616:1: 616:32>::fmt(_1: &Entry<T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _7: core::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &core::fmt::Arguments<'_>;
    let _12: core::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &addr::VirtAddr;
    let _19: addr::VirtAddr;
    let mut _20: &[core::fmt::rt::Placeholder];
    let _21: &[core::fmt::rt::Placeholder; 1];
    let _22: [core::fmt::rt::Placeholder; 1];
    let mut _23: core::fmt::rt::Placeholder;
    let mut _24: core::fmt::rt::Alignment;
    let mut _25: core::fmt::rt::Count;
    let mut _26: core::fmt::rt::Count;
    let mut _27: core::fmt::rt::UnsafeArg;
    let _28: &str;
    let mut _29: &dyn core::fmt::Debug;
    let _30: &u16;
    let _31: &str;
    let mut _32: &dyn core::fmt::Debug;
    let _33: &structures::idt::EntryOptions;
    let mut _34: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _8 = const "Entry";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "handler_addr";
        _34 = const _;
        _13 = _34 as &[&str] (PointerCoercion(Unsize));
        _19 = Entry::<T>::handler_addr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _18 = &_19;
        _17 = core::fmt::rt::Argument::<'_>::new_lower_hex::<addr::VirtAddr>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _24 = core::fmt::rt::Alignment::Unknown;
        _25 = core::fmt::rt::Count::Implied;
        _26 = core::fmt::rt::Count::Implied;
        _23 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _24, const 4_u32, move _25, move _26) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _22 = [move _23];
        _21 = &_22;
        _20 = _21 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _27 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _12 = Arguments::<'_>::new_v1_formatted(move _13, move _14, move _20, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = &_12;
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _28 = const "gdt_selector";
        _30 = &((*_1).1: u16);
        _29 = _30 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _28, move _29) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _31 = const "options";
        _33 = &((*_1).2: structures::idt::EntryOptions);
        _32 = _33 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _31, move _32) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:616:1: 616:32>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:626:1: 626:31>::eq(_1: &Entry<T>, _2: &Entry<T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u16;
    let mut _5: u16;
    let mut _6: bool;
    let mut _7: u16;
    let mut _8: u16;
    let mut _9: bool;
    let mut _10: &structures::idt::EntryOptions;
    let mut _11: &structures::idt::EntryOptions;
    let mut _12: bool;
    let mut _13: u16;
    let mut _14: u16;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;

    bb0: {
        _4 = ((*_1).0: u16);
        _5 = ((*_2).0: u16);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb7, otherwise: bb1];
    }

    bb1: {
        _7 = ((*_1).1: u16);
        _8 = ((*_2).1: u16);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _10 = &((*_1).2: structures::idt::EntryOptions);
        _11 = &((*_2).2: structures::idt::EntryOptions);
        _9 = <EntryOptions as PartialEq>::eq(move _10, move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _9) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _13 = ((*_1).3: u16);
        _14 = ((*_2).3: u16);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        _16 = ((*_1).4: u32);
        _17 = ((*_2).4: u32);
        _15 = Eq(move _16, move _17);
        switchInt(move _15) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _18 = ((*_1).5: u32);
        _19 = ((*_2).5: u32);
        _0 = Eq(move _18, move _19);
        goto -> bb8;
    }

    bb7: {
        _0 = const false;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:692:1: 692:17>::missing() -> Entry<F> {
    let mut _0: structures::idt::Entry<F>;
    let mut _1: structures::idt::EntryOptions;

    bb0: {
        _1 = EntryOptions::minimal() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<F> { pointer_low: const 0_u16, gdt_selector: const 0_u16, options: move _1, pointer_middle: const 0_u16, pointer_high: const 0_u32, reserved: const 0_u32, phantom: const ZeroSized: PhantomData<F> };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:692:1: 692:17>::missing() -> Entry<F> {
    let mut _0: structures::idt::Entry<F>;
    let mut _1: structures::idt::EntryOptions;
    let mut _2: core::marker::PhantomData<F>;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = EntryOptions::minimal() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_2);
        _2 = PhantomData::<F>;
        _0 = Entry::<F> { pointer_low: const 0_u16, gdt_selector: const 0_u16, options: move _1, pointer_middle: const 0_u16, pointer_high: const 0_u32, reserved: const 0_u32, phantom: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:692:1: 692:17>::set_handler_addr(_1: &mut Entry<F>, _2: addr::VirtAddr) -> &mut EntryOptions {
    debug self => _1;
    debug addr => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u16;
    let mut _11: registers::segmentation::SegmentSelector;
    let _12: &mut structures::idt::EntryOptions;
    let mut _13: &mut structures::idt::EntryOptions;
    scope 1 {
        debug addr => _3;
    }

    bb0: {
        _3 = addr::VirtAddr::as_u64(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u16) = _3 as u16 (IntToInt);
        _5 = const 16_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(_3, const 16_i32);
        ((*_1).3: u16) = move _4 as u16 (IntToInt);
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Shr(_3, const 32_i32);
        ((*_1).4: u32) = move _7 as u32 (IntToInt);
        _11 = <CS as Segment>::get_reg() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = (_11.0: u16);
        ((*_1).1: u16) = move _10;
        _13 = &mut ((*_1).2: structures::idt::EntryOptions);
        _12 = EntryOptions::set_present(move _13, const true) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = &mut ((*_1).2: structures::idt::EntryOptions);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:692:1: 692:17>::handler_addr(_1: &Entry<F>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u16;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u16;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    scope 1 {
        debug addr => _2;
    }

    bb0: {
        _5 = ((*_1).0: u16);
        _4 = move _5 as u64 (IntToInt);
        _8 = ((*_1).3: u16);
        _7 = move _8 as u64 (IntToInt);
        _9 = const 16_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shl(move _7, const 16_i32);
        _3 = BitOr(move _4, move _6);
        _13 = ((*_1).4: u32);
        _12 = move _13 as u64 (IntToInt);
        _14 = const 32_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Shl(move _12, const 32_i32);
        _2 = BitOr(move _3, move _11);
        _0 = addr::VirtAddr::new_truncate(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:751:9: 751:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame)>, _2: extern "x86-interrupt" fn(InterruptStackFrame)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:751:9: 751:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)>, _2: extern "x86-interrupt" fn(InterruptStackFrame, u64)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:751:9: 751:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>, _2: extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:751:9: 751:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame) -> !>, _2: extern "x86-interrupt" fn(InterruptStackFrame) -> !) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:751:9: 751:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>, _2: extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:779:10: 779:15>::clone(_1: &EntryOptions) -> EntryOptions {
    debug self => _1;
    let mut _0: structures::idt::EntryOptions;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:779:23: 779:32>::eq(_1: &EntryOptions, _2: &EntryOptions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:782:1: 782:33>::fmt(_1: &EntryOptions, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u16;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "EntryOptions";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u16);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u16>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Is(const 6_usize);
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 12_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:782:1: 782:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::minimal() -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(const 3584_u16);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::minimal() -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(const 3584_u16);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::set_present(_1: &mut EntryOptions, _2: bool) -> &mut EntryOptions {
    debug self => _1;
    debug present => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _3 = <u16 as BitField>::set_bit(move _4, const 15_usize, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::disable_interrupts(_1: &mut EntryOptions, _2: bool) -> &mut EntryOptions {
    debug self => _1;
    debug disable => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Not(_2);
        _3 = <u16 as BitField>::set_bit(move _4, const 8_usize, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::set_privilege_level(_1: &mut EntryOptions, _2: PrivilegeLevel) -> &mut EntryOptions {
    debug self => _1;
    debug dpl => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: u8;
    let mut _8: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 13_usize, end: const 15_usize };
        _7 = discriminant(_2);
        _8 = Le(_7, const 3_u8);
        assume(move _8);
        _6 = _7 as u16 (IntToInt);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:790:1: 790:18>::set_stack_index(_1: &mut EntryOptions, _2: u16) -> &mut EntryOptions {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: (u16, bool);

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 0_usize, end: const 3_usize };
        _7 = CheckedAdd(_2, const 1_u16);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_u16) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move (_7.0: u16);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:854:1: 854:25>::as_mut(_1: &mut InterruptStackFrame) -> Volatile<&mut InterruptStackFrameValue> {
    debug self => _1;
    let mut _0: volatile::Volatile<&mut structures::idt::InterruptStackFrameValue>;
    let mut _2: &mut structures::idt::InterruptStackFrameValue;

    bb0: {
        _2 = &mut ((*_1).0: structures::idt::InterruptStackFrameValue);
        _0 = Volatile::<&mut InterruptStackFrameValue>::new(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:875:1: 875:35>::deref(_1: &InterruptStackFrame) -> &InterruptStackFrameValue {
    debug self => _1;
    let mut _0: &structures::idt::InterruptStackFrameValue;

    bb0: {
        _0 = &((*_1).0: structures::idt::InterruptStackFrameValue);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:884:1: 884:40>::fmt(_1: &InterruptStackFrame, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &structures::idt::InterruptStackFrameValue;

    bb0: {
        _3 = &((*_1).0: structures::idt::InterruptStackFrameValue);
        _0 = <InterruptStackFrameValue as Debug>::fmt(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:892:10: 892:15>::clone(_1: &InterruptStackFrameValue) -> InterruptStackFrameValue {
    debug self => _1;
    let mut _0: structures::idt::InterruptStackFrameValue;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:911:1: 911:45>::fmt(_1: &InterruptStackFrameValue, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &addr::VirtAddr;
    let _10: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _11: &mut core::fmt::DebugStruct<'_, '_>;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &u64;
    let _15: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _16: &mut core::fmt::DebugStruct<'_, '_>;
    let _17: &str;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &<structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;
    let _20: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;
    let mut _21: u64;
    let _22: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _23: &mut core::fmt::DebugStruct<'_, '_>;
    let _24: &str;
    let mut _25: &dyn core::fmt::Debug;
    let _26: &addr::VirtAddr;
    let _27: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _28: &mut core::fmt::DebugStruct<'_, '_>;
    let _29: &str;
    let mut _30: &dyn core::fmt::Debug;
    let _31: &u64;
    let mut _32: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "InterruptStackFrame";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "instruction_pointer";
        _9 = &((*_1).0: addr::VirtAddr);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = &mut _3;
        _12 = const "code_segment";
        _14 = &((*_1).1: u64);
        _13 = _14 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = DebugStruct::<'_, '_>::field(move _11, _12, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = &mut _3;
        _17 = const "cpu_flags";
        _21 = ((*_1).2: u64);
        _20 = Hex(move _21);
        _19 = &_20;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _15 = DebugStruct::<'_, '_>::field(move _16, _17, move _18) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _23 = &mut _3;
        _24 = const "stack_pointer";
        _26 = &((*_1).3: addr::VirtAddr);
        _25 = _26 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _22 = DebugStruct::<'_, '_>::field(move _23, _24, move _25) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _28 = &mut _3;
        _29 = const "stack_segment";
        _31 = &((*_1).4: u64);
        _30 = _31 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = DebugStruct::<'_, '_>::field(move _28, _29, move _30) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _32 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _32) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:911:1: 911:45>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:914:9: 914:32>::fmt(_1: &Hex, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &u64;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _18 = const _;
        _4 = _18 as &[&str] (PointerCoercion(Unsize));
        _9 = &((*_1).0: u64);
        _8 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:911:1: 911:45>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:914:9: 914:32>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &PageFaultErrorCode) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &PageFaultErrorCode, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _95: u64;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: &structures::idt::PageFaultErrorCode;
    let _99: structures::idt::PageFaultErrorCode;
    let mut _100: u64;
    let mut _101: bool;
    let mut _102: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _103: core::result::Result<(), core::fmt::Error>;
    let _104: &str;
    let mut _105: isize;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &u64;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _116: core::result::Result<(), core::fmt::Error>;
    let _117: &str;
    let mut _118: isize;
    scope 1 {
        debug first => _3;
        let _94: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug extra_bits => _94;
            scope 75 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 76 {
                }
            }
            scope 77 {
                debug val => const ();
                scope 78 {
                }
            }
            scope 79 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 80 {
                }
            }
            scope 81 {
                debug val => const ();
                scope 82 {
                }
            }
            scope 83 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 84 {
                }
            }
            scope 85 {
                debug val => const ();
                scope 86 {
                }
            }
            scope 87 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 88 {
                }
            }
            scope 89 {
                debug val => const ();
                scope 90 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::PROTECTION_VIOLATION(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "PROTECTION_VIOLATION";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb12: {
        _14 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::CAUSED_BY_WRITE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "CAUSED_BY_WRITE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb23: {
        _24 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::USER_MODE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "USER_MODE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb34: {
        _34 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::MALFORMED_TABLE(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "MALFORMED_TABLE";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb45: {
        _44 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::INSTRUCTION_FETCH(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "INSTRUCTION_FETCH";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb56: {
        _54 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::PROTECTION_KEY(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "PROTECTION_KEY";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb67: {
        _64 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::SHADOW_STACK(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "SHADOW_STACK";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb78: {
        _74 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::SGX(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "SGX";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb89: {
        _84 = <PageFaultErrorCode as <PageFaultErrorCode as Debug>::fmt::__BitFlags>::RMP(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "RMP";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb100: {
        _95 = ((*_1).0: u64);
        _99 = PageFaultErrorCode::all() -> [return: bb101, unwind unreachable];
    }

    bb101: {
        _98 = &_99;
        _97 = PageFaultErrorCode::bits(move _98) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _96 = Not(move _97);
        _94 = BitAnd(move _95, move _96);
        _100 = _94;
        switchInt(move _100) -> [0: bb116, otherwise: bb103];
    }

    bb103: {
        _101 = _3;
        switchInt(move _101) -> [0: bb104, otherwise: bb108];
    }

    bb104: {
        _104 = const " | ";
        _103 = Formatter::<'_>::write_str(_2, _104) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _102 = <Result<(), core::fmt::Error> as Try>::branch(move _103) -> [return: bb106, unwind unreachable];
    }

    bb106: {
        _105 = discriminant(_102);
        switchInt(move _105) -> [0: bb108, 1: bb107, otherwise: bb6];
    }

    bb107: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb108: {
        _3 = const false;
        _108 = const "0x";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb110, unwind unreachable];
    }

    bb110: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb111, 1: bb112, otherwise: bb6];
    }

    bb111: {
        _112 = &_94;
        _111 = <u64 as LowerHex>::fmt(_112, _2) -> [return: bb113, unwind unreachable];
    }

    bb112: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb113: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb116, 1: bb115, otherwise: bb6];
    }

    bb115: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb116: {
        _114 = _3;
        switchInt(move _114) -> [0: bb121, otherwise: bb117];
    }

    bb117: {
        _117 = const "(empty)";
        _116 = Formatter::<'_>::write_str(_2, _117) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _115 = <Result<(), core::fmt::Error> as Try>::branch(move _116) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _118 = discriminant(_115);
        switchInt(move _118) -> [0: bb121, 1: bb120, otherwise: bb6];
    }

    bb120: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb122, unwind unreachable];
    }

    bb121: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb122;
    }

    bb122: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTION_VIOLATION(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::CAUSED_BY_WRITE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::USER_MODE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::MALFORMED_TABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::INSTRUCTION_FETCH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PROTECTION_KEY(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SHADOW_STACK(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::SGX(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::RMP(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTION_VIOLATION(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::CAUSED_BY_WRITE(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::USER_MODE(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::MALFORMED_TABLE(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::INSTRUCTION_FETCH(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PROTECTION_KEY(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SHADOW_STACK(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::SGX(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::RMP(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::idt::PageFaultErrorCode;
    let mut _9: u64;
    let mut _10: structures::idt::PageFaultErrorCode;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTION_VIOLATION: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode { bits: const 1_u64 };
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::CAUSED_BY_WRITE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::USER_MODE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::MALFORMED_TABLE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::INSTRUCTION_FETCH: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PROTECTION_KEY: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SHADOW_STACK: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::SGX: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::RMP: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 31_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 31_i32);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode { bits: const 0_u64 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _8 = BitOr(const _, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = PageFaultErrorCode { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = BitOr(const _, const _);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = PageFaultErrorCode { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTION_VIOLATION: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::CAUSED_BY_WRITE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::USER_MODE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::MALFORMED_TABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::INSTRUCTION_FETCH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PROTECTION_KEY: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SHADOW_STACK: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::SGX: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::RMP: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTION_VIOLATION: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::CAUSED_BY_WRITE: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::USER_MODE: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::MALFORMED_TABLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::INSTRUCTION_FETCH: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PROTECTION_KEY: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SHADOW_STACK: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::SGX: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::RMP: u64 = {
    let mut _0: u64;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &PageFaultErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &PageFaultErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<PageFaultErrorCode> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::idt::PageFaultErrorCode;
    let _6: structures::idt::PageFaultErrorCode;
    let mut _7: structures::idt::PageFaultErrorCode;

    bb0: {
        _6 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = PageFaultErrorCode::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = PageFaultErrorCode { bits: _1 };
        _0 = Option::<PageFaultErrorCode>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PageFaultErrorCode>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<PageFaultErrorCode> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::PageFaultErrorCode;
    let _8: structures::idt::PageFaultErrorCode;
    let mut _9: structures::idt::PageFaultErrorCode;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = PageFaultErrorCode::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = PageFaultErrorCode { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<PageFaultErrorCode>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<PageFaultErrorCode>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;

    bb0: {
        _4 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = PageFaultErrorCode { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageFaultErrorCode { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = PageFaultErrorCode { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::idt::PageFaultErrorCode;
    let _5: structures::idt::PageFaultErrorCode;

    bb0: {
        _2 = PageFaultErrorCode::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PageFaultErrorCode::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = PageFaultErrorCode::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &structures::idt::PageFaultErrorCode;
    let mut _4: u64;
    let mut _5: &structures::idt::PageFaultErrorCode;
    let _6: structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = PageFaultErrorCode::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = PageFaultErrorCode::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = PageFaultErrorCode::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::idt::PageFaultErrorCode;
    let _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = PageFaultErrorCode { bits: move _6 };
        _4 = &_5;
        _3 = PageFaultErrorCode::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::idt::PageFaultErrorCode;
    let _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = PageFaultErrorCode { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = PageFaultErrorCode::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = PageFaultErrorCode::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = PageFaultErrorCode::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageFaultErrorCode { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageFaultErrorCode { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageFaultErrorCode { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageFaultErrorCode { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = PageFaultErrorCode::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageFaultErrorCode::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = PageFaultErrorCode { bits: move _3 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::idt::PageFaultErrorCode;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = PageFaultErrorCode { bits: move _3 };
        _5 = PageFaultErrorCode::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <PageFaultErrorCode as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut PageFaultErrorCode, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::idt::PageFaultErrorCode);
        _5 = PageFaultErrorCode::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> PageFaultErrorCode {
    debug iterator => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::PageFaultErrorCode;
    let _3: ();
    let mut _4: &mut structures::idt::PageFaultErrorCode;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = PageFaultErrorCode::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <PageFaultErrorCode as Extend<PageFaultErrorCode>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:978:10: 978:15>::clone(_1: &SelectorErrorCode) -> SelectorErrorCode {
    debug self => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:978:23: 978:32>::eq(_1: &SelectorErrorCode, _2: &SelectorErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:978:34: 978:36>::assert_receiver_is_total_eq(_1: &SelectorErrorCode) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:978:38: 978:42>::hash(_1: &SelectorErrorCode, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::new(_1: u64) -> Option<SelectorErrorCode> {
    debug value => _1;
    let mut _0: core::option::Option<structures::idt::SelectorErrorCode>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: structures::idt::SelectorErrorCode;

    bb0: {
        _3 = const _ as u64 (IntToInt);
        _2 = Gt(_1, move _3);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<SelectorErrorCode>::None;
        goto -> bb3;
    }

    bb2: {
        _4 = SelectorErrorCode { flags: _1 };
        _0 = Option::<SelectorErrorCode>::Some(move _4);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::new(_1: u64) -> Option<SelectorErrorCode> {
    debug value => _1;
    let mut _0: core::option::Option<structures::idt::SelectorErrorCode>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::idt::SelectorErrorCode;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = const _ as u64 (IntToInt);
        _2 = Gt(move _3, move _4);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageDead(_4);
        StorageDead(_3);
        _0 = Option::<SelectorErrorCode>::None;
        goto -> bb3;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = SelectorErrorCode { flags: move _6 };
        StorageDead(_6);
        _0 = Option::<SelectorErrorCode>::Some(move _5);
        StorageDead(_5);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::new_truncate(_1: u64) -> SelectorErrorCode {
    debug value => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    let mut _2: u64;
    let mut _3: u16;

    bb0: {
        _3 = _1 as u16 (IntToInt);
        _2 = move _3 as u64 (IntToInt);
        _0 = SelectorErrorCode { flags: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::new_truncate(_1: u64) -> SelectorErrorCode {
    debug value => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    let mut _2: u64;
    let mut _3: u16;
    let mut _4: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        _3 = move _4 as u16 (IntToInt);
        StorageDead(_4);
        _2 = move _3 as u64 (IntToInt);
        StorageDead(_3);
        _0 = SelectorErrorCode { flags: move _2 };
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::external(_1: &SelectorErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &u64;

    bb0: {
        _2 = &((*_1).0: u64);
        _0 = <u64 as BitField>::get_bit(move _2, const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::descriptor_table(_1: &SelectorErrorCode) -> DescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::DescriptorTable;
    let mut _2: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _5: !;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = Range::<usize> { start: const 1_usize, end: const 3_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, otherwise: bb2];
    }

    bb2: {
        _5 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb3: {
        _0 = DescriptorTable::Gdt;
        goto -> bb7;
    }

    bb4: {
        _0 = DescriptorTable::Idt;
        goto -> bb7;
    }

    bb5: {
        _0 = DescriptorTable::Ldt;
        goto -> bb7;
    }

    bb6: {
        _0 = DescriptorTable::Idt;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::index(_1: &SelectorErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &u64;
    let mut _3: core::ops::Range<usize>;

    bb0: {
        _2 = &((*_1).0: u64);
        _3 = Range::<usize> { start: const 3_usize, end: const 16_usize };
        _0 = <u64 as BitField>::get_bits::<Range<usize>>(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:984:1: 984:23>::is_null(_1: &SelectorErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1029:1: 1029:38>::fmt(_1: &SelectorErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &bool;
    let _10: bool;
    let _11: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::idt::DescriptorTable;
    let _16: structures::idt::DescriptorTable;
    let _17: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _18: &mut core::fmt::DebugStruct<'_, '_>;
    let _19: &str;
    let mut _20: &dyn core::fmt::Debug;
    let _21: &u64;
    let _22: u64;
    let mut _23: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "Selector Error";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "external";
        _10 = SelectorErrorCode::external(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &mut _3;
        _13 = const "descriptor table";
        _16 = SelectorErrorCode::descriptor_table(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = DebugStruct::<'_, '_>::field(move _12, _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _18 = &mut _3;
        _19 = const "index";
        _22 = SelectorErrorCode::index(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _21 = &_22;
        _20 = _21 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = DebugStruct::<'_, '_>::field(move _18, _19, move _20) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _23 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _23) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1042:10: 1042:15>::fmt(_1: &DescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "Ldt";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Gdt";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Idt";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1042:17: 1042:22>::clone(_1: &DescriptorTable) -> DescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::DescriptorTable;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1042:30: 1042:39>::eq(_1: &DescriptorTable, _2: &DescriptorTable) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1042:41: 1042:43>::assert_receiver_is_total_eq(_1: &DescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1042:45: 1042:49>::hash(_1: &DescriptorTable, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: isize;
    let _4: &isize;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <isize as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

ExceptionVector::Division::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

ExceptionVector::Debug::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

ExceptionVector::NonMaskableInterrupt::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

ExceptionVector::Breakpoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

ExceptionVector::Overflow::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 4_u8;
        return;
    }
}

ExceptionVector::BoundRange::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 5_u8;
        return;
    }
}

ExceptionVector::InvalidOpcode::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 6_u8;
        return;
    }
}

ExceptionVector::DeviceNotAvailable::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 7_u8;
        return;
    }
}

ExceptionVector::Double::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 8_u8;
        return;
    }
}

ExceptionVector::InvalidTss::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 10_u8;
        return;
    }
}

ExceptionVector::SegmentNotPresent::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 11_u8;
        return;
    }
}

ExceptionVector::Stack::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 12_u8;
        return;
    }
}

ExceptionVector::GeneralProtection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 13_u8;
        return;
    }
}

ExceptionVector::Page::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 14_u8;
        return;
    }
}

ExceptionVector::X87FloatingPoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 16_u8;
        return;
    }
}

ExceptionVector::AlignmentCheck::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 17_u8;
        return;
    }
}

ExceptionVector::MachineCheck::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 18_u8;
        return;
    }
}

ExceptionVector::SimdFloatingPoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 19_u8;
        return;
    }
}

ExceptionVector::Virtualization::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 20_u8;
        return;
    }
}

ExceptionVector::ControlProtection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 21_u8;
        return;
    }
}

ExceptionVector::HypervisorInjection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 28_u8;
        return;
    }
}

ExceptionVector::VmmCommunication::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 29_u8;
        return;
    }
}

ExceptionVector::Security::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 30_u8;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1059:16: 1059:21>::clone(_1: &ExceptionVector) -> ExceptionVector {
    debug self => _1;
    let mut _0: structures::idt::ExceptionVector;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1059:23: 1059:28>::fmt(_1: &ExceptionVector, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;
    let _11: &str;
    let _12: &str;
    let _13: &str;
    let _14: &str;
    let _15: &str;
    let _16: &str;
    let _17: &str;
    let _18: &str;
    let _19: &str;
    let _20: &str;
    let _21: &str;
    let _22: &str;
    let _23: &str;
    let _24: &str;
    let _25: &str;
    let _26: &str;
    let _27: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 10: bb12, 11: bb13, 12: bb14, 13: bb15, 14: bb16, 16: bb17, 17: bb18, 18: bb19, 19: bb20, 20: bb21, 21: bb22, 28: bb23, 29: bb24, 30: bb1, otherwise: bb2];
    }

    bb1: {
        _27 = const "Security";
        _3 = _27;
        goto -> bb25;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Division";
        _3 = _5;
        goto -> bb25;
    }

    bb4: {
        _6 = const "Debug";
        _3 = _6;
        goto -> bb25;
    }

    bb5: {
        _7 = const "NonMaskableInterrupt";
        _3 = _7;
        goto -> bb25;
    }

    bb6: {
        _8 = const "Breakpoint";
        _3 = _8;
        goto -> bb25;
    }

    bb7: {
        _9 = const "Overflow";
        _3 = _9;
        goto -> bb25;
    }

    bb8: {
        _10 = const "BoundRange";
        _3 = _10;
        goto -> bb25;
    }

    bb9: {
        _11 = const "InvalidOpcode";
        _3 = _11;
        goto -> bb25;
    }

    bb10: {
        _12 = const "DeviceNotAvailable";
        _3 = _12;
        goto -> bb25;
    }

    bb11: {
        _13 = const "Double";
        _3 = _13;
        goto -> bb25;
    }

    bb12: {
        _14 = const "InvalidTss";
        _3 = _14;
        goto -> bb25;
    }

    bb13: {
        _15 = const "SegmentNotPresent";
        _3 = _15;
        goto -> bb25;
    }

    bb14: {
        _16 = const "Stack";
        _3 = _16;
        goto -> bb25;
    }

    bb15: {
        _17 = const "GeneralProtection";
        _3 = _17;
        goto -> bb25;
    }

    bb16: {
        _18 = const "Page";
        _3 = _18;
        goto -> bb25;
    }

    bb17: {
        _19 = const "X87FloatingPoint";
        _3 = _19;
        goto -> bb25;
    }

    bb18: {
        _20 = const "AlignmentCheck";
        _3 = _20;
        goto -> bb25;
    }

    bb19: {
        _21 = const "MachineCheck";
        _3 = _21;
        goto -> bb25;
    }

    bb20: {
        _22 = const "SimdFloatingPoint";
        _3 = _22;
        goto -> bb25;
    }

    bb21: {
        _23 = const "Virtualization";
        _3 = _23;
        goto -> bb25;
    }

    bb22: {
        _24 = const "ControlProtection";
        _3 = _24;
        goto -> bb25;
    }

    bb23: {
        _25 = const "HypervisorInjection";
        _3 = _25;
        goto -> bb25;
    }

    bb24: {
        _26 = const "VmmCommunication";
        _3 = _26;
        goto -> bb25;
    }

    bb25: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/idt.rs:1059:30: 1059:39>::eq(_1: &ExceptionVector, _2: &ExceptionVector) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:10: 11:15>::clone(_1: &PhysFrame<S>) -> PhysFrame<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;
    let _3: &addr::PhysAddr;
    let mut _4: core::marker::PhantomData<S>;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _3 = &((*_1).0: addr::PhysAddr);
        _2 = <PhysAddr as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _4 = <PhantomData<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrame::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:23: 11:32>::eq(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &addr::PhysAddr;
    let mut _5: &addr::PhysAddr;
    let mut _6: &core::marker::PhantomData<S>;
    let mut _7: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: core::marker::PhantomData<S>);
        _7 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:34: 11:36>::assert_receiver_is_total_eq(_1: &PhysFrame<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:38: 11:48>::partial_cmp(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let mut _3: core::option::Option<core::cmp::Ordering>;
    let _4: &addr::PhysAddr;
    let _5: &addr::PhysAddr;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &core::marker::PhantomData<S>;
    let _9: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: core::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: core::marker::PhantomData<S>);
        _9 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:50: 11:53>::cmp(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let mut _3: core::cmp::Ordering;
    let _4: &addr::PhysAddr;
    let _5: &addr::PhysAddr;
    let mut _6: i8;
    let _7: &core::marker::PhantomData<S>;
    let _8: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as Ord>::cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb4;
    }

    bb3: {
        _7 = &((*_1).1: core::marker::PhantomData<S>);
        _8 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Ord>::cmp(_7, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:11:55: 11:59>::hash(_1: &PhysFrame<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &addr::PhysAddr;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _3 = <PhysAddr as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address(_1: PhysAddr) -> Result<PhysFrame<S>, AddressNotAligned> {
    debug address => _1;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<S>, structures::paging::page::AddressNotAligned>;
    let mut _2: bool;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    scope 1 {
    }

    bb0: {
        _2 = PhysAddr::is_aligned::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = PhysFrame::<S>::from_start_address_unchecked(_1) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = Result::<PhysFrame<S>, AddressNotAligned>::Err(const AddressNotAligned);
        goto -> bb5;
    }

    bb4: {
        _0 = Result::<PhysFrame<S>, AddressNotAligned>::Ok(move _3);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address_unchecked(_1: PhysAddr) -> PhysFrame<S> {
    debug start_address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _0 = PhysFrame::<S> { start_address: _1, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address_unchecked(_1: PhysAddr) -> PhysFrame<S> {
    debug start_address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;
    let mut _3: core::marker::PhantomData<S>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<S>;
        _0 = PhysFrame::<S> { start_address: move _2, size: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::containing_address(_1: PhysAddr) -> PhysFrame<S> {
    debug address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;

    bb0: {
        _2 = PhysAddr::align_down::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PhysFrame::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::start_address(_1: PhysFrame<S>) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = (_1.0: addr::PhysAddr);
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::start_address(_1: PhysFrame<S>) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = (_1.0: addr::PhysAddr);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::size(_1: PhysFrame<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::size(_1: PhysFrame<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::range(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;

    bb0: {
        _0 = PhysFrameRange::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::range(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PhysFrameRange::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::range_inclusive(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;

    bb0: {
        _0 = PhysFrameRangeInclusive::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:19:1: 19:31>::range_inclusive(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PhysFrameRangeInclusive::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:85:1: 85:46>::fmt(_1: &PhysFrame<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &u64;
    let _11: u64;
    let mut _12: addr::PhysAddr;
    let mut _13: structures::paging::frame::PhysFrame<S>;
    let mut _14: &[core::fmt::rt::Placeholder];
    let _15: &[core::fmt::rt::Placeholder; 2];
    let _16: [core::fmt::rt::Placeholder; 2];
    let mut _17: core::fmt::rt::Placeholder;
    let mut _18: core::fmt::rt::Alignment;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::Count;
    let mut _21: core::fmt::rt::Placeholder;
    let mut _22: core::fmt::rt::Alignment;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::Count;
    let mut _25: core::fmt::rt::UnsafeArg;
    let mut _26: &&str;
    let mut _27: &[&str; 3];
    scope 1 {
    }

    bb0: {
        _27 = const _;
        _4 = _27 as &[&str] (PointerCoercion(Unsize));
        _26 = const _;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _13 = (*_1);
        _12 = PhysFrame::<S>::start_address(move _13) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = PhysAddr::as_u64(move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = [move _8, move _9];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = core::fmt::rt::Alignment::Unknown;
        _19 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Count::Implied;
        _17 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _18, const 0_u32, move _19, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = core::fmt::rt::Alignment::Unknown;
        _23 = core::fmt::rt::Count::Implied;
        _24 = core::fmt::rt::Count::Implied;
        _21 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _22, const 4_u32, move _23, move _24) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _16 = [move _17, move _21];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::UnsafeArg::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _14, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:85:1: 85:46>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:85:1: 85:46>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "PhysFrame[", const "](", const ")"];
        _0 = &_1;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:95:1: 95:44>::add(_1: PhysFrame<S>, _2: u64) -> PhysFrame<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = PhysFrame::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <PhysAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = PhysFrame::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:103:1: 103:50>::add_assign(_1: &mut PhysFrame<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = (*_1);
        _3 = <PhysFrame<S> as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:110:1: 110:44>::sub(_1: PhysFrame<S>, _2: u64) -> PhysFrame<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = PhysFrame::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <PhysAddr as Sub<u64>>::sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = PhysFrame::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:118:1: 118:50>::sub_assign(_1: &mut PhysFrame<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = (*_1);
        _3 = <PhysFrame<S> as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:125:1: 125:53>::sub(_1: PhysFrame<S>, _2: PhysFrame<S>) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: addr::PhysAddr;
    let mut _5: addr::PhysAddr;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: addr::PhysAddr);
        _5 = (_2.0: addr::PhysAddr);
        _3 = <PhysAddr as Sub>::sub(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Eq(const _, const 0_u64);
        assert(!move _6, "attempt to divide `{}` by zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Div(move _3, const _);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:134:10: 134:15>::clone(_1: &PhysFrameRange<S>) -> PhysFrameRange<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;
    let mut _2: structures::paging::frame::PhysFrame<S>;
    let _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _4 = <PhysFrame<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrameRange::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:134:23: 134:32>::eq(_1: &PhysFrameRange<S>, _2: &PhysFrameRange<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let mut _5: &structures::paging::frame::PhysFrame<S>;
    let mut _6: &structures::paging::frame::PhysFrame<S>;
    let mut _7: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _5 = &((*_2).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _7 = &((*_2).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:134:34: 134:36>::assert_receiver_is_total_eq(_1: &PhysFrameRange<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:134:38: 134:42>::hash(_1: &PhysFrameRange<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:143:1: 143:36>::is_empty(_1: &PhysFrameRange<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::frame::PhysFrame<S>;
    let mut _3: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialOrd>::ge(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:151:1: 151:49>::next(_1: &mut PhysFrameRange<S>) -> Option<PhysFrame<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::frame::PhysFrame<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let _5: structures::paging::frame::PhysFrame<S>;
    let _6: ();
    let mut _7: &mut structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug frame => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _4 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as PartialOrd>::lt(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _7 = &mut ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _6 = <PhysFrame<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<PhysFrame<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PhysFrame<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:166:1: 166:51>::fmt(_1: &PhysFrameRange<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::frame::PhysFrame<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _7 = const "PhysFrameRange";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:176:10: 176:15>::clone(_1: &PhysFrameRangeInclusive<S>) -> PhysFrameRangeInclusive<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;
    let mut _2: structures::paging::frame::PhysFrame<S>;
    let _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _4 = <PhysFrame<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrameRangeInclusive::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:176:23: 176:32>::eq(_1: &PhysFrameRangeInclusive<S>, _2: &PhysFrameRangeInclusive<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let mut _5: &structures::paging::frame::PhysFrame<S>;
    let mut _6: &structures::paging::frame::PhysFrame<S>;
    let mut _7: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _5 = &((*_2).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _7 = &((*_2).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:176:34: 176:36>::assert_receiver_is_total_eq(_1: &PhysFrameRangeInclusive<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:176:38: 176:42>::hash(_1: &PhysFrameRangeInclusive<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:185:1: 185:45>::is_empty(_1: &PhysFrameRangeInclusive<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::frame::PhysFrame<S>;
    let mut _3: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialOrd>::gt(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:193:1: 193:58>::next(_1: &mut PhysFrameRangeInclusive<S>) -> Option<PhysFrame<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::frame::PhysFrame<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let _5: structures::paging::frame::PhysFrame<S>;
    let _6: ();
    let mut _7: &mut structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug frame => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _4 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as PartialOrd>::le(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _7 = &mut ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _6 = <PhysFrame<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<PhysFrame<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PhysFrame<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/frame.rs:208:1: 208:60>::fmt(_1: &PhysFrameRangeInclusive<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::frame::PhysFrame<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _7 = const "PhysFrameRangeInclusive";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:16:10: 16:15>::fmt(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&&mut structures::paging::page_table::PageTable;
    let _10: &&mut structures::paging::page_table::PageTable;

    bb0: {
        _3 = const "MappedPageTable";
        _4 = const "page_table_walker";
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "level_4_table";
        _10 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::new(_1: &mut PageTable, _2: P) -> mapped_page_table::MappedPageTable<'_, P> {
    debug level_4_table => _1;
    debug page_table_frame_mapping => _2;
    let mut _0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, P>;
    let mut _3: structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    scope 1 {
    }

    bb0: {
        _3 = PageTableWalker::<P>::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapped_page_table::MappedPageTable::<'_, P> { page_table_walker: move _3, level_4_table: _1 };
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::level_4_table(_1: &mut mapped_page_table::MappedPageTable<'_, P>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut &mut structures::paging::page_table::PageTable;

    bb0: {
        _2 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _0 = deref_copy (*_2);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::page_table_frame_mapping(_1: &mapped_page_table::MappedPageTable<'_, P>) -> &P {
    debug self => _1;
    let mut _0: &P;

    bb0: {
        _0 = &(((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>).0: P);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_1gib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: bool;
    let _17: &structures::paging::page_table::PageTableEntry;
    let mut _18: &structures::paging::page_table::PageTable;
    let mut _19: structures::paging::page_table::PageTableIndex;
    let mut _20: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let _21: ();
    let mut _22: &mut structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _24: addr::PhysAddr;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _27: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _27 = deref_copy (*_7);
        _12 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_27, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &(*_15);
        _19 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb19, unwind unreachable];
    }

    bb8: {
        _17 = <PageTable as Index<PageTableIndex>>::index(move _18, move _19) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = PageTableEntry::is_unused(_17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _23 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _20 = mapper::MapToError::<page::Size1GiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Err(move _20);
        goto -> bb19;
    }

    bb13: {
        _22 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _23) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = PhysFrame::<page::Size1GiB>::start_address(_3) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _25 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _21 = PageTableEntry::set_addr(_22, move _24, move _25) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _26 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Ok(move _26);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_2mib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _17: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _18: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: isize;
    let mut _24: bool;
    let _25: &structures::paging::page_table::PageTableEntry;
    let mut _26: &structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _28: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let _29: ();
    let mut _30: &mut structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: addr::PhysAddr;
    let mut _33: structures::paging::page_table::PageTableFlags;
    let mut _34: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _35: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
            let _22: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
            let _23: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _23;
            }
            scope 8 {
                debug residual => _22;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _23;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _35 = deref_copy (*_7);
        _12 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_35, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb25, unwind unreachable];
    }

    bb8: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = PageTableWalker::<P>::create_next_table::<A>(move _18, _19, _5, _6) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _17) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = discriminant(_16);
        switchInt(move _21) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _23 = move ((_16 as Continue).0: &mut structures::paging::page_table::PageTable);
        _26 = &(*_23);
        _27 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _22 = move ((_16 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _22) -> [return: bb25, unwind unreachable];
    }

    bb14: {
        _25 = <PageTable as Index<PageTableIndex>>::index(move _26, move _27) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _24 = PageTableEntry::is_unused(_25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _31 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _28 = mapper::MapToError::<page::Size2MiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Err(move _28);
        goto -> bb25;
    }

    bb19: {
        _30 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _31) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _32 = PhysFrame::<page::Size2MiB>::start_address(_3) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _33 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _29 = PageTableEntry::set_addr(_30, move _32, move _33) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _34 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Ok(move _34);
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_4kib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _17: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _18: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: isize;
    let mut _24: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _25: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _26: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: isize;
    let mut _32: bool;
    let _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: &structures::paging::page_table::PageTable;
    let mut _35: structures::paging::page_table::PageTableIndex;
    let mut _36: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let _37: ();
    let mut _38: &mut structures::paging::page_table::PageTableEntry;
    let mut _39: structures::paging::page_table::PageTableIndex;
    let mut _40: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _41: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
            let _22: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
            let _23: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _23;
                let _30: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
                let _31: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _31;
                }
                scope 13 {
                    debug residual => _30;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _31;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _22;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _23;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _41 = deref_copy (*_7);
        _12 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_41, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb29, unwind unreachable];
    }

    bb8: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = PageTableWalker::<P>::create_next_table::<A>(move _18, _19, _5, _6) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _17) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = discriminant(_16);
        switchInt(move _21) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _23 = move ((_16 as Continue).0: &mut structures::paging::page_table::PageTable);
        _26 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _28 = Page::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _22 = move ((_16 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _22) -> [return: bb29, unwind unreachable];
    }

    bb14: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _28) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _25 = PageTableWalker::<P>::create_next_table::<A>(move _26, _27, _5, _6) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _24 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _25) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _29 = discriminant(_24);
        switchInt(move _29) -> [0: bb18, 1: bb19, otherwise: bb6];
    }

    bb18: {
        _31 = move ((_24 as Continue).0: &mut structures::paging::page_table::PageTable);
        _34 = &(*_31);
        _35 = Page::p1_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _30 = move ((_24 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _30) -> [return: bb29, unwind unreachable];
    }

    bb20: {
        _33 = <PageTable as Index<PageTableIndex>>::index(move _34, move _35) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _32 = PageTableEntry::is_unused(_33) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        switchInt(move _32) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _39 = Page::p1_index(_2) -> [return: bb25, unwind unreachable];
    }

    bb24: {
        _36 = mapper::MapToError::<page::Size4KiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Err(move _36);
        goto -> bb29;
    }

    bb25: {
        _38 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_31, move _39) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _37 = PageTableEntry::set_frame(_38, _3, _4) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _40 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Ok(move _40);
        goto -> bb29;
    }

    bb29: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_1gib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: bool;
    let mut _18: &structures::paging::page_table::PageTableFlags;
    let mut _19: structures::paging::mapper::UnmapError;
    let mut _20: bool;
    let mut _21: &structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::UnmapError;
    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>>;
    let mut _24: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::UnmapError>;
    let mut _25: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _26: addr::PhysAddr;
    let mut _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41};
    let mut _29: &&mut structures::paging::page_table::PageTableEntry;
    let mut _30: isize;
    let _33: ();
    let mut _34: &mut structures::paging::page_table::PageTableEntry;
    let mut _35: (structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>);
    let mut _36: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _12: &mut structures::paging::page_table::PageTableEntry;
            scope 7 {
                debug p3_entry => _12;
                let _15: structures::paging::page_table::PageTableFlags;
                scope 8 {
                    debug flags => _15;
                    let _31: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _32: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                    scope 9 {
                        debug frame => _32;
                    }
                    scope 10 {
                        debug residual => _31;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _32;
                        scope 13 {
                        }
                    }
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _37 = deref_copy (*_3);
        _8 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb25, unwind unreachable];
    }

    bb8: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _12 = _13;
        _16 = &(*_12);
        _15 = PageTableEntry::flags(move _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = &_15;
        _17 = PageTableFlags::contains(move _18, const _) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _17) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _21 = &_15;
        _20 = PageTableFlags::contains(move _21, const _) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _19);
        goto -> bb25;
    }

    bb14: {
        switchInt(move _20) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _27 = &(*_12);
        _26 = PageTableEntry::addr(move _27) -> [return: bb17, unwind unreachable];
    }

    bb16: {
        _22 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _22);
        goto -> bb25;
    }

    bb17: {
        _25 = PhysFrame::<page::Size1GiB>::from_start_address(move _26) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _29 = &_12;
        _28 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41} { p3_entry: move _29 };
        _24 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41}>(move _25, move _28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _23 = <Result<PhysFrame<page::Size1GiB>, mapper::UnmapError> as Try>::branch(move _24) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _30 = discriminant(_23);
        switchInt(move _30) -> [0: bb21, 1: bb22, otherwise: bb6];
    }

    bb21: {
        _32 = ((_23 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _34 = _12;
        _33 = PageTableEntry::set_unused(move _34) -> [return: bb23, unwind unreachable];
    }

    bb22: {
        _31 = move ((_23 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _31) -> [return: bb25, unwind unreachable];
    }

    bb23: {
        _36 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = (_32, move _36);
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Ok(move _35);
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p3_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _23 = deref_copy (*_4);
        _9 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &(*_12);
        _16 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb18, unwind unreachable];
    }

    bb8: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _13) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb18;
    }

    bb12: {
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _18 = PageTableEntry::set_flags(_19, move _21) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _22 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Ok(move _22);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableEntry;
    let mut _18: structures::paging::mapper::TranslateError;
    let mut _19: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _20: addr::PhysAddr;
    let mut _21: &structures::paging::page_table::PageTableEntry;
    let mut _22: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41};
    let mut _23: &&structures::paging::page_table::PageTableEntry;
    let mut _24: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _13: &structures::paging::page_table::PageTableEntry;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _24 = deref_copy (*_3);
        _8 = &(*_24);
        _9 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb15, unwind unreachable];
    }

    bb8: {
        _14 = <PageTable as Index<PageTableIndex>>::index(_12, move _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = _14;
        _17 = _13;
        _16 = PageTableEntry::is_unused(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _18 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _18);
        goto -> bb15;
    }

    bb12: {
        _21 = _13;
        _20 = PageTableEntry::addr(move _21) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = PhysFrame::<page::Size1GiB>::from_start_address(move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _23 = &_13;
        _22 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41} { p3_entry: move _23 };
        _0 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41}>(move _19, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p3_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_2mib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _13: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _15: &mut structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: bool;
    let mut _26: &structures::paging::page_table::PageTableFlags;
    let mut _27: structures::paging::mapper::UnmapError;
    let mut _28: bool;
    let mut _29: &structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::UnmapError;
    let mut _31: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::UnmapError>;
    let mut _33: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _34: addr::PhysAddr;
    let mut _35: &structures::paging::page_table::PageTableEntry;
    let mut _36: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41};
    let mut _37: &&mut structures::paging::page_table::PageTableEntry;
    let mut _38: isize;
    let _41: ();
    let mut _42: &mut structures::paging::page_table::PageTableEntry;
    let mut _43: (structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>);
    let mut _44: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _45: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _18: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _19: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _19;
                let _20: &mut structures::paging::page_table::PageTableEntry;
                scope 12 {
                    debug p2_entry => _20;
                    let _23: structures::paging::page_table::PageTableFlags;
                    scope 13 {
                        debug flags => _23;
                        let _39: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _40: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                        scope 14 {
                            debug frame => _40;
                        }
                        scope 15 {
                            debug residual => _39;
                            scope 16 {
                            }
                        }
                        scope 17 {
                            debug val => _40;
                            scope 18 {
                            }
                        }
                    }
                }
            }
            scope 8 {
                debug residual => _18;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _19;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _45 = deref_copy (*_3);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_45, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb31, unwind unreachable];
    }

    bb8: {
        _15 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = PageTableWalker::<P>::next_table_mut(move _14, _15) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _12 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _13) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _17 = discriminant(_12);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _19 = move ((_12 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _18 = move ((_12 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _18) -> [return: bb31, unwind unreachable];
    }

    bb14: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_19, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _20 = _21;
        _24 = &(*_20);
        _23 = PageTableEntry::flags(move _24) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = &_23;
        _25 = PageTableFlags::contains(move _26, const _) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _25) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _29 = &_23;
        _28 = PageTableFlags::contains(move _29, const _) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _27 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _27);
        goto -> bb31;
    }

    bb20: {
        switchInt(move _28) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _35 = &(*_20);
        _34 = PageTableEntry::addr(move _35) -> [return: bb23, unwind unreachable];
    }

    bb22: {
        _30 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _30);
        goto -> bb31;
    }

    bb23: {
        _33 = PhysFrame::<page::Size2MiB>::from_start_address(move _34) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _37 = &_20;
        _36 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41} { p2_entry: move _37 };
        _32 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41}>(move _33, move _36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _31 = <Result<PhysFrame<page::Size2MiB>, mapper::UnmapError> as Try>::branch(move _32) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _38 = discriminant(_31);
        switchInt(move _38) -> [0: bb27, 1: bb28, otherwise: bb6];
    }

    bb27: {
        _40 = ((_31 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _42 = _20;
        _41 = PageTableEntry::set_unused(move _42) -> [return: bb29, unwind unreachable];
    }

    bb28: {
        _39 = move ((_31 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _39) -> [return: bb31, unwind unreachable];
    }

    bb29: {
        _44 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _43 = (_40, move _44);
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Ok(move _43);
        goto -> bb31;
    }

    bb31: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p2_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _31: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _31 = deref_copy (*_4);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_31, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb24, unwind unreachable];
    }

    bb8: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _23 = &(*_20);
        _24 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb24, unwind unreachable];
    }

    bb14: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _21) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb24;
    }

    bb18: {
        _28 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _29 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _26 = PageTableEntry::set_flags(_27, move _29) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _30 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Ok(move _30);
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = deref_copy (*_4);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb15, unwind unreachable];
    }

    bb8: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb15;
    }

    bb12: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _24: bool;
    let mut _25: &structures::paging::page_table::PageTableEntry;
    let mut _26: structures::paging::mapper::TranslateError;
    let mut _27: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _28: addr::PhysAddr;
    let mut _29: &structures::paging::page_table::PageTableEntry;
    let mut _30: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41};
    let mut _31: &&structures::paging::page_table::PageTableEntry;
    let mut _32: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _21: &structures::paging::page_table::PageTableEntry;
                scope 12 {
                    debug p2_entry => _21;
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _32 = deref_copy (*_3);
        _8 = &(*_32);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb21, unwind unreachable];
    }

    bb8: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_12, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = PageTableWalker::<P>::next_table(move _15, _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _20 = ((_13 as Continue).0: &structures::paging::page_table::PageTable);
        _23 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb21, unwind unreachable];
    }

    bb14: {
        _22 = <PageTable as Index<PageTableIndex>>::index(_20, move _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = _22;
        _25 = _21;
        _24 = PageTableEntry::is_unused(move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _26 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _26);
        goto -> bb21;
    }

    bb18: {
        _29 = _21;
        _28 = PageTableEntry::addr(move _29) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _27 = PhysFrame::<page::Size2MiB>::from_start_address(move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _31 = &_21;
        _30 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41} { p2_entry: move _31 };
        _0 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41}>(move _27, move _30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p2_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_4kib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _13: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _15: &mut structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _21: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _22: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _23: &mut structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: isize;
    let mut _28: &mut structures::paging::page_table::PageTableEntry;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _31: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: isize;
    let _37: ();
    let mut _38: (structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>);
    let mut _39: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _40: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _18: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _19: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _19;
                let _26: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _27: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _27;
                    scope 17 {
                        debug p1_entry => _28;
                        let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _36: structures::paging::frame::PhysFrame;
                        scope 18 {
                            debug frame => _36;
                        }
                        scope 19 {
                            debug residual => _35;
                            scope 20 {
                            }
                        }
                        scope 21 {
                            debug val => _36;
                            scope 22 {
                            }
                        }
                    }
                }
                scope 13 {
                    debug residual => _26;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _27;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _18;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _19;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _40 = deref_copy (*_3);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_40, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb29, unwind unreachable];
    }

    bb8: {
        _15 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = PageTableWalker::<P>::next_table_mut(move _14, _15) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _12 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _13) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _17 = discriminant(_12);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _19 = move ((_12 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _24 = Page::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _18 = move ((_12 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _18) -> [return: bb29, unwind unreachable];
    }

    bb14: {
        _23 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_19, move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = PageTableWalker::<P>::next_table_mut(move _22, _23) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _20 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _21) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _25 = discriminant(_20);
        switchInt(move _25) -> [0: bb18, 1: bb19, otherwise: bb6];
    }

    bb18: {
        _27 = move ((_20 as Continue).0: &mut structures::paging::page_table::PageTable);
        _29 = Page::p1_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _26 = move ((_20 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _26) -> [return: bb29, unwind unreachable];
    }

    bb20: {
        _28 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_27, move _29) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _33 = &(*_28);
        _32 = PageTableEntry::frame(move _33) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _31 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}>(move _32, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _30 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _31) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _34 = discriminant(_30);
        switchInt(move _34) -> [0: bb25, 1: bb26, otherwise: bb6];
    }

    bb25: {
        _36 = ((_30 as Continue).0: structures::paging::frame::PhysFrame);
        _37 = PageTableEntry::set_unused(_28) -> [return: bb27, unwind unreachable];
    }

    bb26: {
        _35 = move ((_30 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb29, unwind unreachable];
    }

    bb27: {
        _39 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _38 = (_36, move _39);
        _0 = Result::<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError>::Ok(move _38);
        goto -> bb29;
    }

    bb29: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _22: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _23: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _24: &mut structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let mut _26: isize;
    let mut _29: bool;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: &structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let mut _33: structures::paging::mapper::FlagUpdateError;
    let _34: ();
    let mut _35: &mut structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _37: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _38: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _27: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _28: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _28;
                }
                scope 13 {
                    debug residual => _27;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _28;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _38 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_38, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb29, unwind unreachable];
    }

    bb8: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _23 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _25 = Page::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb29, unwind unreachable];
    }

    bb14: {
        _24 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _25) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _22 = PageTableWalker::<P>::next_table_mut(move _23, _24) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _21 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _22) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb18, 1: bb19, otherwise: bb6];
    }

    bb18: {
        _28 = move ((_21 as Continue).0: &mut structures::paging::page_table::PageTable);
        _31 = &(*_28);
        _32 = Page::p1_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _27 = move ((_21 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _27) -> [return: bb29, unwind unreachable];
    }

    bb20: {
        _30 = <PageTable as Index<PageTableIndex>>::index(move _31, move _32) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _29 = PageTableEntry::is_unused(_30) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        switchInt(move _29) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _33 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _33);
        goto -> bb29;
    }

    bb24: {
        _36 = Page::p1_index(_2) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _35 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _36) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _34 = PageTableEntry::set_flags(_35, _3) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _37 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Ok(move _37);
        goto -> bb29;
    }

    bb29: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb15, unwind unreachable];
    }

    bb8: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb15;
    }

    bb12: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: bool;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: structures::paging::mapper::MapperFlushAll;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                scope 12 {
                    debug p2_entry => _21;
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _28 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb21, unwind unreachable];
    }

    bb8: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = Page::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb21, unwind unreachable];
    }

    bb14: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _24 = &(*_21);
        _23 = PageTableEntry::is_unused(move _24) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _23) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb21;
    }

    bb18: {
        _26 = PageTableEntry::set_flags(_21, _3) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _27 = mapper::MapperFlushAll::new() -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb21;
    }

    bb21: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _22: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _23: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let mut _26: isize;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: bool;
    let mut _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: structures::paging::mapper::TranslateError;
    let mut _35: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _36: addr::PhysAddr;
    let mut _37: &structures::paging::page_table::PageTableEntry;
    let mut _38: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41};
    let mut _39: &&structures::paging::page_table::PageTableEntry;
    let mut _40: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _27: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _28: &structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _28;
                    let _29: &structures::paging::page_table::PageTableEntry;
                    scope 17 {
                        debug p1_entry => _29;
                    }
                }
                scope 13 {
                    debug residual => _27;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _28;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _40 = deref_copy (*_3);
        _8 = &(*_40);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb27, unwind unreachable];
    }

    bb8: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_12, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = PageTableWalker::<P>::next_table(move _15, _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _20 = ((_13 as Continue).0: &structures::paging::page_table::PageTable);
        _23 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _25 = Page::p2_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb27, unwind unreachable];
    }

    bb14: {
        _24 = <PageTable as Index<PageTableIndex>>::index(_20, move _25) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _22 = PageTableWalker::<P>::next_table(move _23, _24) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _21 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _22) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb18, 1: bb19, otherwise: bb6];
    }

    bb18: {
        _28 = ((_21 as Continue).0: &structures::paging::page_table::PageTable);
        _31 = Page::p1_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _27 = move ((_21 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _27) -> [return: bb27, unwind unreachable];
    }

    bb20: {
        _30 = <PageTable as Index<PageTableIndex>>::index(_28, move _31) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _29 = _30;
        _33 = _29;
        _32 = PageTableEntry::is_unused(move _33) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        switchInt(move _32) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _34 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _34);
        goto -> bb27;
    }

    bb24: {
        _37 = _29;
        _36 = PageTableEntry::addr(move _37) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _35 = PhysFrame::from_start_address(move _36) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _39 = &_29;
        _38 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41} { p1_entry: move _39 };
        _0 = Result::<PhysFrame, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41}>(move _35, move _38) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p1_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:530:1: 530:72>::translate(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _5: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _10: isize;
    let mut _12: !;
    let mut _13: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _15: &structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _18: isize;
    let _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: structures::paging::page_table::PageTableIndex;
    let mut _23: addr::PhysAddr;
    let mut _25: u64;
    let mut _27: structures::paging::mapper::MappedFrame;
    let mut _28: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _29: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: isize;
    let mut _33: isize;
    let _35: &structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _38: addr::PhysAddr;
    let mut _40: u64;
    let mut _42: structures::paging::mapper::MappedFrame;
    let _43: &structures::paging::page_table::PageTableEntry;
    let mut _44: structures::paging::page_table::PageTableIndex;
    let mut _45: bool;
    let mut _46: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _47: addr::PhysAddr;
    let mut _48: isize;
    let mut _50: addr::PhysAddr;
    let mut _52: structures::paging::page_table::PageOffset;
    let mut _54: structures::paging::mapper::MappedFrame;
    let mut _55: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _19: &structures::paging::page_table::PageTable;
            scope 4 {
                debug p2 => _19;
                let _34: &structures::paging::page_table::PageTable;
                scope 10 {
                    debug p1 => _34;
                    scope 16 {
                        debug p1_entry => _43;
                        let _49: structures::paging::frame::PhysFrame;
                        scope 17 {
                            debug frame => _49;
                            let _51: u64;
                            scope 19 {
                                debug offset => _51;
                                let _53: structures::paging::page_table::PageTableFlags;
                                scope 20 {
                                    debug flags => _53;
                                }
                            }
                        }
                        scope 18 {
                            debug frame => _49;
                        }
                    }
                }
                scope 11 {
                    debug page_table => _34;
                }
                scope 12 {
                    debug entry => _35;
                    let _37: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                    scope 13 {
                        debug frame => _37;
                        let _39: u64;
                        scope 14 {
                            debug offset => _39;
                            let _41: structures::paging::page_table::PageTableFlags;
                            scope 15 {
                                debug flags => _41;
                            }
                        }
                    }
                }
            }
            scope 5 {
                debug page_table => _19;
            }
            scope 6 {
                debug entry => _20;
                let _22: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                scope 7 {
                    debug frame => _22;
                    let _24: u64;
                    scope 8 {
                        debug offset => _24;
                        let _26: structures::paging::page_table::PageTableFlags;
                        scope 9 {
                            debug flags => _26;
                        }
                    }
                }
            }
        }
        scope 3 {
            debug page_table => _11;
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _5 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _55 = deref_copy (*_3);
        _7 = &(*_55);
        _8 = addr::VirtAddr::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableWalker::<P>::next_table(move _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb7, 1: bb4, otherwise: bb6];
    }

    bb4: {
        _9 = discriminant(((_4 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _9) -> [0: bb8, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = panic(const "level 4 entry has huge page bit set") -> unwind unreachable;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = ((_4 as Ok).0: &structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = addr::VirtAddr::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb8: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb48;
    }

    bb9: {
        _15 = <PageTable as Index<PageTableIndex>>::index(_11, move _16) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = PageTableWalker::<P>::next_table(move _14, _15) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb14, 1: bb12, otherwise: bb6];
    }

    bb12: {
        _17 = discriminant(((_13 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _17) -> [0: bb15, 1: bb13, otherwise: bb6];
    }

    bb13: {
        _21 = addr::VirtAddr::p3_index(_2) -> [return: bb16, unwind unreachable];
    }

    bb14: {
        _19 = ((_13 as Ok).0: &structures::paging::page_table::PageTable);
        _29 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _31 = addr::VirtAddr::p2_index(_2) -> [return: bb22, unwind unreachable];
    }

    bb15: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb48;
    }

    bb16: {
        _20 = <PageTable as Index<PageTableIndex>>::index(_11, move _21) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _23 = PageTableEntry::addr(_20) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _22 = PhysFrame::<page::Size1GiB>::containing_address(move _23) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = addr::VirtAddr::as_u64(_2) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _24 = BitAnd(move _25, const 1073741823_u64);
        _26 = PageTableEntry::flags(_20) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _27 = mapper::MappedFrame::Size1GiB(_22);
        _0 = mapper::TranslateResult::Mapped { frame: move _27, offset: _24, flags: _26 };
        goto -> bb48;
    }

    bb22: {
        _30 = <PageTable as Index<PageTableIndex>>::index(_19, move _31) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _28 = PageTableWalker::<P>::next_table(move _29, _30) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _33 = discriminant(_28);
        switchInt(move _33) -> [0: bb27, 1: bb25, otherwise: bb6];
    }

    bb25: {
        _32 = discriminant(((_28 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _32) -> [0: bb28, 1: bb26, otherwise: bb6];
    }

    bb26: {
        _36 = addr::VirtAddr::p2_index(_2) -> [return: bb29, unwind unreachable];
    }

    bb27: {
        _34 = ((_28 as Ok).0: &structures::paging::page_table::PageTable);
        _44 = addr::VirtAddr::p1_index(_2) -> [return: bb35, unwind unreachable];
    }

    bb28: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb48;
    }

    bb29: {
        _35 = <PageTable as Index<PageTableIndex>>::index(_19, move _36) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _38 = PageTableEntry::addr(_35) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _37 = PhysFrame::<page::Size2MiB>::containing_address(move _38) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _40 = addr::VirtAddr::as_u64(_2) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _39 = BitAnd(move _40, const 2097151_u64);
        _41 = PageTableEntry::flags(_35) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _42 = mapper::MappedFrame::Size2MiB(_37);
        _0 = mapper::TranslateResult::Mapped { frame: move _42, offset: _39, flags: _41 };
        goto -> bb48;
    }

    bb35: {
        _43 = <PageTable as Index<PageTableIndex>>::index(_34, move _44) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _45 = PageTableEntry::is_unused(_43) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _45) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb48;
    }

    bb39: {
        _47 = PageTableEntry::addr(_43) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _46 = PhysFrame::from_start_address(move _47) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _48 = discriminant(_46);
        switchInt(move _48) -> [0: bb43, 1: bb42, otherwise: bb6];
    }

    bb42: {
        _50 = PageTableEntry::addr(_43) -> [return: bb44, unwind unreachable];
    }

    bb43: {
        _49 = ((_46 as Ok).0: structures::paging::frame::PhysFrame);
        _52 = addr::VirtAddr::page_offset(_2) -> [return: bb45, unwind unreachable];
    }

    bb44: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _50);
        goto -> bb48;
    }

    bb45: {
        _51 = <u64 as From<PageOffset>>::from(move _52) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _53 = PageTableEntry::flags(_43) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _54 = mapper::MappedFrame::Size4KiB(_49);
        _0 = mapper::TranslateResult::Mapped { frame: move _54, offset: _51, flags: _53 };
        goto -> bb48;
    }

    bb48: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::PageRangeInclusive;
    let mut _4: structures::paging::page::Page;
    let mut _5: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page;
    let mut _8: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _9: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _6 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Page::from_start_address(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Page, AddressNotAligned>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = addr::VirtAddr::new(const 18446744073709547520_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Page::from_start_address(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Result::<Page, AddressNotAligned>::unwrap(move _8) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _3 = PageRangeInclusive { start: move _4, end: move _7 };
        _0 = <mapped_page_table::MappedPageTable<'_, P> as mapper::CleanUp>::clean_up_addr_range::<D>(_1, move _3, _2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up_addr_range(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let _4: bool;
    let _5: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _6: structures::paging::page_table::PageTableLevel;
    let mut _7: &mut structures::paging::page_table::PageTable;
    scope 1 {
    }

    bb0: {
        _7 = deref_copy ((*_1).1: &mut structures::paging::page_table::PageTable);
        _5 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _6 = PageTableLevel::Four;
        _4 = <mapped_page_table::MappedPageTable<'a, P> as mapper::CleanUp>::clean_up_addr_range::clean_up::<P, D>(_7, _5, move _6, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up_addr_range::clean_up(_1: &mut PageTable, _2: &PageTableWalker<P>, _3: PageTableLevel, _4: PageRangeInclusive, _5: &mut impl FrameDeallocator<Size4KiB>) -> bool {
    debug page_table => _1;
    debug page_table_walker => _2;
    debug level => _3;
    debug range => _4;
    debug frame_deallocator => _5;
    let mut _0: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page::PageRangeInclusive;
    let _8: addr::VirtAddr;
    let mut _9: addr::VirtAddr;
    let mut _10: structures::paging::page::Page;
    let mut _11: u64;
    let mut _13: structures::paging::page::Page;
    let mut _15: structures::paging::page::Page;
    let mut _16: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _17: isize;
    let mut _20: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>;
    let mut _21: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>;
    let mut _22: core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>;
    let mut _23: core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>;
    let mut _24: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _25: usize;
    let mut _26: usize;
    let mut _27: (usize, bool);
    let mut _28: usize;
    let mut _30: core::option::Option<(usize, &mut structures::paging::page_table::PageTableEntry)>;
    let mut _31: &mut core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>;
    let mut _32: isize;
    let mut _35: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _36: isize;
    let mut _39: u64;
    let mut _40: u64;
    let mut _41: (u64, bool);
    let mut _43: u64;
    let mut _44: (u64, bool);
    let mut _47: structures::paging::page::Page;
    let mut _50: structures::paging::page::Page;
    let mut _51: bool;
    let mut _52: structures::paging::page::PageRangeInclusive;
    let mut _54: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _55: &structures::paging::page_table::PageTableEntry;
    let _56: ();
    let _57: ();
    let mut _58: &mut core::slice::Iter<'_, structures::paging::page_table::PageTableEntry>;
    let mut _59: core::slice::Iter<'_, structures::paging::page_table::PageTableEntry>;
    let mut _60: &structures::paging::page_table::PageTable;
    scope 1 {
        debug table_addr => _8;
        let _12: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug start => _12;
            let _14: structures::paging::page_table::PageTableIndex;
            scope 3 {
                debug end => _14;
                scope 4 {
                    debug next_level => _18;
                    let _18: structures::paging::page_table::PageTableLevel;
                    let _19: u64;
                    scope 5 {
                        debug offset_per_entry => _19;
                        let mut _29: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>;
                        scope 6 {
                            debug iter => _29;
                            let _33: usize;
                            let _34: &mut structures::paging::page_table::PageTableEntry;
                            scope 7 {
                                debug i => _33;
                                debug entry => _34;
                                scope 8 {
                                    debug page_table => _37;
                                    let _37: &mut structures::paging::page_table::PageTable;
                                    let _38: addr::VirtAddr;
                                    scope 9 {
                                        debug start => _38;
                                        let _42: addr::VirtAddr;
                                        scope 10 {
                                            debug end => _42;
                                            let _45: structures::paging::page::Page;
                                            scope 11 {
                                                debug start => _45;
                                                let _46: structures::paging::page::Page;
                                                scope 12 {
                                                    debug start => _46;
                                                    let _48: structures::paging::page::Page;
                                                    scope 13 {
                                                        debug end => _48;
                                                        let _49: structures::paging::page::Page;
                                                        scope 14 {
                                                            debug end => _49;
                                                            scope 15 {
                                                                let _53: structures::paging::frame::PhysFrame;
                                                                scope 16 {
                                                                    debug frame => _53;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_4;
        _6 = PageRangeInclusive::is_empty(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb42;
    }

    bb3: {
        _10 = (_4.0: structures::paging::page::Page);
        _9 = Page::start_address(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = PageTableLevel::table_address_space_alignment(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = addr::VirtAddr::align_down::<u64>(move _9, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _13 = (_4.0: structures::paging::page::Page);
        _12 = Page::page_table_index(move _13, _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = (_4.1: structures::paging::page::Page);
        _14 = Page::page_table_index(move _15, _3) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = PageTableLevel::next_lower_level(_3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = discriminant(_16);
        switchInt(move _17) -> [1: bb10, otherwise: bb40];
    }

    bb10: {
        _18 = ((_16 as Some).0: structures::paging::page_table::PageTableLevel);
        _19 = PageTableLevel::entry_address_space_alignment(_3) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _24 = PageTable::iter_mut(_1) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = <core::slice::IterMut<'_, PageTableEntry> as Iterator>::enumerate(move _24) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _26 = <usize as From<PageTableIndex>>::from(_14) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _27 = CheckedAdd(_26, const 1_usize);
        assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", move _26, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _25 = move (_27.0: usize);
        _22 = <Enumerate<core::slice::IterMut<'_, PageTableEntry>> as Iterator>::take(move _23, move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _28 = <usize as From<PageTableIndex>>::from(_12) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _21 = <Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>> as Iterator>::skip(move _22, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _20 = <Skip<Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>>> as IntoIterator>::into_iter(move _21) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = move _20;
        goto -> bb20;
    }

    bb20: {
        _31 = &mut _29;
        _30 = <Skip<Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>>> as Iterator>::next(_31) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb40, 1: bb22, otherwise: bb23];
    }

    bb22: {
        _33 = (((_30 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).0: usize);
        _34 = move (((_30 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).1: &mut structures::paging::page_table::PageTableEntry);
        _35 = PageTableWalker::<P>::next_table_mut(_2, _34) -> [return: bb24, unwind unreachable];
    }

    bb23: {
        unreachable;
    }

    bb24: {
        _36 = discriminant(_35);
        switchInt(move _36) -> [0: bb25, otherwise: bb20];
    }

    bb25: {
        _37 = move ((_35 as Ok).0: &mut structures::paging::page_table::PageTable);
        _40 = _33 as u64 (IntToInt);
        _41 = CheckedMul(_19, _40);
        assert(!move (_41.1: bool), "attempt to compute `{} * {}`, which would overflow", _19, move _40) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _39 = move (_41.0: u64);
        _38 = <addr::VirtAddr as Add<u64>>::add(_8, move _39) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _44 = CheckedSub(_19, const 1_u64);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", _19, const 1_u64) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _43 = move (_44.0: u64);
        _42 = <addr::VirtAddr as Add<u64>>::add(_38, move _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _45 = Page::containing_address(_38) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _47 = (_4.0: structures::paging::page::Page);
        _46 = <Page as Ord>::max(_45, move _47) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _48 = Page::containing_address(_42) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _50 = (_4.1: structures::paging::page::Page);
        _49 = <Page as Ord>::min(_48, move _50) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _52 = Page::range_inclusive(_46, _49) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _51 = <mapped_page_table::MappedPageTable<'a, P> as mapper::CleanUp>::clean_up_addr_range::clean_up::<P, impl FrameDeallocator<Size4KiB>>(_37, _2, _18, move _52, _5) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _51) -> [0: bb20, otherwise: bb36];
    }

    bb36: {
        _55 = &(*_34);
        _54 = PageTableEntry::frame(move _55) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _53 = Result::<PhysFrame, FrameError>::unwrap(move _54) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _56 = PageTableEntry::set_unused(_34) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _57 = <impl FrameDeallocator<Size4KiB> as FrameDeallocator<page::Size4KiB>>::deallocate_frame(_5, _53) -> [return: bb20, unwind unreachable];
    }

    bb40: {
        _60 = &(*_1);
        _59 = PageTable::iter(move _60) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _58 = &mut _59;
        _0 = <core::slice::Iter<'_, PageTableEntry> as Iterator>::all::<for<'a> fn(&'a PageTableEntry) -> bool {PageTableEntry::is_unused}>(move _58, PageTableEntry::is_unused) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:682:10: 682:15>::fmt(_1: &PageTableWalker<P>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&P;
    let _7: &P;

    bb0: {
        _3 = const "PageTableWalker";
        _4 = const "page_table_frame_mapping";
        _7 = &((*_1).0: P);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::new(_1: P) -> PageTableWalker<P> {
    debug page_table_frame_mapping => _1;
    let mut _0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>;

    bb0: {
        _0 = PageTableWalker::<P> { page_table_frame_mapping: move _1 };
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::next_table(_1: &PageTableWalker<P>, _2: &PageTableEntry) -> Result<&PageTable, PageTableWalkError> {
    debug self => _1;
    debug entry => _2;
    let mut _0: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let _3: *mut structures::paging::page_table::PageTable;
    let mut _4: &P;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>, structures::paging::frame::PhysFrame>;
    let mut _6: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _7: isize;
    let _8: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>;
    let _9: structures::paging::frame::PhysFrame;
    let _10: &structures::paging::page_table::PageTable;
    scope 1 {
        debug page_table_ptr => _3;
        scope 6 {
            debug page_table => _10;
        }
        scope 7 {
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _4 = &((*_1).0: P);
        _6 = PageTableEntry::frame(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Result<PhysFrame, FrameError> as Try>::branch(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_5 as Continue).0: structures::paging::frame::PhysFrame);
        _3 = <P as mapped_page_table::PageTableFrameMapping>::frame_to_pointer(move _4, _9) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>);
        _0 = <Result<&PageTable, PageTableWalkError> as FromResidual<Result<Infallible, FrameError>>>::from_residual(_8) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _10 = &(*_3);
        _0 = Result::<&PageTable, PageTableWalkError>::Ok(_10);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::next_table_mut(_1: &PageTableWalker<P>, _2: &mut PageTableEntry) -> Result<&mut PageTable, PageTableWalkError> {
    debug self => _1;
    debug entry => _2;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let _3: *mut structures::paging::page_table::PageTable;
    let mut _4: &P;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>, structures::paging::frame::PhysFrame>;
    let mut _6: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: isize;
    let _9: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>;
    let _10: structures::paging::frame::PhysFrame;
    let mut _11: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug page_table_ptr => _3;
        scope 6 {
            debug page_table => _11;
        }
        scope 7 {
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _4 = &((*_1).0: P);
        _7 = &(*_2);
        _6 = PageTableEntry::frame(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Result<PhysFrame, FrameError> as Try>::branch(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = discriminant(_5);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _10 = ((_5 as Continue).0: structures::paging::frame::PhysFrame);
        _3 = <P as mapped_page_table::PageTableFrameMapping>::frame_to_pointer(move _4, _10) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>);
        _0 = <Result<&mut PageTable, PageTableWalkError> as FromResidual<Result<Infallible, FrameError>>>::from_residual(_9) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = &mut (*_3);
        _0 = Result::<&mut PageTable, PageTableWalkError>::Ok(_11);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::create_next_table(_1: &PageTableWalker<P>, _2: &mut PageTableEntry, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, PageTableCreateError> {
    debug self => _1;
    debug entry => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let _5: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: core::option::Option<structures::paging::frame::PhysFrame>;
    let mut _9: isize;
    let _11: ();
    let mut _12: structures::paging::page_table::PageTableFlags;
    let mut _13: structures::paging::mapper::mapped_page_table::PageTableCreateError;
    let mut _14: bool;
    let mut _15: &structures::paging::page_table::PageTableFlags;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableFlags;
    let _18: structures::paging::page_table::PageTableFlags;
    let mut _19: &structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableFlags;
    let _21: ();
    let mut _22: structures::paging::page_table::PageTableFlags;
    let mut _23: structures::paging::page_table::PageTableFlags;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _27: isize;
    let mut _28: isize;
    let mut _29: structures::paging::mapper::mapped_page_table::PageTableCreateError;
    let mut _30: !;
    let mut _32: bool;
    let _33: ();
    scope 1 {
        debug created => _5;
        let _31: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug frame => _10;
            let _10: structures::paging::frame::PhysFrame;
        }
        scope 3 {
            debug page_table => _31;
        }
        scope 4 {
            debug page_table => _31;
        }
    }

    bb0: {
        _7 = &(*_2);
        _6 = PageTableEntry::is_unused(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _8 = <A as frame_alloc::FrameAllocator<page::Size4KiB>>::allocate_frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb4, otherwise: bb6];
    }

    bb4: {
        _10 = ((_8 as Some).0: structures::paging::frame::PhysFrame);
        _12 = _3;
        _11 = PageTableEntry::set_frame(_2, _10, move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _5 = const true;
        goto -> bb16;
    }

    bb6: {
        _13 = PageTableCreateError::FrameAllocationFailed;
        _0 = Result::<&mut PageTable, PageTableCreateError>::Err(move _13);
        goto -> bb25;
    }

    bb7: {
        _15 = &_3;
        _14 = PageTableFlags::is_empty(move _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _14) -> [0: bb9, otherwise: bb15];
    }

    bb9: {
        _19 = &(*_2);
        _18 = PageTableEntry::flags(move _19) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = &_18;
        _20 = _3;
        _16 = PageTableFlags::contains(move _17, move _20) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _16) -> [0: bb12, otherwise: bb15];
    }

    bb12: {
        _24 = &(*_2);
        _23 = PageTableEntry::flags(move _24) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = _3;
        _22 = <PageTableFlags as BitOr>::bitor(move _23, move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::set_flags(_2, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _5 = const false;
        goto -> bb16;
    }

    bb16: {
        _26 = PageTableWalker::<P>::next_table_mut(_1, _2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb18, 1: bb19, otherwise: bb20];
    }

    bb18: {
        _31 = move ((_26 as Ok).0: &mut structures::paging::page_table::PageTable);
        _32 = _5;
        switchInt(move _32) -> [0: bb24, otherwise: bb23];
    }

    bb19: {
        _27 = discriminant(((_26 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _27) -> [0: bb22, 1: bb21, otherwise: bb20];
    }

    bb20: {
        unreachable;
    }

    bb21: {
        _29 = PageTableCreateError::MappedToHugePage;
        _0 = Result::<&mut PageTable, PageTableCreateError>::Err(move _29);
        goto -> bb25;
    }

    bb22: {
        _30 = panic(const "entry should be mapped at this point") -> unwind unreachable;
    }

    bb23: {
        _33 = PageTable::zero(_31) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _0 = Result::<&mut PageTable, PageTableCreateError>::Ok(_31);
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:780:10: 780:15>::fmt(_1: &PageTableWalkError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "MappedToHugePage";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "NotMapped";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:786:10: 786:15>::fmt(_1: &PageTableCreateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "FrameAllocationFailed";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "MappedToHugePage";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:792:1: 792:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size4KiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size4KiB>::FrameAllocationFailed;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::MapToError::<page::Size4KiB>::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:802:1: 802:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size2MiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size2MiB>::FrameAllocationFailed;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::MapToError::<page::Size2MiB>::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:812:1: 812:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size1GiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size1GiB>::FrameAllocationFailed;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::MapToError::<page::Size1GiB>::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:822:1: 822:45>::from(_1: FrameError) -> PageTableWalkError {
    debug err => _1;
    let mut _0: structures::paging::mapper::mapped_page_table::PageTableWalkError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = PageTableWalkError::NotMapped;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = PageTableWalkError::MappedToHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:832:1: 832:45>::from(_1: PageTableWalkError) -> mapper::UnmapError {
    debug err => _1;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:842:1: 842:50>::from(_1: PageTableWalkError) -> mapper::FlagUpdateError {
    debug err => _1;
    let mut _0: structures::paging::mapper::FlagUpdateError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::FlagUpdateError::PageNotMapped;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::FlagUpdateError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mapped_page_table.rs:852:1: 852:49>::from(_1: PageTableWalkError) -> mapper::TranslateError {
    debug err => _1;
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::TranslateError::PageNotMapped;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::TranslateError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:10:10: 10:15>::fmt(_1: &OffsetPageTable<'_>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    let _7: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = const "OffsetPageTable";
        _4 = const "inner";
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::new(_1: &mut PageTable, _2: addr::VirtAddr) -> OffsetPageTable<'_> {
    debug level_4_table => _1;
    debug phys_offset => _2;
    let mut _0: structures::paging::mapper::offset_page_table::OffsetPageTable<'_>;
    let _3: structures::paging::mapper::offset_page_table::PhysOffset;
    let mut _4: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
        debug phys_offset => _3;
        scope 2 {
        }
    }

    bb0: {
        _3 = PhysOffset { offset: _2 };
        _4 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::new(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = OffsetPageTable::<'_> { inner: move _4 };
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::level_4_table(_1: &mut OffsetPageTable<'_>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _2 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::level_4_table(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::phys_offset(_1: &OffsetPageTable<'_>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: &structures::paging::mapper::offset_page_table::PhysOffset;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _2 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::page_table_frame_mapping(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = ((*_2).0: addr::VirtAddr);
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:52:10: 52:15>::fmt(_1: &PhysOffset, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&addr::VirtAddr;
    let _7: &addr::VirtAddr;

    bb0: {
        _3 = const "PhysOffset";
        _4 = const "offset";
        _7 = &((*_1).0: addr::VirtAddr);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:57:1: 57:49>::frame_to_pointer(_1: &PhysOffset, _2: PhysFrame) -> *mut PageTable {
    debug self => _1;
    debug frame => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: addr::PhysAddr;
    scope 1 {
        debug virt => _3;
    }

    bb0: {
        _4 = ((*_1).0: addr::VirtAddr);
        _6 = PhysFrame::start_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:273:1: 273:43>::translate(_1: &OffsetPageTable<'_>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Translate>::translate(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:280:1: 280:41>::clean_up(_1: &mut OffsetPageTable<'_>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::CleanUp>::clean_up::<D>(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/offset_page_table.rs:280:1: 280:41>::clean_up_addr_range(_1: &mut OffsetPageTable<'_>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::CleanUp>::clean_up_addr_range::<D>(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:32:10: 32:15>::fmt(_1: &RecursivePageTable<'_>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&mut structures::paging::page_table::PageTable;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&structures::paging::page_table::PageTableIndex;
    let _10: &structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = const "RecursivePageTable";
        _4 = const "p4";
        _6 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "recursive_index";
        _10 = &((*_1).1: structures::paging::page_table::PageTableIndex);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::new(_1: &mut PageTable) -> Result<RecursivePageTable<'_>, InvalidPageTable> {
    debug table => _1;
    let mut _0: core::result::Result<structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>, structures::paging::mapper::recursive_page_table::InvalidPageTable>;
    let _2: structures::paging::page::Page;
    let mut _3: addr::VirtAddr;
    let mut _4: u64;
    let mut _5: *const structures::paging::page_table::PageTable;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableIndex;
    let _9: structures::paging::page_table::PageTableIndex;
    let mut _10: &structures::paging::page_table::PageTableIndex;
    let mut _11: bool;
    let mut _12: &structures::paging::page_table::PageTableIndex;
    let _13: structures::paging::page_table::PageTableIndex;
    let mut _14: &structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableIndex;
    let _17: structures::paging::page_table::PageTableIndex;
    let mut _18: &structures::paging::page_table::PageTableIndex;
    let mut _19: structures::paging::mapper::recursive_page_table::InvalidPageTable;
    let mut _20: bool;
    let mut _21: &core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _22: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _23: structures::paging::frame::PhysFrame;
    let mut _24: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    let mut _25: &core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _26: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: &structures::paging::page_table::PageTable;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: structures::paging::mapper::recursive_page_table::InvalidPageTable;
    let mut _31: structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>;
    let mut _32: structures::paging::page_table::PageTableIndex;
    scope 1 {
        debug page => _2;
        let _6: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug recursive_index => _6;
        }
    }

    bb0: {
        _5 = &raw const (*_1);
        _4 = _5 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Page::containing_address(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Page::p4_index(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Page::p3_index(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = &_9;
        _10 = &_6;
        _7 = <PageTableIndex as PartialEq>::ne(move _8, move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb6, otherwise: bb12];
    }

    bb6: {
        _13 = Page::p2_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = &_13;
        _14 = &_6;
        _11 = <PageTableIndex as PartialEq>::ne(move _12, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _11) -> [0: bb9, otherwise: bb12];
    }

    bb9: {
        _17 = Page::p1_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = &_17;
        _18 = &_6;
        _15 = <PageTableIndex as PartialEq>::ne(move _16, move _18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _15) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _19 = InvalidPageTable::NotRecursive;
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Err(move _19);
        goto -> bb20;
    }

    bb13: {
        _24 = control::x86_64::<impl control::Cr3>::read() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _23 = (_24.0: structures::paging::frame::PhysFrame);
        _22 = Result::<PhysFrame, FrameError>::Ok(move _23);
        _21 = &_22;
        _28 = &(*_1);
        _29 = _6;
        _27 = <PageTable as Index<PageTableIndex>>::index(move _28, move _29) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _26 = PageTableEntry::frame(_27) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _25 = &_26;
        _20 = <Result<PhysFrame, FrameError> as PartialEq>::ne(move _21, move _25) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _20) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _30 = InvalidPageTable::NotActive;
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Err(move _30);
        goto -> bb20;
    }

    bb19: {
        _32 = _6;
        _31 = RecursivePageTable::<'_> { p4: _1, recursive_index: move _32 };
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Ok(move _31);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::new_unchecked(_1: &mut PageTable, _2: PageTableIndex) -> RecursivePageTable<'_> {
    debug table => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>;

    bb0: {
        _0 = RecursivePageTable::<'_> { p4: _1, recursive_index: _2 };
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::level_4_table(_1: &mut RecursivePageTable<'_>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut &mut structures::paging::page_table::PageTable;

    bb0: {
        _2 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _0 = deref_copy (*_2);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::create_next_table(_1: &mut PageTableEntry, _2: Page, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, mapper::MapToError<S>> {
    debug entry => _1;
    debug next_table_page => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<S>>;

    bb0: {
        _0 = inner::<A, S>(_1, _2, _3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn inner(_1: &mut PageTableEntry, _2: Page, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, mapper::MapToError<S>> {
    debug entry => _1;
    debug next_table_page => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<S>>;
    let _5: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: core::option::Option<structures::paging::frame::PhysFrame>;
    let mut _9: isize;
    let _11: ();
    let mut _12: structures::paging::page_table::PageTableFlags;
    let mut _13: structures::paging::page_table::PageTableFlags;
    let mut _14: structures::paging::page_table::PageTableFlags;
    let mut _15: structures::paging::mapper::MapToError<S>;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableFlags;
    let mut _18: bool;
    let mut _19: &structures::paging::page_table::PageTableFlags;
    let _20: structures::paging::page_table::PageTableFlags;
    let mut _21: &structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableFlags;
    let _23: ();
    let mut _24: structures::paging::page_table::PageTableFlags;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: &structures::paging::page_table::PageTableEntry;
    let mut _27: structures::paging::page_table::PageTableFlags;
    let mut _28: bool;
    let mut _29: &structures::paging::page_table::PageTableFlags;
    let _30: structures::paging::page_table::PageTableFlags;
    let mut _31: &structures::paging::page_table::PageTableEntry;
    let mut _32: structures::paging::mapper::MapToError<S>;
    let mut _34: addr::VirtAddr;
    let mut _35: &mut structures::paging::page_table::PageTable;
    let mut _36: bool;
    let _37: ();
    scope 1 {
        debug created => _5;
        let _33: *mut structures::paging::page_table::PageTable;
        scope 2 {
            debug frame => _10;
            let _10: structures::paging::frame::PhysFrame;
        }
        scope 3 {
            debug page_table_ptr => _33;
            scope 4 {
                debug page_table => _35;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = PageTableEntry::is_unused(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb9, otherwise: bb2];
    }

    bb2: {
        _8 = <A as frame_alloc::FrameAllocator<page::Size4KiB>>::allocate_frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb4, otherwise: bb8];
    }

    bb4: {
        _10 = ((_8 as Some).0: structures::paging::frame::PhysFrame);
        _13 = <PageTableFlags as BitOr>::bitor(const _, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = _3;
        _12 = <PageTableFlags as BitOr>::bitor(move _13, move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = PageTableEntry::set_frame(_1, _10, move _12) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _5 = const true;
        goto -> bb18;
    }

    bb8: {
        _15 = mapper::MapToError::<S>::FrameAllocationFailed;
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Err(move _15);
        goto -> bb27;
    }

    bb9: {
        _17 = &_3;
        _16 = PageTableFlags::is_empty(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb11, otherwise: bb17];
    }

    bb11: {
        _21 = &(*_1);
        _20 = PageTableEntry::flags(move _21) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = &_20;
        _22 = _3;
        _18 = PageTableFlags::contains(move _19, move _22) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _18) -> [0: bb14, otherwise: bb17];
    }

    bb14: {
        _26 = &(*_1);
        _25 = PageTableEntry::flags(move _26) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _27 = _3;
        _24 = <PageTableFlags as BitOr>::bitor(move _25, move _27) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _23 = PageTableEntry::set_flags(_1, move _24) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _5 = const false;
        goto -> bb18;
    }

    bb18: {
        _31 = &(*_1);
        _30 = PageTableEntry::flags(move _31) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = &_30;
        _28 = PageTableFlags::contains(move _29, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _28) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _32 = mapper::MapToError::<S>::ParentEntryHugePage;
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Err(move _32);
        goto -> bb27;
    }

    bb22: {
        _34 = Page::start_address(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _33 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _34) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = &mut (*_33);
        _36 = _5;
        switchInt(move _36) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _37 = PageTable::zero(_35) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Ok(_35);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_1gib(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _17: bool;
    let _18: &structures::paging::page_table::PageTableEntry;
    let mut _19: &structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let _22: ();
    let mut _23: &mut structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: addr::PhysAddr;
    let mut _26: structures::paging::page_table::PageTableFlags;
    let mut _27: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size1GiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _28 = deref_copy (*_7);
        _13 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size1GiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size1GiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _19 = &(*_16);
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size1GiB>>>>::from_residual(move _15) -> [return: bb20, unwind unreachable];
    }

    bb9: {
        _18 = <PageTable as Index<PageTableIndex>>::index(move _19, move _20) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = PageTableEntry::is_unused(_18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _17) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _24 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _21 = mapper::MapToError::<page::Size1GiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Err(move _21);
        goto -> bb20;
    }

    bb14: {
        _23 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _25 = PhysFrame::<page::Size1GiB>::start_address(_3) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _22 = PageTableEntry::set_addr(_23, move _25, move _26) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Ok(move _27);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_2mib(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _20: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: isize;
    let mut _26: bool;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: &structures::paging::page_table::PageTable;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let _31: ();
    let mut _32: &mut structures::paging::page_table::PageTableEntry;
    let mut _33: structures::paging::page_table::PageTableIndex;
    let mut _34: addr::PhysAddr;
    let mut _35: structures::paging::page_table::PageTableFlags;
    let mut _36: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
                let _17: structures::paging::page::Page;
                scope 9 {
                    debug p2_page => _17;
                    scope 10 {
                        debug p2 => _25;
                    }
                    scope 11 {
                        let _24: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
                        let _25: &mut structures::paging::page_table::PageTable;
                        scope 12 {
                            debug residual => _24;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _25;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size2MiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _37 = deref_copy (*_7);
        _13 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size2MiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size2MiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_page::<page::Size2MiB>(_2, move _18) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size2MiB>>>>::from_residual(move _15) -> [return: bb27, unwind unreachable];
    }

    bb9: {
        _22 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _20 = RecursivePageTable::<'_>::create_next_table::<A, page::Size2MiB>(_21, _17, _5, _6) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <Result<&mut PageTable, mapper::MapToError<page::Size2MiB>> as Try>::branch(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _23 = discriminant(_19);
        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb7];
    }

    bb14: {
        _25 = move ((_19 as Continue).0: &mut structures::paging::page_table::PageTable);
        _28 = &(*_25);
        _29 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _24 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size2MiB>>>>::from_residual(move _24) -> [return: bb27, unwind unreachable];
    }

    bb16: {
        _27 = <PageTable as Index<PageTableIndex>>::index(move _28, move _29) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _26 = PageTableEntry::is_unused(_27) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        switchInt(move _26) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _33 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb21, unwind unreachable];
    }

    bb20: {
        _30 = mapper::MapToError::<page::Size2MiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Err(move _30);
        goto -> bb27;
    }

    bb21: {
        _32 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _33) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _34 = PhysFrame::<page::Size2MiB>::start_address(_3) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _35 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _31 = PageTableEntry::set_addr(_32, move _34, move _35) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _36 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Ok(move _36);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_4kib(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _20: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: isize;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _28: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _29: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _30: &mut structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: isize;
    let mut _35: bool;
    let _36: &structures::paging::page_table::PageTableEntry;
    let mut _37: &structures::paging::page_table::PageTable;
    let mut _38: structures::paging::page_table::PageTableIndex;
    let mut _39: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let _40: ();
    let mut _41: &mut structures::paging::page_table::PageTableEntry;
    let mut _42: structures::paging::page_table::PageTableIndex;
    let mut _43: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _44: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
                let _17: structures::paging::page::Page;
                scope 9 {
                    debug p2_page => _17;
                    scope 10 {
                        debug p2 => _25;
                        let _26: structures::paging::page::Page;
                        scope 16 {
                            debug p1_page => _26;
                            scope 17 {
                                debug p1 => _34;
                            }
                            scope 18 {
                                let _33: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                                let _34: &mut structures::paging::page_table::PageTable;
                                scope 19 {
                                    debug residual => _33;
                                    scope 20 {
                                    }
                                }
                                scope 21 {
                                    debug val => _34;
                                    scope 22 {
                                    }
                                }
                            }
                        }
                    }
                    scope 11 {
                        let _24: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                        let _25: &mut structures::paging::page_table::PageTable;
                        scope 12 {
                            debug residual => _24;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _25;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size4KiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _44 = deref_copy (*_7);
        _13 = Page::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_44, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_page::<page::Size4KiB>(_2, move _18) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _15) -> [return: bb32, unwind unreachable];
    }

    bb9: {
        _22 = Page::p3_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _20 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_21, _17, _5, _6) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _23 = discriminant(_19);
        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb7];
    }

    bb14: {
        _25 = move ((_19 as Continue).0: &mut structures::paging::page_table::PageTable);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p1_page(_2, move _27) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _24 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _24) -> [return: bb32, unwind unreachable];
    }

    bb16: {
        _31 = Page::p2_index(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _30 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _31) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _29 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_30, _26, _5, _6) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _28 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _29) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _32 = discriminant(_28);
        switchInt(move _32) -> [0: bb21, 1: bb22, otherwise: bb7];
    }

    bb21: {
        _34 = move ((_28 as Continue).0: &mut structures::paging::page_table::PageTable);
        _37 = &(*_34);
        _38 = Page::p1_index(_2) -> [return: bb23, unwind unreachable];
    }

    bb22: {
        _33 = move ((_28 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _33) -> [return: bb32, unwind unreachable];
    }

    bb23: {
        _36 = <PageTable as Index<PageTableIndex>>::index(move _37, move _38) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = PageTableEntry::is_unused(_36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _35) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _42 = Page::p1_index(_2) -> [return: bb28, unwind unreachable];
    }

    bb27: {
        _39 = mapper::MapToError::<page::Size4KiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Err(move _39);
        goto -> bb32;
    }

    bb28: {
        _41 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_34, move _42) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _40 = PageTableEntry::set_frame(_41, _3, _4) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _43 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Ok(move _43);
        goto -> bb32;
    }

    bb32: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_1gib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let mut _17: &mut structures::paging::page_table::PageTableEntry;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: bool;
    let mut _22: &structures::paging::page_table::PageTableFlags;
    let mut _23: structures::paging::mapper::UnmapError;
    let mut _24: bool;
    let mut _25: &structures::paging::page_table::PageTableFlags;
    let mut _26: structures::paging::mapper::UnmapError;
    let mut _27: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>>;
    let mut _28: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::UnmapError>;
    let mut _29: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _30: addr::PhysAddr;
    let mut _31: &structures::paging::page_table::PageTableEntry;
    let mut _32: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:331:22: 331:41};
    let mut _33: &&mut structures::paging::page_table::PageTableEntry;
    let mut _34: isize;
    let _37: ();
    let mut _38: &mut structures::paging::page_table::PageTableEntry;
    let mut _39: (structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>);
    let mut _40: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _41: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                let _16: &mut structures::paging::page_table::PageTableEntry;
                scope 9 {
                    debug p3_entry => _16;
                    let _19: structures::paging::page_table::PageTableFlags;
                    scope 10 {
                        debug flags => _19;
                        let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _36: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                        scope 11 {
                            debug frame => _36;
                        }
                        scope 12 {
                            debug residual => _35;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _36;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _41 = deref_copy (*_3);
        _5 = &(*_41);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:314:34: 314:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:314:34: 314:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size1GiB>(_2, move _15) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb27, unwind unreachable];
    }

    bb9: {
        _13 = &mut (*_14);
        _18 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_13, move _18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _16 = _17;
        _20 = &(*_16);
        _19 = PageTableEntry::flags(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _22 = &_19;
        _21 = PageTableFlags::contains(move _22, const _) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _21) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _25 = &_19;
        _24 = PageTableFlags::contains(move _25, const _) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _23 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _23);
        goto -> bb27;
    }

    bb16: {
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _31 = &(*_16);
        _30 = PageTableEntry::addr(move _31) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _26 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _26);
        goto -> bb27;
    }

    bb19: {
        _29 = PhysFrame::<page::Size1GiB>::from_start_address(move _30) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _33 = &_16;
        _32 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:331:22: 331:41} { p3_entry: move _33 };
        _28 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:331:22: 331:41}>(move _29, move _32) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _27 = <Result<PhysFrame<page::Size1GiB>, mapper::UnmapError> as Try>::branch(move _28) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _34 = discriminant(_27);
        switchInt(move _34) -> [0: bb23, 1: bb24, otherwise: bb7];
    }

    bb23: {
        _36 = ((_27 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _38 = _16;
        _37 = PageTableEntry::set_unused(move _38) -> [return: bb25, unwind unreachable];
    }

    bb24: {
        _35 = move ((_27 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb27, unwind unreachable];
    }

    bb25: {
        _40 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _39 = (_36, move _40);
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Ok(move _39);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:314:34: 314:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:331:22: 331:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p3_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _23 = deref_copy (*_4);
        _7 = &(*_23);
        _8 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb17;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size1GiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb17;
    }

    bb11: {
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _18 = PageTableEntry::set_flags(_19, move _21) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _22 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Ok(move _22);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _13: &structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::TranslateError;
    let mut _18: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _19: addr::PhysAddr;
    let mut _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:407:22: 407:41};
    let mut _22: &&structures::paging::page_table::PageTableEntry;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            let _12: &structures::paging::page_table::PageTableEntry;
            scope 4 {
                debug p3_entry => _12;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _23 = deref_copy (*_3);
        _6 = &(*_23);
        _7 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _8);
        goto -> bb14;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size1GiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _14 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as Index<PageTableIndex>>::index(_9, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = _13;
        _16 = _12;
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _20 = _12;
        _19 = PageTableEntry::addr(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = PhysFrame::<page::Size1GiB>::from_start_address(move _19) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = &_12;
        _21 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:407:22: 407:41} { p3_entry: move _22 };
        _0 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:407:22: 407:41}>(move _18, move _21) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:291:1: 291:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:407:22: 407:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p3_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_2mib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: &structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _20: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _21: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _22: isize;
    let mut _25: &mut structures::paging::page_table::PageTable;
    let mut _26: *mut structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _29: &mut structures::paging::page_table::PageTableEntry;
    let mut _30: structures::paging::page_table::PageTableIndex;
    let mut _32: &structures::paging::page_table::PageTableEntry;
    let mut _33: bool;
    let mut _34: &structures::paging::page_table::PageTableFlags;
    let mut _35: structures::paging::mapper::UnmapError;
    let mut _36: bool;
    let mut _37: &structures::paging::page_table::PageTableFlags;
    let mut _38: structures::paging::mapper::UnmapError;
    let mut _39: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>>;
    let mut _40: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::UnmapError>;
    let mut _41: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _42: addr::PhysAddr;
    let mut _43: &structures::paging::page_table::PageTableEntry;
    let mut _44: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:457:22: 457:41};
    let mut _45: &&mut structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let _49: ();
    let mut _50: &mut structures::paging::page_table::PageTableEntry;
    let mut _51: (structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>);
    let mut _52: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _53: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                scope 9 {
                    debug p3_entry => _16;
                    let _23: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _24: structures::paging::frame::PhysFrame;
                    scope 10 {
                        debug residual => _23;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _24;
                        scope 13 {
                        }
                    }
                    scope 14 {
                        debug p2 => _25;
                        let _28: &mut structures::paging::page_table::PageTableEntry;
                        scope 16 {
                            debug p2_entry => _28;
                            let _31: structures::paging::page_table::PageTableFlags;
                            scope 17 {
                                debug flags => _31;
                                let _47: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                                let _48: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                                scope 18 {
                                    debug frame => _48;
                                }
                                scope 19 {
                                    debug residual => _47;
                                    scope 20 {
                                    }
                                }
                                scope 21 {
                                    debug val => _48;
                                    scope 22 {
                                    }
                                }
                            }
                        }
                    }
                    scope 15 {
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _53 = deref_copy (*_3);
        _5 = &(*_53);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:433:34: 433:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:433:34: 433:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size2MiB>(_2, move _15) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb35, unwind unreachable];
    }

    bb9: {
        _13 = &mut (*_14);
        _17 = &(*_13);
        _18 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = <PageTable as Index<PageTableIndex>>::index(move _17, move _18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = PageTableEntry::frame(_16) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _20 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:440:34: 440:39}>(move _21, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:440:34: 440:39}) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb15, 1: bb16, otherwise: bb7];
    }

    bb15: {
        _24 = ((_19 as Continue).0: structures::paging::frame::PhysFrame);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p2_ptr::<page::Size2MiB>(_2, move _27) -> [return: bb17, unwind unreachable];
    }

    bb16: {
        _23 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _23) -> [return: bb35, unwind unreachable];
    }

    bb17: {
        _25 = &mut (*_26);
        _30 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _29 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _30) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _28 = _29;
        _32 = &(*_28);
        _31 = PageTableEntry::flags(move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _34 = &_31;
        _33 = PageTableFlags::contains(move _34, const _) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _33) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _37 = &_31;
        _36 = PageTableFlags::contains(move _37, const _) -> [return: bb24, unwind unreachable];
    }

    bb23: {
        _35 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _35);
        goto -> bb35;
    }

    bb24: {
        switchInt(move _36) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _43 = &(*_28);
        _42 = PageTableEntry::addr(move _43) -> [return: bb27, unwind unreachable];
    }

    bb26: {
        _38 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _38);
        goto -> bb35;
    }

    bb27: {
        _41 = PhysFrame::<page::Size2MiB>::from_start_address(move _42) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _45 = &_28;
        _44 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:457:22: 457:41} { p2_entry: move _45 };
        _40 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:457:22: 457:41}>(move _41, move _44) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _39 = <Result<PhysFrame<page::Size2MiB>, mapper::UnmapError> as Try>::branch(move _40) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _46 = discriminant(_39);
        switchInt(move _46) -> [0: bb31, 1: bb32, otherwise: bb7];
    }

    bb31: {
        _48 = ((_39 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _50 = _28;
        _49 = PageTableEntry::set_unused(move _50) -> [return: bb33, unwind unreachable];
    }

    bb32: {
        _47 = move ((_39 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _47) -> [return: bb35, unwind unreachable];
    }

    bb33: {
        _52 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _51 = (_48, move _52);
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Ok(move _51);
        goto -> bb35;
    }

    bb35: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:433:34: 433:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:440:34: 440:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::unmap::{closure#2}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:457:22: 457:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p2_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _31: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _31 = deref_copy (*_4);
        _7 = &(*_31);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb23;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size2MiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb23;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size2MiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _23 = &(*_18);
        _24 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb23;
    }

    bb17: {
        _28 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_18, move _28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _26 = PageTableEntry::set_flags(_27, move _29) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _30 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Ok(move _30);
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _20 = deref_copy (*_4);
        _7 = &(*_20);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb14;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size2MiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _14 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _12: &structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: bool;
    let mut _15: structures::paging::mapper::TranslateError;
    let _17: *mut structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: structures::paging::page_table::PageTableIndex;
    let mut _22: bool;
    let mut _23: &structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::mapper::TranslateError;
    let mut _25: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _26: addr::PhysAddr;
    let mut _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:562:22: 562:41};
    let mut _29: &&structures::paging::page_table::PageTableEntry;
    let mut _30: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            scope 4 {
                debug p3_entry => _12;
                let _16: &structures::paging::page_table::PageTable;
                scope 5 {
                    debug p2 => _16;
                    let _19: &structures::paging::page_table::PageTableEntry;
                    scope 7 {
                        debug p2_entry => _19;
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _30 = deref_copy (*_3);
        _6 = &(*_30);
        _7 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _8);
        goto -> bb20;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size2MiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _13 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = <PageTable as Index<PageTableIndex>>::index(_9, move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableEntry::is_unused(_12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _14) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _15 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _15);
        goto -> bb20;
    }

    bb11: {
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_ptr::<page::Size2MiB>(_2, move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = &(*_17);
        _21 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _20 = <PageTable as Index<PageTableIndex>>::index(_16, move _21) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _19 = _20;
        _23 = _19;
        _22 = PageTableEntry::is_unused(move _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _22) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _24 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _24);
        goto -> bb20;
    }

    bb17: {
        _27 = _19;
        _26 = PageTableEntry::addr(move _27) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _25 = PhysFrame::<page::Size2MiB>::from_start_address(move _26) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = &_19;
        _28 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:562:22: 562:41} { p2_entry: move _29 };
        _0 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:562:22: 562:41}>(move _25, move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:411:1: 411:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:562:22: 562:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p2_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_4kib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: &structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _20: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _21: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _22: isize;
    let mut _25: &mut structures::paging::page_table::PageTable;
    let mut _26: *mut structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let _28: &structures::paging::page_table::PageTableEntry;
    let mut _29: &structures::paging::page_table::PageTable;
    let mut _30: structures::paging::page_table::PageTableIndex;
    let mut _31: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _33: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _34: isize;
    let mut _37: &mut structures::paging::page_table::PageTable;
    let mut _38: *mut structures::paging::page_table::PageTable;
    let mut _39: structures::paging::page_table::PageTableIndex;
    let mut _40: &mut structures::paging::page_table::PageTableEntry;
    let mut _41: structures::paging::page_table::PageTableIndex;
    let mut _42: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _43: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _44: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _45: &structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let _49: ();
    let mut _50: (structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>);
    let mut _51: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _52: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                scope 9 {
                    debug p3_entry => _16;
                    let _23: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _24: structures::paging::frame::PhysFrame;
                    scope 10 {
                        debug residual => _23;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _24;
                        scope 13 {
                        }
                    }
                    scope 14 {
                        debug p2 => _25;
                        scope 16 {
                            debug p2_entry => _28;
                            let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                            let _36: structures::paging::frame::PhysFrame;
                            scope 17 {
                                debug residual => _35;
                                scope 18 {
                                }
                            }
                            scope 19 {
                                debug val => _36;
                                scope 20 {
                                }
                            }
                            scope 21 {
                                debug p1 => _37;
                                scope 23 {
                                    debug p1_entry => _40;
                                    let _47: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                                    let _48: structures::paging::frame::PhysFrame;
                                    scope 24 {
                                        debug frame => _48;
                                    }
                                    scope 25 {
                                        debug residual => _47;
                                        scope 26 {
                                        }
                                    }
                                    scope 27 {
                                        debug val => _48;
                                        scope 28 {
                                        }
                                    }
                                }
                            }
                            scope 22 {
                            }
                        }
                    }
                    scope 15 {
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _52 = deref_copy (*_3);
        _5 = &(*_52);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:588:34: 588:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:588:34: 588:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size4KiB>(_2, move _15) -> [return: bb9, unwind unreachable];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb35, unwind unreachable];
    }

    bb9: {
        _13 = &mut (*_14);
        _17 = &(*_13);
        _18 = Page::p3_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = <PageTable as Index<PageTableIndex>>::index(move _17, move _18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = PageTableEntry::frame(_16) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _20 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:595:34: 595:39}>(move _21, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:595:34: 595:39}) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb15, 1: bb16, otherwise: bb7];
    }

    bb15: {
        _24 = ((_19 as Continue).0: structures::paging::frame::PhysFrame);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p2_ptr::<page::Size4KiB>(_2, move _27) -> [return: bb17, unwind unreachable];
    }

    bb16: {
        _23 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _23) -> [return: bb35, unwind unreachable];
    }

    bb17: {
        _25 = &mut (*_26);
        _29 = &(*_25);
        _30 = Page::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _28 = <PageTable as Index<PageTableIndex>>::index(move _29, move _30) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _33 = PageTableEntry::frame(_28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _32 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:602:34: 602:39}>(move _33, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:602:34: 602:39}) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _31 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _32) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _34 = discriminant(_31);
        switchInt(move _34) -> [0: bb23, 1: bb24, otherwise: bb7];
    }

    bb23: {
        _36 = ((_31 as Continue).0: structures::paging::frame::PhysFrame);
        _39 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _38 = p1_ptr(_2, move _39) -> [return: bb25, unwind unreachable];
    }

    bb24: {
        _35 = move ((_31 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb35, unwind unreachable];
    }

    bb25: {
        _37 = &mut (*_38);
        _41 = Page::p1_index(_2) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _40 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _41) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _45 = &(*_40);
        _44 = PageTableEntry::frame(move _45) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _43 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:610:46: 610:51}>(move _44, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:610:46: 610:51}) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _42 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _43) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _46 = discriminant(_42);
        switchInt(move _46) -> [0: bb31, 1: bb32, otherwise: bb7];
    }

    bb31: {
        _48 = ((_42 as Continue).0: structures::paging::frame::PhysFrame);
        _49 = PageTableEntry::set_unused(_40) -> [return: bb33, unwind unreachable];
    }

    bb32: {
        _47 = move ((_42 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _47) -> [return: bb35, unwind unreachable];
    }

    bb33: {
        _51 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _50 = (_48, move _51);
        _0 = Result::<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError>::Ok(move _50);
        goto -> bb35;
    }

    bb35: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:588:34: 588:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:595:34: 595:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::unmap::{closure#2}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:602:34: 602:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::unmap::{closure#3}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:610:46: 610:51}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let mut _26: &mut structures::paging::page_table::PageTable;
    let mut _27: *mut structures::paging::page_table::PageTable;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: bool;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: &structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let mut _33: structures::paging::mapper::FlagUpdateError;
    let _34: ();
    let mut _35: &mut structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _37: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _38: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
                scope 6 {
                    debug p1 => _26;
                }
                scope 7 {
                }
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _38 = deref_copy (*_4);
        _7 = &(*_38);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb28;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb28;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size4KiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _23 = &(*_18);
        _24 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb28;
    }

    bb17: {
        _28 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _27 = p1_ptr(_2, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _26 = &mut (*_27);
        _31 = &(*_26);
        _32 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _30 = <PageTable as Index<PageTableIndex>>::index(move _31, move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _29 = PageTableEntry::is_unused(_30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _29) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _33 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _33);
        goto -> bb28;
    }

    bb23: {
        _36 = Page::p1_index(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_26, move _36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _34 = PageTableEntry::set_flags(_35, _3) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _37 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Ok(move _37);
        goto -> bb28;
    }

    bb28: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _20 = deref_copy (*_4);
        _7 = &(*_20);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb14;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _14 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: bool;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: structures::paging::mapper::MapperFlushAll;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
                scope 6 {
                    debug p2_entry => _21;
                }
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _28 = deref_copy (*_4);
        _7 = &(*_28);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb20;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb20;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size4KiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _22 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_18, move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = &(*_21);
        _23 = PageTableEntry::is_unused(move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _23) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb20;
    }

    bb17: {
        _26 = PageTableEntry::set_flags(_21, _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = mapper::MapperFlushAll::new() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _12: &structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: bool;
    let mut _15: structures::paging::mapper::TranslateError;
    let _17: *mut structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let _19: &structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let mut _22: structures::paging::mapper::TranslateError;
    let _24: *mut structures::paging::page_table::PageTable;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: bool;
    let mut _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::mapper::TranslateError;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _33: addr::PhysAddr;
    let mut _34: &structures::paging::page_table::PageTableEntry;
    let mut _35: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:751:22: 751:41};
    let mut _36: &&structures::paging::page_table::PageTableEntry;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            scope 4 {
                debug p3_entry => _12;
                let _16: &structures::paging::page_table::PageTable;
                scope 5 {
                    debug p2 => _16;
                    scope 7 {
                        debug p2_entry => _19;
                        let _23: &structures::paging::page_table::PageTable;
                        scope 8 {
                            debug p1 => _23;
                            let _26: &structures::paging::page_table::PageTableEntry;
                            scope 10 {
                                debug p1_entry => _26;
                            }
                        }
                        scope 9 {
                        }
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _37 = deref_copy (*_3);
        _6 = &(*_37);
        _7 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _8);
        goto -> bb26;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size4KiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _13 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = <PageTable as Index<PageTableIndex>>::index(_9, move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableEntry::is_unused(_12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _14) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _15 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _15);
        goto -> bb26;
    }

    bb11: {
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_ptr::<page::Size4KiB>(_2, move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = &(*_17);
        _20 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = <PageTable as Index<PageTableIndex>>::index(_16, move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_19) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _22 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _22);
        goto -> bb26;
    }

    bb17: {
        _25 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _24 = p1_ptr(_2, move _25) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _23 = &(*_24);
        _28 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _27 = <PageTable as Index<PageTableIndex>>::index(_23, move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _26 = _27;
        _30 = _26;
        _29 = PageTableEntry::is_unused(move _30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _29) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _31 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _31);
        goto -> bb26;
    }

    bb23: {
        _34 = _26;
        _33 = PageTableEntry::addr(move _34) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _32 = PhysFrame::from_start_address(move _33) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _36 = &_26;
        _35 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:751:22: 751:41} { p1_entry: move _36 };
        _0 = Result::<PhysFrame, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:751:22: 751:41}>(move _32, move _35) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:566:1: 566:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:751:22: 751:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p1_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:755:1: 755:46>::translate(_1: &RecursivePageTable<'_>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let _3: structures::paging::page::Page;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: &structures::paging::page_table::PageTableFlags;
    let _11: structures::paging::page_table::PageTableFlags;
    let mut _12: !;
    let _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: &structures::paging::page_table::PageTableFlags;
    let _21: structures::paging::page_table::PageTableFlags;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _25: addr::PhysAddr;
    let mut _27: u64;
    let mut _29: structures::paging::mapper::MappedFrame;
    let _31: *mut structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: structures::paging::page_table::PageTableIndex;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: &structures::paging::page_table::PageTableFlags;
    let _38: structures::paging::page_table::PageTableFlags;
    let _39: &structures::paging::page_table::PageTableEntry;
    let mut _40: structures::paging::page_table::PageTableIndex;
    let mut _42: addr::PhysAddr;
    let mut _44: u64;
    let mut _46: structures::paging::mapper::MappedFrame;
    let _48: *mut structures::paging::page_table::PageTable;
    let mut _49: structures::paging::page_table::PageTableIndex;
    let _50: &structures::paging::page_table::PageTableEntry;
    let mut _51: structures::paging::page_table::PageTableIndex;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: &structures::paging::page_table::PageTableFlags;
    let _55: structures::paging::page_table::PageTableFlags;
    let mut _56: !;
    let mut _57: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _58: addr::PhysAddr;
    let mut _59: isize;
    let mut _61: addr::PhysAddr;
    let mut _63: structures::paging::page_table::PageOffset;
    let mut _65: structures::paging::mapper::MappedFrame;
    let mut _66: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug page => _3;
        let _4: &&mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p4 => _4;
            scope 3 {
                debug p4_entry => _5;
                let _13: &structures::paging::page_table::PageTable;
                scope 4 {
                    debug p3 => _13;
                    scope 6 {
                        debug p3_entry => _16;
                        let _30: &structures::paging::page_table::PageTable;
                        scope 7 {
                            debug entry => _22;
                            let _24: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                            scope 8 {
                                debug frame => _24;
                                let _26: u64;
                                scope 9 {
                                    debug offset => _26;
                                    let _28: structures::paging::page_table::PageTableFlags;
                                    scope 10 {
                                        debug flags => _28;
                                    }
                                }
                            }
                        }
                        scope 11 {
                            debug p2 => _30;
                            scope 13 {
                                debug p2_entry => _33;
                                let _47: &structures::paging::page_table::PageTable;
                                scope 14 {
                                    debug entry => _39;
                                    let _41: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                                    scope 15 {
                                        debug frame => _41;
                                        let _43: u64;
                                        scope 16 {
                                            debug offset => _43;
                                            let _45: structures::paging::page_table::PageTableFlags;
                                            scope 17 {
                                                debug flags => _45;
                                            }
                                        }
                                    }
                                }
                                scope 18 {
                                    debug p1 => _47;
                                    scope 20 {
                                        debug p1_entry => _50;
                                        let _60: structures::paging::frame::PhysFrame;
                                        scope 21 {
                                            debug frame => _60;
                                            let _62: u64;
                                            scope 23 {
                                                debug offset => _62;
                                                let _64: structures::paging::page_table::PageTableFlags;
                                                scope 24 {
                                                    debug flags => _64;
                                                }
                                            }
                                        }
                                        scope 22 {
                                            debug frame => _60;
                                        }
                                    }
                                }
                                scope 19 {
                                }
                            }
                        }
                        scope 12 {
                        }
                    }
                }
                scope 5 {
                }
            }
        }
    }

    bb0: {
        _3 = Page::containing_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _66 = deref_copy (*_4);
        _6 = &(*_66);
        _7 = addr::VirtAddr::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = PageTableEntry::is_unused(_5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb62;
    }

    bb6: {
        _11 = PageTableEntry::flags(_5) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _10 = &_11;
        _9 = PageTableFlags::contains(move _10, const _) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _12 = panic(const "level 4 entry has huge page bit set") -> unwind unreachable;
    }

    bb10: {
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size4KiB>(_3, move _15) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = &(*_14);
        _17 = addr::VirtAddr::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_13, move _17) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _18 = PageTableEntry::is_unused(_16) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        switchInt(move _18) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb62;
    }

    bb16: {
        _21 = PageTableEntry::flags(_16) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _20 = &_21;
        _19 = PageTableFlags::contains(move _20, const _) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        switchInt(move _19) -> [0: bb26, otherwise: bb19];
    }

    bb19: {
        _23 = addr::VirtAddr::p3_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _22 = <PageTable as Index<PageTableIndex>>::index(_13, move _23) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _25 = PageTableEntry::addr(_22) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _24 = PhysFrame::<page::Size1GiB>::containing_address(move _25) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _27 = addr::VirtAddr::as_u64(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _26 = BitAnd(move _27, const 1073741823_u64);
        _28 = PageTableEntry::flags(_22) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _29 = mapper::MappedFrame::Size1GiB(_24);
        _0 = mapper::TranslateResult::Mapped { frame: move _29, offset: _26, flags: _28 };
        goto -> bb62;
    }

    bb26: {
        _32 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _31 = p2_ptr::<page::Size4KiB>(_3, move _32) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _30 = &(*_31);
        _34 = addr::VirtAddr::p2_index(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _33 = <PageTable as Index<PageTableIndex>>::index(_30, move _34) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _35 = PageTableEntry::is_unused(_33) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _35) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb62;
    }

    bb32: {
        _38 = PageTableEntry::flags(_33) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _37 = &_38;
        _36 = PageTableFlags::contains(move _37, const _) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _36) -> [0: bb42, otherwise: bb35];
    }

    bb35: {
        _40 = addr::VirtAddr::p2_index(_2) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _39 = <PageTable as Index<PageTableIndex>>::index(_30, move _40) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _42 = PageTableEntry::addr(_39) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _41 = PhysFrame::<page::Size2MiB>::containing_address(move _42) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _44 = addr::VirtAddr::as_u64(_2) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _43 = BitAnd(move _44, const 2097151_u64);
        _45 = PageTableEntry::flags(_39) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _46 = mapper::MappedFrame::Size2MiB(_41);
        _0 = mapper::TranslateResult::Mapped { frame: move _46, offset: _43, flags: _45 };
        goto -> bb62;
    }

    bb42: {
        _49 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _48 = p1_ptr(_3, move _49) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _47 = &(*_48);
        _51 = addr::VirtAddr::p1_index(_2) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _50 = <PageTable as Index<PageTableIndex>>::index(_47, move _51) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _52 = PageTableEntry::is_unused(_50) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _52) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb62;
    }

    bb48: {
        _55 = PageTableEntry::flags(_50) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _54 = &_55;
        _53 = PageTableFlags::contains(move _54, const _) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        switchInt(move _53) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _56 = panic(const "level 1 entry has huge page bit set") -> unwind unreachable;
    }

    bb52: {
        _58 = PageTableEntry::addr(_50) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _57 = PhysFrame::from_start_address(move _58) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _59 = discriminant(_57);
        switchInt(move _59) -> [0: bb57, 1: bb55, otherwise: bb56];
    }

    bb55: {
        _61 = PageTableEntry::addr(_50) -> [return: bb58, unwind unreachable];
    }

    bb56: {
        unreachable;
    }

    bb57: {
        _60 = ((_57 as Ok).0: structures::paging::frame::PhysFrame);
        _63 = addr::VirtAddr::page_offset(_2) -> [return: bb59, unwind unreachable];
    }

    bb58: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _61);
        goto -> bb62;
    }

    bb59: {
        _62 = <u64 as From<PageOffset>>::from(move _63) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _64 = PageTableEntry::flags(_50) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _65 = mapper::MappedFrame::Size4KiB(_60);
        _0 = mapper::TranslateResult::Mapped { frame: move _65, offset: _62, flags: _64 };
        goto -> bb62;
    }

    bb62: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:826:1: 826:44>::clean_up(_1: &mut RecursivePageTable<'_>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::PageRangeInclusive;
    let mut _4: structures::paging::page::Page;
    let mut _5: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page;
    let mut _8: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _9: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _6 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Page::from_start_address(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Page, AddressNotAligned>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = addr::VirtAddr::new(const 18446744073709547520_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Page::from_start_address(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Result::<Page, AddressNotAligned>::unwrap(move _8) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _3 = PageRangeInclusive { start: move _4, end: move _7 };
        _0 = <RecursivePageTable<'_> as mapper::CleanUp>::clean_up_addr_range::<D>(_1, move _3, _2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:826:1: 826:44>::clean_up_addr_range(_1: &mut RecursivePageTable<'_>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let _4: bool;
    let mut _5: structures::paging::page_table::PageTableIndex;
    let mut _6: &mut structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableLevel;

    bb0: {
        _5 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _6 = RecursivePageTable::<'_>::level_4_table(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = PageTableLevel::Four;
        _4 = <RecursivePageTable<'a> as mapper::CleanUp>::clean_up_addr_range::clean_up::<D>(move _5, _6, move _7, _2, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:826:1: 826:44>::clean_up_addr_range::clean_up(_1: PageTableIndex, _2: &mut PageTable, _3: PageTableLevel, _4: PageRangeInclusive, _5: &mut impl FrameDeallocator<Size4KiB>) -> bool {
    debug recursive_index => _1;
    debug page_table => _2;
    debug level => _3;
    debug range => _4;
    debug frame_deallocator => _5;
    let mut _0: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page::PageRangeInclusive;
    let _8: addr::VirtAddr;
    let mut _9: addr::VirtAddr;
    let mut _10: structures::paging::page::Page;
    let mut _11: u64;
    let mut _12: structures::paging::page_table::PageTableLevel;
    let mut _14: structures::paging::page::Page;
    let mut _15: structures::paging::page_table::PageTableLevel;
    let mut _17: structures::paging::page::Page;
    let mut _18: structures::paging::page_table::PageTableLevel;
    let mut _19: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _20: structures::paging::page_table::PageTableLevel;
    let mut _21: isize;
    let mut _24: structures::paging::page_table::PageTableLevel;
    let mut _25: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}>;
    let mut _26: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}>;
    let mut _27: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>;
    let mut _28: core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>;
    let mut _29: core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>;
    let mut _30: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _31: usize;
    let mut _32: usize;
    let mut _33: (usize, bool);
    let mut _34: usize;
    let mut _35: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37};
    let mut _36: &structures::paging::page_table::PageTableLevel;
    let mut _37: &structures::paging::page_table::PageTableIndex;
    let mut _39: core::option::Option<(usize, &mut structures::paging::page_table::PageTableEntry)>;
    let mut _40: &mut core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}>;
    let mut _41: isize;
    let mut _44: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _45: &structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let mut _49: u64;
    let mut _50: u64;
    let mut _51: (u64, bool);
    let mut _53: u64;
    let mut _54: (u64, bool);
    let mut _57: structures::paging::page::Page;
    let mut _60: structures::paging::page::Page;
    let mut _62: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _63: [fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable; 3];
    let mut _64: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _65: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _66: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let _67: usize;
    let mut _68: usize;
    let _69: structures::paging::page_table::PageTableLevel;
    let mut _70: isize;
    let mut _71: u8;
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: (usize, bool);
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: structures::paging::page_table::PageTableIndex;
    let mut _79: &mut structures::paging::page_table::PageTable;
    let mut _80: bool;
    let mut _81: structures::paging::page_table::PageTableIndex;
    let mut _82: structures::paging::page::PageRangeInclusive;
    let _83: ();
    let _84: ();
    let mut _85: &mut core::slice::Iter<'_, structures::paging::page_table::PageTableEntry>;
    let mut _86: core::slice::Iter<'_, structures::paging::page_table::PageTableEntry>;
    let mut _87: &structures::paging::page_table::PageTable;
    scope 1 {
        debug table_addr => _8;
        let _13: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug start => _13;
            let _16: structures::paging::page_table::PageTableIndex;
            scope 3 {
                debug end => _16;
                scope 4 {
                    debug next_level => _22;
                    let _22: structures::paging::page_table::PageTableLevel;
                    let _23: u64;
                    scope 5 {
                        debug offset_per_entry => _23;
                        let mut _38: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}>;
                        scope 6 {
                            debug iter => _38;
                            let _42: usize;
                            let _43: &mut structures::paging::page_table::PageTableEntry;
                            scope 7 {
                                debug i => _42;
                                debug entry => _43;
                                scope 8 {
                                    debug frame => _47;
                                    let _47: structures::paging::frame::PhysFrame;
                                    let _48: addr::VirtAddr;
                                    scope 9 {
                                        debug start => _48;
                                        let _52: addr::VirtAddr;
                                        scope 10 {
                                            debug end => _52;
                                            let _55: structures::paging::page::Page;
                                            scope 11 {
                                                debug start => _55;
                                                let _56: structures::paging::page::Page;
                                                scope 12 {
                                                    debug start => _56;
                                                    let _58: structures::paging::page::Page;
                                                    scope 13 {
                                                        debug end => _58;
                                                        let _59: structures::paging::page::Page;
                                                        scope 14 {
                                                            debug end => _59;
                                                            let _61: *mut structures::paging::page_table::PageTable;
                                                            scope 15 {
                                                                debug page_table => _61;
                                                                scope 16 {
                                                                    debug page_table => _79;
                                                                    scope 18 {
                                                                    }
                                                                }
                                                                scope 17 {
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_4;
        _6 = PageRangeInclusive::is_empty(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb44;
    }

    bb3: {
        _10 = (_4.0: structures::paging::page::Page);
        _9 = Page::start_address(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = _3;
        _11 = PageTableLevel::table_address_space_alignment(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = addr::VirtAddr::align_down::<u64>(move _9, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _14 = (_4.0: structures::paging::page::Page);
        _15 = _3;
        _13 = Page::page_table_index(move _14, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _17 = (_4.1: structures::paging::page::Page);
        _18 = _3;
        _16 = Page::page_table_index(move _17, move _18) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _20 = _3;
        _19 = PageTableLevel::next_lower_level(move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [1: bb10, otherwise: bb42];
    }

    bb10: {
        _22 = ((_19 as Some).0: structures::paging::page_table::PageTableLevel);
        _24 = _3;
        _23 = PageTableLevel::entry_address_space_alignment(move _24) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _30 = PageTable::iter_mut(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _29 = <core::slice::IterMut<'_, PageTableEntry> as Iterator>::enumerate(move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _32 = <usize as From<PageTableIndex>>::from(_16) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _33 = CheckedAdd(_32, const 1_usize);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _32, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _31 = move (_33.0: usize);
        _28 = <Enumerate<core::slice::IterMut<'_, PageTableEntry>> as Iterator>::take(move _29, move _31) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _34 = <usize as From<PageTableIndex>>::from(_13) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _27 = <Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>> as Iterator>::skip(move _28, move _34) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _36 = &_3;
        _37 = &_1;
        _35 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37} { level: move _36, recursive_index: move _37 };
        _26 = <Skip<Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>>> as Iterator>::filter::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}>(move _27, move _35) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = <Filter<Skip<Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}> as IntoIterator>::into_iter(move _26) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _38 = move _25;
        goto -> bb21;
    }

    bb21: {
        _40 = &mut _38;
        _39 = <Filter<Skip<Take<Enumerate<core::slice::IterMut<'_, PageTableEntry>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}> as Iterator>::next(_40) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _41 = discriminant(_39);
        switchInt(move _41) -> [0: bb42, 1: bb23, otherwise: bb24];
    }

    bb23: {
        _42 = (((_39 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).0: usize);
        _43 = move (((_39 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).1: &mut structures::paging::page_table::PageTableEntry);
        _45 = &(*_43);
        _44 = PageTableEntry::frame(move _45) -> [return: bb25, unwind unreachable];
    }

    bb24: {
        unreachable;
    }

    bb25: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb26, otherwise: bb21];
    }

    bb26: {
        _47 = ((_44 as Ok).0: structures::paging::frame::PhysFrame);
        _50 = _42 as u64 (IntToInt);
        _51 = CheckedMul(_23, _50);
        assert(!move (_51.1: bool), "attempt to compute `{} * {}`, which would overflow", _23, move _50) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _49 = move (_51.0: u64);
        _48 = <addr::VirtAddr as Add<u64>>::add(_8, move _49) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _54 = CheckedSub(_23, const 1_u64);
        assert(!move (_54.1: bool), "attempt to compute `{} - {}`, which would overflow", _23, const 1_u64) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _53 = move (_54.0: u64);
        _52 = <addr::VirtAddr as Add<u64>>::add(_48, move _53) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _55 = Page::containing_address(_48) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _57 = (_4.0: structures::paging::page::Page);
        _56 = <Page as Ord>::max(_55, move _57) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _58 = Page::containing_address(_52) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _60 = (_4.1: structures::paging::page::Page);
        _59 = <Page as Ord>::min(_58, move _60) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _64 = structures::paging::mapper::recursive_page_table::p1_ptr as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _65 = structures::paging::mapper::recursive_page_table::p2_ptr::<structures::paging::page::Size4KiB> as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _66 = structures::paging::mapper::recursive_page_table::p3_ptr::<structures::paging::page::Size4KiB> as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _63 = [move _64, move _65, move _66];
        _69 = _3;
        _70 = discriminant(_69);
        _71 = _70 as u8 (IntToInt);
        _72 = Ge(_71, const 1_u8);
        _73 = Le(_71, const 4_u8);
        _74 = BitAnd(move _72, move _73);
        assume(move _74);
        _68 = move _70 as usize (IntToInt);
        _75 = CheckedSub(_68, const 2_usize);
        assert(!move (_75.1: bool), "attempt to compute `{} - {}`, which would overflow", move _68, const 2_usize) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _67 = move (_75.0: usize);
        _76 = const 3_usize;
        _77 = Lt(_67, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _67) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _62 = _63[_67];
        _78 = _1;
        _61 = move _62(_56, move _78) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _79 = &mut (*_61);
        _81 = _1;
        _82 = Page::range_inclusive(_56, _59) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _80 = <RecursivePageTable<'a> as mapper::CleanUp>::clean_up_addr_range::clean_up::<impl FrameDeallocator<Size4KiB>>(move _81, _79, _22, move _82, _5) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        switchInt(move _80) -> [0: bb21, otherwise: bb40];
    }

    bb40: {
        _83 = PageTableEntry::set_unused(_43) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _84 = <impl FrameDeallocator<Size4KiB> as FrameDeallocator<page::Size4KiB>>::deallocate_frame(_5, _47) -> [return: bb21, unwind unreachable];
    }

    bb42: {
        _87 = &(*_2);
        _86 = PageTable::iter(move _87) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _85 = &mut _86;
        _0 = <core::slice::Iter<'_, PageTableEntry> as Iterator>::all::<for<'a> fn(&'a PageTableEntry) -> bool {PageTableEntry::is_unused}>(move _85, PageTableEntry::is_unused) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:826:1: 826:44>::clean_up_addr_range::clean_up::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:876:29: 876:37}, _2: &(usize, &mut PageTableEntry)) -> bool {
    debug level => (*((*_1).0: &structures::paging::page_table::PageTableLevel));
    debug recursive_index => (*((*_1).1: &structures::paging::page_table::PageTableIndex));
    let mut _0: bool;
    let _3: &usize;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _10: &structures::paging::page_table::PageTableLevel;
    let mut _11: &structures::paging::page_table::PageTableIndex;
    scope 1 {
        debug i => _3;
        let mut _9: &structures::paging::page_table::PageTableLevel;
    }

    bb0: {
        _3 = &((*_2).0: usize);
        _10 = deref_copy ((*_1).0: &structures::paging::page_table::PageTableLevel);
        _9 = const _;
        _5 = <PageTableLevel as PartialEq>::eq(_10, _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _5) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = (*_3);
        _11 = deref_copy ((*_1).1: &structures::paging::page_table::PageTableIndex);
        _8 = (*_11);
        _7 = <PageTableIndex as Into<usize>>::into(move _8) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _4 = const false;
        goto -> bb5;
    }

    bb4: {
        _4 = Eq(move _6, move _7);
        goto -> bb5;
    }

    bb5: {
        _0 = Not(move _4);
        return;
    }
}

promoted[0] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:826:1: 826:44>::clean_up_addr_range::clean_up::{closure#0}: &PageTableLevel = {
    let mut _0: &structures::paging::page_table::PageTableLevel;
    let mut _1: structures::paging::page_table::PageTableLevel;

    bb0: {
        _1 = PageTableLevel::Four;
        _0 = &_1;
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:920:10: 920:15>::fmt(_1: &InvalidPageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "NotActive";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "NotRecursive";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:935:1: 935:39>::fmt(_1: &InvalidPageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: core::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[&str; 1];
    let mut _9: &[&str; 1];

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const _;
        _7 = _8 as &[&str] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_const(move _7) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_const(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

promoted[0] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:935:1: 935:39>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "given page table is not active on the CPU"];
        _0 = &_1;
        return;
    }
}

promoted[1] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/recursive_page_table.rs:935:1: 935:39>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "given page table address is not recursive"];
        _0 = &_1;
        return;
    }
}

fn p3_ptr(_1: Page<S>, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p3_page::<S>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p3_page(_1: Page<S>, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::<S>::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Page::from_page_table_indices(_2, _2, _2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn p2_ptr(_1: Page<S>, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p2_page::<S>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p2_page(_1: Page<S>, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;
    let mut _4: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::<S>::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Page::<S>::p3_index(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Page::from_page_table_indices(_2, _2, move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p1_ptr(_1: Page, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p1_page(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p1_page(_1: Page, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;
    let mut _4: structures::paging::page_table::PageTableIndex;
    let mut _5: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Page::p3_index(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Page::p2_index(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::from_page_table_indices(_2, move _3, move _4, move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapper::Translate::translate_addr(_1: &Self, _2: addr::VirtAddr) -> Option<PhysAddr> {
    debug self => _1;
    debug addr => _2;
    let mut _0: core::option::Option<addr::PhysAddr>;
    let mut _3: structures::paging::mapper::TranslateResult;
    let mut _4: isize;
    let _5: structures::paging::mapper::MappedFrame;
    let _6: u64;
    let mut _7: addr::PhysAddr;
    let mut _8: addr::PhysAddr;
    let mut _9: &structures::paging::mapper::MappedFrame;
    scope 1 {
        debug frame => _5;
        debug offset => _6;
    }

    bb0: {
        _3 = <Self as mapper::Translate>::translate(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, 2: bb4, otherwise: bb3];
    }

    bb2: {
        _5 = move ((_3 as Mapped).0: structures::paging::mapper::MappedFrame);
        _6 = ((_3 as Mapped).1: u64);
        _9 = &_5;
        _8 = mapper::MappedFrame::start_address(move _9) -> [return: bb5, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = Option::<PhysAddr>::None;
        goto -> bb7;
    }

    bb5: {
        _7 = <PhysAddr as Add<u64>>::add(move _8, _6) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Option::<PhysAddr>::Some(move _7);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:57:10: 57:15>::fmt(_1: &mapper::TranslateResult, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &structures::paging::mapper::MappedFrame;
    let _5: &u64;
    let _6: &structures::paging::page_table::PageTableFlags;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &&structures::paging::page_table::PageTableFlags;
    let _15: &str;
    let _16: &addr::PhysAddr;
    let _17: &str;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
        debug __self_2 => _6;
    }
    scope 2 {
        debug __self_0 => _16;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _16 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _17 = const "InvalidFrameAddress";
        _19 = &_16;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _17, move _18) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Mapped).0: structures::paging::mapper::MappedFrame);
        _5 = &(((*_1) as Mapped).1: u64);
        _6 = &(((*_1) as Mapped).2: structures::paging::page_table::PageTableFlags);
        _7 = const "Mapped";
        _8 = const "frame";
        _9 = _4 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "offset";
        _11 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _12 = const "flags";
        _14 = &_6;
        _13 = _14 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _7, _8, move _9, _10, move _11, _12, move _13) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _15 = const "NotMapped";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:79:10: 79:15>::fmt(_1: &mapper::MappedFrame, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &structures::paging::frame::PhysFrame;
    let _5: &str;
    let mut _6: &dyn core::fmt::Debug;
    let _7: &&structures::paging::frame::PhysFrame;
    let _8: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &&structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _12: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &&structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _12 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _13 = const "Size1GiB";
        _15 = &_12;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _5 = const "Size4KiB";
        _7 = &_4;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _8 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _9 = const "Size2MiB";
        _11 = &_8;
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:89:1: 89:17>::start_address(_1: &mapper::MappedFrame) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: isize;
    let _3: &structures::paging::frame::PhysFrame;
    let _4: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _5: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug frame => _3;
    }
    scope 2 {
        debug frame => _4;
    }
    scope 3 {
        debug frame => _5;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _0 = ((*_5).0: addr::PhysAddr);
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _0 = ((*_3).0: addr::PhysAddr);
        goto -> bb5;
    }

    bb4: {
        _4 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _0 = ((*_4).0: addr::PhysAddr);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:89:1: 89:17>::start_address(_1: &mapper::MappedFrame) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: isize;
    let _3: &structures::paging::frame::PhysFrame;
    let _4: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _5: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug frame => _3;
    }
    scope 2 {
        debug frame => _4;
    }
    scope 3 {
        debug frame => _5;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        StorageLive(_5);
        _5 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _0 = ((*_5).0: addr::PhysAddr);
        StorageDead(_5);
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_3);
        _3 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _0 = ((*_3).0: addr::PhysAddr);
        StorageDead(_3);
        goto -> bb5;
    }

    bb4: {
        StorageLive(_4);
        _4 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _0 = ((*_4).0: addr::PhysAddr);
        StorageDead(_4);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:89:1: 89:17>::size(_1: &mapper::MappedFrame) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:89:1: 89:17>::size(_1: &mapper::MappedFrame) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn mapper::Mapper::map_to(_1: &mut Self, _2: Page<S>, _3: PhysFrame<S>, _4: PageTableFlags, _5: &mut A) -> Result<mapper::MapperFlush<S>, mapper::MapToError<S>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug frame_allocator => _5;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<S>, structures::paging::mapper::MapToError<S>>;
    let _6: structures::paging::page_table::PageTableFlags;
    let mut _7: structures::paging::page_table::PageTableFlags;
    let mut _8: structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug parent_table_flags => _6;
        scope 2 {
        }
    }

    bb0: {
        _8 = <PageTableFlags as BitOr>::bitor(const _, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTableFlags as BitOr>::bitor(move _8, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = <PageTableFlags as BitAnd>::bitand(_4, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <Self as mapper::Mapper<S>>::map_to_with_table_flags::<A>(_1, _2, _3, _4, _6, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapper::Mapper::identity_map(_1: &mut Self, _2: PhysFrame<S>, _3: PageTableFlags, _4: &mut A) -> Result<mapper::MapperFlush<S>, mapper::MapToError<S>> {
    debug self => _1;
    debug frame => _2;
    debug flags => _3;
    debug frame_allocator => _4;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<S>, structures::paging::mapper::MapToError<S>>;
    let _5: structures::paging::page::Page<S>;
    let mut _6: addr::VirtAddr;
    let mut _7: u64;
    let mut _8: addr::PhysAddr;
    scope 1 {
        debug page => _5;
        scope 2 {
        }
    }

    bb0: {
        _8 = PhysFrame::<S>::start_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = PhysAddr::as_u64(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = addr::VirtAddr::new(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Page::<S>::containing_address(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <Self as mapper::Mapper<S>>::map_to::<A>(_1, _5, _2, _3, _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:382:10: 382:15>::fmt(_1: &mapper::MapperFlush<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&structures::paging::page::Page<S>;
    let _6: &structures::paging::page::Page<S>;

    bb0: {
        _3 = const "MapperFlush";
        _6 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:386:1: 386:33>::new(_1: Page<S>) -> mapper::MapperFlush<S> {
    debug page => _1;
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(_1);
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:386:1: 386:33>::flush(_1: mapper::MapperFlush<S>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (_1.0: structures::paging::page::Page<S>);
        _3 = Page::<S>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = flush(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:386:1: 386:33>::ignore(_1: mapper::MapperFlush<S>) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:413:10: 413:15>::fmt(_1: &mapper::MapperFlushAll, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "MapperFlushAll";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:413:17: 413:24>::default() -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;
    let mut _1: ();

    bb0: {
        _1 = <() as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:417:1: 417:20>::new() -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:417:1: 417:20>::flush_all(_1: mapper::MapperFlushAll) -> () {
    debug self => const mapper::MapperFlushAll(());
    let mut _0: ();

    bb0: {
        _0 = flush_all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:417:1: 417:20>::ignore(_1: mapper::MapperFlushAll) -> () {
    debug self => const mapper::MapperFlushAll(());
    let mut _0: ();

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:440:10: 440:15>::fmt(_1: &mapper::MapToError<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &structures::paging::frame::PhysFrame<S>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = &(((*_1) as PageAlreadyMapped).0: structures::paging::frame::PhysFrame<S>);
        _7 = const "PageAlreadyMapped";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "FrameAllocationFailed";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _5 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:453:10: 453:15>::fmt(_1: &mapper::UnmapError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &addr::PhysAddr;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _7 = const "InvalidFrameAddress";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _5 = const "PageNotMapped";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:465:10: 465:15>::fmt(_1: &mapper::FlagUpdateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "ParentEntryHugePage";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "PageNotMapped";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/mapper/mod.rs:475:10: 475:15>::fmt(_1: &mapper::TranslateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &addr::PhysAddr;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _7 = const "InvalidFrameAddress";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "PageNotMapped";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _5 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

static _ASSERT_OBJECT_SAFE: Option<&dyn mapper::Translate + Sync> = {
    let mut _0: core::option::Option<&dyn structures::paging::mapper::Translate + core::marker::Sync>;

    bb0: {
        _0 = Option::<&dyn mapper::Translate + Sync>::None;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:10: 25:15>::fmt(_1: &page::Size4KiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:17: 25:22>::clone(_1: &page::Size4KiB) -> page::Size4KiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size4KiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:30: 25:39>::eq(_1: &page::Size4KiB, _2: &page::Size4KiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:41: 25:43>::assert_receiver_is_total_eq(_1: &page::Size4KiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:45: 25:55>::partial_cmp(_1: &page::Size4KiB, _2: &page::Size4KiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:25:57: 25:60>::cmp(_1: &page::Size4KiB, _2: &page::Size4KiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:10: 29:15>::fmt(_1: &page::Size2MiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:17: 29:22>::clone(_1: &page::Size2MiB) -> page::Size2MiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size2MiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:30: 29:39>::eq(_1: &page::Size2MiB, _2: &page::Size2MiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:41: 29:43>::assert_receiver_is_total_eq(_1: &page::Size2MiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:45: 29:55>::partial_cmp(_1: &page::Size2MiB, _2: &page::Size2MiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:29:57: 29:60>::cmp(_1: &page::Size2MiB, _2: &page::Size2MiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:10: 35:15>::fmt(_1: &page::Size1GiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:17: 35:22>::clone(_1: &page::Size1GiB) -> page::Size1GiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size1GiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:30: 35:39>::eq(_1: &page::Size1GiB, _2: &page::Size1GiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:41: 35:43>::assert_receiver_is_total_eq(_1: &page::Size1GiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:45: 35:55>::partial_cmp(_1: &page::Size1GiB, _2: &page::Size1GiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:35:57: 35:60>::cmp(_1: &page::Size1GiB, _2: &page::Size1GiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:38:1: 38:27>::SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 4096_u64;
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:38:1: 38:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "4KiB";
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:45:1: 45:27>::SIZE: u64 = {
    let mut _0: u64;
    let mut _1: (u64, bool);

    bb0: {
        _1 = CheckedMul(const _, const 512_u64);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 512_u64) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: u64);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:45:1: 45:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "2MiB";
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:52:1: 52:27>::SIZE: u64 = {
    let mut _0: u64;
    let mut _1: (u64, bool);

    bb0: {
        _1 = CheckedMul(const _, const 512_u64);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 512_u64) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: u64);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:52:1: 52:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "1GiB";
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:10: 58:15>::clone(_1: &Page<S>) -> Page<S> {
    debug self => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;
    let _3: &addr::VirtAddr;
    let mut _4: core::marker::PhantomData<S>;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _3 = &((*_1).0: addr::VirtAddr);
        _2 = <addr::VirtAddr as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _4 = <PhantomData<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Page::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:23: 58:32>::eq(_1: &Page<S>, _2: &Page<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &addr::VirtAddr;
    let mut _5: &addr::VirtAddr;
    let mut _6: &core::marker::PhantomData<S>;
    let mut _7: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: core::marker::PhantomData<S>);
        _7 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:34: 58:36>::assert_receiver_is_total_eq(_1: &Page<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:38: 58:48>::partial_cmp(_1: &Page<S>, _2: &Page<S>) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let mut _3: core::option::Option<core::cmp::Ordering>;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &core::marker::PhantomData<S>;
    let _9: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: core::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: core::marker::PhantomData<S>);
        _9 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:50: 58:53>::cmp(_1: &Page<S>, _2: &Page<S>) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let mut _3: core::cmp::Ordering;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;
    let mut _6: i8;
    let _7: &core::marker::PhantomData<S>;
    let _8: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Ord>::cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb4;
    }

    bb3: {
        _7 = &((*_1).1: core::marker::PhantomData<S>);
        _8 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Ord>::cmp(_7, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:58:55: 58:59>::hash(_1: &Page<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &addr::VirtAddr;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::from_start_address(_1: addr::VirtAddr) -> Result<Page<S>, AddressNotAligned> {
    debug address => _1;
    let mut _0: core::result::Result<structures::paging::page::Page<S>, structures::paging::page::AddressNotAligned>;
    let mut _2: bool;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        _2 = addr::VirtAddr::is_aligned::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = Page::<S>::containing_address(_1) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = Result::<Page<S>, AddressNotAligned>::Err(const AddressNotAligned);
        goto -> bb5;
    }

    bb4: {
        _0 = Result::<Page<S>, AddressNotAligned>::Ok(move _3);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::from_start_address_unchecked(_1: addr::VirtAddr) -> Page<S> {
    debug start_address => _1;
    let mut _0: structures::paging::page::Page<S>;

    bb0: {
        _0 = Page::<S> { start_address: _1, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::from_start_address_unchecked(_1: addr::VirtAddr) -> Page<S> {
    debug start_address => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;
    let mut _3: core::marker::PhantomData<S>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<S>;
        _0 = Page::<S> { start_address: move _2, size: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::containing_address(_1: addr::VirtAddr) -> Page<S> {
    debug address => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = addr::VirtAddr::align_down::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Page::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::start_address(_1: Page<S>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = (_1.0: addr::VirtAddr);
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::start_address(_1: Page<S>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = (_1.0: addr::VirtAddr);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::size(_1: Page<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::size(_1: Page<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::p4_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p4_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::p4_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p4_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::p3_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p3_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::p3_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p3_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::page_table_index(_1: Page<S>, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: addr::VirtAddr;

    bb0: {
        _3 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::page_table_index(move _3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::page_table_index(_1: Page<S>, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<S>;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        ConstEvalCounter;
        _3 = Page::<S>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _0 = addr::VirtAddr::page_table_index(move _3, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::range(_1: Page<S>, _2: Page<S>) -> PageRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRange<S>;

    bb0: {
        _0 = PageRange::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::range(_1: Page<S>, _2: Page<S>) -> PageRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRange<S>;
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PageRange::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::range_inclusive(_1: Page<S>, _2: Page<S>) -> PageRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;

    bb0: {
        _0 = PageRangeInclusive::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:65:1: 65:26>::range_inclusive(_1: Page<S>, _2: Page<S>) -> PageRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PageRangeInclusive::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:153:1: 153:34>::p2_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p2_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:153:1: 153:34>::p2_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p2_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:162:1: 162:20>::from_page_table_indices_1gib(_1: PageTableIndex, _2: PageTableIndex) -> Page<page::Size1GiB> {
    debug p4_index => _1;
    debug p3_index => _2;
    let mut _0: structures::paging::page::Page<structures::paging::page::Size1GiB>;
    let mut _3: u64;
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let _8: &mut u64;
    let mut _9: &mut u64;
    let mut _10: core::ops::Range<usize>;
    let mut _11: u64;
    let mut _12: addr::VirtAddr;
    let mut _13: u64;
    scope 1 {
        debug addr => _3;
    }

    bb0: {
        _3 = const 0_u64;
        _5 = &mut _3;
        _6 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _7 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &mut _3;
        _10 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _11 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <u64 as BitField>::set_bits::<Range<usize>>(move _9, move _10, move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = _3;
        _12 = addr::VirtAddr::new(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Page::<page::Size1GiB>::containing_address(move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:178:1: 178:20>::from_page_table_indices_2mib(_1: PageTableIndex, _2: PageTableIndex, _3: PageTableIndex) -> Page<page::Size2MiB> {
    debug p4_index => _1;
    debug p3_index => _2;
    debug p2_index => _3;
    let mut _0: structures::paging::page::Page<structures::paging::page::Size2MiB>;
    let mut _4: u64;
    let _5: &mut u64;
    let mut _6: &mut u64;
    let mut _7: core::ops::Range<usize>;
    let mut _8: u64;
    let _9: &mut u64;
    let mut _10: &mut u64;
    let mut _11: core::ops::Range<usize>;
    let mut _12: u64;
    let _13: &mut u64;
    let mut _14: &mut u64;
    let mut _15: core::ops::Range<usize>;
    let mut _16: u64;
    let mut _17: addr::VirtAddr;
    let mut _18: u64;
    scope 1 {
        debug addr => _4;
    }

    bb0: {
        _4 = const 0_u64;
        _6 = &mut _4;
        _7 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _8 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <u64 as BitField>::set_bits::<Range<usize>>(move _6, move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = &mut _4;
        _11 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _12 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = <u64 as BitField>::set_bits::<Range<usize>>(move _10, move _11, move _12) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _14 = &mut _4;
        _15 = Range::<usize> { start: const 21_usize, end: const 30_usize };
        _16 = <u64 as From<PageTableIndex>>::from(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = <u64 as BitField>::set_bits::<Range<usize>>(move _14, move _15, move _16) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _18 = _4;
        _17 = addr::VirtAddr::new(move _18) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Page::<page::Size2MiB>::containing_address(move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:196:1: 196:20>::from_page_table_indices(_1: PageTableIndex, _2: PageTableIndex, _3: PageTableIndex, _4: PageTableIndex) -> Page {
    debug p4_index => _1;
    debug p3_index => _2;
    debug p2_index => _3;
    debug p1_index => _4;
    let mut _0: structures::paging::page::Page;
    let mut _5: u64;
    let _6: &mut u64;
    let mut _7: &mut u64;
    let mut _8: core::ops::Range<usize>;
    let mut _9: u64;
    let _10: &mut u64;
    let mut _11: &mut u64;
    let mut _12: core::ops::Range<usize>;
    let mut _13: u64;
    let _14: &mut u64;
    let mut _15: &mut u64;
    let mut _16: core::ops::Range<usize>;
    let mut _17: u64;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::Range<usize>;
    let mut _21: u64;
    let mut _22: addr::VirtAddr;
    let mut _23: u64;
    scope 1 {
        debug addr => _5;
    }

    bb0: {
        _5 = const 0_u64;
        _7 = &mut _5;
        _8 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _9 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <u64 as BitField>::set_bits::<Range<usize>>(move _7, move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = &mut _5;
        _12 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _13 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = <u64 as BitField>::set_bits::<Range<usize>>(move _11, move _12, move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &mut _5;
        _16 = Range::<usize> { start: const 21_usize, end: const 30_usize };
        _17 = <u64 as From<PageTableIndex>>::from(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = <u64 as BitField>::set_bits::<Range<usize>>(move _15, move _16, move _17) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _19 = &mut _5;
        _20 = Range::<usize> { start: const 12_usize, end: const 21_usize };
        _21 = <u64 as From<PageTableIndex>>::from(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _18 = <u64 as BitField>::set_bits::<Range<usize>>(move _19, move _20, move _21) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _23 = _5;
        _22 = addr::VirtAddr::new(move _23) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = Page::containing_address(move _22) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:196:1: 196:20>::p1_index(_1: Page) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = (_1.0: addr::VirtAddr);
        _0 = addr::VirtAddr::p1_index(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:196:1: 196:20>::p1_index(_1: Page) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: addr::VirtAddr);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p1_index(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:222:1: 222:41>::fmt(_1: &Page<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &u64;
    let _11: u64;
    let mut _12: addr::VirtAddr;
    let mut _13: structures::paging::page::Page<S>;
    let mut _14: &[core::fmt::rt::Placeholder];
    let _15: &[core::fmt::rt::Placeholder; 2];
    let _16: [core::fmt::rt::Placeholder; 2];
    let mut _17: core::fmt::rt::Placeholder;
    let mut _18: core::fmt::rt::Alignment;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::Count;
    let mut _21: core::fmt::rt::Placeholder;
    let mut _22: core::fmt::rt::Alignment;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::Count;
    let mut _25: core::fmt::rt::UnsafeArg;
    let mut _26: &&str;
    let mut _27: &[&str; 3];
    scope 1 {
    }

    bb0: {
        _27 = const _;
        _4 = _27 as &[&str] (PointerCoercion(Unsize));
        _26 = const _;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _13 = (*_1);
        _12 = Page::<S>::start_address(move _13) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = addr::VirtAddr::as_u64(move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = [move _8, move _9];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = core::fmt::rt::Alignment::Unknown;
        _19 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Count::Implied;
        _17 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _18, const 0_u32, move _19, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = core::fmt::rt::Alignment::Unknown;
        _23 = core::fmt::rt::Count::Implied;
        _24 = core::fmt::rt::Count::Implied;
        _21 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _22, const 4_u32, move _23, move _24) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _16 = [move _17, move _21];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::UnsafeArg::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _14, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:222:1: 222:41>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:222:1: 222:41>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Page[", const "](", const ")"];
        _0 = &_1;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:232:1: 232:39>::add(_1: Page<S>, _2: u64) -> Page<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::page::Page<S>;
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:240:1: 240:45>::add_assign(_1: &mut Page<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (*_1);
        _3 = <Page<S> as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:247:1: 247:39>::sub(_1: Page<S>, _2: u64) -> Page<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::page::Page<S>;
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <addr::VirtAddr as Sub<u64>>::sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:255:1: 255:45>::sub_assign(_1: &mut Page<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (*_1);
        _3 = <Page<S> as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:262:1: 262:40>::sub(_1: Page<S>, _2: Page<S>) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: addr::VirtAddr;
    let mut _5: addr::VirtAddr;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: addr::VirtAddr);
        _5 = (_2.0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Sub>::sub(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Eq(const _, const 0_u64);
        assert(!move _6, "attempt to divide `{}` by zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Div(move _3, const _);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:271:1: 271:35>::steps_between(_1: &Page<S>, _2: &Page<S>) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;
    let mut _3: core::option::Option<usize>;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Step>::steps_between(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Option::<usize>::map::<usize, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:274:18: 274:25}>(move _3, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:274:18: 274:25}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:271:1: 271:35>::steps_between::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:274:18: 274:25}, _2: usize) -> usize {
    debug steps => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const _ as usize (IntToInt);
        _4 = Eq(_3, const 0_usize);
        assert(!move _4, "attempt to divide `{}` by zero", _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Div(_2, move _3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:271:1: 271:35>::forward_checked(_1: Page<S>, _2: usize) -> Option<Page<S>> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;
    let mut _4: core::option::Option<usize>;
    let mut _5: usize;
    let mut _6: isize;
    let _7: usize;
    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, addr::VirtAddr>;
    let mut _9: core::option::Option<addr::VirtAddr>;
    let mut _10: addr::VirtAddr;
    let mut _11: isize;
    let mut _13: structures::paging::page::Page<S>;
    scope 1 {
        debug count => _7;
        let _12: addr::VirtAddr;
        scope 6 {
            debug start_address => _12;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = const _ as usize (IntToInt);
        _4 = num::<impl usize>::checked_mul(_2, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <Option<usize> as Try>::branch(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: usize);
        _10 = (_1.0: addr::VirtAddr);
        _9 = <addr::VirtAddr as Step>::forward_checked(move _10, _7) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb10, unwind unreachable];
    }

    bb6: {
        _8 = <Option<addr::VirtAddr> as Try>::branch(move _9) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: addr::VirtAddr);
        _13 = Page::<S> { start_address: _12, size: const ZeroSized: PhantomData<S> };
        _0 = Option::<Page<S>>::Some(move _13);
        goto -> bb10;
    }

    bb9: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:271:1: 271:35>::backward_checked(_1: Page<S>, _2: usize) -> Option<Page<S>> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;
    let mut _4: core::option::Option<usize>;
    let mut _5: usize;
    let mut _6: isize;
    let _7: usize;
    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, addr::VirtAddr>;
    let mut _9: core::option::Option<addr::VirtAddr>;
    let mut _10: addr::VirtAddr;
    let mut _11: isize;
    let mut _13: structures::paging::page::Page<S>;
    scope 1 {
        debug count => _7;
        let _12: addr::VirtAddr;
        scope 6 {
            debug start_address => _12;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = const _ as usize (IntToInt);
        _4 = num::<impl usize>::checked_mul(_2, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <Option<usize> as Try>::branch(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: usize);
        _10 = (_1.0: addr::VirtAddr);
        _9 = <addr::VirtAddr as Step>::backward_checked(move _10, _7) -> [return: bb6, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb10, unwind unreachable];
    }

    bb6: {
        _8 = <Option<addr::VirtAddr> as Try>::branch(move _9) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: addr::VirtAddr);
        _13 = Page::<S> { start_address: _12, size: const ZeroSized: PhantomData<S> };
        _0 = Option::<Page<S>>::Some(move _13);
        goto -> bb10;
    }

    bb9: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:297:10: 297:15>::clone(_1: &PageRange<S>) -> PageRange<S> {
    debug self => _1;
    let mut _0: structures::paging::page::PageRange<S>;
    let mut _2: structures::paging::page::Page<S>;
    let _3: &structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _2 = <Page<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _4 = <Page<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PageRange::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:297:23: 297:32>::eq(_1: &PageRange<S>, _2: &PageRange<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page::Page<S>;
    let mut _5: &structures::paging::page::Page<S>;
    let mut _6: &structures::paging::page::Page<S>;
    let mut _7: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &((*_2).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::page::Page<S>);
        _7 = &((*_2).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:297:34: 297:36>::assert_receiver_is_total_eq(_1: &PageRange<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:297:38: 297:42>::hash(_1: &PageRange<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:306:1: 306:31>::is_empty(_1: &PageRange<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page::Page<S>;
    let mut _3: &structures::paging::page::Page<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialOrd>::ge(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:314:1: 314:44>::next(_1: &mut PageRange<S>) -> Option<Page<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::page::Page<S>;
    let mut _4: &structures::paging::page::Page<S>;
    let _5: structures::paging::page::Page<S>;
    let _6: ();
    let mut _7: &mut structures::paging::page::Page<S>;
    scope 1 {
        debug page => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _4 = &((*_1).1: structures::paging::page::Page<S>);
        _2 = <Page<S> as PartialOrd>::lt(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::page::Page<S>);
        _7 = &mut ((*_1).0: structures::paging::page::Page<S>);
        _6 = <Page<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<Page<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<Page<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:329:1: 329:25>::as_4kib_page_range(_1: PageRange<page::Size2MiB>) -> PageRange {
    debug self => _1;
    let mut _0: structures::paging::page::PageRange;
    let mut _2: structures::paging::page::Page;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<structures::paging::page::Size2MiB>;
    let mut _5: structures::paging::page::Page;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page<structures::paging::page::Size2MiB>;

    bb0: {
        _4 = (_1.0: structures::paging::page::Page<structures::paging::page::Size2MiB>);
        _3 = Page::<page::Size2MiB>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Page::containing_address(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = (_1.1: structures::paging::page::Page<structures::paging::page::Size2MiB>);
        _6 = Page::<page::Size2MiB>::start_address(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Page::containing_address(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = PageRange { start: move _2, end: move _5 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:340:1: 340:46>::fmt(_1: &PageRange<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::page::Page<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::page::Page<S>;

    bb0: {
        _7 = const "PageRange";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::page::Page<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::page::Page<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:350:10: 350:15>::clone(_1: &PageRangeInclusive<S>) -> PageRangeInclusive<S> {
    debug self => _1;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;
    let mut _2: structures::paging::page::Page<S>;
    let _3: &structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _2 = <Page<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _4 = <Page<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PageRangeInclusive::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:350:23: 350:32>::eq(_1: &PageRangeInclusive<S>, _2: &PageRangeInclusive<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page::Page<S>;
    let mut _5: &structures::paging::page::Page<S>;
    let mut _6: &structures::paging::page::Page<S>;
    let mut _7: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &((*_2).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::page::Page<S>);
        _7 = &((*_2).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:350:34: 350:36>::assert_receiver_is_total_eq(_1: &PageRangeInclusive<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:350:38: 350:42>::hash(_1: &PageRangeInclusive<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:359:1: 359:40>::is_empty(_1: &PageRangeInclusive<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page::Page<S>;
    let mut _3: &structures::paging::page::Page<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialOrd>::gt(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:367:1: 367:53>::next(_1: &mut PageRangeInclusive<S>) -> Option<Page<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::page::Page<S>;
    let mut _4: &structures::paging::page::Page<S>;
    let _5: structures::paging::page::Page<S>;
    let mut _7: addr::VirtAddr;
    let mut _8: u64;
    let mut _9: (u64, bool);
    let mut _10: bool;
    let mut _11: &addr::VirtAddr;
    let _12: addr::VirtAddr;
    let mut _13: structures::paging::page::Page<S>;
    let mut _14: &addr::VirtAddr;
    let _15: ();
    let mut _16: &mut structures::paging::page::Page<S>;
    let _17: ();
    let mut _18: &mut structures::paging::page::Page<S>;
    scope 1 {
        debug page => _5;
        let _6: addr::VirtAddr;
        scope 2 {
            debug max_page_addr => _6;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _4 = &((*_1).1: structures::paging::page::Page<S>);
        _2 = <Page<S> as PartialOrd>::le(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb11, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::page::Page<S>);
        _7 = addr::VirtAddr::new(const _) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: u64);
        _6 = <addr::VirtAddr as Sub<u64>>::sub(move _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = ((*_1).0: structures::paging::page::Page<S>);
        _12 = Page::<S>::start_address(move _13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = &_12;
        _14 = &_6;
        _10 = <addr::VirtAddr as PartialOrd>::lt(move _11, move _14) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _10) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _16 = &mut ((*_1).0: structures::paging::page::Page<S>);
        _15 = <Page<S> as AddAssign<u64>>::add_assign(move _16, const 1_u64) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _18 = &mut ((*_1).1: structures::paging::page::Page<S>);
        _17 = <Page<S> as SubAssign<u64>>::sub_assign(move _18, const 1_u64) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = Option::<Page<S>>::Some(_5);
        goto -> bb12;
    }

    bb11: {
        _0 = Option::<Page<S>>::None;
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:391:1: 391:55>::fmt(_1: &PageRangeInclusive<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::page::Page<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::page::Page<S>;

    bb0: {
        _7 = const "PageRangeInclusive";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::page::Page<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::page::Page<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:401:10: 401:15>::fmt(_1: &AddressNotAligned, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "AddressNotAligned";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:404:1: 404:40>::fmt(_1: &AddressNotAligned, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];

    bb0: {
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page.rs:404:1: 404:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "the given address was not sufficiently aligned"];
        _0 = &_1;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:12:10: 12:15>::fmt(_1: &FrameError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "HugeFrame";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "FrameNotPresent";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:12:17: 12:22>::clone(_1: &FrameError) -> FrameError {
    debug self => _1;
    let mut _0: structures::paging::page_table::FrameError;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:12:30: 12:39>::eq(_1: &FrameError, _2: &FrameError) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:22:10: 22:15>::clone(_1: &PageTableEntry) -> PageTableEntry {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableEntry;
    let mut _2: u64;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _2 = (*_3);
        _0 = PageTableEntry { entry: move _2 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::new() -> PageTableEntry {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        _0 = PageTableEntry { entry: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::new() -> PageTableEntry {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        _0 = PageTableEntry { entry: const 0_u64 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::is_unused(_1: &PageTableEntry) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::is_unused(_1: &PageTableEntry) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::set_unused(_1: &mut PageTableEntry) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: u64) = const 0_u64;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::flags(_1: &PageTableEntry) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = PageTableFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::flags(_1: &PageTableEntry) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = ((*_1).0: u64);
        ConstEvalCounter;
        _0 = PageTableFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::addr(_1: &PageTableEntry) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _2 = BitAnd(move _3, const 4503599627366400_u64);
        _0 = PhysAddr::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::frame(_1: &PageTableEntry) -> Result<PhysFrame, FrameError> {
    debug self => _1;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _2: bool;
    let mut _3: &structures::paging::page_table::PageTableFlags;
    let _4: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::FrameError;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableFlags;
    let _8: structures::paging::page_table::PageTableFlags;
    let mut _9: structures::paging::page_table::FrameError;
    let mut _10: structures::paging::frame::PhysFrame;
    let mut _11: addr::PhysAddr;

    bb0: {
        _4 = PageTableEntry::flags(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = PageTableFlags::contains(move _3, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _8 = PageTableEntry::flags(_1) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _5 = FrameError::FrameNotPresent;
        _0 = Result::<PhysFrame, FrameError>::Err(move _5);
        goto -> bb11;
    }

    bb5: {
        _7 = &_8;
        _6 = PageTableFlags::contains(move _7, const _) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(move _6) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _9 = FrameError::HugeFrame;
        _0 = Result::<PhysFrame, FrameError>::Err(move _9);
        goto -> bb11;
    }

    bb8: {
        _11 = PageTableEntry::addr(_1) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = PhysFrame::containing_address(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = Result::<PhysFrame, FrameError>::Ok(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::set_addr(_1: &mut PageTableEntry, _2: PhysAddr, _3: PageTableFlags) -> () {
    debug self => _1;
    debug addr => _2;
    debug flags => _3;
    let mut _0: ();
    let mut _4: bool;
    let mut _5: !;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _4 = PhysAddr::is_aligned::<u64>(_2, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = PhysAddr::as_u64(_2) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _5 = panic(const "assertion failed: addr.is_aligned(Size4KiB::SIZE)") -> unwind unreachable;
    }

    bb4: {
        _8 = &_3;
        _7 = PageTableFlags::bits(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        ((*_1).0: u64) = BitOr(move _6, move _7);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::set_frame(_1: &mut PageTableEntry, _2: PhysFrame, _3: PageTableFlags) -> () {
    debug self => _1;
    debug frame => _2;
    debug flags => _3;
    let mut _0: ();
    let mut _4: bool;
    let mut _5: &structures::paging::page_table::PageTableFlags;
    let mut _6: !;
    let mut _7: addr::PhysAddr;
    let mut _8: structures::paging::page_table::PageTableFlags;

    bb0: {
        _5 = &_3;
        _4 = PageTableFlags::contains(move _5, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = panic(const "assertion failed: !flags.contains(PageTableFlags::HUGE_PAGE)") -> unwind unreachable;
    }

    bb3: {
        _7 = PhysFrame::start_address(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = _3;
        _0 = PageTableEntry::set_addr(_1, move _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:28:1: 28:20>::set_flags(_1: &mut PageTableEntry, _2: PageTableFlags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: addr::PhysAddr;
    let mut _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _5 = &(*_1);
        _4 = PageTableEntry::addr(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = PhysAddr::as_u64(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = &_2;
        _6 = PageTableFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        ((*_1).0: u64) = BitOr(move _3, move _6);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:98:1: 98:35>::fmt(_1: &PageTableEntry, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &addr::PhysAddr;
    let _10: addr::PhysAddr;
    let _11: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::paging::page_table::PageTableFlags;
    let _16: structures::paging::page_table::PageTableFlags;
    let mut _17: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug f => _3;
    }

    bb0: {
        _4 = const "PageTableEntry";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "addr";
        _10 = PageTableEntry::addr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &mut _3;
        _13 = const "flags";
        _16 = PageTableEntry::flags(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = DebugStruct::<'_, '_>::field(move _12, _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _17 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _17) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:24: 363:33>::eq(_1: &PageTableFlags, _2: &PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:35: 363:37>::assert_receiver_is_total_eq(_1: &PageTableFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:39: 363:44>::clone(_1: &PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:46: 363:56>::partial_cmp(_1: &PageTableFlags, _2: &PageTableFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:58: 363:61>::cmp(_1: &PageTableFlags, _2: &PageTableFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:363:63: 363:67>::hash(_1: &PageTableFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _11: core::result::Result<(), core::fmt::Error>;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _17: core::result::Result<(), core::fmt::Error>;
    let _18: &str;
    let mut _19: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _21: core::result::Result<(), core::fmt::Error>;
    let _22: &str;
    let mut _23: isize;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _27: core::result::Result<(), core::fmt::Error>;
    let _28: &str;
    let mut _29: isize;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _31: core::result::Result<(), core::fmt::Error>;
    let _32: &str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _37: core::result::Result<(), core::fmt::Error>;
    let _38: &str;
    let mut _39: isize;
    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _41: core::result::Result<(), core::fmt::Error>;
    let _42: &str;
    let mut _43: isize;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _47: core::result::Result<(), core::fmt::Error>;
    let _48: &str;
    let mut _49: isize;
    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _51: core::result::Result<(), core::fmt::Error>;
    let _52: &str;
    let mut _53: isize;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _57: core::result::Result<(), core::fmt::Error>;
    let _58: &str;
    let mut _59: isize;
    let mut _60: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _61: core::result::Result<(), core::fmt::Error>;
    let _62: &str;
    let mut _63: isize;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _67: core::result::Result<(), core::fmt::Error>;
    let _68: &str;
    let mut _69: isize;
    let mut _70: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _71: core::result::Result<(), core::fmt::Error>;
    let _72: &str;
    let mut _73: isize;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _77: core::result::Result<(), core::fmt::Error>;
    let _78: &str;
    let mut _79: isize;
    let mut _80: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _81: core::result::Result<(), core::fmt::Error>;
    let _82: &str;
    let mut _83: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _87: core::result::Result<(), core::fmt::Error>;
    let _88: &str;
    let mut _89: isize;
    let mut _90: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _91: core::result::Result<(), core::fmt::Error>;
    let _92: &str;
    let mut _93: isize;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _97: core::result::Result<(), core::fmt::Error>;
    let _98: &str;
    let mut _99: isize;
    let mut _100: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _101: core::result::Result<(), core::fmt::Error>;
    let _102: &str;
    let mut _103: isize;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _107: core::result::Result<(), core::fmt::Error>;
    let _108: &str;
    let mut _109: isize;
    let mut _110: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _111: core::result::Result<(), core::fmt::Error>;
    let _112: &str;
    let mut _113: isize;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _117: core::result::Result<(), core::fmt::Error>;
    let _118: &str;
    let mut _119: isize;
    let mut _120: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _121: core::result::Result<(), core::fmt::Error>;
    let _122: &str;
    let mut _123: isize;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _127: core::result::Result<(), core::fmt::Error>;
    let _128: &str;
    let mut _129: isize;
    let mut _130: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _131: core::result::Result<(), core::fmt::Error>;
    let _132: &str;
    let mut _133: isize;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _137: core::result::Result<(), core::fmt::Error>;
    let _138: &str;
    let mut _139: isize;
    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _141: core::result::Result<(), core::fmt::Error>;
    let _142: &str;
    let mut _143: isize;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _147: core::result::Result<(), core::fmt::Error>;
    let _148: &str;
    let mut _149: isize;
    let mut _150: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _151: core::result::Result<(), core::fmt::Error>;
    let _152: &str;
    let mut _153: isize;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _157: core::result::Result<(), core::fmt::Error>;
    let _158: &str;
    let mut _159: isize;
    let mut _160: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _161: core::result::Result<(), core::fmt::Error>;
    let _162: &str;
    let mut _163: isize;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _167: core::result::Result<(), core::fmt::Error>;
    let _168: &str;
    let mut _169: isize;
    let mut _170: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _171: core::result::Result<(), core::fmt::Error>;
    let _172: &str;
    let mut _173: isize;
    let mut _174: bool;
    let mut _175: bool;
    let mut _176: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _177: core::result::Result<(), core::fmt::Error>;
    let _178: &str;
    let mut _179: isize;
    let mut _180: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _181: core::result::Result<(), core::fmt::Error>;
    let _182: &str;
    let mut _183: isize;
    let mut _184: bool;
    let mut _185: bool;
    let mut _186: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _187: core::result::Result<(), core::fmt::Error>;
    let _188: &str;
    let mut _189: isize;
    let mut _190: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _191: core::result::Result<(), core::fmt::Error>;
    let _192: &str;
    let mut _193: isize;
    let mut _194: bool;
    let mut _195: bool;
    let mut _196: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _197: core::result::Result<(), core::fmt::Error>;
    let _198: &str;
    let mut _199: isize;
    let mut _200: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _201: core::result::Result<(), core::fmt::Error>;
    let _202: &str;
    let mut _203: isize;
    let mut _204: bool;
    let mut _205: bool;
    let mut _206: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _207: core::result::Result<(), core::fmt::Error>;
    let _208: &str;
    let mut _209: isize;
    let mut _210: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _211: core::result::Result<(), core::fmt::Error>;
    let _212: &str;
    let mut _213: isize;
    let mut _214: bool;
    let mut _215: bool;
    let mut _216: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _217: core::result::Result<(), core::fmt::Error>;
    let _218: &str;
    let mut _219: isize;
    let mut _220: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _221: core::result::Result<(), core::fmt::Error>;
    let _222: &str;
    let mut _223: isize;
    let mut _224: bool;
    let mut _225: bool;
    let mut _226: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _227: core::result::Result<(), core::fmt::Error>;
    let _228: &str;
    let mut _229: isize;
    let mut _230: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _231: core::result::Result<(), core::fmt::Error>;
    let _232: &str;
    let mut _233: isize;
    let mut _234: bool;
    let mut _235: bool;
    let mut _236: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _237: core::result::Result<(), core::fmt::Error>;
    let _238: &str;
    let mut _239: isize;
    let mut _240: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _241: core::result::Result<(), core::fmt::Error>;
    let _242: &str;
    let mut _243: isize;
    let mut _245: u64;
    let mut _246: u64;
    let mut _247: u64;
    let mut _248: &structures::paging::page_table::PageTableFlags;
    let _249: structures::paging::page_table::PageTableFlags;
    let mut _250: u64;
    let mut _251: bool;
    let mut _252: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _253: core::result::Result<(), core::fmt::Error>;
    let _254: &str;
    let mut _255: isize;
    let mut _256: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _257: core::result::Result<(), core::fmt::Error>;
    let _258: &str;
    let mut _259: isize;
    let mut _260: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _261: core::result::Result<(), core::fmt::Error>;
    let _262: &u64;
    let mut _263: isize;
    let mut _264: bool;
    let mut _265: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;
    let mut _266: core::result::Result<(), core::fmt::Error>;
    let _267: &str;
    let mut _268: isize;
    scope 1 {
        debug first => _3;
        let _244: u64;
        scope 2 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
        scope 18 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 19 {
            }
        }
        scope 20 {
            debug val => const ();
            scope 21 {
            }
        }
        scope 22 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 23 {
            }
        }
        scope 24 {
            debug val => const ();
            scope 25 {
            }
        }
        scope 26 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 27 {
            }
        }
        scope 28 {
            debug val => const ();
            scope 29 {
            }
        }
        scope 30 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 31 {
            }
        }
        scope 32 {
            debug val => const ();
            scope 33 {
            }
        }
        scope 34 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 35 {
            }
        }
        scope 36 {
            debug val => const ();
            scope 37 {
            }
        }
        scope 38 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 39 {
            }
        }
        scope 40 {
            debug val => const ();
            scope 41 {
            }
        }
        scope 42 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 43 {
            }
        }
        scope 44 {
            debug val => const ();
            scope 45 {
            }
        }
        scope 46 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 47 {
            }
        }
        scope 48 {
            debug val => const ();
            scope 49 {
            }
        }
        scope 50 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 51 {
            }
        }
        scope 52 {
            debug val => const ();
            scope 53 {
            }
        }
        scope 54 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 55 {
            }
        }
        scope 56 {
            debug val => const ();
            scope 57 {
            }
        }
        scope 58 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 59 {
            }
        }
        scope 60 {
            debug val => const ();
            scope 61 {
            }
        }
        scope 62 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 63 {
            }
        }
        scope 64 {
            debug val => const ();
            scope 65 {
            }
        }
        scope 66 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 67 {
            }
        }
        scope 68 {
            debug val => const ();
            scope 69 {
            }
        }
        scope 70 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 71 {
            }
        }
        scope 72 {
            debug val => const ();
            scope 73 {
            }
        }
        scope 74 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 75 {
            }
        }
        scope 76 {
            debug val => const ();
            scope 77 {
            }
        }
        scope 78 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 79 {
            }
        }
        scope 80 {
            debug val => const ();
            scope 81 {
            }
        }
        scope 82 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 83 {
            }
        }
        scope 84 {
            debug val => const ();
            scope 85 {
            }
        }
        scope 86 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 87 {
            }
        }
        scope 88 {
            debug val => const ();
            scope 89 {
            }
        }
        scope 90 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 91 {
            }
        }
        scope 92 {
            debug val => const ();
            scope 93 {
            }
        }
        scope 94 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 95 {
            }
        }
        scope 96 {
            debug val => const ();
            scope 97 {
            }
        }
        scope 98 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 99 {
            }
        }
        scope 100 {
            debug val => const ();
            scope 101 {
            }
        }
        scope 102 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 103 {
            }
        }
        scope 104 {
            debug val => const ();
            scope 105 {
            }
        }
        scope 106 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 107 {
            }
        }
        scope 108 {
            debug val => const ();
            scope 109 {
            }
        }
        scope 110 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 111 {
            }
        }
        scope 112 {
            debug val => const ();
            scope 113 {
            }
        }
        scope 114 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 115 {
            }
        }
        scope 116 {
            debug val => const ();
            scope 117 {
            }
        }
        scope 118 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 119 {
            }
        }
        scope 120 {
            debug val => const ();
            scope 121 {
            }
        }
        scope 122 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 123 {
            }
        }
        scope 124 {
            debug val => const ();
            scope 125 {
            }
        }
        scope 126 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 127 {
            }
        }
        scope 128 {
            debug val => const ();
            scope 129 {
            }
        }
        scope 130 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 131 {
            }
        }
        scope 132 {
            debug val => const ();
            scope 133 {
            }
        }
        scope 134 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 135 {
            }
        }
        scope 136 {
            debug val => const ();
            scope 137 {
            }
        }
        scope 138 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 139 {
            }
        }
        scope 140 {
            debug val => const ();
            scope 141 {
            }
        }
        scope 142 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 143 {
            }
        }
        scope 144 {
            debug val => const ();
            scope 145 {
            }
        }
        scope 146 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 147 {
            }
        }
        scope 148 {
            debug val => const ();
            scope 149 {
            }
        }
        scope 150 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 151 {
            }
        }
        scope 152 {
            debug val => const ();
            scope 153 {
            }
        }
        scope 154 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 155 {
            }
        }
        scope 156 {
            debug val => const ();
            scope 157 {
            }
        }
        scope 158 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 159 {
            }
        }
        scope 160 {
            debug val => const ();
            scope 161 {
            }
        }
        scope 162 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 163 {
            }
        }
        scope 164 {
            debug val => const ();
            scope 165 {
            }
        }
        scope 166 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 167 {
            }
        }
        scope 168 {
            debug val => const ();
            scope 169 {
            }
        }
        scope 170 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 171 {
            }
        }
        scope 172 {
            debug val => const ();
            scope 173 {
            }
        }
        scope 174 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 175 {
            }
        }
        scope 176 {
            debug val => const ();
            scope 177 {
            }
        }
        scope 178 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 179 {
            }
        }
        scope 180 {
            debug val => const ();
            scope 181 {
            }
        }
        scope 182 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 183 {
            }
        }
        scope 184 {
            debug val => const ();
            scope 185 {
            }
        }
        scope 186 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 187 {
            }
        }
        scope 188 {
            debug val => const ();
            scope 189 {
            }
        }
        scope 190 {
            debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
            scope 191 {
            }
        }
        scope 192 {
            debug val => const ();
            scope 193 {
            }
        }
        scope 194 {
            debug extra_bits => _244;
            scope 195 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 196 {
                }
            }
            scope 197 {
                debug val => const ();
                scope 198 {
                }
            }
            scope 199 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 200 {
                }
            }
            scope 201 {
                debug val => const ();
                scope 202 {
                }
            }
            scope 203 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 204 {
                }
            }
            scope 205 {
                debug val => const ();
                scope 206 {
                }
            }
            scope 207 {
                debug residual => const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error);
                scope 208 {
                }
            }
            scope 209 {
                debug val => const ();
                scope 210 {
                }
            }
        }
    }

    bb0: {
        _3 = const true;
        _4 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::PRESENT(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb12, otherwise: bb2];
    }

    bb2: {
        _5 = _3;
        switchInt(move _5) -> [0: bb3, otherwise: bb8];
    }

    bb3: {
        _8 = const " | ";
        _7 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _6 = <Result<(), core::fmt::Error> as Try>::branch(move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb8, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb8: {
        _3 = const false;
        _12 = const "PRESENT";
        _11 = Formatter::<'_>::write_str(_2, _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = <Result<(), core::fmt::Error> as Try>::branch(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb12, 1: bb11, otherwise: bb6];
    }

    bb11: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb12: {
        _14 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::WRITABLE(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _14) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _15 = _3;
        switchInt(move _15) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _18 = const " | ";
        _17 = Formatter::<'_>::write_str(_2, _18) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _16 = <Result<(), core::fmt::Error> as Try>::branch(move _17) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb19, 1: bb18, otherwise: bb6];
    }

    bb18: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb19: {
        _3 = const false;
        _22 = const "WRITABLE";
        _21 = Formatter::<'_>::write_str(_2, _22) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _20 = <Result<(), core::fmt::Error> as Try>::branch(move _21) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb23, 1: bb22, otherwise: bb6];
    }

    bb22: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb23: {
        _24 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::USER_ACCESSIBLE(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _24) -> [0: bb34, otherwise: bb25];
    }

    bb25: {
        _25 = _3;
        switchInt(move _25) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _28 = const " | ";
        _27 = Formatter::<'_>::write_str(_2, _28) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _26 = <Result<(), core::fmt::Error> as Try>::branch(move _27) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb30, 1: bb29, otherwise: bb6];
    }

    bb29: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb30: {
        _3 = const false;
        _32 = const "USER_ACCESSIBLE";
        _31 = Formatter::<'_>::write_str(_2, _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _30 = <Result<(), core::fmt::Error> as Try>::branch(move _31) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb34: {
        _34 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::WRITE_THROUGH(_1) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        switchInt(move _34) -> [0: bb45, otherwise: bb36];
    }

    bb36: {
        _35 = _3;
        switchInt(move _35) -> [0: bb37, otherwise: bb41];
    }

    bb37: {
        _38 = const " | ";
        _37 = Formatter::<'_>::write_str(_2, _38) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _36 = <Result<(), core::fmt::Error> as Try>::branch(move _37) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb41, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb41: {
        _3 = const false;
        _42 = const "WRITE_THROUGH";
        _41 = Formatter::<'_>::write_str(_2, _42) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _40 = <Result<(), core::fmt::Error> as Try>::branch(move _41) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _43 = discriminant(_40);
        switchInt(move _43) -> [0: bb45, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb45: {
        _44 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::NO_CACHE(_1) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _44) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _45 = _3;
        switchInt(move _45) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _48 = const " | ";
        _47 = Formatter::<'_>::write_str(_2, _48) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _46 = <Result<(), core::fmt::Error> as Try>::branch(move _47) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _49 = discriminant(_46);
        switchInt(move _49) -> [0: bb52, 1: bb51, otherwise: bb6];
    }

    bb51: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb52: {
        _3 = const false;
        _52 = const "NO_CACHE";
        _51 = Formatter::<'_>::write_str(_2, _52) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _50 = <Result<(), core::fmt::Error> as Try>::branch(move _51) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _53 = discriminant(_50);
        switchInt(move _53) -> [0: bb56, 1: bb55, otherwise: bb6];
    }

    bb55: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb56: {
        _54 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::ACCESSED(_1) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _54) -> [0: bb67, otherwise: bb58];
    }

    bb58: {
        _55 = _3;
        switchInt(move _55) -> [0: bb59, otherwise: bb63];
    }

    bb59: {
        _58 = const " | ";
        _57 = Formatter::<'_>::write_str(_2, _58) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _56 = <Result<(), core::fmt::Error> as Try>::branch(move _57) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _59 = discriminant(_56);
        switchInt(move _59) -> [0: bb63, 1: bb62, otherwise: bb6];
    }

    bb62: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb63: {
        _3 = const false;
        _62 = const "ACCESSED";
        _61 = Formatter::<'_>::write_str(_2, _62) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _60 = <Result<(), core::fmt::Error> as Try>::branch(move _61) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _63 = discriminant(_60);
        switchInt(move _63) -> [0: bb67, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb67: {
        _64 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::DIRTY(_1) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        switchInt(move _64) -> [0: bb78, otherwise: bb69];
    }

    bb69: {
        _65 = _3;
        switchInt(move _65) -> [0: bb70, otherwise: bb74];
    }

    bb70: {
        _68 = const " | ";
        _67 = Formatter::<'_>::write_str(_2, _68) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _66 = <Result<(), core::fmt::Error> as Try>::branch(move _67) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb74, 1: bb73, otherwise: bb6];
    }

    bb73: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb74: {
        _3 = const false;
        _72 = const "DIRTY";
        _71 = Formatter::<'_>::write_str(_2, _72) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _70 = <Result<(), core::fmt::Error> as Try>::branch(move _71) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _73 = discriminant(_70);
        switchInt(move _73) -> [0: bb78, 1: bb77, otherwise: bb6];
    }

    bb77: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb78: {
        _74 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::HUGE_PAGE(_1) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        switchInt(move _74) -> [0: bb89, otherwise: bb80];
    }

    bb80: {
        _75 = _3;
        switchInt(move _75) -> [0: bb81, otherwise: bb85];
    }

    bb81: {
        _78 = const " | ";
        _77 = Formatter::<'_>::write_str(_2, _78) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _76 = <Result<(), core::fmt::Error> as Try>::branch(move _77) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _79 = discriminant(_76);
        switchInt(move _79) -> [0: bb85, 1: bb84, otherwise: bb6];
    }

    bb84: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb85: {
        _3 = const false;
        _82 = const "HUGE_PAGE";
        _81 = Formatter::<'_>::write_str(_2, _82) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _80 = <Result<(), core::fmt::Error> as Try>::branch(move _81) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _83 = discriminant(_80);
        switchInt(move _83) -> [0: bb89, 1: bb88, otherwise: bb6];
    }

    bb88: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb89: {
        _84 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::GLOBAL(_1) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        switchInt(move _84) -> [0: bb100, otherwise: bb91];
    }

    bb91: {
        _85 = _3;
        switchInt(move _85) -> [0: bb92, otherwise: bb96];
    }

    bb92: {
        _88 = const " | ";
        _87 = Formatter::<'_>::write_str(_2, _88) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _86 = <Result<(), core::fmt::Error> as Try>::branch(move _87) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _89 = discriminant(_86);
        switchInt(move _89) -> [0: bb96, 1: bb95, otherwise: bb6];
    }

    bb95: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb96: {
        _3 = const false;
        _92 = const "GLOBAL";
        _91 = Formatter::<'_>::write_str(_2, _92) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _90 = <Result<(), core::fmt::Error> as Try>::branch(move _91) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _93 = discriminant(_90);
        switchInt(move _93) -> [0: bb100, 1: bb99, otherwise: bb6];
    }

    bb99: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb100: {
        _94 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_9(_1) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        switchInt(move _94) -> [0: bb111, otherwise: bb102];
    }

    bb102: {
        _95 = _3;
        switchInt(move _95) -> [0: bb103, otherwise: bb107];
    }

    bb103: {
        _98 = const " | ";
        _97 = Formatter::<'_>::write_str(_2, _98) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _96 = <Result<(), core::fmt::Error> as Try>::branch(move _97) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _99 = discriminant(_96);
        switchInt(move _99) -> [0: bb107, 1: bb106, otherwise: bb6];
    }

    bb106: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb107: {
        _3 = const false;
        _102 = const "BIT_9";
        _101 = Formatter::<'_>::write_str(_2, _102) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _100 = <Result<(), core::fmt::Error> as Try>::branch(move _101) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _103 = discriminant(_100);
        switchInt(move _103) -> [0: bb111, 1: bb110, otherwise: bb6];
    }

    bb110: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb111: {
        _104 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_10(_1) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        switchInt(move _104) -> [0: bb122, otherwise: bb113];
    }

    bb113: {
        _105 = _3;
        switchInt(move _105) -> [0: bb114, otherwise: bb118];
    }

    bb114: {
        _108 = const " | ";
        _107 = Formatter::<'_>::write_str(_2, _108) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _106 = <Result<(), core::fmt::Error> as Try>::branch(move _107) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _109 = discriminant(_106);
        switchInt(move _109) -> [0: bb118, 1: bb117, otherwise: bb6];
    }

    bb117: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb118: {
        _3 = const false;
        _112 = const "BIT_10";
        _111 = Formatter::<'_>::write_str(_2, _112) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _110 = <Result<(), core::fmt::Error> as Try>::branch(move _111) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _113 = discriminant(_110);
        switchInt(move _113) -> [0: bb122, 1: bb121, otherwise: bb6];
    }

    bb121: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb122: {
        _114 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_11(_1) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _114) -> [0: bb133, otherwise: bb124];
    }

    bb124: {
        _115 = _3;
        switchInt(move _115) -> [0: bb125, otherwise: bb129];
    }

    bb125: {
        _118 = const " | ";
        _117 = Formatter::<'_>::write_str(_2, _118) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _116 = <Result<(), core::fmt::Error> as Try>::branch(move _117) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _119 = discriminant(_116);
        switchInt(move _119) -> [0: bb129, 1: bb128, otherwise: bb6];
    }

    bb128: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb129: {
        _3 = const false;
        _122 = const "BIT_11";
        _121 = Formatter::<'_>::write_str(_2, _122) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _120 = <Result<(), core::fmt::Error> as Try>::branch(move _121) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _123 = discriminant(_120);
        switchInt(move _123) -> [0: bb133, 1: bb132, otherwise: bb6];
    }

    bb132: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb133: {
        _124 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_52(_1) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        switchInt(move _124) -> [0: bb144, otherwise: bb135];
    }

    bb135: {
        _125 = _3;
        switchInt(move _125) -> [0: bb136, otherwise: bb140];
    }

    bb136: {
        _128 = const " | ";
        _127 = Formatter::<'_>::write_str(_2, _128) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _126 = <Result<(), core::fmt::Error> as Try>::branch(move _127) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _129 = discriminant(_126);
        switchInt(move _129) -> [0: bb140, 1: bb139, otherwise: bb6];
    }

    bb139: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb140: {
        _3 = const false;
        _132 = const "BIT_52";
        _131 = Formatter::<'_>::write_str(_2, _132) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _130 = <Result<(), core::fmt::Error> as Try>::branch(move _131) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _133 = discriminant(_130);
        switchInt(move _133) -> [0: bb144, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb144: {
        _134 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_53(_1) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        switchInt(move _134) -> [0: bb155, otherwise: bb146];
    }

    bb146: {
        _135 = _3;
        switchInt(move _135) -> [0: bb147, otherwise: bb151];
    }

    bb147: {
        _138 = const " | ";
        _137 = Formatter::<'_>::write_str(_2, _138) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _136 = <Result<(), core::fmt::Error> as Try>::branch(move _137) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _139 = discriminant(_136);
        switchInt(move _139) -> [0: bb151, 1: bb150, otherwise: bb6];
    }

    bb150: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb151: {
        _3 = const false;
        _142 = const "BIT_53";
        _141 = Formatter::<'_>::write_str(_2, _142) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _140 = <Result<(), core::fmt::Error> as Try>::branch(move _141) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb155, 1: bb154, otherwise: bb6];
    }

    bb154: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb155: {
        _144 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_54(_1) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        switchInt(move _144) -> [0: bb166, otherwise: bb157];
    }

    bb157: {
        _145 = _3;
        switchInt(move _145) -> [0: bb158, otherwise: bb162];
    }

    bb158: {
        _148 = const " | ";
        _147 = Formatter::<'_>::write_str(_2, _148) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _146 = <Result<(), core::fmt::Error> as Try>::branch(move _147) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _149 = discriminant(_146);
        switchInt(move _149) -> [0: bb162, 1: bb161, otherwise: bb6];
    }

    bb161: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb162: {
        _3 = const false;
        _152 = const "BIT_54";
        _151 = Formatter::<'_>::write_str(_2, _152) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _150 = <Result<(), core::fmt::Error> as Try>::branch(move _151) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _153 = discriminant(_150);
        switchInt(move _153) -> [0: bb166, 1: bb165, otherwise: bb6];
    }

    bb165: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb166: {
        _154 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_55(_1) -> [return: bb167, unwind unreachable];
    }

    bb167: {
        switchInt(move _154) -> [0: bb177, otherwise: bb168];
    }

    bb168: {
        _155 = _3;
        switchInt(move _155) -> [0: bb169, otherwise: bb173];
    }

    bb169: {
        _158 = const " | ";
        _157 = Formatter::<'_>::write_str(_2, _158) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _156 = <Result<(), core::fmt::Error> as Try>::branch(move _157) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _159 = discriminant(_156);
        switchInt(move _159) -> [0: bb173, 1: bb172, otherwise: bb6];
    }

    bb172: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb173: {
        _3 = const false;
        _162 = const "BIT_55";
        _161 = Formatter::<'_>::write_str(_2, _162) -> [return: bb174, unwind unreachable];
    }

    bb174: {
        _160 = <Result<(), core::fmt::Error> as Try>::branch(move _161) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _163 = discriminant(_160);
        switchInt(move _163) -> [0: bb177, 1: bb176, otherwise: bb6];
    }

    bb176: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb177: {
        _164 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_56(_1) -> [return: bb178, unwind unreachable];
    }

    bb178: {
        switchInt(move _164) -> [0: bb188, otherwise: bb179];
    }

    bb179: {
        _165 = _3;
        switchInt(move _165) -> [0: bb180, otherwise: bb184];
    }

    bb180: {
        _168 = const " | ";
        _167 = Formatter::<'_>::write_str(_2, _168) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _166 = <Result<(), core::fmt::Error> as Try>::branch(move _167) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _169 = discriminant(_166);
        switchInt(move _169) -> [0: bb184, 1: bb183, otherwise: bb6];
    }

    bb183: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb184: {
        _3 = const false;
        _172 = const "BIT_56";
        _171 = Formatter::<'_>::write_str(_2, _172) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _170 = <Result<(), core::fmt::Error> as Try>::branch(move _171) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _173 = discriminant(_170);
        switchInt(move _173) -> [0: bb188, 1: bb187, otherwise: bb6];
    }

    bb187: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb188: {
        _174 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_57(_1) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        switchInt(move _174) -> [0: bb199, otherwise: bb190];
    }

    bb190: {
        _175 = _3;
        switchInt(move _175) -> [0: bb191, otherwise: bb195];
    }

    bb191: {
        _178 = const " | ";
        _177 = Formatter::<'_>::write_str(_2, _178) -> [return: bb192, unwind unreachable];
    }

    bb192: {
        _176 = <Result<(), core::fmt::Error> as Try>::branch(move _177) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _179 = discriminant(_176);
        switchInt(move _179) -> [0: bb195, 1: bb194, otherwise: bb6];
    }

    bb194: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb195: {
        _3 = const false;
        _182 = const "BIT_57";
        _181 = Formatter::<'_>::write_str(_2, _182) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _180 = <Result<(), core::fmt::Error> as Try>::branch(move _181) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        _183 = discriminant(_180);
        switchInt(move _183) -> [0: bb199, 1: bb198, otherwise: bb6];
    }

    bb198: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb199: {
        _184 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_58(_1) -> [return: bb200, unwind unreachable];
    }

    bb200: {
        switchInt(move _184) -> [0: bb210, otherwise: bb201];
    }

    bb201: {
        _185 = _3;
        switchInt(move _185) -> [0: bb202, otherwise: bb206];
    }

    bb202: {
        _188 = const " | ";
        _187 = Formatter::<'_>::write_str(_2, _188) -> [return: bb203, unwind unreachable];
    }

    bb203: {
        _186 = <Result<(), core::fmt::Error> as Try>::branch(move _187) -> [return: bb204, unwind unreachable];
    }

    bb204: {
        _189 = discriminant(_186);
        switchInt(move _189) -> [0: bb206, 1: bb205, otherwise: bb6];
    }

    bb205: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb206: {
        _3 = const false;
        _192 = const "BIT_58";
        _191 = Formatter::<'_>::write_str(_2, _192) -> [return: bb207, unwind unreachable];
    }

    bb207: {
        _190 = <Result<(), core::fmt::Error> as Try>::branch(move _191) -> [return: bb208, unwind unreachable];
    }

    bb208: {
        _193 = discriminant(_190);
        switchInt(move _193) -> [0: bb210, 1: bb209, otherwise: bb6];
    }

    bb209: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb210: {
        _194 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_59(_1) -> [return: bb211, unwind unreachable];
    }

    bb211: {
        switchInt(move _194) -> [0: bb221, otherwise: bb212];
    }

    bb212: {
        _195 = _3;
        switchInt(move _195) -> [0: bb213, otherwise: bb217];
    }

    bb213: {
        _198 = const " | ";
        _197 = Formatter::<'_>::write_str(_2, _198) -> [return: bb214, unwind unreachable];
    }

    bb214: {
        _196 = <Result<(), core::fmt::Error> as Try>::branch(move _197) -> [return: bb215, unwind unreachable];
    }

    bb215: {
        _199 = discriminant(_196);
        switchInt(move _199) -> [0: bb217, 1: bb216, otherwise: bb6];
    }

    bb216: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb217: {
        _3 = const false;
        _202 = const "BIT_59";
        _201 = Formatter::<'_>::write_str(_2, _202) -> [return: bb218, unwind unreachable];
    }

    bb218: {
        _200 = <Result<(), core::fmt::Error> as Try>::branch(move _201) -> [return: bb219, unwind unreachable];
    }

    bb219: {
        _203 = discriminant(_200);
        switchInt(move _203) -> [0: bb221, 1: bb220, otherwise: bb6];
    }

    bb220: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb221: {
        _204 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_60(_1) -> [return: bb222, unwind unreachable];
    }

    bb222: {
        switchInt(move _204) -> [0: bb232, otherwise: bb223];
    }

    bb223: {
        _205 = _3;
        switchInt(move _205) -> [0: bb224, otherwise: bb228];
    }

    bb224: {
        _208 = const " | ";
        _207 = Formatter::<'_>::write_str(_2, _208) -> [return: bb225, unwind unreachable];
    }

    bb225: {
        _206 = <Result<(), core::fmt::Error> as Try>::branch(move _207) -> [return: bb226, unwind unreachable];
    }

    bb226: {
        _209 = discriminant(_206);
        switchInt(move _209) -> [0: bb228, 1: bb227, otherwise: bb6];
    }

    bb227: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb228: {
        _3 = const false;
        _212 = const "BIT_60";
        _211 = Formatter::<'_>::write_str(_2, _212) -> [return: bb229, unwind unreachable];
    }

    bb229: {
        _210 = <Result<(), core::fmt::Error> as Try>::branch(move _211) -> [return: bb230, unwind unreachable];
    }

    bb230: {
        _213 = discriminant(_210);
        switchInt(move _213) -> [0: bb232, 1: bb231, otherwise: bb6];
    }

    bb231: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb232: {
        _214 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_61(_1) -> [return: bb233, unwind unreachable];
    }

    bb233: {
        switchInt(move _214) -> [0: bb243, otherwise: bb234];
    }

    bb234: {
        _215 = _3;
        switchInt(move _215) -> [0: bb235, otherwise: bb239];
    }

    bb235: {
        _218 = const " | ";
        _217 = Formatter::<'_>::write_str(_2, _218) -> [return: bb236, unwind unreachable];
    }

    bb236: {
        _216 = <Result<(), core::fmt::Error> as Try>::branch(move _217) -> [return: bb237, unwind unreachable];
    }

    bb237: {
        _219 = discriminant(_216);
        switchInt(move _219) -> [0: bb239, 1: bb238, otherwise: bb6];
    }

    bb238: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb239: {
        _3 = const false;
        _222 = const "BIT_61";
        _221 = Formatter::<'_>::write_str(_2, _222) -> [return: bb240, unwind unreachable];
    }

    bb240: {
        _220 = <Result<(), core::fmt::Error> as Try>::branch(move _221) -> [return: bb241, unwind unreachable];
    }

    bb241: {
        _223 = discriminant(_220);
        switchInt(move _223) -> [0: bb243, 1: bb242, otherwise: bb6];
    }

    bb242: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb243: {
        _224 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::BIT_62(_1) -> [return: bb244, unwind unreachable];
    }

    bb244: {
        switchInt(move _224) -> [0: bb254, otherwise: bb245];
    }

    bb245: {
        _225 = _3;
        switchInt(move _225) -> [0: bb246, otherwise: bb250];
    }

    bb246: {
        _228 = const " | ";
        _227 = Formatter::<'_>::write_str(_2, _228) -> [return: bb247, unwind unreachable];
    }

    bb247: {
        _226 = <Result<(), core::fmt::Error> as Try>::branch(move _227) -> [return: bb248, unwind unreachable];
    }

    bb248: {
        _229 = discriminant(_226);
        switchInt(move _229) -> [0: bb250, 1: bb249, otherwise: bb6];
    }

    bb249: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb250: {
        _3 = const false;
        _232 = const "BIT_62";
        _231 = Formatter::<'_>::write_str(_2, _232) -> [return: bb251, unwind unreachable];
    }

    bb251: {
        _230 = <Result<(), core::fmt::Error> as Try>::branch(move _231) -> [return: bb252, unwind unreachable];
    }

    bb252: {
        _233 = discriminant(_230);
        switchInt(move _233) -> [0: bb254, 1: bb253, otherwise: bb6];
    }

    bb253: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb254: {
        _234 = <PageTableFlags as <PageTableFlags as Debug>::fmt::__BitFlags>::NO_EXECUTE(_1) -> [return: bb255, unwind unreachable];
    }

    bb255: {
        switchInt(move _234) -> [0: bb265, otherwise: bb256];
    }

    bb256: {
        _235 = _3;
        switchInt(move _235) -> [0: bb257, otherwise: bb261];
    }

    bb257: {
        _238 = const " | ";
        _237 = Formatter::<'_>::write_str(_2, _238) -> [return: bb258, unwind unreachable];
    }

    bb258: {
        _236 = <Result<(), core::fmt::Error> as Try>::branch(move _237) -> [return: bb259, unwind unreachable];
    }

    bb259: {
        _239 = discriminant(_236);
        switchInt(move _239) -> [0: bb261, 1: bb260, otherwise: bb6];
    }

    bb260: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb261: {
        _3 = const false;
        _242 = const "NO_EXECUTE";
        _241 = Formatter::<'_>::write_str(_2, _242) -> [return: bb262, unwind unreachable];
    }

    bb262: {
        _240 = <Result<(), core::fmt::Error> as Try>::branch(move _241) -> [return: bb263, unwind unreachable];
    }

    bb263: {
        _243 = discriminant(_240);
        switchInt(move _243) -> [0: bb265, 1: bb264, otherwise: bb6];
    }

    bb264: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb265: {
        _245 = ((*_1).0: u64);
        _249 = PageTableFlags::all() -> [return: bb266, unwind unreachable];
    }

    bb266: {
        _248 = &_249;
        _247 = PageTableFlags::bits(move _248) -> [return: bb267, unwind unreachable];
    }

    bb267: {
        _246 = Not(move _247);
        _244 = BitAnd(move _245, move _246);
        _250 = _244;
        switchInt(move _250) -> [0: bb281, otherwise: bb268];
    }

    bb268: {
        _251 = _3;
        switchInt(move _251) -> [0: bb269, otherwise: bb273];
    }

    bb269: {
        _254 = const " | ";
        _253 = Formatter::<'_>::write_str(_2, _254) -> [return: bb270, unwind unreachable];
    }

    bb270: {
        _252 = <Result<(), core::fmt::Error> as Try>::branch(move _253) -> [return: bb271, unwind unreachable];
    }

    bb271: {
        _255 = discriminant(_252);
        switchInt(move _255) -> [0: bb273, 1: bb272, otherwise: bb6];
    }

    bb272: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb273: {
        _3 = const false;
        _258 = const "0x";
        _257 = Formatter::<'_>::write_str(_2, _258) -> [return: bb274, unwind unreachable];
    }

    bb274: {
        _256 = <Result<(), core::fmt::Error> as Try>::branch(move _257) -> [return: bb275, unwind unreachable];
    }

    bb275: {
        _259 = discriminant(_256);
        switchInt(move _259) -> [0: bb276, 1: bb277, otherwise: bb6];
    }

    bb276: {
        _262 = &_244;
        _261 = <u64 as LowerHex>::fmt(_262, _2) -> [return: bb278, unwind unreachable];
    }

    bb277: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb278: {
        _260 = <Result<(), core::fmt::Error> as Try>::branch(move _261) -> [return: bb279, unwind unreachable];
    }

    bb279: {
        _263 = discriminant(_260);
        switchInt(move _263) -> [0: bb281, 1: bb280, otherwise: bb6];
    }

    bb280: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb281: {
        _264 = _3;
        switchInt(move _264) -> [0: bb286, otherwise: bb282];
    }

    bb282: {
        _267 = const "(empty)";
        _266 = Formatter::<'_>::write_str(_2, _267) -> [return: bb283, unwind unreachable];
    }

    bb283: {
        _265 = <Result<(), core::fmt::Error> as Try>::branch(move _266) -> [return: bb284, unwind unreachable];
    }

    bb284: {
        _268 = discriminant(_265);
        switchInt(move _268) -> [0: bb286, 1: bb285, otherwise: bb6];
    }

    bb285: {
        _0 = <Result<(), core::fmt::Error> as FromResidual<Result<Infallible, core::fmt::Error>>>::from_residual(const Result::<Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb287, unwind unreachable];
    }

    bb286: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ());
        goto -> bb287;
    }

    bb287: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::PRESENT(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::WRITABLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::USER_ACCESSIBLE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::WRITE_THROUGH(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NO_CACHE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::ACCESSED(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::DIRTY(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::HUGE_PAGE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::GLOBAL(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_9(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_10(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_11(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_52(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_53(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_54(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_55(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_56(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_57(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_58(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_59(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_60(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_61(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::BIT_62(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::__BitFlags::NO_EXECUTE(_1: &Self) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::PRESENT(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::WRITABLE(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::USER_ACCESSIBLE(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::WRITE_THROUGH(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NO_CACHE(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::ACCESSED(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::DIRTY(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::HUGE_PAGE(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::GLOBAL(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_9(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_10(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_11(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_52(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_53(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_54(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_55(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_56(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_57(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_58(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_59(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_60(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_61(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::BIT_62(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:433:9: 433:53>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:454:17: 454:46>::NO_EXECUTE(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: structures::paging::page_table::PageTableFlags;
    let mut _9: u64;
    let mut _10: structures::paging::page_table::PageTableFlags;

    bb0: {
        _3 = const _;
        _2 = (_3.0: u64);
        switchInt(move _2) -> [0: bb1, otherwise: bb3];
    }

    bb1: {
        _4 = ((*_1).0: u64);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _6 = ((*_1).0: u64);
        _8 = const _;
        _7 = (_8.0: u64);
        _5 = BitAnd(move _6, move _7);
        _10 = const _;
        _9 = (_10.0: u64);
        _0 = Eq(move _5, move _9);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:496:9: 496:54>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:501:9: 501:53>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:506:9: 506:56>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:511:9: 511:56>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::PRESENT: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags { bits: const 1_u64 };
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::WRITABLE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::USER_ACCESSIBLE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::WRITE_THROUGH: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NO_CACHE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::ACCESSED: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::DIRTY: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::HUGE_PAGE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::GLOBAL: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_9: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_10: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_11: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_52: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 52_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 52_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_53: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 53_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 53_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_54: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 54_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 54_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 54_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_55: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 55_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 55_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 55_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_56: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 56_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 56_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 56_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_57: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 57_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 57_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 57_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_58: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 58_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 58_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 58_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_59: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 59_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 59_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 59_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_60: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 60_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 60_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 60_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_61: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 61_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 61_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 61_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::BIT_62: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 62_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 62_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 62_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::NO_EXECUTE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 63_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 63_i32);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags { bits: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::empty() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags { bits: const 0_u64 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u64;

    bb0: {
        _23 = BitOr(const _, const _);
        _22 = BitOr(move _23, const _);
        _21 = BitOr(move _22, const _);
        _20 = BitOr(move _21, const _);
        _19 = BitOr(move _20, const _);
        _18 = BitOr(move _19, const _);
        _17 = BitOr(move _18, const _);
        _16 = BitOr(move _17, const _);
        _15 = BitOr(move _16, const _);
        _14 = BitOr(move _15, const _);
        _13 = BitOr(move _14, const _);
        _12 = BitOr(move _13, const _);
        _11 = BitOr(move _12, const _);
        _10 = BitOr(move _11, const _);
        _9 = BitOr(move _10, const _);
        _8 = BitOr(move _9, const _);
        _7 = BitOr(move _8, const _);
        _6 = BitOr(move _7, const _);
        _5 = BitOr(move _6, const _);
        _4 = BitOr(move _5, const _);
        _3 = BitOr(move _4, const _);
        _2 = BitOr(move _3, const _);
        _1 = BitOr(move _2, const _);
        _0 = PageTableFlags { bits: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u64;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        StorageLive(_13);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        _23 = BitOr(const _, const _);
        _22 = BitOr(move _23, const _);
        StorageDead(_23);
        _21 = BitOr(move _22, const _);
        StorageDead(_22);
        _20 = BitOr(move _21, const _);
        StorageDead(_21);
        _19 = BitOr(move _20, const _);
        StorageDead(_20);
        _18 = BitOr(move _19, const _);
        StorageDead(_19);
        _17 = BitOr(move _18, const _);
        StorageDead(_18);
        _16 = BitOr(move _17, const _);
        StorageDead(_17);
        _15 = BitOr(move _16, const _);
        StorageDead(_16);
        _14 = BitOr(move _15, const _);
        StorageDead(_15);
        _13 = BitOr(move _14, const _);
        StorageDead(_14);
        _12 = BitOr(move _13, const _);
        StorageDead(_13);
        _11 = BitOr(move _12, const _);
        StorageDead(_12);
        _10 = BitOr(move _11, const _);
        StorageDead(_11);
        _9 = BitOr(move _10, const _);
        StorageDead(_10);
        _8 = BitOr(move _9, const _);
        StorageDead(_9);
        _7 = BitOr(move _8, const _);
        StorageDead(_8);
        _6 = BitOr(move _7, const _);
        StorageDead(_7);
        _5 = BitOr(move _6, const _);
        StorageDead(_6);
        _4 = BitOr(move _5, const _);
        StorageDead(_5);
        _3 = BitOr(move _4, const _);
        StorageDead(_4);
        _2 = BitOr(move _3, const _);
        StorageDead(_3);
        _1 = BitOr(move _2, const _);
        StorageDead(_2);
        _0 = PageTableFlags { bits: move _1 };
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::PRESENT: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::WRITABLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::USER_ACCESSIBLE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::WRITE_THROUGH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NO_CACHE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::ACCESSED: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::DIRTY: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::HUGE_PAGE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::GLOBAL: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_9: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_10: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_11: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_52: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_53: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_54: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_55: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_56: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_57: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_58: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_59: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_60: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_61: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::BIT_62: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::__BitFlags::NO_EXECUTE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::PRESENT: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::WRITABLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::USER_ACCESSIBLE: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::WRITE_THROUGH: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NO_CACHE: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::ACCESSED: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::DIRTY: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::HUGE_PAGE: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::GLOBAL: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_9: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_10: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_11: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_52: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_53: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_54: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_55: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_56: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_57: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_58: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_59: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_60: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_61: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::BIT_62: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::all::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:404:9: 404:38>::NO_EXECUTE: u64 = {
    let mut _0: u64;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_1);
        _1 = const _;
        _0 = (_1.0: u64);
        StorageDead(_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &PageTableFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::bits(_1: &PageTableFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<PageTableFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::paging::page_table::PageTableFlags;
    let _6: structures::paging::page_table::PageTableFlags;
    let mut _7: structures::paging::page_table::PageTableFlags;

    bb0: {
        _6 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        _4 = PageTableFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = PageTableFlags { bits: _1 };
        _0 = Option::<PageTableFlags>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PageTableFlags>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits(_1: u64) -> Option<PageTableFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::PageTableFlags;
    let _8: structures::paging::page_table::PageTableFlags;
    let mut _9: structures::paging::page_table::PageTableFlags;
    let mut _10: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        ConstEvalCounter;
        _8 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_8;
        ConstEvalCounter;
        _6 = PageTableFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_7);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _1;
        _9 = PageTableFlags { bits: move _10 };
        StorageDead(_10);
        _0 = Option::<PageTableFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb5;
    }

    bb4: {
        StorageDead(_8);
        StorageDead(_3);
        _0 = Option::<PageTableFlags>::None;
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;

    bb0: {
        _4 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _2 = BitAnd(_1, move _3);
        _0 = PageTableFlags { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_truncate(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        StorageLive(_5);
        ConstEvalCounter;
        _5 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_5.0: u64);
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageTableFlags { bits: move _2 };
        StorageDead(_2);
        StorageDead(_5);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::from_bits_unchecked(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = PageTableFlags { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::PageTableFlags;
    let _5: structures::paging::page_table::PageTableFlags;

    bb0: {
        _2 = PageTableFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PageTableFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &_5;
        _3 = PageTableFlags::bits(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_empty(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: &structures::paging::page_table::PageTableFlags;
    let mut _4: u64;
    let mut _5: &structures::paging::page_table::PageTableFlags;
    let _6: structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = PageTableFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = PageTableFlags::empty() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = PageTableFlags::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        _0 = Eq(move _2, move _4);
        StorageDead(_4);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::is_all(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_4.0: u64);
        StorageLive(_5);
        _5 = ((*_1).0: u64);
        _2 = BitOr(move _3, move _5);
        StorageDead(_5);
        StorageDead(_3);
        StorageLive(_6);
        _6 = ((*_1).0: u64);
        _0 = Eq(move _2, move _6);
        StorageDead(_6);
        StorageDead(_2);
        StorageDead(_4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page_table::PageTableFlags;
    let _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        _7 = ((*_1).0: u64);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        _5 = PageTableFlags { bits: move _6 };
        _4 = &_5;
        _3 = PageTableFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersects(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page_table::PageTableFlags;
    let _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = ((*_1).0: u64);
        StorageLive(_8);
        _8 = (_2.0: u64);
        _6 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        _5 = PageTableFlags { bits: move _6 };
        _4 = &_5;
        StorageDead(_6);
        ConstEvalCounter;
        _3 = PageTableFlags::is_empty(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Not(move _3);
        StorageDead(_3);
        StorageDead(_5);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::contains(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = ((*_1).0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _0 = Eq(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::insert(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::remove(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::toggle(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::set(_1: &mut PageTableFlags, _2: PageTableFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = PageTableFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = PageTableFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::intersection(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageTableFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::union(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageTableFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageTableFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::symmetric_difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        StorageLive(_5);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = PageTableFlags { bits: move _3 };
        StorageDead(_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        _0 = PageTableFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:518:9: 518:23>::complement(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = Not(move _3);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableFlags::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:726:9: 726:53>::bitor(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitOr(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:736:9: 736:59>::bitor_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:744:9: 744:54>::bitxor(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitXor(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:754:9: 754:60>::bitxor_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:762:9: 762:54>::bitand(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = (_2.0: u64);
        _3 = BitAnd(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:772:9: 772:60>::bitand_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = (_2.0: u64);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:780:9: 780:51>::sub(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _4 = (_1.0: u64);
        _6 = (_2.0: u64);
        _5 = Not(move _6);
        _3 = BitAnd(move _4, move _5);
        _0 = PageTableFlags { bits: move _3 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:790:9: 790:57>::sub_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = (_2.0: u64);
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:798:9: 798:51>::not(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::paging::page_table::PageTableFlags;

    bb0: {
        _4 = (_1.0: u64);
        _3 = Not(move _4);
        _2 = PageTableFlags { bits: move _3 };
        _5 = PageTableFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <PageTableFlags as BitAnd>::bitand(move _2, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:808:9: 808:66>::extend(_1: &mut PageTableFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::paging::page_table::PageTableFlags);
        _5 = PageTableFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs:816:9: 816:72>::from_iter(_1: T) -> PageTableFlags {
    debug iterator => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let _3: ();
    let mut _4: &mut structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = PageTableFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <PageTableFlags as Extend<PageTableFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

const ENTRY_COUNT: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 512_usize;
        return;
    }
}

PageTable::entries::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:185:10: 185:15>::clone(_1: &PageTable) -> PageTable {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTable;
    let mut _2: [structures::paging::page_table::PageTableEntry; 512];
    let _3: &[structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _3 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _2 = <[PageTableEntry; 512] as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTable { entries: move _2 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::new() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;
    let mut _1: [structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _1 = [const _; 512];
        _0 = PageTable { entries: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::new() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;
    let mut _1: [structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        StorageLive(_1);
        _1 = [const _; 512];
        _0 = PageTable { entries: move _1 };
        StorageDead(_1);
        return;
    }
}

const EMPTY: PageTableEntry = {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        ConstEvalCounter;
        _0 = PageTableEntry::new() -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::zero(_1: &mut PageTable) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _3: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _4: &mut [structures::paging::page_table::PageTableEntry];
    let mut _5: &mut [structures::paging::page_table::PageTableEntry; 512];
    let mut _6: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _7: core::option::Option<&mut structures::paging::page_table::PageTableEntry>;
    let mut _8: &mut core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _9: isize;
    let _11: ();
    scope 1 {
        debug iter => _6;
        let _10: &mut structures::paging::page_table::PageTableEntry;
        scope 2 {
            debug entry => _10;
        }
    }

    bb0: {
        _5 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _4 = move _5 as &mut [structures::paging::page_table::PageTableEntry] (PointerCoercion(Unsize));
        _3 = slice::<impl [PageTableEntry]>::iter_mut(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = <core::slice::IterMut<'_, PageTableEntry> as IntoIterator>::into_iter(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = move _2;
        goto -> bb3;
    }

    bb3: {
        _8 = &mut _6;
        _7 = <core::slice::IterMut<'_, PageTableEntry> as Iterator>::next(_8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_7 as Some).0: &mut structures::paging::page_table::PageTableEntry);
        _11 = PageTableEntry::set_unused(_10) -> [return: bb3, unwind unreachable];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::iter(_1: &PageTable) -> core::slice::Iter<'_, PageTableEntry> {
    debug self => _1;
    let mut _0: core::slice::Iter<'_, structures::paging::page_table::PageTableEntry>;
    let mut _2: &[structures::paging::page_table::PageTableEntry];
    let mut _3: &[structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _3 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _2 = move _3 as &[structures::paging::page_table::PageTableEntry] (PointerCoercion(Unsize));
        _0 = slice::<impl [PageTableEntry]>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:190:1: 190:15>::iter_mut(_1: &mut PageTable) -> core::slice::IterMut<'_, PageTableEntry> {
    debug self => _1;
    let mut _0: core::slice::IterMut<'_, structures::paging::page_table::PageTableEntry>;
    let mut _2: &mut [structures::paging::page_table::PageTableEntry];
    let mut _3: &mut [structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _3 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _2 = move _3 as &mut [structures::paging::page_table::PageTableEntry] (PointerCoercion(Unsize));
        _0 = slice::<impl [PageTableEntry]>::iter_mut(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:221:1: 221:32>::index(_1: &PageTable, _2: usize) -> &PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::paging::page_table::PageTableEntry;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const 512_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_2];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:230:1: 230:35>::index_mut(_1: &mut PageTable, _2: usize) -> &mut PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::paging::page_table::PageTableEntry;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const 512_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_2];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:237:1: 237:41>::index(_1: &PageTable, _2: PageTableIndex) -> &PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::paging::page_table::PageTableEntry;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;

    bb0: {
        _3 = <usize as From<PageTableIndex>>::from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 512_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_3];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:246:1: 246:44>::index_mut(_1: &mut PageTable, _2: PageTableIndex) -> &mut PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::paging::page_table::PageTableEntry;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;

    bb0: {
        _3 = <usize as From<PageTableIndex>>::from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 512_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_3];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:253:1: 253:27>::default() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;

    bb0: {
        _0 = PageTable::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:259:1: 259:30>::fmt(_1: &PageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &[structures::paging::page_table::PageTableEntry];
    let mut _4: &[structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _4 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _3 = <[PageTableEntry; 512] as Index<RangeFull>>::index(move _4, const RangeFull) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <[PageTableEntry] as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:10: 271:15>::fmt(_1: &PageTableIndex, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "PageTableIndex";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:17: 271:22>::clone(_1: &PageTableIndex) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:30: 271:39>::eq(_1: &PageTableIndex, _2: &PageTableIndex) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:41: 271:43>::assert_receiver_is_total_eq(_1: &PageTableIndex) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:45: 271:55>::partial_cmp(_1: &PageTableIndex, _2: &PageTableIndex) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:57: 271:60>::cmp(_1: &PageTableIndex, _2: &PageTableIndex) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:271:62: 271:66>::hash(_1: &PageTableIndex, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:274:1: 274:20>::new(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: !;

    bb0: {
        _3 = <usize as From<u16>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Lt(move _3, const _);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = PageTableIndex(_1);
        return;
    }

    bb3: {
        _4 = panic(const "assertion failed: usize::from(index) < ENTRY_COUNT") -> unwind unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:274:1: 274:20>::new_truncate(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: bool;

    bb0: {
        _3 = const _ as u16 (IntToInt);
        _4 = Eq(_3, const 0_u16);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Rem(_1, move _3);
        _0 = PageTableIndex(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:274:1: 274:20>::new_truncate(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = const _ as u16 (IntToInt);
        _5 = Eq(_4, const 0_u16);
        assert(!move _5, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageTableIndex(move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:289:1: 289:34>::from(_1: PageTableIndex) -> u16 {
    debug index => _1;
    let mut _0: u16;

    bb0: {
        _0 = (_1.0: u16);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:296:1: 296:34>::from(_1: PageTableIndex) -> u32 {
    debug index => _1;
    let mut _0: u32;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u32 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:303:1: 303:34>::from(_1: PageTableIndex) -> u64 {
    debug index => _1;
    let mut _0: u64;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u64 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:310:1: 310:36>::from(_1: PageTableIndex) -> usize {
    debug index => _1;
    let mut _0: usize;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <usize as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:10: 322:15>::fmt(_1: &PageOffset, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "PageOffset";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:17: 322:22>::clone(_1: &PageOffset) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:30: 322:39>::eq(_1: &PageOffset, _2: &PageOffset) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:41: 322:43>::assert_receiver_is_total_eq(_1: &PageOffset) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:45: 322:55>::partial_cmp(_1: &PageOffset, _2: &PageOffset) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:57: 322:60>::cmp(_1: &PageOffset, _2: &PageOffset) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:322:62: 322:66>::hash(_1: &PageOffset, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:325:1: 325:16>::new(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: bool;
    let mut _3: u16;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: !;

    bb0: {
        _4 = const 12_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 16_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u16, const 12_i32);
        _2 = Lt(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = PageOffset(_1);
        return;
    }

    bb3: {
        _6 = panic(const "assertion failed: offset < (1 << 12)") -> unwind unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:325:1: 325:16>::new_truncate(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: bool;

    bb0: {
        _4 = const 12_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 16_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u16, const 12_i32);
        _6 = Eq(_3, const 0_u16);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(_1, move _3);
        _0 = PageOffset(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:325:1: 325:16>::new_truncate(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 16_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(const 1_u16, const 12_i32);
        _7 = Eq(_4, const 0_u16);
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageOffset(move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:340:1: 340:30>::from(_1: PageOffset) -> u16 {
    debug offset => _1;
    let mut _0: u16;

    bb0: {
        _0 = (_1.0: u16);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:347:1: 347:30>::from(_1: PageOffset) -> u32 {
    debug offset => _1;
    let mut _0: u32;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u32 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:354:1: 354:30>::from(_1: PageOffset) -> u64 {
    debug offset => _1;
    let mut _0: u64;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u64 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:361:1: 361:32>::from(_1: PageOffset) -> usize {
    debug offset => _1;
    let mut _0: usize;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <usize as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

PageTableLevel::One::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 1_isize;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:10: 368:15>::fmt(_1: &PageTableLevel, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [1: bb3, 2: bb4, 3: bb5, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Four";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "One";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Two";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Three";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:17: 368:22>::clone(_1: &PageTableLevel) -> PageTableLevel {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableLevel;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:30: 368:39>::eq(_1: &PageTableLevel, _2: &PageTableLevel) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:41: 368:43>::assert_receiver_is_total_eq(_1: &PageTableLevel) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:45: 368:55>::partial_cmp(_1: &PageTableLevel, _2: &PageTableLevel) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as PartialOrd>::partial_cmp(_5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:57: 368:60>::cmp(_1: &PageTableLevel, _2: &PageTableLevel) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as Ord>::cmp(_5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:368:62: 368:66>::hash(_1: &PageTableLevel, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: isize;
    let _4: &isize;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <isize as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::next_lower_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb5, 3: bb4, 4: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = PageTableLevel::One;
        _0 = Option::<PageTableLevel>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::next_lower_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb5, 3: bb4, 4: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_3);
        _3 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = PageTableLevel::One;
        _0 = Option::<PageTableLevel>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::table_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: isize;
    let mut _6: u8;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: (u8, bool);
    let mut _11: (u8, bool);
    let mut _12: bool;

    bb0: {
        _5 = discriminant(_1);
        _6 = _5 as u8 (IntToInt);
        _7 = Ge(_6, const 1_u8);
        _8 = Le(_6, const 4_u8);
        _9 = BitAnd(move _7, move _8);
        assume(move _9);
        _4 = move _5 as u8 (IntToInt);
        _10 = CheckedMul(_4, const 9_u8);
        assert(!move (_10.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_10.0: u8);
        _11 = CheckedAdd(_3, const 12_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = move (_11.0: u8);
        _12 = Lt(_2, const 64_u8);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Shl(const 1_u64, move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::table_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let _5: structures::paging::page_table::PageTableLevel;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: (u8, bool);
    let mut _12: (u8, bool);
    let mut _13: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        _6 = discriminant(_5);
        _7 = _6 as u8 (IntToInt);
        _8 = Ge(_7, const 1_u8);
        _9 = Le(_7, const 4_u8);
        _10 = BitAnd(move _8, move _9);
        assume(move _10);
        _4 = move _6 as u8 (IntToInt);
        StorageDead(_5);
        _11 = CheckedMul(_4, const 9_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_11.0: u8);
        StorageDead(_4);
        _12 = CheckedAdd(_3, const 12_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = move (_12.0: u8);
        StorageDead(_3);
        _13 = Lt(_2, const 64_u8);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Shl(const 1_u64, move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::entry_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: (u8, bool);
    let mut _12: (u8, bool);
    let mut _13: (u8, bool);
    let mut _14: bool;

    bb0: {
        _6 = discriminant(_1);
        _7 = _6 as u8 (IntToInt);
        _8 = Ge(_7, const 1_u8);
        _9 = Le(_7, const 4_u8);
        _10 = BitAnd(move _8, move _9);
        assume(move _10);
        _5 = move _6 as u8 (IntToInt);
        _11 = CheckedSub(_5, const 1_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, const 1_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move (_11.0: u8);
        _12 = CheckedMul(_4, const 9_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_12.0: u8);
        _13 = CheckedAdd(_3, const 12_u8);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move (_13.0: u8);
        _14 = Lt(_2, const 64_u8);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Shl(const 1_u64, move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/paging/page_table.rs:381:1: 381:20>::entry_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let _6: structures::paging::page_table::PageTableLevel;
    let mut _7: isize;
    let mut _8: u8;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: (u8, bool);
    let mut _13: (u8, bool);
    let mut _14: (u8, bool);
    let mut _15: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _7 = discriminant(_6);
        _8 = _7 as u8 (IntToInt);
        _9 = Ge(_8, const 1_u8);
        _10 = Le(_8, const 4_u8);
        _11 = BitAnd(move _9, move _10);
        assume(move _11);
        _5 = move _7 as u8 (IntToInt);
        StorageDead(_6);
        _12 = CheckedSub(_5, const 1_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, const 1_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move (_12.0: u8);
        StorageDead(_5);
        _13 = CheckedMul(_4, const 9_u8);
        assert(!move (_13.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_13.0: u8);
        StorageDead(_4);
        _14 = CheckedAdd(_3, const 12_u8);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move (_14.0: u8);
        StorageDead(_3);
        _15 = Lt(_2, const 64_u8);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Shl(const 1_u64, move _2);
        StorageDead(_2);
        return;
    }
}

TaskStateSegment::privilege_stack_table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

TaskStateSegment::interrupt_stack_table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:10:10: 10:15>::fmt(_1: &TaskStateSegment, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _4: &[&dyn core::fmt::Debug; 7];
    let _5: [&dyn core::fmt::Debug; 7];
    let mut _6: &dyn core::fmt::Debug;
    let _7: &u32;
    let _8: u32;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &[addr::VirtAddr; 3];
    let _11: [addr::VirtAddr; 3];
    let mut _12: &dyn core::fmt::Debug;
    let _13: &u64;
    let _14: u64;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &[addr::VirtAddr; 7];
    let _17: [addr::VirtAddr; 7];
    let mut _18: &dyn core::fmt::Debug;
    let _19: &u64;
    let _20: u64;
    let mut _21: &dyn core::fmt::Debug;
    let _22: &u16;
    let _23: u16;
    let mut _24: &dyn core::fmt::Debug;
    let _25: &&u16;
    let _26: &u16;
    let _27: u16;
    let _28: &str;
    let mut _29: &[&str];
    let mut _30: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn core::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _30 = const _;
        _8 = ((*_1).0: u32);
        _7 = &_8;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = ((*_1).1: [addr::VirtAddr; 3]);
        _10 = &_11;
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _14 = ((*_1).2: u64);
        _13 = &_14;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = ((*_1).3: [addr::VirtAddr; 7]);
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _20 = ((*_1).4: u64);
        _19 = &_20;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _23 = ((*_1).5: u16);
        _22 = &_23;
        _21 = _22 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = ((*_1).6: u16);
        _26 = &_27;
        _25 = &_26;
        _24 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _9, move _12, move _15, move _18, move _21, move _24];
        _4 = &_5;
        _3 = _4 as &[&dyn core::fmt::Debug] (PointerCoercion(Unsize));
        _28 = const "TaskStateSegment";
        _29 = _30 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _28, move _29, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:10:10: 10:15>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "privilege_stack_table";
        _2 = &(*_3);
        _5 = const "reserved_2";
        _4 = &(*_5);
        _7 = const "interrupt_stack_table";
        _6 = &(*_7);
        _9 = const "reserved_3";
        _8 = &(*_9);
        _11 = const "reserved_4";
        _10 = &(*_11);
        _13 = const "iomap_base";
        _12 = &(*_13);
        _1 = [const "reserved_1", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:10:17: 10:22>::clone(_1: &TaskStateSegment) -> TaskStateSegment {
    debug self => _1;
    let mut _0: structures::tss::TaskStateSegment;
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:10:17: 10:22>::clone::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:10:17: 10:22>::clone::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:25:1: 25:22>::new() -> TaskStateSegment {
    let mut _0: structures::tss::TaskStateSegment;
    let mut _1: [addr::VirtAddr; 3];
    let mut _2: addr::VirtAddr;
    let mut _3: [addr::VirtAddr; 7];
    let mut _4: addr::VirtAddr;
    let mut _5: u16;
    let mut _6: usize;

    bb0: {
        _2 = addr::VirtAddr::zero() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = [move _2; 3];
        _4 = addr::VirtAddr::zero() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = [move _4; 7];
        _6 = core::mem::size_of::<TaskStateSegment>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move _6 as u16 (IntToInt);
        _0 = TaskStateSegment { reserved_1: const 0_u32, privilege_stack_table: move _1, reserved_2: const 0_u64, interrupt_stack_table: move _3, reserved_3: const 0_u64, reserved_4: const 0_u16, iomap_base: move _5 };
        return;
    }
}

// MIR FOR CTFE
fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:25:1: 25:22>::new() -> TaskStateSegment {
    let mut _0: structures::tss::TaskStateSegment;
    let mut _1: [addr::VirtAddr; 3];
    let mut _2: addr::VirtAddr;
    let mut _3: [addr::VirtAddr; 7];
    let mut _4: addr::VirtAddr;
    let mut _5: u16;
    let mut _6: usize;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        ConstEvalCounter;
        _2 = addr::VirtAddr::zero() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = [move _2; 3];
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = addr::VirtAddr::zero() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = [move _4; 7];
        StorageDead(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = core::mem::size_of::<TaskStateSegment>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move _6 as u16 (IntToInt);
        StorageDead(_6);
        _0 = TaskStateSegment { reserved_1: const 0_u32, privilege_stack_table: move _1, reserved_2: const 0_u64, interrupt_stack_table: move _3, reserved_3: const 0_u64, reserved_4: const 0_u16, iomap_base: move _5 };
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:25:1: 25:22>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/tss.rs:25:1: 25:22>::new::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn structures::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/mod.rs:15:10: 15:15>::fmt(_1: &DescriptorTablePointer, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u16;
    let _7: u16;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &&addr::VirtAddr;
    let _11: &addr::VirtAddr;
    let _12: addr::VirtAddr;

    bb0: {
        _3 = const "DescriptorTablePointer";
        _4 = const "limit";
        _7 = ((*_1).0: u16);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _8 = const "base";
        _12 = ((*_1).1: addr::VirtAddr);
        _11 = &_12;
        _10 = &_11;
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _8, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn structures::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/structures/mod.rs:15:17: 15:22>::clone(_1: &DescriptorTablePointer) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

PrivilegeLevel::Ring0::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

PrivilegeLevel::Ring1::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

PrivilegeLevel::Ring2::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

PrivilegeLevel::Ring3::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:21:10: 21:15>::fmt(_1: &PrivilegeLevel, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Ring3";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Ring0";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Ring1";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Ring2";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:21:23: 21:28>::clone(_1: &PrivilegeLevel) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:21:30: 21:39>::eq(_1: &PrivilegeLevel, _2: &PrivilegeLevel) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:21:41: 21:43>::assert_receiver_is_total_eq(_1: &PrivilegeLevel) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:21:45: 21:49>::hash(_1: &PrivilegeLevel, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: u8;
    let _4: &u8;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <u8 as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:50:1: 50:20>::from_u16(_1: u16) -> PrivilegeLevel {
    debug value => _1;
    let mut _0: PrivilegeLevel;
    let _2: u16;
    let _3: !;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &u16;
    scope 1 {
        debug i => _2;
        let mut _11: &[&str; 2];
    }

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _2 = _1;
        _11 = const _;
        _5 = _11 as &[&str] (PointerCoercion(Unsize));
        _10 = &_2;
        _9 = core::fmt::rt::Argument::<'_>::new_display::<u16>(_10) -> [return: bb6, unwind unreachable];
    }

    bb2: {
        _0 = PrivilegeLevel::Ring0;
        goto -> bb8;
    }

    bb3: {
        _0 = PrivilegeLevel::Ring1;
        goto -> bb8;
    }

    bb4: {
        _0 = PrivilegeLevel::Ring2;
        goto -> bb8;
    }

    bb5: {
        _0 = PrivilegeLevel::Ring3;
        goto -> bb8;
    }

    bb6: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = panic_fmt(move _4) -> unwind unreachable;
    }

    bb8: {
        return;
    }
}

promoted[0] in <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.10/src/lib.rs:50:1: 50:20>::from_u16: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const " is not a valid privilege level"];
        _0 = &_1;
        return;
    }
}

fn addr::VirtAddr(_1: u64) -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn addr::VirtAddr(_1: u64) -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(move _1);
        return;
    }
}

fn PhysAddr(_1: u64) -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PhysAddr(_1: u64) -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(move _1);
        return;
    }
}

fn VirtAddrNotValid(_1: u64) -> VirtAddrNotValid {
    let mut _0: addr::VirtAddrNotValid;

    bb0: {
        _0 = VirtAddrNotValid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn VirtAddrNotValid(_1: u64) -> VirtAddrNotValid {
    let mut _0: addr::VirtAddrNotValid;

    bb0: {
        _0 = VirtAddrNotValid(move _1);
        return;
    }
}

fn PhysAddrNotValid(_1: u64) -> PhysAddrNotValid {
    let mut _0: addr::PhysAddrNotValid;

    bb0: {
        _0 = PhysAddrNotValid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PhysAddrNotValid(_1: u64) -> PhysAddrNotValid {
    let mut _0: addr::PhysAddrNotValid;

    bb0: {
        _0 = PhysAddrNotValid(move _1);
        return;
    }
}

fn ReadOnlyAccess(_1: ()) -> ReadOnlyAccess {
    let mut _0: instructions::port::ReadOnlyAccess;

    bb0: {
        _0 = ReadOnlyAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ReadOnlyAccess(_1: ()) -> ReadOnlyAccess {
    let mut _0: instructions::port::ReadOnlyAccess;

    bb0: {
        _0 = ReadOnlyAccess(move _1);
        return;
    }
}

fn WriteOnlyAccess(_1: ()) -> WriteOnlyAccess {
    let mut _0: instructions::port::WriteOnlyAccess;

    bb0: {
        _0 = WriteOnlyAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn WriteOnlyAccess(_1: ()) -> WriteOnlyAccess {
    let mut _0: instructions::port::WriteOnlyAccess;

    bb0: {
        _0 = WriteOnlyAccess(move _1);
        return;
    }
}

fn ReadWriteAccess(_1: ()) -> ReadWriteAccess {
    let mut _0: instructions::port::ReadWriteAccess;

    bb0: {
        _0 = ReadWriteAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ReadWriteAccess(_1: ()) -> ReadWriteAccess {
    let mut _0: instructions::port::ReadWriteAccess;

    bb0: {
        _0 = ReadWriteAccess(move _1);
        return;
    }
}

fn RdRand(_1: ()) -> RdRand {
    let mut _0: instructions::random::RdRand;

    bb0: {
        _0 = RdRand(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RdRand(_1: ()) -> RdRand {
    let mut _0: instructions::random::RdRand;

    bb0: {
        _0 = RdRand(move _1);
        return;
    }
}

fn InvPicdCommand::Address(_1: addr::VirtAddr, _2: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Address(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn InvPicdCommand::Address(_1: addr::VirtAddr, _2: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Address(move _1, move _2);
        return;
    }
}

fn InvPicdCommand::Single(_1: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Single(move _1);
        return;
    }
}

// MIR FOR CTFE
fn InvPicdCommand::Single(_1: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Single(move _1);
        return;
    }
}

fn Pcid(_1: u16) -> Pcid {
    let mut _0: instructions::tlb::Pcid;

    bb0: {
        _0 = Pcid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Pcid(_1: u16) -> Pcid {
    let mut _0: instructions::tlb::Pcid;

    bb0: {
        _0 = Pcid(move _1);
        return;
    }
}

fn model_specific::Msr(_1: u32) -> model_specific::Msr {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::Msr(_1: u32) -> model_specific::Msr {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(move _1);
        return;
    }
}

fn SegmentSelector(_1: u16) -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = SegmentSelector(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SegmentSelector(_1: u16) -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = SegmentSelector(move _1);
        return;
    }
}

fn Descriptor::UserSegment(_1: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Descriptor::UserSegment(_1: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

fn Descriptor::SystemSegment(_1: u64, _2: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::SystemSegment(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn Descriptor::SystemSegment(_1: u64, _2: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::SystemSegment(move _1, move _2);
        return;
    }
}

fn EntryOptions(_1: u16) -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EntryOptions(_1: u16) -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(move _1);
        return;
    }
}

fn Hex(_1: u64) -> Hex {
    let mut _0: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;

    bb0: {
        _0 = Hex(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Hex(_1: u64) -> Hex {
    let mut _0: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;

    bb0: {
        _0 = Hex(move _1);
        return;
    }
}

fn mapper::TranslateResult::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateResult {
    let mut _0: structures::paging::mapper::TranslateResult;

    bb0: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::TranslateResult::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateResult {
    let mut _0: structures::paging::mapper::TranslateResult;

    bb0: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size4KiB(_1: PhysFrame) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size4KiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size4KiB(_1: PhysFrame) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size4KiB(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size2MiB(_1: PhysFrame<page::Size2MiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size2MiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size2MiB(_1: PhysFrame<page::Size2MiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size2MiB(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size1GiB(_1: PhysFrame<page::Size1GiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size1GiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size1GiB(_1: PhysFrame<page::Size1GiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size1GiB(move _1);
        return;
    }
}

fn mapper::MapperFlush(_1: Page<S>) -> mapper::MapperFlush<S> {
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapperFlush(_1: Page<S>) -> mapper::MapperFlush<S> {
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(move _1);
        return;
    }
}

fn mapper::MapperFlushAll(_1: ()) -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        _0 = mapper::MapperFlushAll(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapperFlushAll(_1: ()) -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        _0 = mapper::MapperFlushAll(move _1);
        return;
    }
}

fn mapper::MapToError::PageAlreadyMapped(_1: PhysFrame<S>) -> mapper::MapToError<S> {
    let mut _0: structures::paging::mapper::MapToError<S>;

    bb0: {
        _0 = mapper::MapToError::<S>::PageAlreadyMapped(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapToError::PageAlreadyMapped(_1: PhysFrame<S>) -> mapper::MapToError<S> {
    let mut _0: structures::paging::mapper::MapToError<S>;

    bb0: {
        _0 = mapper::MapToError::<S>::PageAlreadyMapped(move _1);
        return;
    }
}

fn mapper::UnmapError::InvalidFrameAddress(_1: PhysAddr) -> mapper::UnmapError {
    let mut _0: structures::paging::mapper::UnmapError;

    bb0: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::UnmapError::InvalidFrameAddress(_1: PhysAddr) -> mapper::UnmapError {
    let mut _0: structures::paging::mapper::UnmapError;

    bb0: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _1);
        return;
    }
}

fn mapper::TranslateError::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateError {
    let mut _0: structures::paging::mapper::TranslateError;

    bb0: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::TranslateError::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateError {
    let mut _0: structures::paging::mapper::TranslateError;

    bb0: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _1);
        return;
    }
}

fn PageTableIndex(_1: u16) -> PageTableIndex {
    let mut _0: structures::paging::page_table::PageTableIndex;

    bb0: {
        _0 = PageTableIndex(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageTableIndex(_1: u16) -> PageTableIndex {
    let mut _0: structures::paging::page_table::PageTableIndex;

    bb0: {
        _0 = PageTableIndex(move _1);
        return;
    }
}

fn PageOffset(_1: u16) -> PageOffset {
    let mut _0: structures::paging::page_table::PageOffset;

    bb0: {
        _0 = PageOffset(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageOffset(_1: u16) -> PageOffset {
    let mut _0: structures::paging::page_table::PageOffset;

    bb0: {
        _0 = PageOffset(move _1);
        return;
    }
}
