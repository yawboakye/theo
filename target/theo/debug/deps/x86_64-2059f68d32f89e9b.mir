// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const ADDRESS_SPACE_SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 281474976710656_u64;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:10: 25:15>::clone(_1: &addr::VirtAddr) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:23: 25:32>::eq(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:34: 25:36>::assert_receiver_is_total_eq(_1: &addr::VirtAddr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:38: 25:48>::partial_cmp(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:50: 25:53>::cmp(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:25:55: 25:59>::hash(_1: &addr::VirtAddr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:10: 38:15>::clone(_1: &PhysAddr) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:23: 38:32>::eq(_1: &PhysAddr, _2: &PhysAddr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:34: 38:36>::assert_receiver_is_total_eq(_1: &PhysAddr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:38: 38:48>::partial_cmp(_1: &PhysAddr, _2: &PhysAddr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:50: 38:53>::cmp(_1: &PhysAddr, _2: &PhysAddr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:38:55: 38:59>::hash(_1: &PhysAddr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:52:1: 52:43>::fmt(_1: &VirtAddrNotValid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "VirtAddrNotValid";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:52:1: 52:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::new(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: core::result::Result<addr::VirtAddr, addr::VirtAddrNotValid>;
    let _3: &str;

    bb0: {
        _2 = addr::VirtAddr::try_new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = const "address passed to VirtAddr::new must not contain any data in bits 48 to 64";
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::expect(move _2, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::try_new(_1: u64) -> Result<addr::VirtAddr, VirtAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::VirtAddr, addr::VirtAddrNotValid>;
    let mut _2: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: addr::VirtAddr;
    let mut _8: u64;
    let mut _9: addr::VirtAddrNotValid;
    let mut _10: u64;

    bb0: {
        _3 = &_1;
        _4 = Range::<usize> { start: const 47_usize, end: const 64_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, 131071: bb3, 1: bb4, otherwise: bb2];
    }

    bb2: {
        _10 = _1;
        _9 = VirtAddrNotValid(move _10);
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Err(move _9);
        goto -> bb6;
    }

    bb3: {
        _6 = _1;
        _5 = addr::VirtAddr(move _6);
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Ok(move _5);
        goto -> bb6;
    }

    bb4: {
        _8 = _1;
        _7 = addr::VirtAddr::new_truncate(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Result::<addr::VirtAddr, VirtAddrNotValid>::Ok(move _7);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::new_truncate(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    let mut _3: i64;
    let mut _4: i64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shl(_1, const 16_i32);
        _4 = move _5 as i64 (IntToInt);
        _8 = const 16_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 16_i32);
        _2 = move _3 as u64 (IntToInt);
        _0 = addr::VirtAddr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::new_truncate(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    let mut _3: i64;
    let mut _4: i64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _7 = const 16_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shl(move _6, const 16_i32);
        StorageDead(_6);
        _4 = move _5 as i64 (IntToInt);
        StorageDead(_5);
        _9 = const 16_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 16_i32);
        StorageDead(_4);
        _2 = move _3 as u64 (IntToInt);
        StorageDead(_3);
        _0 = addr::VirtAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::new_unsafe(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(_1);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::new_unsafe(_1: u64) -> addr::VirtAddr {
    debug addr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = addr::VirtAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::zero() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::zero() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(const 0_u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_u64(_1: addr::VirtAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_u64(_1: addr::VirtAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::from_ptr(_1: *const T) -> addr::VirtAddr {
    debug ptr => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: u64;

    bb0: {
        _2 = _1 as u64 (PointerExposeAddress);
        _0 = addr::VirtAddr::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_ptr(_1: addr::VirtAddr) -> *const T {
    debug self => _1;
    let mut _0: *const T;
    let mut _2: u64;

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as *const T (PointerFromExposedAddress);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_ptr(_1: addr::VirtAddr) -> *const T {
    debug self => _1;
    let mut _0: *const T;
    let mut _2: u64;
    let mut _3: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = addr::VirtAddr::as_u64(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = move _2 as *const T (PointerFromExposedAddress);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_mut_ptr(_1: addr::VirtAddr) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: *const T;

    bb0: {
        _2 = addr::VirtAddr::as_ptr::<T>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as *mut T (PtrToPtr);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::as_mut_ptr(_1: addr::VirtAddr) -> *mut T {
    debug self => _1;
    let mut _0: *mut T;
    let mut _2: *const T;
    let mut _3: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = addr::VirtAddr::as_ptr::<T>(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _0 = move _2 as *mut T (PtrToPtr);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::is_null(_1: addr::VirtAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::is_null(_1: addr::VirtAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::align_up(_1: addr::VirtAddr, _2: U) -> addr::VirtAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_up(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new_truncate(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::align_down(_1: addr::VirtAddr, _2: U) -> addr::VirtAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_down(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new_truncate(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::is_aligned(_1: addr::VirtAddr, _2: U) -> bool {
    debug self => _1;
    debug align => _2;
    let mut _0: bool;
    let mut _3: &addr::VirtAddr;
    let _4: addr::VirtAddr;
    let mut _5: addr::VirtAddr;
    let mut _6: &addr::VirtAddr;

    bb0: {
        _5 = _1;
        _4 = addr::VirtAddr::align_down::<U>(move _5, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _6 = &_1;
        _0 = <addr::VirtAddr as PartialEq>::eq(move _3, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::page_offset(_1: addr::VirtAddr) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u64;

    bb0: {
        _3 = (_1.0: u64);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageOffset::new_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::page_offset(_1: addr::VirtAddr) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = (_1.0: u64);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageOffset::new_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p1_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: u64);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shr(move _4, const 12_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p1_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_1.0: u64);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shr(move _4, const 12_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p2_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        _5 = (_1.0: u64);
        _6 = const 12_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(move _5, const 12_i32);
        _8 = const 9_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p2_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = (_1.0: u64);
        _6 = const 12_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(move _5, const 12_i32);
        StorageDead(_5);
        _8 = const 9_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p3_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;

    bb0: {
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        _9 = const 9_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 9_i32);
        _11 = const 9_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p3_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        StorageDead(_6);
        _9 = const 9_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 9_i32);
        StorageDead(_5);
        _11 = const 9_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p4_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: bool;

    bb0: {
        _7 = (_1.0: u64);
        _8 = const 12_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shr(move _7, const 12_i32);
        _10 = const 9_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 9_i32);
        _12 = const 9_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Shr(move _5, const 9_i32);
        _14 = const 9_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = Shr(move _4, const 9_i32);
        _2 = move _3 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::p4_index(_1: addr::VirtAddr) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = (_1.0: u64);
        _8 = const 12_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shr(move _7, const 12_i32);
        StorageDead(_7);
        _10 = const 9_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 9_i32);
        StorageDead(_6);
        _12 = const 9_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Shr(move _5, const 9_i32);
        StorageDead(_5);
        _14 = const 9_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = Shr(move _4, const 9_i32);
        StorageDead(_4);
        _2 = move _3 as u16 (IntToInt);
        StorageDead(_3);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::page_table_index(_1: addr::VirtAddr, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: u16;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u8;
    let mut _10: u8;
    let mut _11: u8;
    let mut _12: isize;
    let mut _13: u8;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: (u8, bool);
    let mut _18: (u8, bool);
    let mut _19: bool;

    bb0: {
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        _12 = discriminant(_2);
        _13 = _12 as u8 (IntToInt);
        _14 = Ge(_13, const 1_u8);
        _15 = Le(_13, const 4_u8);
        _16 = BitAnd(move _14, move _15);
        assume(move _16);
        _11 = move _12 as u8 (IntToInt);
        _17 = CheckedSub(_11, const 1_u8);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", move _11, const 1_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _10 = move (_17.0: u8);
        _18 = CheckedMul(_10, const 9_u8);
        assert(!move (_18.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, const 9_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_18.0: u8);
        _19 = Lt(_9, const 64_u8);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", _9) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shr(move _5, move _9);
        _3 = move _4 as u16 (IntToInt);
        _0 = PageTableIndex::new_truncate(move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::page_table_index(_1: addr::VirtAddr, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: u16;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u8;
    let mut _10: u8;
    let mut _11: u8;
    let _12: structures::paging::page_table::PageTableLevel;
    let mut _13: isize;
    let mut _14: u8;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: (u8, bool);
    let mut _19: (u8, bool);
    let mut _20: bool;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_1.0: u64);
        _7 = const 12_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(move _6, const 12_i32);
        StorageDead(_6);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = _2;
        _13 = discriminant(_12);
        _14 = _13 as u8 (IntToInt);
        _15 = Ge(_14, const 1_u8);
        _16 = Le(_14, const 4_u8);
        _17 = BitAnd(move _15, move _16);
        assume(move _17);
        _11 = move _13 as u8 (IntToInt);
        StorageDead(_12);
        _18 = CheckedSub(_11, const 1_u8);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", move _11, const 1_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _10 = move (_18.0: u8);
        StorageDead(_11);
        _19 = CheckedMul(_10, const 9_u8);
        assert(!move (_19.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, const 9_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_19.0: u8);
        StorageDead(_10);
        _20 = Lt(_9, const 64_u8);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", _9) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shr(move _5, move _9);
        StorageDead(_9);
        StorageDead(_5);
        _3 = move _4 as u16 (IntToInt);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = PageTableIndex::new_truncate(move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_3);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::steps_between_impl(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;
    let mut _3: u64;
    let mut _4: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _5: core::option::Option<u64>;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: isize;
    let _9: u64;
    let mut _10: bool;
    let mut _11: &u64;
    let mut _12: bool;
    let mut _13: &u64;
    let mut _14: u64;
    let mut _15: core::option::Option<u64>;
    let mut _16: u64;
    let mut _17: core::result::Result<usize, core::num::TryFromIntError>;
    let mut _18: u64;
    scope 1 {
        debug steps => _3;
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = ((*_2).0: u64);
        _7 = ((*_1).0: u64);
        _5 = core::num::<impl u64>::checked_sub(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <Option<u64> as Try>::branch(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb3, 1: bb4, otherwise: bb14];
    }

    bb3: {
        _9 = ((_4 as Continue).0: u64);
        _3 = _9;
        _11 = &((*_2).0: u64);
        _10 = <u64 as BitField>::get_bit(move _11, const 47_usize) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _0 = <Option<usize> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb13, unwind unreachable];
    }

    bb5: {
        switchInt(move _10) -> [0: bb11, otherwise: bb6];
    }

    bb6: {
        _13 = &((*_1).0: u64);
        _12 = <u64 as BitField>::get_bit(move _13, const 47_usize) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _12) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        _16 = _3;
        _15 = core::num::<impl u64>::checked_sub(move _16, const 18446462598732840960_u64) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = Option::<u64>::unwrap(move _15) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _3 = move _14;
        goto -> bb11;
    }

    bb11: {
        _18 = _3;
        _17 = <usize as TryFrom<u64>>::try_from(move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _0 = Result::<usize, TryFromIntError>::ok(move _17) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        return;
    }

    bb14: {
        unreachable;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:60:1: 60:14>::forward_checked_impl(_1: addr::VirtAddr, _2: usize) -> Option<addr::VirtAddr> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<addr::VirtAddr>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _4: core::option::Option<u64>;
    let mut _5: core::result::Result<u64, core::num::TryFromIntError>;
    let mut _6: isize;
    let _7: u64;
    let mut _8: bool;
    let mut _10: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _11: core::option::Option<u64>;
    let mut _12: u64;
    let mut _13: isize;
    let mut _15: u64;
    let mut _16: &u64;
    let mut _17: core::ops::RangeFrom<usize>;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::RangeFrom<usize>;
    let mut _21: addr::VirtAddr;
    let mut _22: u64;
    scope 1 {
        debug offset => _7;
        let mut _9: u64;
        let _14: u64;
        scope 6 {
            debug addr => _9;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _14;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = <u64 as TryFrom<usize>>::try_from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Result::<u64, TryFromIntError>::ok(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <Option<u64> as Try>::branch(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb18];
    }

    bb4: {
        _7 = ((_3 as Continue).0: u64);
        _8 = Gt(_7, const _);
        switchInt(move _8) -> [0: bb7, otherwise: bb6];
    }

    bb5: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb17, unwind unreachable];
    }

    bb6: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb17;
    }

    bb7: {
        _12 = (_1.0: u64);
        _11 = core::num::<impl u64>::checked_add(move _12, _7) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _10 = <Option<u64> as Try>::branch(move _11) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb18];
    }

    bb10: {
        _14 = ((_10 as Continue).0: u64);
        _9 = _14;
        _16 = &_9;
        _17 = RangeFrom::<usize> { start: const 47_usize };
        _15 = <u64 as BitField>::get_bits::<RangeFrom<usize>>(move _16, move _17) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb17, unwind unreachable];
    }

    bb12: {
        switchInt(_15) -> [1: bb13, 2: bb14, otherwise: bb15];
    }

    bb13: {
        _19 = &mut _9;
        _20 = RangeFrom::<usize> { start: const 47_usize };
        _18 = <u64 as BitField>::set_bits::<RangeFrom<usize>>(move _19, move _20, const 131071_u64) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb17;
    }

    bb15: {
        _22 = _9;
        _21 = addr::VirtAddr::new(move _22) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Option::<addr::VirtAddr>::Some(move _21);
        goto -> bb17;
    }

    bb17: {
        return;
    }

    bb18: {
        unreachable;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:265:1: 265:29>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "VirtAddr";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:265:1: 265:29>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:273:1: 273:30>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:280:1: 280:32>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:287:1: 287:29>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:294:1: 294:32>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:301:1: 301:31>::fmt(_1: &addr::VirtAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &*const ();
    let _4: *const ();
    let mut _5: u64;

    bb0: {
        _5 = ((*_1).0: u64);
        _4 = move _5 as *const () (PointerFromExposedAddress);
        _3 = &_4;
        _0 = <*const () as Pointer>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:308:1: 308:27>::add(_1: addr::VirtAddr, _2: u64) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: (u64, bool);

    bb0: {
        _4 = (_1.0: u64);
        _5 = CheckedAdd(_4, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_5.0: u64);
        _0 = addr::VirtAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:316:1: 316:33>::add_assign(_1: &mut addr::VirtAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;

    bb0: {
        _4 = (*_1);
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:324:1: 324:29>::add(_1: addr::VirtAddr, _2: usize) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as Add<u64>>::add(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:333:1: 333:35>::add_assign(_1: &mut addr::VirtAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as AddAssign<u64>>::add_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:340:1: 340:27>::sub(_1: addr::VirtAddr, _2: u64) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: core::option::Option<u64>;
    let mut _5: u64;

    bb0: {
        _5 = (_1.0: u64);
        _4 = core::num::<impl u64>::checked_sub(move _5, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<u64>::unwrap(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:348:1: 348:33>::sub_assign(_1: &mut addr::VirtAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;

    bb0: {
        _4 = (*_1);
        _3 = <addr::VirtAddr as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:356:1: 356:29>::sub(_1: addr::VirtAddr, _2: usize) -> addr::VirtAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::VirtAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as Sub<u64>>::sub(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:365:1: 365:35>::sub_assign(_1: &mut addr::VirtAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <addr::VirtAddr as SubAssign<u64>>::sub_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:372:1: 372:32>::sub(_1: addr::VirtAddr, _2: addr::VirtAddr) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: core::option::Option<u64>;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = addr::VirtAddr::as_u64(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = core::num::<impl u64>::checked_sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<u64>::unwrap(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:381:1: 381:23>::steps_between(_1: &addr::VirtAddr, _2: &addr::VirtAddr) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;

    bb0: {
        _0 = addr::VirtAddr::steps_between_impl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:381:1: 381:23>::forward_checked(_1: addr::VirtAddr, _2: usize) -> Option<addr::VirtAddr> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<addr::VirtAddr>;

    bb0: {
        _0 = addr::VirtAddr::forward_checked_impl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:381:1: 381:23>::backward_checked(_1: addr::VirtAddr, _2: usize) -> Option<addr::VirtAddr> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<addr::VirtAddr>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _4: core::option::Option<u64>;
    let mut _5: core::result::Result<u64, core::num::TryFromIntError>;
    let mut _6: isize;
    let _7: u64;
    let mut _8: bool;
    let mut _10: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, u64>;
    let mut _11: core::option::Option<u64>;
    let mut _12: u64;
    let mut _13: isize;
    let mut _15: u64;
    let mut _16: &u64;
    let mut _17: core::ops::RangeFrom<usize>;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::RangeFrom<usize>;
    let mut _21: addr::VirtAddr;
    let mut _22: u64;
    scope 1 {
        debug offset => _7;
        let mut _9: u64;
        let _14: u64;
        scope 6 {
            debug addr => _9;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _14;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = <u64 as TryFrom<usize>>::try_from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Result::<u64, TryFromIntError>::ok(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <Option<u64> as Try>::branch(move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb18];
    }

    bb4: {
        _7 = ((_3 as Continue).0: u64);
        _8 = Gt(_7, const _);
        switchInt(move _8) -> [0: bb7, otherwise: bb6];
    }

    bb5: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb17, unwind unreachable];
    }

    bb6: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb17;
    }

    bb7: {
        _12 = (_1.0: u64);
        _11 = core::num::<impl u64>::checked_sub(move _12, _7) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _10 = <Option<u64> as Try>::branch(move _11) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb18];
    }

    bb10: {
        _14 = ((_10 as Continue).0: u64);
        _9 = _14;
        _16 = &_9;
        _17 = RangeFrom::<usize> { start: const 47_usize };
        _15 = <u64 as BitField>::get_bits::<RangeFrom<usize>>(move _16, move _17) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _0 = <Option<addr::VirtAddr> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb17, unwind unreachable];
    }

    bb12: {
        switchInt(_15) -> [131070: bb13, 131069: bb14, otherwise: bb15];
    }

    bb13: {
        _19 = &mut _9;
        _20 = RangeFrom::<usize> { start: const 47_usize };
        _18 = <u64 as BitField>::set_bits::<RangeFrom<usize>>(move _19, move _20, const 0_u64) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _0 = Option::<addr::VirtAddr>::None;
        goto -> bb17;
    }

    bb15: {
        _22 = _9;
        _21 = addr::VirtAddr::new(move _22) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Option::<addr::VirtAddr>::Some(move _21);
        goto -> bb17;
    }

    bb17: {
        return;
    }

    bb18: {
        unreachable;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:421:1: 421:43>::fmt(_1: &PhysAddrNotValid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "PhysAddrNotValid";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:421:1: 421:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let mut _3: isize;
    let mut _4: !;
    scope 1 {
        debug p => _0;
    }

    bb0: {
        _2 = PhysAddr::try_new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = panic(const "physical addresses must not have any bits in the range 52 to 64 set") -> unwind unreachable;
    }

    bb3: {
        _0 = ((_2 as Ok).0: addr::PhysAddr);
        return;
    }

    bb4: {
        unreachable;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let mut _3: u64;
    let mut _4: isize;
    let _5: addr::PhysAddr;
    let mut _6: !;
    scope 1 {
        debug p => _5;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = PhysAddr::try_new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "physical addresses must not have any bits in the range 52 to 64 set") -> unwind unreachable;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_5);
        _5 = ((_2 as Ok).0: addr::PhysAddr);
        _0 = _5;
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new_truncate(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: bool;

    bb0: {
        _4 = const 52_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 64_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u64, const 52_i32);
        _6 = Eq(_3, const 0_u64);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(_1, move _3);
        _0 = PhysAddr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new_truncate(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _5 = const 52_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(const 1_u64, const 52_i32);
        _7 = Eq(_4, const 0_u64);
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PhysAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new_unsafe(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(_1);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::new_unsafe(_1: u64) -> PhysAddr {
    debug addr => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = PhysAddr(move _2);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::try_new(_1: u64) -> Result<PhysAddr, PhysAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let _2: addr::PhysAddr;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: addr::PhysAddrNotValid;
    scope 1 {
        debug p => _2;
    }

    bb0: {
        _2 = PhysAddr::new_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_2.0: u64);
        _3 = Eq(move _4, _1);
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Ok(_2);
        goto -> bb4;
    }

    bb3: {
        _5 = PhysAddrNotValid(_1);
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Err(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::try_new(_1: u64) -> Result<PhysAddr, PhysAddrNotValid> {
    debug addr => _1;
    let mut _0: core::result::Result<addr::PhysAddr, addr::PhysAddrNotValid>;
    let _2: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: addr::PhysAddr;
    let mut _8: addr::PhysAddrNotValid;
    let mut _9: u64;
    scope 1 {
        debug p => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = PhysAddr::new_truncate(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = (_2.0: u64);
        StorageLive(_6);
        _6 = _1;
        _4 = Eq(move _5, move _6);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_7);
        _7 = _2;
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Ok(move _7);
        StorageDead(_7);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _8 = PhysAddrNotValid(move _9);
        StorageDead(_9);
        _0 = Result::<PhysAddr, PhysAddrNotValid>::Err(move _8);
        StorageDead(_8);
        goto -> bb4;
    }

    bb4: {
        StorageDead(_4);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::zero() -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::zero() -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(const 0_u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::as_u64(_1: PhysAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::as_u64(_1: PhysAddr) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = (_1.0: u64);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::is_null(_1: PhysAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::is_null(_1: PhysAddr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::align_up(_1: PhysAddr, _2: U) -> PhysAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_up(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::align_down(_1: PhysAddr, _2: U) -> PhysAddr {
    debug self => _1;
    debug align => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = (_1.0: u64);
        _5 = <U as Into<u64>>::into(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = align_down(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr(move _3);
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:429:1: 429:14>::is_aligned(_1: PhysAddr, _2: U) -> bool {
    debug self => _1;
    debug align => _2;
    let mut _0: bool;
    let mut _3: &addr::PhysAddr;
    let _4: addr::PhysAddr;
    let mut _5: addr::PhysAddr;
    let mut _6: &addr::PhysAddr;

    bb0: {
        _5 = _1;
        _4 = PhysAddr::align_down::<U>(move _5, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _6 = &_1;
        _0 = <PhysAddr as PartialEq>::eq(move _3, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:528:1: 528:29>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u64;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "PhysAddr";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u64);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 4_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:528:1: 528:29>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:536:1: 536:30>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:543:1: 543:32>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:550:1: 550:29>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:557:1: 557:32>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:564:1: 564:31>::fmt(_1: &PhysAddr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &*const ();
    let _4: *const ();
    let mut _5: u64;

    bb0: {
        _5 = ((*_1).0: u64);
        _4 = move _5 as *const () (PointerFromExposedAddress);
        _3 = &_4;
        _0 = <*const () as Pointer>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:571:1: 571:27>::add(_1: PhysAddr, _2: u64) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: (u64, bool);

    bb0: {
        _4 = (_1.0: u64);
        _5 = CheckedAdd(_4, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_5.0: u64);
        _0 = PhysAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:579:1: 579:33>::add_assign(_1: &mut PhysAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;

    bb0: {
        _4 = (*_1);
        _3 = <PhysAddr as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:587:1: 587:29>::add(_1: PhysAddr, _2: usize) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as Add<u64>>::add(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:596:1: 596:35>::add_assign(_1: &mut PhysAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as AddAssign<u64>>::add_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:603:1: 603:27>::sub(_1: PhysAddr, _2: u64) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;
    let mut _4: core::option::Option<u64>;
    let mut _5: u64;

    bb0: {
        _5 = (_1.0: u64);
        _4 = core::num::<impl u64>::checked_sub(move _5, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Option::<u64>::unwrap(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysAddr::new(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:611:1: 611:33>::sub_assign(_1: &mut PhysAddr, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;

    bb0: {
        _4 = (*_1);
        _3 = <PhysAddr as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:619:1: 619:29>::sub(_1: PhysAddr, _2: usize) -> PhysAddr {
    debug self => _1;
    debug rhs => _2;
    let mut _0: addr::PhysAddr;
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as Sub<u64>>::sub(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:628:1: 628:35>::sub_assign(_1: &mut PhysAddr, _2: usize) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: u64;

    bb0: {
        _3 = _2 as u64 (IntToInt);
        _0 = <PhysAddr as SubAssign<u64>>::sub_assign(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/addr.rs:635:1: 635:32>::sub(_1: PhysAddr, _2: PhysAddr) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: core::option::Option<u64>;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _4 = PhysAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = core::num::<impl u64>::checked_sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<u64>::unwrap(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn align_down(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let mut _3: bool;
    let mut _4: !;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: (u64, bool);

    bb0: {
        _3 = core::num::<impl u64>::is_power_of_two(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _7 = CheckedSub(_2, const 1_u64);
        assert(!move (_7.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        _4 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _6 = move (_7.0: u64);
        _5 = Not(move _6);
        _0 = BitAnd(_1, move _5);
        return;
    }
}

// MIR FOR CTFE
fn align_down(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let _3: ();
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: !;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: (u64, bool);

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = core::num::<impl u64>::is_power_of_two(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_5);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_7);
        _7 = _1;
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _11 = CheckedSub(_10, const 1_u64);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _10, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _9 = move (_11.0: u64);
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _0 = BitAnd(move _7, move _8);
        StorageDead(_8);
        StorageDead(_7);
        return;
    }
}

fn align_up(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let mut _3: bool;
    let mut _4: !;
    let _5: u64;
    let mut _6: (u64, bool);
    let mut _7: u64;
    let mut _8: core::option::Option<u64>;
    let mut _9: u64;
    let mut _10: isize;
    let mut _12: !;
    scope 1 {
        debug align_mask => _5;
        scope 2 {
            debug aligned => _11;
            let _11: u64;
        }
    }

    bb0: {
        _3 = core::num::<impl u64>::is_power_of_two(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = CheckedSub(_2, const 1_u64);
        assert(!move (_6.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        _4 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _5 = move (_6.0: u64);
        _7 = BitAnd(_1, _5);
        switchInt(move _7) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = _1;
        goto -> bb10;
    }

    bb6: {
        _9 = BitOr(_1, _5);
        _8 = core::num::<impl u64>::checked_add(move _9, const 1_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _11 = ((_8 as Some).0: u64);
        _0 = _11;
        goto -> bb10;
    }

    bb9: {
        _12 = panic(const "attempt to add with overflow") -> unwind unreachable;
    }

    bb10: {
        return;
    }
}

// MIR FOR CTFE
fn align_up(_1: u64, _2: u64) -> u64 {
    debug addr => _1;
    debug align => _2;
    let mut _0: u64;
    let _3: ();
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: !;
    let _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: core::option::Option<u64>;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: isize;
    let mut _20: !;
    scope 1 {
        debug align_mask => _7;
        scope 2 {
            debug aligned => _19;
            let _19: u64;
        }
    }

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = core::num::<impl u64>::is_power_of_two(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_5);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _2;
        _9 = CheckedSub(_8, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _8, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = panic(const "`align` must be a power of two") -> unwind unreachable;
    }

    bb4: {
        _7 = move (_9.0: u64);
        StorageDead(_8);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _7;
        _11 = BitAnd(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _10 = Eq(move _11, const 0_u64);
        switchInt(move _10) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        StorageDead(_11);
        _0 = _1;
        goto -> bb10;
    }

    bb6: {
        StorageDead(_11);
        StorageLive(_14);
        StorageLive(_15);
        StorageLive(_16);
        _16 = _1;
        StorageLive(_17);
        _17 = _7;
        _15 = BitOr(move _16, move _17);
        StorageDead(_17);
        StorageDead(_16);
        ConstEvalCounter;
        _14 = core::num::<impl u64>::checked_add(move _15, const 1_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_15);
        _18 = discriminant(_14);
        switchInt(move _18) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        StorageLive(_19);
        _19 = ((_14 as Some).0: u64);
        _0 = _19;
        StorageDead(_19);
        StorageDead(_14);
        goto -> bb10;
    }

    bb9: {
        StorageLive(_20);
        ConstEvalCounter;
        _20 = panic(const "attempt to add with overflow") -> unwind unreachable;
    }

    bb10: {
        StorageDead(_10);
        StorageDead(_7);
        return;
    }
}

fn are_enabled() -> bool {
    let mut _0: bool;
    let mut _1: &registers::rflags::RFlags;
    let _2: registers::rflags::RFlags;

    bb0: {
        _2 = rflags::x86_64::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = &_2;
        _0 = rflags::_::<impl rflags::RFlags>::contains(move _1, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn enable() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: core::sync::atomic::Ordering;
    scope 1 {
    }

    bb0: {
        _2 = Release;
        _1 = compiler_fence(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("sti", options(NOMEM | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn disable() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: core::sync::atomic::Ordering;
    scope 1 {
    }

    bb0: {
        _2 = Acquire;
        _1 = compiler_fence(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("cli", options(NOMEM | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn without_interrupts(_1: F) -> R {
    debug f => _1;
    let mut _0: R;
    let _2: bool;
    let _3: ();
    let _4: ();
    scope 1 {
        debug saved_intpt_flag => _2;
        scope 2 {
            debug ret => _0;
        }
    }

    bb0: {
        _2 = are_enabled() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = disable() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <F as FnOnce<()>>::call_once(move _1, const ()) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(_2) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _4 = enable() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn enable_and_hlt() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("sti; hlt", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int3() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("int3", options(NOMEM | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:9:1: 9:21>::read_from_port(_1: u16) -> u8 {
    debug port => _1;
    let mut _0: u8;
    let _2: u8;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in al, dx", out("al") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:20:1: 20:22>::read_from_port(_1: u16) -> u16 {
    debug port => _1;
    let mut _0: u16;
    let _2: u16;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in ax, dx", out("ax") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:31:1: 31:22>::read_from_port(_1: u16) -> u32 {
    debug port => _1;
    let mut _0: u32;
    let _2: u32;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        asm!("in eax, dx", out("ax") _2, in("dx") _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:42:1: 42:22>::write_to_port(_1: u16, _2: u8) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, al", in("dx") _1, in("al") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:51:1: 51:23>::write_to_port(_1: u16, _2: u16) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, ax", in("dx") _1, in("ax") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:60:1: 60:23>::write_to_port(_1: u16, _2: u32) -> () {
    debug port => _1;
    debug value => _2;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("out dx, eax", in("dx") _1, in("ax") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:82:10: 82:15>::fmt(_1: &ReadOnlyAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "ReadOnlyAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:85:1: 85:39>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "ReadOnly";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:91:10: 91:15>::fmt(_1: &WriteOnlyAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "WriteOnlyAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:94:1: 94:40>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "WriteOnly";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:100:10: 100:15>::fmt(_1: &ReadWriteAccess, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "ReadWriteAccess";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:103:1: 103:40>::DEBUG_NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "ReadWrite";
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:131:1: 131:29>::new(_1: u16) -> PortGeneric<T, A> {
    debug port => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;

    bb0: {
        _0 = PortGeneric::<T, A> { port: _1, phantom: const ZeroSized: PhantomData<(T, A)> };
        return;
    }
}

// MIR FOR CTFE
fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:131:1: 131:29>::new(_1: u16) -> PortGeneric<T, A> {
    debug port => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;
    let mut _2: u16;
    let mut _3: core::marker::PhantomData<(T, A)>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<(T, A)>;
        _0 = PortGeneric::<T, A> { port: move _2, phantom: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:142:1: 142:55>::read(_1: &mut PortGeneric<T, A>) -> T {
    debug self => _1;
    let mut _0: T;
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = ((*_1).0: u16);
        _0 = <T as PortRead>::read_from_port(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:155:1: 155:57>::write(_1: &mut PortGeneric<T, A>, _2: T) -> () {
    debug self => _1;
    debug value => _2;
    let mut _0: ();
    let mut _3: u16;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: u16);
        _0 = <T as PortWrite>::write_to_port(move _3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:168:1: 168:60>::fmt(_1: &PortGeneric<T, A>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _7: core::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &u16;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &str;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &core::fmt::Arguments<'_>;
    let _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[core::fmt::rt::Argument<'_>];
    let _20: &[core::fmt::rt::Argument<'_>; 1];
    let _21: [core::fmt::rt::Argument<'_>; 1];
    let mut _22: core::fmt::rt::Argument<'_>;
    let mut _23: &&str;
    let mut _24: &[&str; 1];
    let mut _25: &usize;

    bb0: {
        _8 = const "PortGeneric";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "port";
        _11 = &((*_1).0: u16);
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = const "size";
        _25 = const _;
        _13 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _12, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _14 = const "access";
        _24 = const _;
        _18 = _24 as &[&str] (PointerCoercion(Unsize));
        _23 = const _;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_23) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _21 = [move _22];
        _20 = &_21;
        _19 = _20 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_v1(move _18, move _19) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _14, move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:168:1: 168:60>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:168:1: 168:60>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[2] in instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:168:1: 168:60>::fmt: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &_1;
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:178:1: 178:39>::clone(_1: &PortGeneric<T, A>) -> PortGeneric<T, A> {
    debug self => _1;
    let mut _0: instructions::port::PortGeneric<T, A>;
    let mut _2: u16;

    bb0: {
        _2 = ((*_1).0: u16);
        _0 = PortGeneric::<T, A> { port: move _2, phantom: const ZeroSized: PhantomData<(T, A)> };
        return;
    }
}

fn instructions::port::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/port.rs:187:1: 187:43>::eq(_1: &PortGeneric<T, A>, _2: &PortGeneric<T, A>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:3:16: 3:21>::clone(_1: &RdRand) -> RdRand {
    debug self => _1;
    let mut _0: instructions::random::RdRand;
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:3:23: 3:28>::fmt(_1: &RdRand, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "RdRand";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::new() -> Option<RdRand> {
    let mut _0: core::option::Option<instructions::random::RdRand>;
    let _1: core::arch::x86_64::CpuidResult;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    scope 1 {
        debug cpuid => _1;
    }
    scope 2 {
    }

    bb0: {
        _1 = __cpuid(const 1_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_1.2: u32);
        _5 = const 30_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 30_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 1_u32, const 30_i32);
        _2 = BitAnd(move _3, move _4);
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Option::<RdRand>::Some(const RdRand(()));
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<RdRand>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u64(_1: RdRand) -> Option<u64> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u64>;
    let mut _2: u64;
    let mut _3: i32;
    let mut _4: &mut u64;
    let mut _5: u64;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _4 = &mut _2;
        _3 = _rdrand64_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u64>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u64>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u64: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand64 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u64: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u32(_1: RdRand) -> Option<u32> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u32>;
    let mut _2: u32;
    let mut _3: i32;
    let mut _4: &mut u32;
    let mut _5: u32;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u32;
        _4 = &mut _2;
        _3 = _rdrand32_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u32>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u32>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u32: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand32 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u32: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u16(_1: RdRand) -> Option<u16> {
    debug self => const RdRand(());
    let mut _0: core::option::Option<u16>;
    let mut _2: u16;
    let mut _3: i32;
    let mut _4: &mut u16;
    let mut _5: u16;
    let mut _7: bool;
    let mut _8: (&i32, &i32);
    let mut _9: &i32;
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: i32;
    let _16: !;
    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _18: core::fmt::Arguments<'_>;
    let mut _19: &[&str];
    scope 1 {
        debug res => _2;
        scope 2 {
            let _6: i32;
            scope 3 {
                debug x => _6;
                let _10: &i32;
                let _11: &i32;
                let mut _21: &i32;
                scope 4 {
                    debug left_val => _10;
                    debug right_val => _11;
                    let _15: core::panicking::AssertKind;
                    scope 5 {
                        debug kind => _15;
                        let mut _20: &[&str; 1];
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u16;
        _4 = &mut _2;
        _3 = _rdrand16_step(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_3) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _3;
        _7 = const true;
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb3: {
        _5 = _2;
        _0 = Option::<u16>::Some(move _5);
        goto -> bb8;
    }

    bb4: {
        _9 = &_6;
        _21 = const _;
        _8 = (move _9, _21);
        _10 = (_8.0: &i32);
        _11 = (_8.1: &i32);
        _13 = (*_10);
        _14 = (*_11);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _15 = core::panicking::AssertKind::Eq;
        _20 = const _;
        _19 = _20 as &[&str] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_const(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Option::<Arguments<'_>>::Some(move _18);
        _16 = assert_failed::<i32, i32>(move _15, _10, _11, move _17) -> unwind unreachable;
    }

    bb7: {
        _0 = Option::<u16>::None;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

promoted[0] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u16: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "rdrand16 returned non-binary value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in random::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/random.rs:7:1: 7:12>::get_u16: &i32 = {
    let mut _0: &i32;
    let mut _1: i32;

    bb0: {
        _1 = const 0_i32;
        _0 = &_1;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:62:1: 62:20>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, cs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:62:1: 62:20>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u64;
    let mut _3: u16;
    scope 1 {
    }

    bb0: {
        _3 = (_1.0: u16);
        _2 = <u64 as From<u16>>::from(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("push {0}
lea {1}, [1f + rip]
push {1}
retfq
1:", in(reg) move _2, lateout(reg) _, options(PRESERVES_FLAGS)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, ss", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov ss, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, ds", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov ds, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, es", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov es, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, fs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov fs, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::BASE: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = const _;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::read_base() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    scope 1 {
        let _1: u64;
        scope 2 {
            debug val => _1;
        }
    }

    bb0: {
        asm!("rdfsbase {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new_unsafe(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::write_base(_1: addr::VirtAddr) -> () {
    debug base => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("wrfsbase {0}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::get_reg() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;
    let _1: u16;
    let mut _2: u16;
    scope 1 {
        debug segment => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0:x}, gs", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = SegmentSelector(move _2);
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:26:9: 26:31>::set_reg(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("mov gs, {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::BASE: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = const _;
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::read_base() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _2: u64;
    scope 1 {
        let _1: u64;
        scope 2 {
            debug val => _1;
        }
    }

    bb0: {
        asm!("rdgsbase {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new_unsafe(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:41:9: 41:33>::write_base(_1: addr::VirtAddr) -> () {
    debug base => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("wrgsbase {0}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn instructions::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/segmentation.rs:98:1: 98:8>::swap() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("swapgs", options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn set_cs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <CS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_ss(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <SS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_ds(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <DS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_es(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <ES as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_fs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <FS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn load_gs(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = <GS as Segment>::set_reg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn swap_gs() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = instructions::segmentation::<impl GS>::swap() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn cs() -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = <CS as Segment>::get_reg() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn wrfsbase(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    let mut _2: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <FS as Segment64>::write_base(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rdfsbase() -> u64 {
    let mut _0: u64;
    let mut _1: addr::VirtAddr;

    bb0: {
        _1 = <FS as Segment64>::read_base() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::as_u64(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn wrgsbase(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    let mut _2: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::new(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <GS as Segment64>::write_base(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rdgsbase() -> u64 {
    let mut _0: u64;
    let mut _1: addr::VirtAddr;

    bb0: {
        _1 = <GS as Segment64>::read_base() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::as_u64(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn lgdt(_1: &DescriptorTablePointer) -> () {
    debug gdt => _1;
    let mut _0: ();
    let mut _2: *const structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _2 = &raw const (*_1);
        asm!("lgdt [{0}]", in(reg) move _2, options(READONLY | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lidt(_1: &DescriptorTablePointer) -> () {
    debug idt => _1;
    let mut _0: ();
    let mut _2: *const structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _2 = &raw const (*_1);
        asm!("lidt [{0}]", in(reg) move _2, options(READONLY | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sgdt() -> DescriptorTablePointer {
    let mut _0: structures::DescriptorTablePointer;
    let mut _1: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: *mut structures::DescriptorTablePointer;
    let mut _4: &mut structures::DescriptorTablePointer;
    scope 1 {
        debug gdt => _1;
        scope 2 {
        }
    }

    bb0: {
        _2 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = DescriptorTablePointer { limit: const 0_u16, base: move _2 };
        _4 = &mut _1;
        _3 = &raw mut (*_4);
        asm!("sgdt [{0}]", in(reg) move _3, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn sidt() -> DescriptorTablePointer {
    let mut _0: structures::DescriptorTablePointer;
    let mut _1: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: *mut structures::DescriptorTablePointer;
    let mut _4: &mut structures::DescriptorTablePointer;
    scope 1 {
        debug idt => _1;
        scope 2 {
        }
    }

    bb0: {
        _2 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = DescriptorTablePointer { limit: const 0_u16, base: move _2 };
        _4 = &mut _1;
        _3 = &raw mut (*_4);
        asm!("sidt [{0}]", in(reg) move _3, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn load_tss(_1: SegmentSelector) -> () {
    debug sel => _1;
    let mut _0: ();
    let mut _2: u16;
    scope 1 {
    }

    bb0: {
        _2 = (_1.0: u16);
        asm!("ltr {0:x}", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn flush(_1: addr::VirtAddr) -> () {
    debug addr => _1;
    let mut _0: ();
    let mut _2: u64;
    scope 1 {
    }

    bb0: {
        _2 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        asm!("invlpg [{0}]", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn flush_all() -> () {
    let mut _0: ();
    let _1: structures::paging::frame::PhysFrame;
    let _2: registers::control::Cr3Flags;
    let mut _3: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    scope 1 {
        debug frame => _1;
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: registers::control::Cr3Flags);
        _0 = control::x86_64::<impl control::Cr3>::write(_1, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:32:10: 32:15>::fmt(_1: &InvPicdCommand, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &addr::VirtAddr;
    let _5: &instructions::tlb::Pcid;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&instructions::tlb::Pcid;
    let _10: &instructions::tlb::Pcid;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &&instructions::tlb::Pcid;
    let _14: &str;
    let _15: &str;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
    }
    scope 2 {
        debug __self_0 => _10;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _15 = const "AllExceptGlobal";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb5, unwind unreachable];
    }

    bb2: {
        _4 = &(((*_1) as Address).0: addr::VirtAddr);
        _5 = &(((*_1) as Address).1: instructions::tlb::Pcid);
        _6 = const "Address";
        _7 = _4 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _9 = &_5;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _6, move _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb3: {
        _10 = &(((*_1) as Single).0: instructions::tlb::Pcid);
        _11 = const "Single";
        _13 = &_10;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _11, move _12) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _14 = const "All";
        _0 = Formatter::<'_>::write_str(_2, _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:50:10: 50:15>::fmt(_1: &InvpcidDescriptor, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u64;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&u64;
    let _10: &u64;

    bb0: {
        _3 = const "InvpcidDescriptor";
        _4 = const "address";
        _6 = &((*_1).0: u64);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "pcid";
        _10 = &((*_1).1: u64);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:10: 58:15>::fmt(_1: &Pcid, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "Pcid";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:17: 58:22>::clone(_1: &Pcid) -> Pcid {
    debug self => _1;
    let mut _0: instructions::tlb::Pcid;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:30: 58:39>::eq(_1: &Pcid, _2: &Pcid) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:41: 58:43>::assert_receiver_is_total_eq(_1: &Pcid) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:45: 58:55>::partial_cmp(_1: &Pcid, _2: &Pcid) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:57: 58:60>::cmp(_1: &Pcid, _2: &Pcid) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:58:62: 58:66>::hash(_1: &Pcid, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:61:1: 61:10>::new(_1: u16) -> Result<Pcid, &str> {
    debug pcid => _1;
    let mut _0: core::result::Result<instructions::tlb::Pcid, &str>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: instructions::tlb::Pcid;

    bb0: {
        _2 = Ge(_1, const 4096_u16);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = const "PCID should be < 4096.";
        _0 = Result::<Pcid, &str>::Err(_3);
        goto -> bb3;
    }

    bb2: {
        _4 = Pcid(_1);
        _0 = Result::<Pcid, &str>::Ok(move _4);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:61:1: 61:10>::new(_1: u16) -> Result<Pcid, &str> {
    debug pcid => _1;
    let mut _0: core::result::Result<instructions::tlb::Pcid, &str>;
    let mut _2: bool;
    let mut _3: u16;
    let mut _4: &str;
    let _5: &str;
    let mut _6: instructions::tlb::Pcid;
    let mut _7: u16;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        _2 = Ge(move _3, const 4096_u16);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const "PCID should be < 4096.";
        _4 = &(*_5);
        _0 = Result::<Pcid, &str>::Err(move _4);
        StorageDead(_4);
        StorageDead(_5);
        goto -> bb3;
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _1;
        _6 = Pcid(move _7);
        StorageDead(_7);
        _0 = Result::<Pcid, &str>::Ok(move _6);
        StorageDead(_6);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:61:1: 61:10>::value(_1: &Pcid) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = ((*_1).0: u16);
        return;
    }
}

// MIR FOR CTFE
fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:61:1: 61:10>::value(_1: &Pcid) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = ((*_1).0: u16);
        return;
    }
}

fn flush_pcid(_1: InvPicdCommand) -> () {
    debug command => _1;
    let mut _0: ();
    let mut _2: instructions::tlb::InvpcidDescriptor;
    let mut _4: isize;
    let mut _7: u64;
    let mut _8: u16;
    let mut _9: &instructions::tlb::Pcid;
    let mut _10: u64;
    let mut _12: u64;
    let mut _13: u16;
    let mut _14: u64;
    let mut _15: *const instructions::tlb::InvpcidDescriptor;
    let _16: &instructions::tlb::InvpcidDescriptor;
    scope 1 {
        debug desc => _2;
        let _3: u64;
        scope 2 {
            debug kind => _3;
            let _5: addr::VirtAddr;
            let _6: instructions::tlb::Pcid;
            let _11: instructions::tlb::Pcid;
            scope 3 {
                debug addr => _5;
                debug pcid => _6;
            }
            scope 4 {
                debug pcid => _11;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _2 = InvpcidDescriptor { address: const 0_u64, pcid: const 0_u64 };
        _4 = discriminant(_1);
        switchInt(move _4) -> [0: bb2, 1: bb6, 2: bb8, 3: bb1, otherwise: bb11];
    }

    bb1: {
        _3 = const 3_u64;
        goto -> bb9;
    }

    bb2: {
        _5 = ((_1 as Address).0: addr::VirtAddr);
        _6 = ((_1 as Address).1: instructions::tlb::Pcid);
        _3 = const 0_u64;
        _9 = &_6;
        _8 = Pcid::value(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = <u16 as Into<u64>>::into(move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        (_2.1: u64) = move _7;
        _10 = addr::VirtAddr::as_u64(_5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        (_2.0: u64) = move _10;
        goto -> bb9;
    }

    bb6: {
        _11 = ((_1 as Single).0: instructions::tlb::Pcid);
        _3 = const 1_u64;
        _13 = (_11.0: u16);
        _12 = <u16 as Into<u64>>::into(move _13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        (_2.1: u64) = move _12;
        goto -> bb9;
    }

    bb8: {
        _3 = const 2_u64;
        goto -> bb9;
    }

    bb9: {
        _14 = _3;
        _16 = &_2;
        _15 = &raw const (*_16);
        asm!("invpcid {0}, [{1}]", in(reg) move _14, in(reg) move _15, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }

    bb11: {
        unreachable;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:128:10: 128:15>::fmt(_1: &Invlpgb, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u16;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &bool;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &&u32;
    let _13: &u32;

    bb0: {
        _3 = const "Invlpgb";
        _4 = const "invlpgb_count_max";
        _6 = &((*_1).0: u16);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "tlb_flush_nested";
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "nasid";
        _13 = &((*_1).2: u32);
        _12 = &_13;
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:128:17: 128:22>::clone(_1: &Invlpgb) -> Invlpgb {
    debug self => _1;
    let mut _0: instructions::tlb::Invlpgb;
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::new() -> Option<Invlpgb> {
    let mut _0: core::option::Option<instructions::tlb::Invlpgb>;
    let _1: registers::segmentation::SegmentSelector;
    let mut _2: (&PrivilegeLevel, &PrivilegeLevel);
    let mut _3: &PrivilegeLevel;
    let _4: PrivilegeLevel;
    let mut _7: bool;
    let _9: !;
    let mut _10: core::option::Option<core::fmt::Arguments<'_>>;
    let mut _12: bool;
    let mut _13: &u32;
    let mut _15: &u32;
    let mut _17: u32;
    let mut _18: &u32;
    let mut _19: core::ops::RangeInclusive<usize>;
    let mut _22: instructions::tlb::Invlpgb;
    scope 1 {
        debug cs => _1;
        let _5: &PrivilegeLevel;
        let _6: &PrivilegeLevel;
        let _11: core::arch::x86_64::CpuidResult;
        let mut _23: &PrivilegeLevel;
        scope 2 {
            debug left_val => _5;
            debug right_val => _6;
            let _8: core::panicking::AssertKind;
            scope 3 {
                debug kind => _8;
            }
        }
        scope 4 {
            debug cpuid => _11;
            let _14: bool;
            scope 6 {
                debug tlb_flush_nested => _14;
                let _16: u16;
                scope 7 {
                    debug invlpgb_count_max => _16;
                    let _20: core::arch::x86_64::CpuidResult;
                    scope 8 {
                        debug cpuid => _20;
                        let _21: u32;
                        scope 10 {
                            debug nasid => _21;
                        }
                    }
                    scope 9 {
                    }
                }
            }
        }
        scope 5 {
        }
    }

    bb0: {
        _1 = <CS as Segment>::get_reg() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = SegmentSelector::rpl(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = &_4;
        _23 = const _;
        _2 = (move _3, _23);
        _5 = (_2.0: &PrivilegeLevel);
        _6 = (_2.1: &PrivilegeLevel);
        _7 = <PrivilegeLevel as PartialEq>::eq(_5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _11 = __cpuid(const 2147483656_u32) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _8 = core::panicking::AssertKind::Eq;
        _10 = Option::<Arguments<'_>>::None;
        _9 = assert_failed::<PrivilegeLevel, PrivilegeLevel>(move _8, _5, _6, move _10) -> unwind unreachable;
    }

    bb6: {
        _13 = &(_11.1: u32);
        _12 = <u32 as BitField>::get_bit(move _13, const 3_usize) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _12) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _15 = &(_11.1: u32);
        _14 = <u32 as BitField>::get_bit(move _15, const 21_usize) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = Option::<Invlpgb>::None;
        goto -> bb14;
    }

    bb10: {
        _18 = &(_11.3: u32);
        _19 = RangeInclusive::<usize>::new(const 0_usize, const 15_usize) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _17 = <u32 as BitField>::get_bits::<RangeInclusive<usize>>(move _18, move _19) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = move _17 as u16 (IntToInt);
        _20 = __cpuid(const 2147483658_u32) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = (_20.1: u32);
        _22 = Invlpgb { invlpgb_count_max: _16, tlb_flush_nested: _14, nasid: _21 };
        _0 = Option::<Invlpgb>::Some(move _22);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

promoted[0] in tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::new: &PrivilegeLevel = {
    let mut _0: &PrivilegeLevel;
    let mut _1: PrivilegeLevel;

    bb0: {
        _1 = PrivilegeLevel::Ring0;
        _0 = &_1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::invlpgb_count_max(_1: &Invlpgb) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = ((*_1).0: u16);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::tlb_flush_nested(_1: &Invlpgb) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = ((*_1).1: bool);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::nasid(_1: &Invlpgb) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = ((*_1).2: u32);
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::build(_1: &Invlpgb) -> InvlpgbFlushBuilder<'_> {
    debug self => _1;
    let mut _0: instructions::tlb::InvlpgbFlushBuilder<'_>;
    let mut _2: core::option::Option<structures::paging::page::PageRange>;
    let mut _3: core::option::Option<instructions::tlb::Pcid>;
    let mut _4: core::option::Option<u16>;

    bb0: {
        _2 = Option::<PageRange>::None;
        _3 = Option::<Pcid>::None;
        _4 = Option::<u16>::None;
        _0 = InvlpgbFlushBuilder::<'_> { invlpgb: _1, page_range: move _2, pcid: move _3, asid: move _4, include_global: const false, final_translation_only: const false, include_nested_translations: const false };
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:135:1: 135:13>::tlbsync(_1: &Invlpgb) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("tlbsync", options(NOMEM | PRESERVES_FLAGS)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:207:10: 207:15>::fmt(_1: &InvlpgbFlushBuilder<'_, S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _4: &[&dyn core::fmt::Debug; 7];
    let _5: [&dyn core::fmt::Debug; 7];
    let mut _6: &dyn core::fmt::Debug;
    let _7: &&instructions::tlb::Invlpgb;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &core::option::Option<structures::paging::page::PageRange<S>>;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &core::option::Option<instructions::tlb::Pcid>;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &core::option::Option<u16>;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &bool;
    let mut _16: &dyn core::fmt::Debug;
    let _17: &bool;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &&bool;
    let _20: &bool;
    let _21: &str;
    let mut _22: &[&str];
    let mut _23: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn core::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _23 = const _;
        _7 = &((*_1).0: &instructions::tlb::Invlpgb);
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: core::option::Option<structures::paging::page::PageRange<S>>);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: core::option::Option<instructions::tlb::Pcid>);
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: core::option::Option<u16>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: bool);
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: bool);
        _16 = _17 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _20 = &((*_1).6: bool);
        _19 = &_20;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _4 = &_5;
        _3 = _4 as &[&dyn core::fmt::Debug] (PointerCoercion(Unsize));
        _21 = const "InvlpgbFlushBuilder";
        _22 = _23 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _21, move _22, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:207:10: 207:15>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "page_range";
        _2 = &(*_3);
        _5 = const "pcid";
        _4 = &(*_5);
        _7 = const "asid";
        _6 = &(*_7);
        _9 = const "include_global";
        _8 = &(*_9);
        _11 = const "final_translation_only";
        _10 = &(*_11);
        _13 = const "include_nested_translations";
        _12 = &(*_13);
        _1 = [const "invlpgb", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:207:17: 207:22>::clone(_1: &InvlpgbFlushBuilder<'_, S>) -> InvlpgbFlushBuilder<'_, S> {
    debug self => _1;
    let mut _0: instructions::tlb::InvlpgbFlushBuilder<'_, S>;
    let _2: &instructions::tlb::Invlpgb;
    let _3: &&instructions::tlb::Invlpgb;
    let mut _4: core::option::Option<structures::paging::page::PageRange<S>>;
    let _5: &core::option::Option<structures::paging::page::PageRange<S>>;
    let mut _6: core::option::Option<instructions::tlb::Pcid>;
    let _7: &core::option::Option<instructions::tlb::Pcid>;
    let mut _8: core::option::Option<u16>;
    let _9: &core::option::Option<u16>;
    let mut _10: bool;
    let _11: &bool;
    let mut _12: bool;
    let _13: &bool;
    let mut _14: bool;
    let _15: &bool;

    bb0: {
        _3 = &((*_1).0: &instructions::tlb::Invlpgb);
        _2 = <&Invlpgb as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::option::Option<structures::paging::page::PageRange<S>>);
        _4 = <Option<PageRange<S>> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = &((*_1).2: core::option::Option<instructions::tlb::Pcid>);
        _6 = <Option<Pcid> as Clone>::clone(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = &((*_1).3: core::option::Option<u16>);
        _8 = <Option<u16> as Clone>::clone(_9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = &((*_1).4: bool);
        _10 = (*_11);
        _13 = &((*_1).5: bool);
        _12 = (*_13);
        _15 = &((*_1).6: bool);
        _14 = (*_15);
        _0 = InvlpgbFlushBuilder::<'_, S> { invlpgb: _2, page_range: move _4, pcid: move _6, asid: move _8, include_global: move _10, final_translation_only: move _12, include_nested_translations: move _14 };
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::pages(_1: InvlpgbFlushBuilder<'_, S>, _2: PageRange<T>) -> InvlpgbFlushBuilder<'_, T> {
    debug self => _1;
    debug page_range => _2;
    let mut _0: instructions::tlb::InvlpgbFlushBuilder<'_, T>;
    let mut _3: core::option::Option<structures::paging::page::PageRange<T>>;
    let mut _4: core::option::Option<instructions::tlb::Pcid>;
    let mut _5: core::option::Option<u16>;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: &instructions::tlb::Invlpgb;

    bb0: {
        _9 = deref_copy (_1.0: &instructions::tlb::Invlpgb);
        _3 = Option::<PageRange<T>>::Some(_2);
        _4 = (_1.2: core::option::Option<instructions::tlb::Pcid>);
        _5 = (_1.3: core::option::Option<u16>);
        _6 = (_1.4: bool);
        _7 = (_1.5: bool);
        _8 = (_1.6: bool);
        _0 = InvlpgbFlushBuilder::<'_, T> { invlpgb: _9, page_range: move _3, pcid: move _4, asid: move _5, include_global: move _6, final_translation_only: move _7, include_nested_translations: move _8 };
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::pcid(_1: &mut InvlpgbFlushBuilder<'_, S>, _2: Pcid) -> &mut InvlpgbFlushBuilder<'_, S> {
    debug self => _1;
    debug pcid => _2;
    let mut _0: &mut instructions::tlb::InvlpgbFlushBuilder<'_, S>;
    let mut _3: core::option::Option<instructions::tlb::Pcid>;

    bb0: {
        _3 = Option::<Pcid>::Some(_2);
        ((*_1).2: core::option::Option<instructions::tlb::Pcid>) = move _3;
        _0 = _1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::asid(_1: &mut InvlpgbFlushBuilder<'_, S>, _2: u16) -> Result<&mut InvlpgbFlushBuilder<'_, S>, AsidOutOfRangeError> {
    debug self => _1;
    debug asid => _2;
    let mut _0: core::result::Result<&mut instructions::tlb::InvlpgbFlushBuilder<'_, S>, instructions::tlb::AsidOutOfRangeError>;
    let mut _3: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: instructions::tlb::AsidOutOfRangeError;
    let mut _7: u32;
    let mut _8: core::option::Option<u16>;
    let mut _9: &instructions::tlb::Invlpgb;
    let mut _10: &instructions::tlb::Invlpgb;

    bb0: {
        _4 = <u32 as From<u16>>::from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = deref_copy ((*_1).0: &instructions::tlb::Invlpgb);
        _5 = ((*_9).2: u32);
        _3 = Ge(move _4, move _5);
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _10 = deref_copy ((*_1).0: &instructions::tlb::Invlpgb);
        _7 = ((*_10).2: u32);
        _6 = AsidOutOfRangeError { asid: _2, nasid: move _7 };
        _0 = Result::<&mut InvlpgbFlushBuilder<'_, S>, AsidOutOfRangeError>::Err(move _6);
        goto -> bb4;
    }

    bb3: {
        _8 = Option::<u16>::Some(_2);
        ((*_1).3: core::option::Option<u16>) = move _8;
        _0 = Result::<&mut InvlpgbFlushBuilder<'_, S>, AsidOutOfRangeError>::Ok(_1);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::include_global(_1: &mut InvlpgbFlushBuilder<'_, S>) -> &mut InvlpgbFlushBuilder<'_, S> {
    debug self => _1;
    let mut _0: &mut instructions::tlb::InvlpgbFlushBuilder<'_, S>;

    bb0: {
        ((*_1).4: bool) = const true;
        _0 = _1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::final_translation_only(_1: &mut InvlpgbFlushBuilder<'_, S>) -> &mut InvlpgbFlushBuilder<'_, S> {
    debug self => _1;
    let mut _0: &mut instructions::tlb::InvlpgbFlushBuilder<'_, S>;

    bb0: {
        ((*_1).5: bool) = const true;
        _0 = _1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::include_nested_translations(_1: InvlpgbFlushBuilder<'_, S>) -> InvlpgbFlushBuilder<'_, S> {
    debug self => _1;
    let mut _0: instructions::tlb::InvlpgbFlushBuilder<'_, S>;
    let mut _2: bool;
    let mut _3: !;
    let mut _4: &instructions::tlb::Invlpgb;

    bb0: {
        _4 = deref_copy (_1.0: &instructions::tlb::Invlpgb);
        _2 = ((*_4).1: bool);
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = panic(const "flushing all nested translations is not supported") -> unwind unreachable;
    }

    bb2: {
        (_1.6: bool) = const true;
        _0 = move _1;
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:222:1: 224:25>::flush(_1: &InvlpgbFlushBuilder<'_, S>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: isize;
    let mut _4: bool;
    let mut _5: &structures::paging::page::PageRange<S>;
    let mut _7: core::option::Option<usize>;
    let _8: &structures::paging::page::Page<S>;
    let _9: &structures::paging::page::Page<S>;
    let mut _11: addr::VirtAddr;
    let mut _13: bool;
    let mut _14: &structures::paging::page::Page<S>;
    let mut _15: &structures::paging::page::Page<S>;
    let mut _17: core::option::Option<usize>;
    let _18: &structures::paging::page::Page<S>;
    let _19: &structures::paging::page::Page<S>;
    let mut _21: core::result::Result<u16, core::num::TryFromIntError>;
    let mut _22: usize;
    let mut _24: u16;
    let _25: ();
    let mut _26: core::option::Option<(structures::paging::page::Page<S>, u16)>;
    let mut _27: (structures::paging::page::Page<S>, u16);
    let mut _28: structures::paging::page::Page<S>;
    let mut _29: core::option::Option<instructions::tlb::Pcid>;
    let mut _30: core::option::Option<u16>;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _35: structures::paging::page::Page<S>;
    let mut _36: core::option::Option<structures::paging::page::Page<S>>;
    let mut _37: structures::paging::page::Page<S>;
    let mut _38: usize;
    let _39: ();
    let mut _40: core::option::Option<(structures::paging::page::Page<S>, u16)>;
    let mut _41: core::option::Option<instructions::tlb::Pcid>;
    let mut _42: core::option::Option<u16>;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: &instructions::tlb::Invlpgb;
    scope 1 {
        debug pages => _3;
        let mut _3: structures::paging::page::PageRange<S>;
        let _6: usize;
        scope 2 {
            debug count => _6;
            let _10: structures::paging::page::Page<S>;
            scope 3 {
                debug second_half_start => _10;
                let _12: usize;
                let _16: usize;
                scope 4 {
                    debug count => _12;
                    let _20: u16;
                    scope 6 {
                        debug count => _20;
                        let _23: u16;
                        scope 7 {
                            debug count => _23;
                            let _34: u16;
                            scope 8 {
                            }
                            scope 9 {
                                debug inc_count => _34;
                            }
                        }
                    }
                }
                scope 5 {
                    debug count_to_second_half => _16;
                }
            }
        }
    }
    scope 10 {
    }

    bb0: {
        _2 = discriminant(((*_1).1: core::option::Option<structures::paging::page::PageRange<S>>));
        switchInt(move _2) -> [1: bb1, otherwise: bb23];
    }

    bb1: {
        _3 = ((((*_1).1: core::option::Option<structures::paging::page::PageRange<S>>) as Some).0: structures::paging::page::PageRange<S>);
        goto -> bb2;
    }

    bb2: {
        _5 = &_3;
        _4 = PageRange::<S>::is_empty(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb4, otherwise: bb24];
    }

    bb4: {
        _8 = &(_3.0: structures::paging::page::Page<S>);
        _9 = &(_3.1: structures::paging::page::Page<S>);
        _7 = Page::<S>::steps_between_impl(_8, _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = Option::<usize>::unwrap(move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = addr::VirtAddr::new(const 18446603336221196288_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _10 = Page::<S>::containing_address(move _11) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = &(_3.0: structures::paging::page::Page<S>);
        _15 = &_10;
        _13 = <Page<S> as PartialOrd>::lt(move _14, move _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb13, otherwise: bb10];
    }

    bb10: {
        _18 = &(_3.0: structures::paging::page::Page<S>);
        _19 = &_10;
        _17 = Page::<S>::steps_between_impl(_18, _19) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _16 = Option::<usize>::unwrap(move _17) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _12 = core::cmp::min::<usize>(_6, _16) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _12 = _6;
        goto -> bb14;
    }

    bb14: {
        _22 = _12;
        _21 = <u16 as TryFrom<usize>>::try_from(move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _20 = Result::<u16, TryFromIntError>::unwrap_or(move _21, const _) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _46 = deref_copy ((*_1).0: &instructions::tlb::Invlpgb);
        _24 = ((*_46).0: u16);
        _23 = core::cmp::min::<u16>(_20, move _24) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = (_3.0: structures::paging::page::Page<S>);
        _27 = (move _28, _23);
        _26 = Option::<(Page<S>, u16)>::Some(move _27);
        _29 = ((*_1).2: core::option::Option<instructions::tlb::Pcid>);
        _30 = ((*_1).3: core::option::Option<u16>);
        _31 = ((*_1).4: bool);
        _32 = ((*_1).5: bool);
        _33 = ((*_1).6: bool);
        _25 = flush_broadcast::<S>(move _26, move _29, move _30, move _31, move _32, move _33) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _34 = core::cmp::max::<u16>(_23, const 1_u16) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _37 = (_3.0: structures::paging::page::Page<S>);
        _38 = <usize as From<u16>>::from(_34) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _36 = Page::<S>::forward_checked_impl(move _37, move _38) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _35 = Option::<Page<S>>::unwrap(move _36) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        (_3.0: structures::paging::page::Page<S>) = move _35;
        goto -> bb2;
    }

    bb23: {
        _40 = Option::<(Page<S>, u16)>::None;
        _41 = ((*_1).2: core::option::Option<instructions::tlb::Pcid>);
        _42 = ((*_1).3: core::option::Option<u16>);
        _43 = ((*_1).4: bool);
        _44 = ((*_1).5: bool);
        _45 = ((*_1).6: bool);
        _39 = flush_broadcast::<S>(move _40, move _41, move _42, move _43, move _44, move _45) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:353:10: 353:15>::fmt(_1: &AsidOutOfRangeError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u16;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&u32;
    let _10: &u32;

    bb0: {
        _3 = const "AsidOutOfRangeError";
        _4 = const "asid";
        _6 = &((*_1).0: u16);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "nasid";
        _10 = &((*_1).1: u32);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:361:1: 361:42>::fmt(_1: &AsidOutOfRangeError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &u16;
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &u32;
    let mut _12: &[&str; 3];

    bb0: {
        _12 = const _;
        _4 = _12 as &[&str] (PointerCoercion(Unsize));
        _9 = &((*_1).0: u16);
        _8 = core::fmt::rt::Argument::<'_>::new_display::<u16>(_9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = &((*_1).1: u32);
        _10 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_11) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = [move _8, move _10];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

promoted[0] in tlb::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/instructions/tlb.rs:361:1: 361:42>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const " is out of the range of available ASIDS (", const ")"];
        _0 = &_1;
        return;
    }
}

fn flush_broadcast(_1: Option<(Page<S>, u16)>, _2: Option<Pcid>, _3: Option<u16>, _4: bool, _5: bool, _6: bool) -> () {
    debug va_and_count => _1;
    debug pcid => _2;
    debug asid => _3;
    debug include_global => _4;
    debug final_translation_only => _5;
    debug include_nested_translations => _6;
    let mut _0: ();
    let mut _7: u64;
    let mut _10: isize;
    let _13: &mut u64;
    let mut _14: &mut u64;
    let _15: &mut u64;
    let mut _16: &mut u64;
    let mut _17: core::ops::RangeFrom<usize>;
    let mut _18: u64;
    let mut _19: &u64;
    let _20: u64;
    let mut _21: addr::VirtAddr;
    let mut _22: core::ops::RangeFrom<usize>;
    let _23: &mut u32;
    let mut _24: &mut u32;
    let mut _25: core::ops::RangeInclusive<usize>;
    let mut _26: u32;
    let _27: &mut u32;
    let mut _28: &mut u32;
    let mut _29: bool;
    let mut _30: isize;
    let _32: &mut u64;
    let mut _33: &mut u64;
    let _34: &mut u32;
    let mut _35: &mut u32;
    let mut _36: core::ops::RangeInclusive<usize>;
    let mut _37: u32;
    let mut _38: u16;
    let mut _39: &instructions::tlb::Pcid;
    let mut _40: isize;
    let _42: &mut u64;
    let mut _43: &mut u64;
    let _44: &mut u32;
    let mut _45: &mut u32;
    let mut _46: core::ops::RangeInclusive<usize>;
    let mut _47: u32;
    let _48: &mut u64;
    let mut _49: &mut u64;
    let _50: &mut u64;
    let mut _51: &mut u64;
    let _52: &mut u64;
    let mut _53: &mut u64;
    let mut _54: u64;
    let mut _55: u32;
    let mut _56: u32;
    scope 1 {
        debug rax => _7;
        let mut _8: u32;
        scope 2 {
            debug ecx => _8;
            let mut _9: u32;
            scope 3 {
                debug edx => _9;
                scope 4 {
                    debug va => _11;
                    debug count => _12;
                    let _11: structures::paging::page::Page<S>;
                    let _12: u16;
                }
                scope 5 {
                    debug pcid => _31;
                    let _31: instructions::tlb::Pcid;
                }
                scope 6 {
                    debug asid => _41;
                    let _41: u16;
                }
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _7 = const 0_u64;
        _8 = const 0_u32;
        _9 = const 0_u32;
        _10 = discriminant(_1);
        switchInt(move _10) -> [1: bb1, otherwise: bb10];
    }

    bb1: {
        _11 = (((_1 as Some).0: (structures::paging::page::Page<S>, u16)).0: structures::paging::page::Page<S>);
        _12 = (((_1 as Some).0: (structures::paging::page::Page<S>, u16)).1: u16);
        _14 = &mut _7;
        _13 = <u64 as BitField>::set_bit(move _14, const 0_usize, const true) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _16 = &mut _7;
        _17 = RangeFrom::<usize> { start: const 12_usize };
        _21 = Page::<S>::start_address(_11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _20 = addr::VirtAddr::as_u64(move _21) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _19 = &_20;
        _22 = RangeFrom::<usize> { start: const 12_usize };
        _18 = <u64 as BitField>::get_bits::<RangeFrom<usize>>(move _19, move _22) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _15 = <u64 as BitField>::set_bits::<RangeFrom<usize>>(move _16, move _17, move _18) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _24 = &mut _8;
        _25 = RangeInclusive::<usize>::new(const 0_usize, const 15_usize) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _26 = <u32 as From<u16>>::from(_12) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _23 = <u32 as BitField>::set_bits::<RangeInclusive<usize>>(move _24, move _25, move _26) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _28 = &mut _8;
        _29 = Eq(const _, const _);
        _27 = <u32 as BitField>::set_bit(move _28, const 31_usize, move _29) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _30 = discriminant(_2);
        switchInt(move _30) -> [1: bb11, otherwise: bb16];
    }

    bb11: {
        _31 = ((_2 as Some).0: instructions::tlb::Pcid);
        _33 = &mut _7;
        _32 = <u64 as BitField>::set_bit(move _33, const 1_usize, const true) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _35 = &mut _9;
        _36 = RangeInclusive::<usize>::new(const 16_usize, const 27_usize) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _39 = &_31;
        _38 = Pcid::value(move _39) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _37 = <u32 as From<u16>>::from(move _38) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _34 = <u32 as BitField>::set_bits::<RangeInclusive<usize>>(move _35, move _36, move _37) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _40 = discriminant(_3);
        switchInt(move _40) -> [1: bb17, otherwise: bb21];
    }

    bb17: {
        _41 = ((_3 as Some).0: u16);
        _43 = &mut _7;
        _42 = <u64 as BitField>::set_bit(move _43, const 2_usize, const true) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _45 = &mut _9;
        _46 = RangeInclusive::<usize>::new(const 0_usize, const 15_usize) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _47 = <u32 as From<u16>>::from(_41) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _44 = <u32 as BitField>::set_bits::<RangeInclusive<usize>>(move _45, move _46, move _47) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _49 = &mut _7;
        _48 = <u64 as BitField>::set_bit(move _49, const 3_usize, _4) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _51 = &mut _7;
        _50 = <u64 as BitField>::set_bit(move _51, const 4_usize, _5) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _53 = &mut _7;
        _52 = <u64 as BitField>::set_bit(move _53, const 5_usize, _6) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _54 = _7;
        _55 = _8;
        _56 = _9;
        asm!("invlpgb", in("ax") move _54, in("cx") move _55, in("dx") move _56, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        return;
    }
}

fn hlt() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("hlt", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn nop() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("nop", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn bochs_breakpoint() -> () {
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("xchg bx, bx", options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn read_rip() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let _1: u64;
    let mut _2: u64;
    scope 1 {
        debug rip => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("lea {0}, [rip]", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = _1;
        _0 = addr::VirtAddr::new(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:7:10: 7:15>::fmt(_1: &control::Cr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:14: 13:23>::eq(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:25: 13:27>::assert_receiver_is_total_eq(_1: &control::Cr0Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:29: 13:39>::partial_cmp(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:41: 13:44>::cmp(_1: &control::Cr0Flags, _2: &control::Cr0Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:46: 13:50>::hash(_1: &control::Cr0Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:52: 13:57>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::control::_::InternalBitFlags;
    let _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = const "Cr0Flags";
        _6 = &((*_1).0: registers::control::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:13:59: 13:64>::clone(_1: &control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTED_MODE_ENABLE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::MONITOR_COPROCESSOR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::EMULATE_COPROCESSOR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TASK_SWITCHED: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::EXTENSION_TYPE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NUMERIC_ERROR: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::WRITE_PROTECT: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ALIGNMENT_MASK: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NOT_WRITE_THROUGH: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 29_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 29_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 29_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::CACHE_DISABLE: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 30_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 30_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 30_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PAGING: control::Cr0Flags = {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 31_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 31_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr0Flags>] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr0Flags>];
    let mut _1: &[bitflags::Flag<registers::control::Cr0Flags>; 11];
    let _2: &[bitflags::Flag<registers::control::Cr0Flags>; 11];
    let _3: [bitflags::Flag<registers::control::Cr0Flags>; 11];
    let mut _4: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _5: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _6: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _7: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _8: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _9: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _10: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _11: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _12: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _13: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _14: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _15: &[bitflags::Flag<registers::control::Cr0Flags>; 11];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _15 = const _;
        _2 = &(*_15);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::control::Cr0Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr0Flags>; 11] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr0Flags>; 11];
    let mut _1: [bitflags::Flag<registers::control::Cr0Flags>; 11];
    let mut _2: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _3: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _4: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _5: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _6: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _7: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _8: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _9: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _10: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _11: bitflags::Flag<registers::control::Cr0Flags>;
    let mut _12: bitflags::Flag<registers::control::Cr0Flags>;

    bb0: {
        _2 = Flag::<control::Cr0Flags>::new(const "PROTECTED_MODE_ENABLE", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<control::Cr0Flags>::new(const "MONITOR_COPROCESSOR", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<control::Cr0Flags>::new(const "EMULATE_COPROCESSOR", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<control::Cr0Flags>::new(const "TASK_SWITCHED", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<control::Cr0Flags>::new(const "EXTENSION_TYPE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<control::Cr0Flags>::new(const "NUMERIC_ERROR", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<control::Cr0Flags>::new(const "WRITE_PROTECT", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<control::Cr0Flags>::new(const "ALIGNMENT_MASK", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<control::Cr0Flags>::new(const "NOT_WRITE_THROUGH", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<control::Cr0Flags>::new(const "CACHE_DISABLE", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<control::Cr0Flags>::new(const "PAGING", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12];
        _0 = &_1;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &control::Cr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &control::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &control::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = control::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <control::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::Cr0Flags;
    let _4: registers::control::Cr0Flags;
    let mut _5: registers::control::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = control::Cr0Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<control::Cr0Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<control::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::control::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::control::Cr0Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<control::Cr0Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<control::Cr0Flags, ParseError>::map::<control::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: control::Cr0Flags) -> control::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::control::_::InternalBitFlags);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &control::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::control::Cr0Flags;
    let mut _5: &bitflags::Flag<registers::control::Cr0Flags>;
    let _6: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::control::Cr0Flags;
    let mut _14: &bitflags::Flag<registers::control::Cr0Flags>;
    let _15: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::control::Cr0Flags;
    let mut _23: &bitflags::Flag<registers::control::Cr0Flags>;
    let _24: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::control::Cr0Flags;
    let mut _32: &bitflags::Flag<registers::control::Cr0Flags>;
    let _33: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::control::Cr0Flags;
    let mut _41: &bitflags::Flag<registers::control::Cr0Flags>;
    let _42: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::control::Cr0Flags;
    let mut _50: &bitflags::Flag<registers::control::Cr0Flags>;
    let _51: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::control::Cr0Flags;
    let mut _59: &bitflags::Flag<registers::control::Cr0Flags>;
    let _60: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::control::Cr0Flags;
    let mut _68: &bitflags::Flag<registers::control::Cr0Flags>;
    let _69: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::control::Cr0Flags;
    let mut _77: &bitflags::Flag<registers::control::Cr0Flags>;
    let _78: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &registers::control::Cr0Flags;
    let mut _86: &bitflags::Flag<registers::control::Cr0Flags>;
    let _87: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &registers::control::Cr0Flags;
    let mut _95: &bitflags::Flag<registers::control::Cr0Flags>;
    let _96: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let mut _102: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<control::Cr0Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr0Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<control::Cr0Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = control::_::<impl control::Cr0Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<control::Cr0Flags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = control::_::<impl control::Cr0Flags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<control::Cr0Flags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = control::_::<impl control::Cr0Flags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<control::Cr0Flags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = control::_::<impl control::Cr0Flags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<control::Cr0Flags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = control::_::<impl control::Cr0Flags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<control::Cr0Flags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = control::_::<impl control::Cr0Flags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<control::Cr0Flags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = control::_::<impl control::Cr0Flags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<control::Cr0Flags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = control::_::<impl control::Cr0Flags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<control::Cr0Flags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = control::_::<impl control::Cr0Flags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<control::Cr0Flags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = control::_::<impl control::Cr0Flags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _102 = _1;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _102) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::control::Cr0Flags;
    let _6: &registers::control::Cr0Flags;
    let mut _7: &bitflags::Flag<registers::control::Cr0Flags>;
    let _8: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::control::Cr0Flags;
    let _18: &registers::control::Cr0Flags;
    let mut _19: &bitflags::Flag<registers::control::Cr0Flags>;
    let _20: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::control::Cr0Flags;
    let _30: &registers::control::Cr0Flags;
    let mut _31: &bitflags::Flag<registers::control::Cr0Flags>;
    let _32: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::control::Cr0Flags;
    let _42: &registers::control::Cr0Flags;
    let mut _43: &bitflags::Flag<registers::control::Cr0Flags>;
    let _44: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::control::Cr0Flags;
    let _54: &registers::control::Cr0Flags;
    let mut _55: &bitflags::Flag<registers::control::Cr0Flags>;
    let _56: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::control::Cr0Flags;
    let _66: &registers::control::Cr0Flags;
    let mut _67: &bitflags::Flag<registers::control::Cr0Flags>;
    let _68: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::control::Cr0Flags;
    let _78: &registers::control::Cr0Flags;
    let mut _79: &bitflags::Flag<registers::control::Cr0Flags>;
    let _80: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::control::Cr0Flags;
    let _90: &registers::control::Cr0Flags;
    let mut _91: &bitflags::Flag<registers::control::Cr0Flags>;
    let _92: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::control::Cr0Flags;
    let _102: &registers::control::Cr0Flags;
    let mut _103: &bitflags::Flag<registers::control::Cr0Flags>;
    let _104: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::control::Cr0Flags;
    let _114: &registers::control::Cr0Flags;
    let mut _115: &bitflags::Flag<registers::control::Cr0Flags>;
    let _116: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::control::Cr0Flags;
    let _126: &registers::control::Cr0Flags;
    let mut _127: &bitflags::Flag<registers::control::Cr0Flags>;
    let _128: &[bitflags::Flag<registers::control::Cr0Flags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let mut _135: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<control::Cr0Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = control::_::<impl control::Cr0Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<control::Cr0Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = control::_::<impl control::Cr0Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<control::Cr0Flags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = control::_::<impl control::Cr0Flags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<control::Cr0Flags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = control::_::<impl control::Cr0Flags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<control::Cr0Flags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = control::_::<impl control::Cr0Flags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<control::Cr0Flags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = control::_::<impl control::Cr0Flags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<control::Cr0Flags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = control::_::<impl control::Cr0Flags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<control::Cr0Flags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = control::_::<impl control::Cr0Flags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<control::Cr0Flags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = control::_::<impl control::Cr0Flags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<control::Cr0Flags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = control::_::<impl control::Cr0Flags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<control::Cr0Flags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = control::_::<impl control::Cr0Flags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        _135 = _1;
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _135) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        StorageDead(_135);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = control::_::InternalBitFlags(_1);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = control::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = control::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    let _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = control::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::control::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::control::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::control::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::control::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::control::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::control::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::control::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::control::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::control::_::InternalBitFlags;
    let mut _46: u64;
    scope 1 {
        debug name => _2;
        let mut _47: &registers::control::Cr0Flags;
        let mut _48: &registers::control::Cr0Flags;
        let mut _49: &registers::control::Cr0Flags;
        let mut _50: &registers::control::Cr0Flags;
        let mut _51: &registers::control::Cr0Flags;
        let mut _52: &registers::control::Cr0Flags;
        let mut _53: &registers::control::Cr0Flags;
        let mut _54: &registers::control::Cr0Flags;
        let mut _55: &registers::control::Cr0Flags;
        let mut _56: &registers::control::Cr0Flags;
        let mut _57: &registers::control::Cr0Flags;
        let mut _58: &&str;
        let mut _59: &&str;
        let mut _60: &&str;
        let mut _61: &&str;
        let mut _62: &&str;
        let mut _63: &&str;
        let mut _64: &&str;
        let mut _65: &&str;
        let mut _66: &&str;
        let mut _67: &&str;
        let mut _68: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _68 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _68) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _47 = const _;
        _6 = control::_::<impl control::Cr0Flags>::bits(_47) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = control::_::InternalBitFlags(move _6);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb45;
    }

    bb4: {
        _8 = &_2;
        _67 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _67) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _48 = const _;
        _10 = control::_::<impl control::Cr0Flags>::bits(_48) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = control::_::InternalBitFlags(move _10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        goto -> bb45;
    }

    bb8: {
        _12 = &_2;
        _66 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _66) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _49 = const _;
        _14 = control::_::<impl control::Cr0Flags>::bits(_49) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = control::_::InternalBitFlags(move _14);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _13);
        goto -> bb45;
    }

    bb12: {
        _16 = &_2;
        _65 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _65) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _50 = const _;
        _18 = control::_::<impl control::Cr0Flags>::bits(_50) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = control::_::InternalBitFlags(move _18);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _17);
        goto -> bb45;
    }

    bb16: {
        _20 = &_2;
        _64 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _64) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _51 = const _;
        _22 = control::_::<impl control::Cr0Flags>::bits(_51) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = control::_::InternalBitFlags(move _22);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _21);
        goto -> bb45;
    }

    bb20: {
        _24 = &_2;
        _63 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _63) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _52 = const _;
        _26 = control::_::<impl control::Cr0Flags>::bits(_52) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = control::_::InternalBitFlags(move _26);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _25);
        goto -> bb45;
    }

    bb24: {
        _28 = &_2;
        _62 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _62) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _53 = const _;
        _30 = control::_::<impl control::Cr0Flags>::bits(_53) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = control::_::InternalBitFlags(move _30);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _29);
        goto -> bb45;
    }

    bb28: {
        _32 = &_2;
        _61 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _61) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _54 = const _;
        _34 = control::_::<impl control::Cr0Flags>::bits(_54) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = control::_::InternalBitFlags(move _34);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _33);
        goto -> bb45;
    }

    bb32: {
        _36 = &_2;
        _60 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _60) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _55 = const _;
        _38 = control::_::<impl control::Cr0Flags>::bits(_55) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = control::_::InternalBitFlags(move _38);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _37);
        goto -> bb45;
    }

    bb36: {
        _40 = &_2;
        _59 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _59) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _56 = const _;
        _42 = control::_::<impl control::Cr0Flags>::bits(_56) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = control::_::InternalBitFlags(move _42);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _41);
        goto -> bb45;
    }

    bb40: {
        _44 = &_2;
        _58 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _58) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _57 = const _;
        _46 = control::_::<impl control::Cr0Flags>::bits(_57) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = control::_::InternalBitFlags(move _46);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _45);
        goto -> bb45;
    }

    bb44: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb45;
    }

    bb45: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr0Flags = {
    let mut _0: &registers::control::Cr0Flags;
    let mut _1: registers::control::Cr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PAGING";
        _0 = &_1;
        return;
    }
}

promoted[12] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "CACHE_DISABLE";
        _0 = &_1;
        return;
    }
}

promoted[13] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NOT_WRITE_THROUGH";
        _0 = &_1;
        return;
    }
}

promoted[14] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ALIGNMENT_MASK";
        _0 = &_1;
        return;
    }
}

promoted[15] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "WRITE_PROTECT";
        _0 = &_1;
        return;
    }
}

promoted[16] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NUMERIC_ERROR";
        _0 = &_1;
        return;
    }
}

promoted[17] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "EXTENSION_TYPE";
        _0 = &_1;
        return;
    }
}

promoted[18] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TASK_SWITCHED";
        _0 = &_1;
        return;
    }
}

promoted[19] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "EMULATE_COPROCESSOR";
        _0 = &_1;
        return;
    }
}

promoted[20] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "MONITOR_COPROCESSOR";
        _0 = &_1;
        return;
    }
}

promoted[21] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTED_MODE_ENABLE";
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = control::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    let _6: registers::control::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::control::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = control::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: registers::control::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::_::InternalBitFlags as Extend<control::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: &registers::control::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = control::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut control::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::Cr0Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr0Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr0Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr0Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr0Flags(_4);
        _0 = Option::<control::Cr0Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr0Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::control::Cr0Flags;
    let mut _8: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<control::Cr0Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = control::Cr0Flags(move _8);
        StorageDead(_8);
        _0 = Option::<control::Cr0Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::Cr0Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::Cr0Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr0Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr0Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr0Flags(_4);
        _0 = Option::<control::Cr0Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr0Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr0Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr0Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr0Flags, _2: control::Cr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr0Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::Cr0Flags, _2: control::Cr0Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let _3: registers::control::Cr0Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let _3: registers::control::Cr0Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let _3: registers::control::Cr0Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;
    let _3: registers::control::Cr0Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    let mut _3: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::control::_::InternalBitFlags);
        _2 = control::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;
    let _2: registers::control::Cr0Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::Cr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr0Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr0Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::Cr0Flags;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;
    let mut _6: &registers::control::Cr0Flags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::<impl control::Cr0Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr0Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::Cr0Flags, _2: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::Cr0Flags, _2: control::Cr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr0Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::Cr0Flags) -> control::Cr0Flags {
    debug self => _1;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::Cr0Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr0Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr0Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr0Flags);
        _5 = control::_::<impl control::Cr0Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::Cr0Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: registers::control::Cr0Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr0Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::<impl control::Cr0Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr0Flags as Extend<control::Cr0Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr0Flags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr0Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr0Flags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr0Flags;
    let mut _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr0Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr0Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr0Flags) -> IterNames<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr0Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr0Flags) -> IterNames<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr0Flags>;
    let mut _2: registers::control::Cr0Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr0Flags;
    let mut _5: registers::control::Cr0Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr0Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr0Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::Cr0Flags) -> bitflags::iter::Iter<control::Cr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr0Flags>;
    let mut _2: &registers::control::Cr0Flags;

    bb0: {
        _2 = &_1;
        _0 = control::_::<impl control::Cr0Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:54:1: 54:14>::from_bits_unchecked(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:54:1: 54:14>::from_bits_unchecked(_1: u64) -> control::Cr0Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr0Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr0Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:65:10: 65:15>::fmt(_1: &control::Cr2, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr2";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:69:10: 69:15>::fmt(_1: &control::Cr3, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr3";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:14: 76:23>::eq(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:25: 76:27>::assert_receiver_is_total_eq(_1: &control::Cr3Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:29: 76:39>::partial_cmp(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:41: 76:44>::cmp(_1: &control::Cr3Flags, _2: &control::Cr3Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:46: 76:50>::hash(_1: &control::Cr3Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:52: 76:57>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::control::_::InternalBitFlags;
    let _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = const "Cr3Flags";
        _6 = &((*_1).0: registers::control::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:76:59: 76:64>::clone(_1: &control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PAGE_LEVEL_WRITETHROUGH: control::Cr3Flags = {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PAGE_LEVEL_CACHE_DISABLE: control::Cr3Flags = {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr3Flags>] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr3Flags>];
    let mut _1: &[bitflags::Flag<registers::control::Cr3Flags>; 2];
    let _2: &[bitflags::Flag<registers::control::Cr3Flags>; 2];
    let _3: [bitflags::Flag<registers::control::Cr3Flags>; 2];
    let mut _4: bitflags::Flag<registers::control::Cr3Flags>;
    let mut _5: bitflags::Flag<registers::control::Cr3Flags>;
    let mut _6: &[bitflags::Flag<registers::control::Cr3Flags>; 2];
    scope 1 {
    }
    scope 2 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _6 = const _;
        _2 = &(*_6);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::control::Cr3Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr3Flags>; 2] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr3Flags>; 2];
    let mut _1: [bitflags::Flag<registers::control::Cr3Flags>; 2];
    let mut _2: bitflags::Flag<registers::control::Cr3Flags>;
    let mut _3: bitflags::Flag<registers::control::Cr3Flags>;

    bb0: {
        _2 = Flag::<control::Cr3Flags>::new(const "PAGE_LEVEL_WRITETHROUGH", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<control::Cr3Flags>::new(const "PAGE_LEVEL_CACHE_DISABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = [move _2, move _3];
        _0 = &_1;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &control::Cr3Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &control::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &control::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = control::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <control::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::Cr3Flags;
    let _4: registers::control::Cr3Flags;
    let mut _5: registers::control::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = control::Cr3Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<control::Cr3Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<control::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::control::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::control::Cr3Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<control::Cr3Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<control::Cr3Flags, ParseError>::map::<control::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: control::Cr3Flags) -> control::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::control::_::InternalBitFlags);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &control::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::control::Cr3Flags;
    let mut _5: &bitflags::Flag<registers::control::Cr3Flags>;
    let _6: &[bitflags::Flag<registers::control::Cr3Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::control::Cr3Flags;
    let mut _14: &bitflags::Flag<registers::control::Cr3Flags>;
    let _15: &[bitflags::Flag<registers::control::Cr3Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let mut _21: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<control::Cr3Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr3Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<control::Cr3Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = control::_::<impl control::Cr3Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _21 = _1;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _21) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::control::Cr3Flags;
    let _6: &registers::control::Cr3Flags;
    let mut _7: &bitflags::Flag<registers::control::Cr3Flags>;
    let _8: &[bitflags::Flag<registers::control::Cr3Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::control::Cr3Flags;
    let _18: &registers::control::Cr3Flags;
    let mut _19: &bitflags::Flag<registers::control::Cr3Flags>;
    let _20: &[bitflags::Flag<registers::control::Cr3Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let mut _27: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<control::Cr3Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = control::_::<impl control::Cr3Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<control::Cr3Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = control::_::<impl control::Cr3Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        _27 = _1;
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _27) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        StorageDead(_27);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = control::_::InternalBitFlags(_1);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = control::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = control::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    let _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = control::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug name => _2;
        let mut _11: &registers::control::Cr3Flags;
        let mut _12: &registers::control::Cr3Flags;
        let mut _13: &&str;
        let mut _14: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _14 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _14) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _11 = const _;
        _6 = control::_::<impl control::Cr3Flags>::bits(_11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = control::_::InternalBitFlags(move _6);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb9;
    }

    bb4: {
        _8 = &_2;
        _13 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _12 = const _;
        _10 = control::_::<impl control::Cr3Flags>::bits(_12) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = control::_::InternalBitFlags(move _10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        goto -> bb9;
    }

    bb8: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr3Flags = {
    let mut _0: &registers::control::Cr3Flags;
    let mut _1: registers::control::Cr3Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr3Flags = {
    let mut _0: &registers::control::Cr3Flags;
    let mut _1: registers::control::Cr3Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PAGE_LEVEL_CACHE_DISABLE";
        _0 = &_1;
        return;
    }
}

promoted[3] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PAGE_LEVEL_WRITETHROUGH";
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = control::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    let _6: registers::control::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::control::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = control::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: registers::control::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::_::InternalBitFlags as Extend<control::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr3Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr3Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr3Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr3Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: &registers::control::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = control::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut control::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr3Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr3Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::Cr3Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr3Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr3Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr3Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr3Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr3Flags(_4);
        _0 = Option::<control::Cr3Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr3Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr3Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::control::Cr3Flags;
    let mut _8: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<control::Cr3Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = control::Cr3Flags(move _8);
        StorageDead(_8);
        _0 = Option::<control::Cr3Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr3Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr3Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::Cr3Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::Cr3Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr3Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr3Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr3Flags(_4);
        _0 = Option::<control::Cr3Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr3Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr3Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr3Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr3Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr3Flags, _2: control::Cr3Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr3Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::Cr3Flags, _2: control::Cr3Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let _3: registers::control::Cr3Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr3Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let _3: registers::control::Cr3Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr3Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let _3: registers::control::Cr3Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr3Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;
    let _3: registers::control::Cr3Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr3Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    let mut _3: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::control::_::InternalBitFlags);
        _2 = control::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr3Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;
    let _2: registers::control::Cr3Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr3Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::Cr3Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr3Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr3Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::Cr3Flags;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;
    let mut _6: &registers::control::Cr3Flags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::<impl control::Cr3Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr3Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::Cr3Flags, _2: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::Cr3Flags, _2: control::Cr3Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr3Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::Cr3Flags) -> control::Cr3Flags {
    debug self => _1;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::Cr3Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr3Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr3Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr3Flags);
        _5 = control::_::<impl control::Cr3Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::Cr3Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: registers::control::Cr3Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr3Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::<impl control::Cr3Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr3Flags as Extend<control::Cr3Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr3Flags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr3Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr3Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr3Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr3Flags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr3Flags;
    let mut _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr3Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr3Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr3Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr3Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr3Flags) -> IterNames<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr3Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr3Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr3Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr3Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr3Flags) -> IterNames<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr3Flags>;
    let mut _2: registers::control::Cr3Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr3Flags;
    let mut _5: registers::control::Cr3Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr3Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr3Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr3Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr3Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::Cr3Flags) -> bitflags::iter::Iter<control::Cr3Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr3Flags>;
    let mut _2: &registers::control::Cr3Flags;

    bb0: {
        _2 = &_1;
        _0 = control::_::<impl control::Cr3Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:85:1: 85:14>::from_bits_unchecked(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::_::<impl control::Cr3Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:85:1: 85:14>::from_bits_unchecked(_1: u64) -> control::Cr3Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr3Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr3Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:95:10: 95:15>::fmt(_1: &control::Cr4, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Cr4";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:14: 101:23>::eq(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:25: 101:27>::assert_receiver_is_total_eq(_1: &control::Cr4Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:29: 101:39>::partial_cmp(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:41: 101:44>::cmp(_1: &control::Cr4Flags, _2: &control::Cr4Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::control::_::InternalBitFlags;
    let _4: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = &((*_2).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:46: 101:50>::hash(_1: &control::Cr4Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:52: 101:57>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::control::_::InternalBitFlags;
    let _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = const "Cr4Flags";
        _6 = &((*_1).0: registers::control::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:101:59: 101:64>::clone(_1: &control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::VIRTUAL_8086_MODE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTED_MODE_VIRTUAL_INTERRUPTS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TIMESTAMP_DISABLE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DEBUGGING_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PAGE_SIZE_EXTENSION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PHYSICAL_ADDRESS_EXTENSION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::MACHINE_CHECK_EXCEPTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PAGE_GLOBAL: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PERFORMANCE_MONITOR_COUNTER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OSFXSR: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OSXMMEXCPT_ENABLE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::USER_MODE_INSTRUCTION_PREVENTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::L5_PAGING: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::VIRTUAL_MACHINE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SAFER_MODE_EXTENSIONS: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::FSGSBASE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PCID: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 17_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 17_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 17_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OSXSAVE: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::KEY_LOCKER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 19_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 19_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 19_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SUPERVISOR_MODE_EXECUTION_PROTECTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 20_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 20_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SUPERVISOR_MODE_ACCESS_PREVENTION: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 21_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 21_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 21_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTION_KEY_USER: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 22_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 22_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 22_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTION_KEY: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 22_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 22_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 22_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::CONTROL_FLOW_ENFORCEMENT: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 23_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 23_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTION_KEY_SUPERVISOR: control::Cr4Flags = {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 24_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 24_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 24_i32);
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr4Flags>] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr4Flags>];
    let mut _1: &[bitflags::Flag<registers::control::Cr4Flags>; 25];
    let _2: &[bitflags::Flag<registers::control::Cr4Flags>; 25];
    let _3: [bitflags::Flag<registers::control::Cr4Flags>; 25];
    let mut _4: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _5: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _6: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _7: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _8: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _9: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _10: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _11: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _12: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _13: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _14: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _15: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _16: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _17: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _18: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _19: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _20: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _21: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _22: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _23: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _24: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _25: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _26: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _27: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _28: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _29: &[bitflags::Flag<registers::control::Cr4Flags>; 25];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }
    scope 16 {
    }
    scope 17 {
    }
    scope 18 {
    }
    scope 19 {
    }
    scope 20 {
    }
    scope 21 {
    }
    scope 22 {
    }
    scope 23 {
    }
    scope 24 {
    }
    scope 25 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _29 = const _;
        _2 = &(*_29);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::control::Cr4Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<control::Cr4Flags>; 25] = {
    let mut _0: &[bitflags::Flag<registers::control::Cr4Flags>; 25];
    let mut _1: [bitflags::Flag<registers::control::Cr4Flags>; 25];
    let mut _2: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _3: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _4: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _5: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _6: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _7: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _8: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _9: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _10: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _11: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _12: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _13: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _14: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _15: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _16: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _17: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _18: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _19: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _20: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _21: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _22: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _23: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _24: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _25: bitflags::Flag<registers::control::Cr4Flags>;
    let mut _26: bitflags::Flag<registers::control::Cr4Flags>;

    bb0: {
        _2 = Flag::<control::Cr4Flags>::new(const "VIRTUAL_8086_MODE_EXTENSIONS", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<control::Cr4Flags>::new(const "PROTECTED_MODE_VIRTUAL_INTERRUPTS", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<control::Cr4Flags>::new(const "TIMESTAMP_DISABLE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<control::Cr4Flags>::new(const "DEBUGGING_EXTENSIONS", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<control::Cr4Flags>::new(const "PAGE_SIZE_EXTENSION", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<control::Cr4Flags>::new(const "PHYSICAL_ADDRESS_EXTENSION", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<control::Cr4Flags>::new(const "MACHINE_CHECK_EXCEPTION", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<control::Cr4Flags>::new(const "PAGE_GLOBAL", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<control::Cr4Flags>::new(const "PERFORMANCE_MONITOR_COUNTER", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<control::Cr4Flags>::new(const "OSFXSR", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<control::Cr4Flags>::new(const "OSXMMEXCPT_ENABLE", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<control::Cr4Flags>::new(const "USER_MODE_INSTRUCTION_PREVENTION", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Flag::<control::Cr4Flags>::new(const "L5_PAGING", const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Flag::<control::Cr4Flags>::new(const "VIRTUAL_MACHINE_EXTENSIONS", const _) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Flag::<control::Cr4Flags>::new(const "SAFER_MODE_EXTENSIONS", const _) -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = Flag::<control::Cr4Flags>::new(const "FSGSBASE", const _) -> [return: bb16, unwind continue];
    }

    bb16: {
        _18 = Flag::<control::Cr4Flags>::new(const "PCID", const _) -> [return: bb17, unwind continue];
    }

    bb17: {
        _19 = Flag::<control::Cr4Flags>::new(const "OSXSAVE", const _) -> [return: bb18, unwind continue];
    }

    bb18: {
        _20 = Flag::<control::Cr4Flags>::new(const "KEY_LOCKER", const _) -> [return: bb19, unwind continue];
    }

    bb19: {
        _21 = Flag::<control::Cr4Flags>::new(const "SUPERVISOR_MODE_EXECUTION_PROTECTION", const _) -> [return: bb20, unwind continue];
    }

    bb20: {
        _22 = Flag::<control::Cr4Flags>::new(const "SUPERVISOR_MODE_ACCESS_PREVENTION", const _) -> [return: bb21, unwind continue];
    }

    bb21: {
        _23 = Flag::<control::Cr4Flags>::new(const "PROTECTION_KEY_USER", const _) -> [return: bb22, unwind continue];
    }

    bb22: {
        _24 = Flag::<control::Cr4Flags>::new(const "PROTECTION_KEY", const _) -> [return: bb23, unwind continue];
    }

    bb23: {
        _25 = Flag::<control::Cr4Flags>::new(const "CONTROL_FLOW_ENFORCEMENT", const _) -> [return: bb24, unwind continue];
    }

    bb24: {
        _26 = Flag::<control::Cr4Flags>::new(const "PROTECTION_KEY_SUPERVISOR", const _) -> [return: bb25, unwind continue];
    }

    bb25: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16, move _17, move _18, move _19, move _20, move _21, move _22, move _23, move _24, move _25, move _26];
        _0 = &_1;
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &control::Cr4Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const control::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &control::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &control::_::InternalBitFlags, _2: &control::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &control::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = control::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <control::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::Cr4Flags;
    let _4: registers::control::Cr4Flags;
    let mut _5: registers::control::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = control::Cr4Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<control::Cr4Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<control::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::control::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::control::Cr4Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<control::Cr4Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<control::Cr4Flags, ParseError>::map::<control::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: control::Cr4Flags) -> control::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::control::_::InternalBitFlags);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &control::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(const _);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::control::Cr4Flags;
    let mut _5: &bitflags::Flag<registers::control::Cr4Flags>;
    let _6: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::control::Cr4Flags;
    let mut _14: &bitflags::Flag<registers::control::Cr4Flags>;
    let _15: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::control::Cr4Flags;
    let mut _23: &bitflags::Flag<registers::control::Cr4Flags>;
    let _24: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::control::Cr4Flags;
    let mut _32: &bitflags::Flag<registers::control::Cr4Flags>;
    let _33: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::control::Cr4Flags;
    let mut _41: &bitflags::Flag<registers::control::Cr4Flags>;
    let _42: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::control::Cr4Flags;
    let mut _50: &bitflags::Flag<registers::control::Cr4Flags>;
    let _51: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::control::Cr4Flags;
    let mut _59: &bitflags::Flag<registers::control::Cr4Flags>;
    let _60: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::control::Cr4Flags;
    let mut _68: &bitflags::Flag<registers::control::Cr4Flags>;
    let _69: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::control::Cr4Flags;
    let mut _77: &bitflags::Flag<registers::control::Cr4Flags>;
    let _78: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &registers::control::Cr4Flags;
    let mut _86: &bitflags::Flag<registers::control::Cr4Flags>;
    let _87: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &registers::control::Cr4Flags;
    let mut _95: &bitflags::Flag<registers::control::Cr4Flags>;
    let _96: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let _103: &registers::control::Cr4Flags;
    let mut _104: &bitflags::Flag<registers::control::Cr4Flags>;
    let _105: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _112: &registers::control::Cr4Flags;
    let mut _113: &bitflags::Flag<registers::control::Cr4Flags>;
    let _114: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: u64;
    let mut _119: (usize, bool);
    let _121: &registers::control::Cr4Flags;
    let mut _122: &bitflags::Flag<registers::control::Cr4Flags>;
    let _123: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _124: usize;
    let mut _125: usize;
    let mut _126: bool;
    let mut _127: u64;
    let mut _128: (usize, bool);
    let _130: &registers::control::Cr4Flags;
    let mut _131: &bitflags::Flag<registers::control::Cr4Flags>;
    let _132: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _133: usize;
    let mut _134: usize;
    let mut _135: bool;
    let mut _136: u64;
    let mut _137: (usize, bool);
    let _139: &registers::control::Cr4Flags;
    let mut _140: &bitflags::Flag<registers::control::Cr4Flags>;
    let _141: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _142: usize;
    let mut _143: usize;
    let mut _144: bool;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _148: &registers::control::Cr4Flags;
    let mut _149: &bitflags::Flag<registers::control::Cr4Flags>;
    let _150: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _151: usize;
    let mut _152: usize;
    let mut _153: bool;
    let mut _154: u64;
    let mut _155: (usize, bool);
    let _157: &registers::control::Cr4Flags;
    let mut _158: &bitflags::Flag<registers::control::Cr4Flags>;
    let _159: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _160: usize;
    let mut _161: usize;
    let mut _162: bool;
    let mut _163: u64;
    let mut _164: (usize, bool);
    let _166: &registers::control::Cr4Flags;
    let mut _167: &bitflags::Flag<registers::control::Cr4Flags>;
    let _168: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _169: usize;
    let mut _170: usize;
    let mut _171: bool;
    let mut _172: u64;
    let mut _173: (usize, bool);
    let _175: &registers::control::Cr4Flags;
    let mut _176: &bitflags::Flag<registers::control::Cr4Flags>;
    let _177: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _178: usize;
    let mut _179: usize;
    let mut _180: bool;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let _184: &registers::control::Cr4Flags;
    let mut _185: &bitflags::Flag<registers::control::Cr4Flags>;
    let _186: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _187: usize;
    let mut _188: usize;
    let mut _189: bool;
    let mut _190: u64;
    let mut _191: (usize, bool);
    let _193: &registers::control::Cr4Flags;
    let mut _194: &bitflags::Flag<registers::control::Cr4Flags>;
    let _195: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _196: usize;
    let mut _197: usize;
    let mut _198: bool;
    let mut _199: u64;
    let mut _200: (usize, bool);
    let _202: &registers::control::Cr4Flags;
    let mut _203: &bitflags::Flag<registers::control::Cr4Flags>;
    let _204: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _205: usize;
    let mut _206: usize;
    let mut _207: bool;
    let mut _208: u64;
    let mut _209: (usize, bool);
    let _211: &registers::control::Cr4Flags;
    let mut _212: &bitflags::Flag<registers::control::Cr4Flags>;
    let _213: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _214: usize;
    let mut _215: usize;
    let mut _216: bool;
    let mut _217: u64;
    let mut _218: (usize, bool);
    let _220: &registers::control::Cr4Flags;
    let mut _221: &bitflags::Flag<registers::control::Cr4Flags>;
    let _222: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _223: usize;
    let mut _224: usize;
    let mut _225: bool;
    let mut _226: u64;
    let mut _227: (usize, bool);
    let mut _228: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            let _102: u64;
            let _111: u64;
            let _120: u64;
            let _129: u64;
            let _138: u64;
            let _147: u64;
            let _156: u64;
            let _165: u64;
            let _174: u64;
            let _183: u64;
            let _192: u64;
            let _201: u64;
            let _210: u64;
            let _219: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
                debug flag => _111;
            }
            scope 16 {
                debug flag => _120;
            }
            scope 17 {
                debug flag => _129;
            }
            scope 18 {
                debug flag => _138;
            }
            scope 19 {
                debug flag => _147;
            }
            scope 20 {
                debug flag => _156;
            }
            scope 21 {
                debug flag => _165;
            }
            scope 22 {
                debug flag => _174;
            }
            scope 23 {
                debug flag => _183;
            }
            scope 24 {
                debug flag => _192;
            }
            scope 25 {
                debug flag => _201;
            }
            scope 26 {
                debug flag => _210;
            }
            scope 27 {
                debug flag => _219;
            }
            scope 28 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<control::Cr4Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr4Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<control::Cr4Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = control::_::<impl control::Cr4Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<control::Cr4Flags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = control::_::<impl control::Cr4Flags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<control::Cr4Flags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = control::_::<impl control::Cr4Flags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<control::Cr4Flags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = control::_::<impl control::Cr4Flags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<control::Cr4Flags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = control::_::<impl control::Cr4Flags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<control::Cr4Flags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = control::_::<impl control::Cr4Flags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<control::Cr4Flags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = control::_::<impl control::Cr4Flags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<control::Cr4Flags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = control::_::<impl control::Cr4Flags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<control::Cr4Flags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = control::_::<impl control::Cr4Flags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<control::Cr4Flags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = control::_::<impl control::Cr4Flags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<control::Cr4Flags>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = control::_::<impl control::Cr4Flags>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _114 = const _;
        _115 = _2;
        _116 = Len((*_114));
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _113 = &(*_114)[_115];
        _112 = Flag::<control::Cr4Flags>::value(move _113) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _111 = control::_::<impl control::Cr4Flags>::bits(_112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _118 = _1;
        _1 = BitOr(move _118, _111);
        _119 = CheckedAdd(_2, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_119.0: usize);
        _123 = const _;
        _124 = _2;
        _125 = Len((*_123));
        _126 = Lt(_124, _125);
        assert(move _126, "index out of bounds: the length is {} but the index is {}", move _125, _124) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _122 = &(*_123)[_124];
        _121 = Flag::<control::Cr4Flags>::value(move _122) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _120 = control::_::<impl control::Cr4Flags>::bits(_121) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = _1;
        _1 = BitOr(move _127, _120);
        _128 = CheckedAdd(_2, const 1_usize);
        assert(!move (_128.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_128.0: usize);
        _132 = const _;
        _133 = _2;
        _134 = Len((*_132));
        _135 = Lt(_133, _134);
        assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _133) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _131 = &(*_132)[_133];
        _130 = Flag::<control::Cr4Flags>::value(move _131) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _129 = control::_::<impl control::Cr4Flags>::bits(_130) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _136 = _1;
        _1 = BitOr(move _136, _129);
        _137 = CheckedAdd(_2, const 1_usize);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_137.0: usize);
        _141 = const _;
        _142 = _2;
        _143 = Len((*_141));
        _144 = Lt(_142, _143);
        assert(move _144, "index out of bounds: the length is {} but the index is {}", move _143, _142) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _140 = &(*_141)[_142];
        _139 = Flag::<control::Cr4Flags>::value(move _140) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _138 = control::_::<impl control::Cr4Flags>::bits(_139) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _145 = _1;
        _1 = BitOr(move _145, _138);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_146.0: usize);
        _150 = const _;
        _151 = _2;
        _152 = Len((*_150));
        _153 = Lt(_151, _152);
        assert(move _153, "index out of bounds: the length is {} but the index is {}", move _152, _151) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _149 = &(*_150)[_151];
        _148 = Flag::<control::Cr4Flags>::value(move _149) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _147 = control::_::<impl control::Cr4Flags>::bits(_148) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _154 = _1;
        _1 = BitOr(move _154, _147);
        _155 = CheckedAdd(_2, const 1_usize);
        assert(!move (_155.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_155.0: usize);
        _159 = const _;
        _160 = _2;
        _161 = Len((*_159));
        _162 = Lt(_160, _161);
        assert(move _162, "index out of bounds: the length is {} but the index is {}", move _161, _160) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _158 = &(*_159)[_160];
        _157 = Flag::<control::Cr4Flags>::value(move _158) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _156 = control::_::<impl control::Cr4Flags>::bits(_157) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _163 = _1;
        _1 = BitOr(move _163, _156);
        _164 = CheckedAdd(_2, const 1_usize);
        assert(!move (_164.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_164.0: usize);
        _168 = const _;
        _169 = _2;
        _170 = Len((*_168));
        _171 = Lt(_169, _170);
        assert(move _171, "index out of bounds: the length is {} but the index is {}", move _170, _169) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _167 = &(*_168)[_169];
        _166 = Flag::<control::Cr4Flags>::value(move _167) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _165 = control::_::<impl control::Cr4Flags>::bits(_166) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _172 = _1;
        _1 = BitOr(move _172, _165);
        _173 = CheckedAdd(_2, const 1_usize);
        assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _2 = move (_173.0: usize);
        _177 = const _;
        _178 = _2;
        _179 = Len((*_177));
        _180 = Lt(_178, _179);
        assert(move _180, "index out of bounds: the length is {} but the index is {}", move _179, _178) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _176 = &(*_177)[_178];
        _175 = Flag::<control::Cr4Flags>::value(move _176) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _174 = control::_::<impl control::Cr4Flags>::bits(_175) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _181 = _1;
        _1 = BitOr(move _181, _174);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _2 = move (_182.0: usize);
        _186 = const _;
        _187 = _2;
        _188 = Len((*_186));
        _189 = Lt(_187, _188);
        assert(move _189, "index out of bounds: the length is {} but the index is {}", move _188, _187) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _185 = &(*_186)[_187];
        _184 = Flag::<control::Cr4Flags>::value(move _185) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _183 = control::_::<impl control::Cr4Flags>::bits(_184) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _190 = _1;
        _1 = BitOr(move _190, _183);
        _191 = CheckedAdd(_2, const 1_usize);
        assert(!move (_191.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _2 = move (_191.0: usize);
        _195 = const _;
        _196 = _2;
        _197 = Len((*_195));
        _198 = Lt(_196, _197);
        assert(move _198, "index out of bounds: the length is {} but the index is {}", move _197, _196) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _194 = &(*_195)[_196];
        _193 = Flag::<control::Cr4Flags>::value(move _194) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _192 = control::_::<impl control::Cr4Flags>::bits(_193) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _199 = _1;
        _1 = BitOr(move _199, _192);
        _200 = CheckedAdd(_2, const 1_usize);
        assert(!move (_200.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _2 = move (_200.0: usize);
        _204 = const _;
        _205 = _2;
        _206 = Len((*_204));
        _207 = Lt(_205, _206);
        assert(move _207, "index out of bounds: the length is {} but the index is {}", move _206, _205) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _203 = &(*_204)[_205];
        _202 = Flag::<control::Cr4Flags>::value(move _203) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _201 = control::_::<impl control::Cr4Flags>::bits(_202) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _208 = _1;
        _1 = BitOr(move _208, _201);
        _209 = CheckedAdd(_2, const 1_usize);
        assert(!move (_209.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb92, unwind unreachable];
    }

    bb92: {
        _2 = move (_209.0: usize);
        _213 = const _;
        _214 = _2;
        _215 = Len((*_213));
        _216 = Lt(_214, _215);
        assert(move _216, "index out of bounds: the length is {} but the index is {}", move _215, _214) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _212 = &(*_213)[_214];
        _211 = Flag::<control::Cr4Flags>::value(move _212) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _210 = control::_::<impl control::Cr4Flags>::bits(_211) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _217 = _1;
        _1 = BitOr(move _217, _210);
        _218 = CheckedAdd(_2, const 1_usize);
        assert(!move (_218.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _2 = move (_218.0: usize);
        _222 = const _;
        _223 = _2;
        _224 = Len((*_222));
        _225 = Lt(_223, _224);
        assert(move _225, "index out of bounds: the length is {} but the index is {}", move _224, _223) -> [success: bb97, unwind unreachable];
    }

    bb97: {
        _221 = &(*_222)[_223];
        _220 = Flag::<control::Cr4Flags>::value(move _221) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _219 = control::_::<impl control::Cr4Flags>::bits(_220) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _226 = _1;
        _1 = BitOr(move _226, _219);
        _227 = CheckedAdd(_2, const 1_usize);
        assert(!move (_227.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb100, unwind unreachable];
    }

    bb100: {
        _2 = move (_227.0: usize);
        _228 = _1;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _228) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::control::Cr4Flags;
    let _6: &registers::control::Cr4Flags;
    let mut _7: &bitflags::Flag<registers::control::Cr4Flags>;
    let _8: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::control::Cr4Flags;
    let _18: &registers::control::Cr4Flags;
    let mut _19: &bitflags::Flag<registers::control::Cr4Flags>;
    let _20: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::control::Cr4Flags;
    let _30: &registers::control::Cr4Flags;
    let mut _31: &bitflags::Flag<registers::control::Cr4Flags>;
    let _32: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::control::Cr4Flags;
    let _42: &registers::control::Cr4Flags;
    let mut _43: &bitflags::Flag<registers::control::Cr4Flags>;
    let _44: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::control::Cr4Flags;
    let _54: &registers::control::Cr4Flags;
    let mut _55: &bitflags::Flag<registers::control::Cr4Flags>;
    let _56: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::control::Cr4Flags;
    let _66: &registers::control::Cr4Flags;
    let mut _67: &bitflags::Flag<registers::control::Cr4Flags>;
    let _68: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::control::Cr4Flags;
    let _78: &registers::control::Cr4Flags;
    let mut _79: &bitflags::Flag<registers::control::Cr4Flags>;
    let _80: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::control::Cr4Flags;
    let _90: &registers::control::Cr4Flags;
    let mut _91: &bitflags::Flag<registers::control::Cr4Flags>;
    let _92: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::control::Cr4Flags;
    let _102: &registers::control::Cr4Flags;
    let mut _103: &bitflags::Flag<registers::control::Cr4Flags>;
    let _104: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::control::Cr4Flags;
    let _114: &registers::control::Cr4Flags;
    let mut _115: &bitflags::Flag<registers::control::Cr4Flags>;
    let _116: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::control::Cr4Flags;
    let _126: &registers::control::Cr4Flags;
    let mut _127: &bitflags::Flag<registers::control::Cr4Flags>;
    let _128: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &registers::control::Cr4Flags;
    let _138: &registers::control::Cr4Flags;
    let mut _139: &bitflags::Flag<registers::control::Cr4Flags>;
    let _140: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u64;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _147: ();
    let mut _149: &registers::control::Cr4Flags;
    let _150: &registers::control::Cr4Flags;
    let mut _151: &bitflags::Flag<registers::control::Cr4Flags>;
    let _152: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: (usize, bool);
    let _159: ();
    let mut _161: &registers::control::Cr4Flags;
    let _162: &registers::control::Cr4Flags;
    let mut _163: &bitflags::Flag<registers::control::Cr4Flags>;
    let _164: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _165: usize;
    let mut _166: usize;
    let mut _167: bool;
    let mut _168: u64;
    let mut _169: u64;
    let mut _170: (usize, bool);
    let _171: ();
    let mut _173: &registers::control::Cr4Flags;
    let _174: &registers::control::Cr4Flags;
    let mut _175: &bitflags::Flag<registers::control::Cr4Flags>;
    let _176: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _177: usize;
    let mut _178: usize;
    let mut _179: bool;
    let mut _180: u64;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let _183: ();
    let mut _185: &registers::control::Cr4Flags;
    let _186: &registers::control::Cr4Flags;
    let mut _187: &bitflags::Flag<registers::control::Cr4Flags>;
    let _188: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _189: usize;
    let mut _190: usize;
    let mut _191: bool;
    let mut _192: u64;
    let mut _193: u64;
    let mut _194: (usize, bool);
    let _195: ();
    let mut _197: &registers::control::Cr4Flags;
    let _198: &registers::control::Cr4Flags;
    let mut _199: &bitflags::Flag<registers::control::Cr4Flags>;
    let _200: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _201: usize;
    let mut _202: usize;
    let mut _203: bool;
    let mut _204: u64;
    let mut _205: u64;
    let mut _206: (usize, bool);
    let _207: ();
    let mut _209: &registers::control::Cr4Flags;
    let _210: &registers::control::Cr4Flags;
    let mut _211: &bitflags::Flag<registers::control::Cr4Flags>;
    let _212: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _213: usize;
    let mut _214: usize;
    let mut _215: bool;
    let mut _216: u64;
    let mut _217: u64;
    let mut _218: (usize, bool);
    let _219: ();
    let mut _221: &registers::control::Cr4Flags;
    let _222: &registers::control::Cr4Flags;
    let mut _223: &bitflags::Flag<registers::control::Cr4Flags>;
    let _224: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _225: usize;
    let mut _226: usize;
    let mut _227: bool;
    let mut _228: u64;
    let mut _229: u64;
    let mut _230: (usize, bool);
    let _231: ();
    let mut _233: &registers::control::Cr4Flags;
    let _234: &registers::control::Cr4Flags;
    let mut _235: &bitflags::Flag<registers::control::Cr4Flags>;
    let _236: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _237: usize;
    let mut _238: usize;
    let mut _239: bool;
    let mut _240: u64;
    let mut _241: u64;
    let mut _242: (usize, bool);
    let _243: ();
    let mut _245: &registers::control::Cr4Flags;
    let _246: &registers::control::Cr4Flags;
    let mut _247: &bitflags::Flag<registers::control::Cr4Flags>;
    let _248: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _249: usize;
    let mut _250: usize;
    let mut _251: bool;
    let mut _252: u64;
    let mut _253: u64;
    let mut _254: (usize, bool);
    let _255: ();
    let mut _257: &registers::control::Cr4Flags;
    let _258: &registers::control::Cr4Flags;
    let mut _259: &bitflags::Flag<registers::control::Cr4Flags>;
    let _260: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _261: usize;
    let mut _262: usize;
    let mut _263: bool;
    let mut _264: u64;
    let mut _265: u64;
    let mut _266: (usize, bool);
    let _267: ();
    let mut _269: &registers::control::Cr4Flags;
    let _270: &registers::control::Cr4Flags;
    let mut _271: &bitflags::Flag<registers::control::Cr4Flags>;
    let _272: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _273: usize;
    let mut _274: usize;
    let mut _275: bool;
    let mut _276: u64;
    let mut _277: u64;
    let mut _278: (usize, bool);
    let _279: ();
    let mut _281: &registers::control::Cr4Flags;
    let _282: &registers::control::Cr4Flags;
    let mut _283: &bitflags::Flag<registers::control::Cr4Flags>;
    let _284: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _285: usize;
    let mut _286: usize;
    let mut _287: bool;
    let mut _288: u64;
    let mut _289: u64;
    let mut _290: (usize, bool);
    let _291: ();
    let mut _293: &registers::control::Cr4Flags;
    let _294: &registers::control::Cr4Flags;
    let mut _295: &bitflags::Flag<registers::control::Cr4Flags>;
    let _296: &[bitflags::Flag<registers::control::Cr4Flags>];
    let _297: usize;
    let mut _298: usize;
    let mut _299: bool;
    let mut _300: u64;
    let mut _301: u64;
    let mut _302: (usize, bool);
    let mut _303: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            let _136: u64;
            let _148: u64;
            let _160: u64;
            let _172: u64;
            let _184: u64;
            let _196: u64;
            let _208: u64;
            let _220: u64;
            let _232: u64;
            let _244: u64;
            let _256: u64;
            let _268: u64;
            let _280: u64;
            let _292: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
                debug flag => _148;
            }
            scope 16 {
                debug flag => _160;
            }
            scope 17 {
                debug flag => _172;
            }
            scope 18 {
                debug flag => _184;
            }
            scope 19 {
                debug flag => _196;
            }
            scope 20 {
                debug flag => _208;
            }
            scope 21 {
                debug flag => _220;
            }
            scope 22 {
                debug flag => _232;
            }
            scope 23 {
                debug flag => _244;
            }
            scope 24 {
                debug flag => _256;
            }
            scope 25 {
                debug flag => _268;
            }
            scope 26 {
                debug flag => _280;
            }
            scope 27 {
                debug flag => _292;
            }
            scope 28 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<control::Cr4Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = control::_::<impl control::Cr4Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<control::Cr4Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = control::_::<impl control::Cr4Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<control::Cr4Flags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = control::_::<impl control::Cr4Flags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<control::Cr4Flags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = control::_::<impl control::Cr4Flags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<control::Cr4Flags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = control::_::<impl control::Cr4Flags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<control::Cr4Flags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = control::_::<impl control::Cr4Flags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<control::Cr4Flags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = control::_::<impl control::Cr4Flags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<control::Cr4Flags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = control::_::<impl control::Cr4Flags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<control::Cr4Flags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = control::_::<impl control::Cr4Flags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<control::Cr4Flags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = control::_::<impl control::Cr4Flags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<control::Cr4Flags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = control::_::<impl control::Cr4Flags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<control::Cr4Flags>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = control::_::<impl control::Cr4Flags>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        StorageLive(_148);
        StorageLive(_149);
        StorageLive(_150);
        StorageLive(_151);
        StorageLive(_152);
        _152 = const _;
        StorageLive(_153);
        _153 = _2;
        _154 = Len((*_152));
        _155 = Lt(_153, _154);
        assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _153) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _151 = &(*_152)[_153];
        ConstEvalCounter;
        _150 = Flag::<control::Cr4Flags>::value(move _151) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _149 = &(*_150);
        StorageDead(_151);
        ConstEvalCounter;
        _148 = control::_::<impl control::Cr4Flags>::bits(move _149) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        StorageDead(_149);
        StorageDead(_153);
        StorageDead(_152);
        StorageDead(_150);
        StorageLive(_156);
        _156 = _1;
        StorageLive(_157);
        _157 = _148;
        _1 = BitOr(move _156, move _157);
        StorageDead(_157);
        StorageDead(_156);
        _158 = CheckedAdd(_2, const 1_usize);
        assert(!move (_158.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_158.0: usize);
        _147 = const ();
        StorageDead(_148);
        StorageDead(_147);
        StorageLive(_159);
        StorageLive(_160);
        StorageLive(_161);
        StorageLive(_162);
        StorageLive(_163);
        StorageLive(_164);
        _164 = const _;
        StorageLive(_165);
        _165 = _2;
        _166 = Len((*_164));
        _167 = Lt(_165, _166);
        assert(move _167, "index out of bounds: the length is {} but the index is {}", move _166, _165) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _163 = &(*_164)[_165];
        ConstEvalCounter;
        _162 = Flag::<control::Cr4Flags>::value(move _163) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _161 = &(*_162);
        StorageDead(_163);
        ConstEvalCounter;
        _160 = control::_::<impl control::Cr4Flags>::bits(move _161) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        StorageDead(_161);
        StorageDead(_165);
        StorageDead(_164);
        StorageDead(_162);
        StorageLive(_168);
        _168 = _1;
        StorageLive(_169);
        _169 = _160;
        _1 = BitOr(move _168, move _169);
        StorageDead(_169);
        StorageDead(_168);
        _170 = CheckedAdd(_2, const 1_usize);
        assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_170.0: usize);
        _159 = const ();
        StorageDead(_160);
        StorageDead(_159);
        StorageLive(_171);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        StorageLive(_175);
        StorageLive(_176);
        _176 = const _;
        StorageLive(_177);
        _177 = _2;
        _178 = Len((*_176));
        _179 = Lt(_177, _178);
        assert(move _179, "index out of bounds: the length is {} but the index is {}", move _178, _177) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _175 = &(*_176)[_177];
        ConstEvalCounter;
        _174 = Flag::<control::Cr4Flags>::value(move _175) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _173 = &(*_174);
        StorageDead(_175);
        ConstEvalCounter;
        _172 = control::_::<impl control::Cr4Flags>::bits(move _173) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        StorageDead(_173);
        StorageDead(_177);
        StorageDead(_176);
        StorageDead(_174);
        StorageLive(_180);
        _180 = _1;
        StorageLive(_181);
        _181 = _172;
        _1 = BitOr(move _180, move _181);
        StorageDead(_181);
        StorageDead(_180);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_182.0: usize);
        _171 = const ();
        StorageDead(_172);
        StorageDead(_171);
        StorageLive(_183);
        StorageLive(_184);
        StorageLive(_185);
        StorageLive(_186);
        StorageLive(_187);
        StorageLive(_188);
        _188 = const _;
        StorageLive(_189);
        _189 = _2;
        _190 = Len((*_188));
        _191 = Lt(_189, _190);
        assert(move _191, "index out of bounds: the length is {} but the index is {}", move _190, _189) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _187 = &(*_188)[_189];
        ConstEvalCounter;
        _186 = Flag::<control::Cr4Flags>::value(move _187) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _185 = &(*_186);
        StorageDead(_187);
        ConstEvalCounter;
        _184 = control::_::<impl control::Cr4Flags>::bits(move _185) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        StorageDead(_185);
        StorageDead(_189);
        StorageDead(_188);
        StorageDead(_186);
        StorageLive(_192);
        _192 = _1;
        StorageLive(_193);
        _193 = _184;
        _1 = BitOr(move _192, move _193);
        StorageDead(_193);
        StorageDead(_192);
        _194 = CheckedAdd(_2, const 1_usize);
        assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_194.0: usize);
        _183 = const ();
        StorageDead(_184);
        StorageDead(_183);
        StorageLive(_195);
        StorageLive(_196);
        StorageLive(_197);
        StorageLive(_198);
        StorageLive(_199);
        StorageLive(_200);
        _200 = const _;
        StorageLive(_201);
        _201 = _2;
        _202 = Len((*_200));
        _203 = Lt(_201, _202);
        assert(move _203, "index out of bounds: the length is {} but the index is {}", move _202, _201) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _199 = &(*_200)[_201];
        ConstEvalCounter;
        _198 = Flag::<control::Cr4Flags>::value(move _199) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _197 = &(*_198);
        StorageDead(_199);
        ConstEvalCounter;
        _196 = control::_::<impl control::Cr4Flags>::bits(move _197) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        StorageDead(_197);
        StorageDead(_201);
        StorageDead(_200);
        StorageDead(_198);
        StorageLive(_204);
        _204 = _1;
        StorageLive(_205);
        _205 = _196;
        _1 = BitOr(move _204, move _205);
        StorageDead(_205);
        StorageDead(_204);
        _206 = CheckedAdd(_2, const 1_usize);
        assert(!move (_206.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_206.0: usize);
        _195 = const ();
        StorageDead(_196);
        StorageDead(_195);
        StorageLive(_207);
        StorageLive(_208);
        StorageLive(_209);
        StorageLive(_210);
        StorageLive(_211);
        StorageLive(_212);
        _212 = const _;
        StorageLive(_213);
        _213 = _2;
        _214 = Len((*_212));
        _215 = Lt(_213, _214);
        assert(move _215, "index out of bounds: the length is {} but the index is {}", move _214, _213) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _211 = &(*_212)[_213];
        ConstEvalCounter;
        _210 = Flag::<control::Cr4Flags>::value(move _211) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _209 = &(*_210);
        StorageDead(_211);
        ConstEvalCounter;
        _208 = control::_::<impl control::Cr4Flags>::bits(move _209) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        StorageDead(_209);
        StorageDead(_213);
        StorageDead(_212);
        StorageDead(_210);
        StorageLive(_216);
        _216 = _1;
        StorageLive(_217);
        _217 = _208;
        _1 = BitOr(move _216, move _217);
        StorageDead(_217);
        StorageDead(_216);
        _218 = CheckedAdd(_2, const 1_usize);
        assert(!move (_218.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_218.0: usize);
        _207 = const ();
        StorageDead(_208);
        StorageDead(_207);
        StorageLive(_219);
        StorageLive(_220);
        StorageLive(_221);
        StorageLive(_222);
        StorageLive(_223);
        StorageLive(_224);
        _224 = const _;
        StorageLive(_225);
        _225 = _2;
        _226 = Len((*_224));
        _227 = Lt(_225, _226);
        assert(move _227, "index out of bounds: the length is {} but the index is {}", move _226, _225) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _223 = &(*_224)[_225];
        ConstEvalCounter;
        _222 = Flag::<control::Cr4Flags>::value(move _223) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _221 = &(*_222);
        StorageDead(_223);
        ConstEvalCounter;
        _220 = control::_::<impl control::Cr4Flags>::bits(move _221) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        StorageDead(_221);
        StorageDead(_225);
        StorageDead(_224);
        StorageDead(_222);
        StorageLive(_228);
        _228 = _1;
        StorageLive(_229);
        _229 = _220;
        _1 = BitOr(move _228, move _229);
        StorageDead(_229);
        StorageDead(_228);
        _230 = CheckedAdd(_2, const 1_usize);
        assert(!move (_230.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _2 = move (_230.0: usize);
        _219 = const ();
        StorageDead(_220);
        StorageDead(_219);
        StorageLive(_231);
        StorageLive(_232);
        StorageLive(_233);
        StorageLive(_234);
        StorageLive(_235);
        StorageLive(_236);
        _236 = const _;
        StorageLive(_237);
        _237 = _2;
        _238 = Len((*_236));
        _239 = Lt(_237, _238);
        assert(move _239, "index out of bounds: the length is {} but the index is {}", move _238, _237) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _235 = &(*_236)[_237];
        ConstEvalCounter;
        _234 = Flag::<control::Cr4Flags>::value(move _235) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _233 = &(*_234);
        StorageDead(_235);
        ConstEvalCounter;
        _232 = control::_::<impl control::Cr4Flags>::bits(move _233) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        StorageDead(_233);
        StorageDead(_237);
        StorageDead(_236);
        StorageDead(_234);
        StorageLive(_240);
        _240 = _1;
        StorageLive(_241);
        _241 = _232;
        _1 = BitOr(move _240, move _241);
        StorageDead(_241);
        StorageDead(_240);
        _242 = CheckedAdd(_2, const 1_usize);
        assert(!move (_242.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _2 = move (_242.0: usize);
        _231 = const ();
        StorageDead(_232);
        StorageDead(_231);
        StorageLive(_243);
        StorageLive(_244);
        StorageLive(_245);
        StorageLive(_246);
        StorageLive(_247);
        StorageLive(_248);
        _248 = const _;
        StorageLive(_249);
        _249 = _2;
        _250 = Len((*_248));
        _251 = Lt(_249, _250);
        assert(move _251, "index out of bounds: the length is {} but the index is {}", move _250, _249) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _247 = &(*_248)[_249];
        ConstEvalCounter;
        _246 = Flag::<control::Cr4Flags>::value(move _247) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _245 = &(*_246);
        StorageDead(_247);
        ConstEvalCounter;
        _244 = control::_::<impl control::Cr4Flags>::bits(move _245) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        StorageDead(_245);
        StorageDead(_249);
        StorageDead(_248);
        StorageDead(_246);
        StorageLive(_252);
        _252 = _1;
        StorageLive(_253);
        _253 = _244;
        _1 = BitOr(move _252, move _253);
        StorageDead(_253);
        StorageDead(_252);
        _254 = CheckedAdd(_2, const 1_usize);
        assert(!move (_254.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _2 = move (_254.0: usize);
        _243 = const ();
        StorageDead(_244);
        StorageDead(_243);
        StorageLive(_255);
        StorageLive(_256);
        StorageLive(_257);
        StorageLive(_258);
        StorageLive(_259);
        StorageLive(_260);
        _260 = const _;
        StorageLive(_261);
        _261 = _2;
        _262 = Len((*_260));
        _263 = Lt(_261, _262);
        assert(move _263, "index out of bounds: the length is {} but the index is {}", move _262, _261) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _259 = &(*_260)[_261];
        ConstEvalCounter;
        _258 = Flag::<control::Cr4Flags>::value(move _259) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _257 = &(*_258);
        StorageDead(_259);
        ConstEvalCounter;
        _256 = control::_::<impl control::Cr4Flags>::bits(move _257) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        StorageDead(_257);
        StorageDead(_261);
        StorageDead(_260);
        StorageDead(_258);
        StorageLive(_264);
        _264 = _1;
        StorageLive(_265);
        _265 = _256;
        _1 = BitOr(move _264, move _265);
        StorageDead(_265);
        StorageDead(_264);
        _266 = CheckedAdd(_2, const 1_usize);
        assert(!move (_266.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _2 = move (_266.0: usize);
        _255 = const ();
        StorageDead(_256);
        StorageDead(_255);
        StorageLive(_267);
        StorageLive(_268);
        StorageLive(_269);
        StorageLive(_270);
        StorageLive(_271);
        StorageLive(_272);
        _272 = const _;
        StorageLive(_273);
        _273 = _2;
        _274 = Len((*_272));
        _275 = Lt(_273, _274);
        assert(move _275, "index out of bounds: the length is {} but the index is {}", move _274, _273) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _271 = &(*_272)[_273];
        ConstEvalCounter;
        _270 = Flag::<control::Cr4Flags>::value(move _271) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _269 = &(*_270);
        StorageDead(_271);
        ConstEvalCounter;
        _268 = control::_::<impl control::Cr4Flags>::bits(move _269) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        StorageDead(_269);
        StorageDead(_273);
        StorageDead(_272);
        StorageDead(_270);
        StorageLive(_276);
        _276 = _1;
        StorageLive(_277);
        _277 = _268;
        _1 = BitOr(move _276, move _277);
        StorageDead(_277);
        StorageDead(_276);
        _278 = CheckedAdd(_2, const 1_usize);
        assert(!move (_278.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb92, unwind unreachable];
    }

    bb92: {
        _2 = move (_278.0: usize);
        _267 = const ();
        StorageDead(_268);
        StorageDead(_267);
        StorageLive(_279);
        StorageLive(_280);
        StorageLive(_281);
        StorageLive(_282);
        StorageLive(_283);
        StorageLive(_284);
        _284 = const _;
        StorageLive(_285);
        _285 = _2;
        _286 = Len((*_284));
        _287 = Lt(_285, _286);
        assert(move _287, "index out of bounds: the length is {} but the index is {}", move _286, _285) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _283 = &(*_284)[_285];
        ConstEvalCounter;
        _282 = Flag::<control::Cr4Flags>::value(move _283) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _281 = &(*_282);
        StorageDead(_283);
        ConstEvalCounter;
        _280 = control::_::<impl control::Cr4Flags>::bits(move _281) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        StorageDead(_281);
        StorageDead(_285);
        StorageDead(_284);
        StorageDead(_282);
        StorageLive(_288);
        _288 = _1;
        StorageLive(_289);
        _289 = _280;
        _1 = BitOr(move _288, move _289);
        StorageDead(_289);
        StorageDead(_288);
        _290 = CheckedAdd(_2, const 1_usize);
        assert(!move (_290.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _2 = move (_290.0: usize);
        _279 = const ();
        StorageDead(_280);
        StorageDead(_279);
        StorageLive(_291);
        StorageLive(_292);
        StorageLive(_293);
        StorageLive(_294);
        StorageLive(_295);
        StorageLive(_296);
        _296 = const _;
        StorageLive(_297);
        _297 = _2;
        _298 = Len((*_296));
        _299 = Lt(_297, _298);
        assert(move _299, "index out of bounds: the length is {} but the index is {}", move _298, _297) -> [success: bb97, unwind unreachable];
    }

    bb97: {
        _295 = &(*_296)[_297];
        ConstEvalCounter;
        _294 = Flag::<control::Cr4Flags>::value(move _295) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _293 = &(*_294);
        StorageDead(_295);
        ConstEvalCounter;
        _292 = control::_::<impl control::Cr4Flags>::bits(move _293) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        StorageDead(_293);
        StorageDead(_297);
        StorageDead(_296);
        StorageDead(_294);
        StorageLive(_300);
        _300 = _1;
        StorageLive(_301);
        _301 = _292;
        _1 = BitOr(move _300, move _301);
        StorageDead(_301);
        StorageDead(_300);
        _302 = CheckedAdd(_2, const 1_usize);
        assert(!move (_302.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb100, unwind unreachable];
    }

    bb100: {
        _2 = move (_302.0: usize);
        _291 = const ();
        StorageDead(_292);
        StorageDead(_291);
        StorageLive(_303);
        _303 = _1;
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _303) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        StorageDead(_303);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = control::_::InternalBitFlags(_1);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = control::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = control::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    let _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = control::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = control::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::control::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::control::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::control::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::control::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::control::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::control::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::control::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::control::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::control::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::control::_::InternalBitFlags;
    let mut _46: u64;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: registers::control::_::InternalBitFlags;
    let mut _50: u64;
    let mut _51: bool;
    let mut _52: &&str;
    let mut _53: registers::control::_::InternalBitFlags;
    let mut _54: u64;
    let mut _55: bool;
    let mut _56: &&str;
    let mut _57: registers::control::_::InternalBitFlags;
    let mut _58: u64;
    let mut _59: bool;
    let mut _60: &&str;
    let mut _61: registers::control::_::InternalBitFlags;
    let mut _62: u64;
    let mut _63: bool;
    let mut _64: &&str;
    let mut _65: registers::control::_::InternalBitFlags;
    let mut _66: u64;
    let mut _67: bool;
    let mut _68: &&str;
    let mut _69: registers::control::_::InternalBitFlags;
    let mut _70: u64;
    let mut _71: bool;
    let mut _72: &&str;
    let mut _73: registers::control::_::InternalBitFlags;
    let mut _74: u64;
    let mut _75: bool;
    let mut _76: &&str;
    let mut _77: registers::control::_::InternalBitFlags;
    let mut _78: u64;
    let mut _79: bool;
    let mut _80: &&str;
    let mut _81: registers::control::_::InternalBitFlags;
    let mut _82: u64;
    let mut _83: bool;
    let mut _84: &&str;
    let mut _85: registers::control::_::InternalBitFlags;
    let mut _86: u64;
    let mut _87: bool;
    let mut _88: &&str;
    let mut _89: registers::control::_::InternalBitFlags;
    let mut _90: u64;
    let mut _91: bool;
    let mut _92: &&str;
    let mut _93: registers::control::_::InternalBitFlags;
    let mut _94: u64;
    let mut _95: bool;
    let mut _96: &&str;
    let mut _97: registers::control::_::InternalBitFlags;
    let mut _98: u64;
    let mut _99: bool;
    let mut _100: &&str;
    let mut _101: registers::control::_::InternalBitFlags;
    let mut _102: u64;
    scope 1 {
        debug name => _2;
        let mut _103: &registers::control::Cr4Flags;
        let mut _104: &registers::control::Cr4Flags;
        let mut _105: &registers::control::Cr4Flags;
        let mut _106: &registers::control::Cr4Flags;
        let mut _107: &registers::control::Cr4Flags;
        let mut _108: &registers::control::Cr4Flags;
        let mut _109: &registers::control::Cr4Flags;
        let mut _110: &registers::control::Cr4Flags;
        let mut _111: &registers::control::Cr4Flags;
        let mut _112: &registers::control::Cr4Flags;
        let mut _113: &registers::control::Cr4Flags;
        let mut _114: &registers::control::Cr4Flags;
        let mut _115: &registers::control::Cr4Flags;
        let mut _116: &registers::control::Cr4Flags;
        let mut _117: &registers::control::Cr4Flags;
        let mut _118: &registers::control::Cr4Flags;
        let mut _119: &registers::control::Cr4Flags;
        let mut _120: &registers::control::Cr4Flags;
        let mut _121: &registers::control::Cr4Flags;
        let mut _122: &registers::control::Cr4Flags;
        let mut _123: &registers::control::Cr4Flags;
        let mut _124: &registers::control::Cr4Flags;
        let mut _125: &registers::control::Cr4Flags;
        let mut _126: &registers::control::Cr4Flags;
        let mut _127: &registers::control::Cr4Flags;
        let mut _128: &&str;
        let mut _129: &&str;
        let mut _130: &&str;
        let mut _131: &&str;
        let mut _132: &&str;
        let mut _133: &&str;
        let mut _134: &&str;
        let mut _135: &&str;
        let mut _136: &&str;
        let mut _137: &&str;
        let mut _138: &&str;
        let mut _139: &&str;
        let mut _140: &&str;
        let mut _141: &&str;
        let mut _142: &&str;
        let mut _143: &&str;
        let mut _144: &&str;
        let mut _145: &&str;
        let mut _146: &&str;
        let mut _147: &&str;
        let mut _148: &&str;
        let mut _149: &&str;
        let mut _150: &&str;
        let mut _151: &&str;
        let mut _152: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _152 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _152) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _103 = const _;
        _6 = control::_::<impl control::Cr4Flags>::bits(_103) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = control::_::InternalBitFlags(move _6);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _5);
        goto -> bb101;
    }

    bb4: {
        _8 = &_2;
        _151 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _151) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _104 = const _;
        _10 = control::_::<impl control::Cr4Flags>::bits(_104) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = control::_::InternalBitFlags(move _10);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _9);
        goto -> bb101;
    }

    bb8: {
        _12 = &_2;
        _150 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _150) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _105 = const _;
        _14 = control::_::<impl control::Cr4Flags>::bits(_105) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = control::_::InternalBitFlags(move _14);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _13);
        goto -> bb101;
    }

    bb12: {
        _16 = &_2;
        _149 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _149) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _106 = const _;
        _18 = control::_::<impl control::Cr4Flags>::bits(_106) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = control::_::InternalBitFlags(move _18);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _17);
        goto -> bb101;
    }

    bb16: {
        _20 = &_2;
        _148 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _148) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _107 = const _;
        _22 = control::_::<impl control::Cr4Flags>::bits(_107) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = control::_::InternalBitFlags(move _22);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _21);
        goto -> bb101;
    }

    bb20: {
        _24 = &_2;
        _147 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _147) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _108 = const _;
        _26 = control::_::<impl control::Cr4Flags>::bits(_108) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = control::_::InternalBitFlags(move _26);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _25);
        goto -> bb101;
    }

    bb24: {
        _28 = &_2;
        _146 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _146) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _109 = const _;
        _30 = control::_::<impl control::Cr4Flags>::bits(_109) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = control::_::InternalBitFlags(move _30);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _29);
        goto -> bb101;
    }

    bb28: {
        _32 = &_2;
        _145 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _145) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _110 = const _;
        _34 = control::_::<impl control::Cr4Flags>::bits(_110) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = control::_::InternalBitFlags(move _34);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _33);
        goto -> bb101;
    }

    bb32: {
        _36 = &_2;
        _144 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _144) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _111 = const _;
        _38 = control::_::<impl control::Cr4Flags>::bits(_111) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = control::_::InternalBitFlags(move _38);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _37);
        goto -> bb101;
    }

    bb36: {
        _40 = &_2;
        _143 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _143) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _112 = const _;
        _42 = control::_::<impl control::Cr4Flags>::bits(_112) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = control::_::InternalBitFlags(move _42);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _41);
        goto -> bb101;
    }

    bb40: {
        _44 = &_2;
        _142 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _142) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _113 = const _;
        _46 = control::_::<impl control::Cr4Flags>::bits(_113) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = control::_::InternalBitFlags(move _46);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _45);
        goto -> bb101;
    }

    bb44: {
        _48 = &_2;
        _141 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _141) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _114 = const _;
        _50 = control::_::<impl control::Cr4Flags>::bits(_114) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = control::_::InternalBitFlags(move _50);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _49);
        goto -> bb101;
    }

    bb48: {
        _52 = &_2;
        _140 = const _;
        _51 = <&str as PartialEq>::eq(move _52, _140) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _51) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _115 = const _;
        _54 = control::_::<impl control::Cr4Flags>::bits(_115) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _53 = control::_::InternalBitFlags(move _54);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _53);
        goto -> bb101;
    }

    bb52: {
        _56 = &_2;
        _139 = const _;
        _55 = <&str as PartialEq>::eq(move _56, _139) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _55) -> [0: bb56, otherwise: bb54];
    }

    bb54: {
        _116 = const _;
        _58 = control::_::<impl control::Cr4Flags>::bits(_116) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _57 = control::_::InternalBitFlags(move _58);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _57);
        goto -> bb101;
    }

    bb56: {
        _60 = &_2;
        _138 = const _;
        _59 = <&str as PartialEq>::eq(move _60, _138) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _59) -> [0: bb60, otherwise: bb58];
    }

    bb58: {
        _117 = const _;
        _62 = control::_::<impl control::Cr4Flags>::bits(_117) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _61 = control::_::InternalBitFlags(move _62);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _61);
        goto -> bb101;
    }

    bb60: {
        _64 = &_2;
        _137 = const _;
        _63 = <&str as PartialEq>::eq(move _64, _137) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        switchInt(move _63) -> [0: bb64, otherwise: bb62];
    }

    bb62: {
        _118 = const _;
        _66 = control::_::<impl control::Cr4Flags>::bits(_118) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _65 = control::_::InternalBitFlags(move _66);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _65);
        goto -> bb101;
    }

    bb64: {
        _68 = &_2;
        _136 = const _;
        _67 = <&str as PartialEq>::eq(move _68, _136) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        switchInt(move _67) -> [0: bb68, otherwise: bb66];
    }

    bb66: {
        _119 = const _;
        _70 = control::_::<impl control::Cr4Flags>::bits(_119) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _69 = control::_::InternalBitFlags(move _70);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _69);
        goto -> bb101;
    }

    bb68: {
        _72 = &_2;
        _135 = const _;
        _71 = <&str as PartialEq>::eq(move _72, _135) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        switchInt(move _71) -> [0: bb72, otherwise: bb70];
    }

    bb70: {
        _120 = const _;
        _74 = control::_::<impl control::Cr4Flags>::bits(_120) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _73 = control::_::InternalBitFlags(move _74);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _73);
        goto -> bb101;
    }

    bb72: {
        _76 = &_2;
        _134 = const _;
        _75 = <&str as PartialEq>::eq(move _76, _134) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        switchInt(move _75) -> [0: bb76, otherwise: bb74];
    }

    bb74: {
        _121 = const _;
        _78 = control::_::<impl control::Cr4Flags>::bits(_121) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _77 = control::_::InternalBitFlags(move _78);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _77);
        goto -> bb101;
    }

    bb76: {
        _80 = &_2;
        _133 = const _;
        _79 = <&str as PartialEq>::eq(move _80, _133) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        switchInt(move _79) -> [0: bb80, otherwise: bb78];
    }

    bb78: {
        _122 = const _;
        _82 = control::_::<impl control::Cr4Flags>::bits(_122) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _81 = control::_::InternalBitFlags(move _82);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _81);
        goto -> bb101;
    }

    bb80: {
        _84 = &_2;
        _132 = const _;
        _83 = <&str as PartialEq>::eq(move _84, _132) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        switchInt(move _83) -> [0: bb84, otherwise: bb82];
    }

    bb82: {
        _123 = const _;
        _86 = control::_::<impl control::Cr4Flags>::bits(_123) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _85 = control::_::InternalBitFlags(move _86);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _85);
        goto -> bb101;
    }

    bb84: {
        _88 = &_2;
        _131 = const _;
        _87 = <&str as PartialEq>::eq(move _88, _131) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        switchInt(move _87) -> [0: bb88, otherwise: bb86];
    }

    bb86: {
        _124 = const _;
        _90 = control::_::<impl control::Cr4Flags>::bits(_124) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _89 = control::_::InternalBitFlags(move _90);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _89);
        goto -> bb101;
    }

    bb88: {
        _92 = &_2;
        _130 = const _;
        _91 = <&str as PartialEq>::eq(move _92, _130) -> [return: bb89, unwind unreachable];
    }

    bb89: {
        switchInt(move _91) -> [0: bb92, otherwise: bb90];
    }

    bb90: {
        _125 = const _;
        _94 = control::_::<impl control::Cr4Flags>::bits(_125) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _93 = control::_::InternalBitFlags(move _94);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _93);
        goto -> bb101;
    }

    bb92: {
        _96 = &_2;
        _129 = const _;
        _95 = <&str as PartialEq>::eq(move _96, _129) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        switchInt(move _95) -> [0: bb96, otherwise: bb94];
    }

    bb94: {
        _126 = const _;
        _98 = control::_::<impl control::Cr4Flags>::bits(_126) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _97 = control::_::InternalBitFlags(move _98);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _97);
        goto -> bb101;
    }

    bb96: {
        _100 = &_2;
        _128 = const _;
        _99 = <&str as PartialEq>::eq(move _100, _128) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        switchInt(move _99) -> [0: bb100, otherwise: bb98];
    }

    bb98: {
        _127 = const _;
        _102 = control::_::<impl control::Cr4Flags>::bits(_127) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _101 = control::_::InternalBitFlags(move _102);
        _0 = Option::<control::_::InternalBitFlags>::Some(move _101);
        goto -> bb101;
    }

    bb100: {
        _0 = Option::<control::_::InternalBitFlags>::None;
        goto -> bb101;
    }

    bb101: {
        return;
    }
}

promoted[0] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[14] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[16] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[17] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[18] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[19] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[20] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[21] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[22] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[23] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[24] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &control::Cr4Flags = {
    let mut _0: &registers::control::Cr4Flags;
    let mut _1: registers::control::Cr4Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[25] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTION_KEY_SUPERVISOR";
        _0 = &_1;
        return;
    }
}

promoted[26] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "CONTROL_FLOW_ENFORCEMENT";
        _0 = &_1;
        return;
    }
}

promoted[27] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTION_KEY";
        _0 = &_1;
        return;
    }
}

promoted[28] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTION_KEY_USER";
        _0 = &_1;
        return;
    }
}

promoted[29] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SUPERVISOR_MODE_ACCESS_PREVENTION";
        _0 = &_1;
        return;
    }
}

promoted[30] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SUPERVISOR_MODE_EXECUTION_PROTECTION";
        _0 = &_1;
        return;
    }
}

promoted[31] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "KEY_LOCKER";
        _0 = &_1;
        return;
    }
}

promoted[32] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OSXSAVE";
        _0 = &_1;
        return;
    }
}

promoted[33] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PCID";
        _0 = &_1;
        return;
    }
}

promoted[34] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "FSGSBASE";
        _0 = &_1;
        return;
    }
}

promoted[35] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SAFER_MODE_EXTENSIONS";
        _0 = &_1;
        return;
    }
}

promoted[36] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "VIRTUAL_MACHINE_EXTENSIONS";
        _0 = &_1;
        return;
    }
}

promoted[37] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "L5_PAGING";
        _0 = &_1;
        return;
    }
}

promoted[38] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "USER_MODE_INSTRUCTION_PREVENTION";
        _0 = &_1;
        return;
    }
}

promoted[39] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OSXMMEXCPT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[40] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OSFXSR";
        _0 = &_1;
        return;
    }
}

promoted[41] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PERFORMANCE_MONITOR_COUNTER";
        _0 = &_1;
        return;
    }
}

promoted[42] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PAGE_GLOBAL";
        _0 = &_1;
        return;
    }
}

promoted[43] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "MACHINE_CHECK_EXCEPTION";
        _0 = &_1;
        return;
    }
}

promoted[44] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PHYSICAL_ADDRESS_EXTENSION";
        _0 = &_1;
        return;
    }
}

promoted[45] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PAGE_SIZE_EXTENSION";
        _0 = &_1;
        return;
    }
}

promoted[46] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DEBUGGING_EXTENSIONS";
        _0 = &_1;
        return;
    }
}

promoted[47] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TIMESTAMP_DISABLE";
        _0 = &_1;
        return;
    }
}

promoted[48] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTED_MODE_VIRTUAL_INTERRUPTS";
        _0 = &_1;
        return;
    }
}

promoted[49] in control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "VIRTUAL_8086_MODE_EXTENSIONS";
        _0 = &_1;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let _5: registers::control::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = control::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    let _6: registers::control::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::control::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = control::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = control::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = control::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;
    let _3: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = control::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let _2: registers::control::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = control::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::control::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::_::InternalBitFlags, _2: control::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::_::InternalBitFlags) -> control::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::control::_::InternalBitFlags;
    let mut _2: registers::control::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::_::InternalBitFlags as Extend<control::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr4Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr4Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr4Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::_::InternalBitFlags) -> IterNames<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: &registers::control::_::InternalBitFlags;
    let mut _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: &registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr4Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::_::InternalBitFlags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: &registers::control::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = control::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut control::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: registers::control::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = control::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr4Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &control::Cr4Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::control::Cr4Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr4Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr4Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr4Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr4Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr4Flags(_4);
        _0 = Option::<control::Cr4Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<control::Cr4Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::control::Cr4Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::control::Cr4Flags;
    let mut _8: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<control::Cr4Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = control::Cr4Flags(move _8);
        StorageDead(_8);
        _0 = Option::<control::Cr4Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr4Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let _2: u64;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr4Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<control::Cr4Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::control::Cr4Flags>;
    let mut _2: core::option::Option<registers::control::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::control::Cr4Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::control::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = control::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<control::Cr4Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::control::_::InternalBitFlags);
        _5 = control::Cr4Flags(_4);
        _0 = Option::<control::Cr4Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr4Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &control::Cr4Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::control::Cr4Flags;
    let mut _3: &registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr4Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &control::Cr4Flags, _2: control::Cr4Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::control::Cr4Flags;
    let mut _5: &registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::control::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = control::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut control::Cr4Flags, _2: control::Cr4Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _0 = control::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let _3: registers::control::Cr4Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr4Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let _3: registers::control::Cr4Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr4Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let _3: registers::control::Cr4Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr4Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    let mut _5: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::control::_::InternalBitFlags);
        _5 = (_2.0: registers::control::_::InternalBitFlags);
        _3 = control::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;
    let _3: registers::control::Cr4Flags;
    let mut _5: registers::control::_::InternalBitFlags;
    let mut _6: registers::control::_::InternalBitFlags;
    let mut _7: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::control::Cr4Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::control::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = control::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = control::Cr4Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::_::InternalBitFlags;
    let mut _3: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::control::_::InternalBitFlags);
        _2 = control::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::Cr4Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;
    let _2: registers::control::Cr4Flags;
    let mut _3: registers::control::_::InternalBitFlags;
    let mut _4: registers::control::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::control::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = control::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = control::Cr4Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &control::Cr4Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::control::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::control::_::InternalBitFlags);
        _0 = <control::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr4Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr4Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::control::Cr4Flags;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;
    let mut _6: &registers::control::Cr4Flags;

    bb0: {
        _6 = &(*_1);
        _5 = control::_::<impl control::Cr4Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = control::_::<impl control::Cr4Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: control::Cr4Flags, _2: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut control::Cr4Flags, _2: control::Cr4Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = control::_::<impl control::Cr4Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: control::Cr4Flags) -> control::Cr4Flags {
    debug self => _1;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut control::Cr4Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::control::Cr4Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::control::Cr4Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::control::Cr4Flags);
        _5 = control::_::<impl control::Cr4Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> control::Cr4Flags {
    debug iterator => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: registers::control::Cr4Flags;
    let _3: ();
    let mut _4: &mut registers::control::Cr4Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = control::_::<impl control::Cr4Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <control::Cr4Flags as Extend<control::Cr4Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr4Flags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr4Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr4Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<control::Cr4Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &control::Cr4Flags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr4Flags;
    let mut _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr4Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr4Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr4Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<control::Cr4Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr4Flags) -> IterNames<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: registers::control::Cr4Flags;
    let mut _5: u64;

    bb0: {
        _3 = control::_::<impl control::Cr4Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = control::_::<impl control::Cr4Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<control::Cr4Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &control::Cr4Flags) -> IterNames<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::control::Cr4Flags>;
    let mut _2: registers::control::Cr4Flags;
    let mut _3: u64;
    let mut _4: &registers::control::Cr4Flags;
    let mut _5: registers::control::Cr4Flags;
    let mut _6: u64;
    let mut _7: &registers::control::Cr4Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = control::_::<impl control::Cr4Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = control::_::<impl control::Cr4Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<control::Cr4Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn control::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: control::Cr4Flags) -> bitflags::iter::Iter<control::Cr4Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::control::Cr4Flags>;
    let mut _2: &registers::control::Cr4Flags;

    bb0: {
        _2 = &_1;
        _0 = control::_::<impl control::Cr4Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:181:1: 181:14>::from_bits_unchecked(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn control::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:181:1: 181:14>::from_bits_unchecked(_1: u64) -> control::Cr4Flags {
    debug bits => _1;
    let mut _0: registers::control::Cr4Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = control::_::<impl control::Cr4Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:195:5: 195:13>::read() -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::_::<impl control::Cr0Flags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:195:5: 195:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr0", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:195:5: 195:13>::write(_1: control::Cr0Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::Cr0Flags;
    let _7: registers::control::Cr0Flags;
    let mut _9: u64;
    let mut _10: &registers::control::Cr0Flags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = control::_::<impl control::Cr0Flags>::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = control::_::<impl control::Cr0Flags>::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = control::_::<impl control::Cr0Flags>::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = control::x86_64::<impl control::Cr0>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:195:5: 195:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov cr0, {0}", in(reg) _1, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:195:5: 195:13>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::control::Cr0Flags;
    let _3: ();
    let mut _4: (&mut registers::control::Cr0Flags,);
    let mut _5: &mut registers::control::Cr0Flags;
    let _6: ();
    let mut _7: registers::control::Cr0Flags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr0>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut control::Cr0Flags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = control::x86_64::<impl control::Cr0>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:269:5: 269:13>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr2>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:269:5: 269:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr2", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::read() -> (PhysFrame, control::Cr3Flags) {
    let mut _0: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    let _1: structures::paging::frame::PhysFrame;
    let _2: u16;
    let mut _3: (structures::paging::frame::PhysFrame, u16);
    let mut _5: u64;
    scope 1 {
        debug frame => _1;
        debug value => _2;
        let _4: registers::control::Cr3Flags;
        scope 2 {
            debug flags => _4;
        }
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: u16);
        _5 = <u16 as Into<u64>>::into(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = control::_::<impl control::Cr3Flags>::from_bits_truncate(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = (_1, _4);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::read_raw() -> (PhysFrame, u16) {
    let mut _0: (structures::paging::frame::PhysFrame, u16);
    let _1: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _6: u16;
    let mut _7: u64;
    let mut _8: u64;
    scope 1 {
        debug value => _1;
        let _2: addr::PhysAddr;
        scope 2 {
        }
        scope 3 {
            debug addr => _2;
            let _5: structures::paging::frame::PhysFrame;
            scope 4 {
                debug frame => _5;
            }
        }
    }

    bb0: {
        asm!("mov {0}, cr3", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = BitAnd(move _4, const 4503599627366400_u64);
        _2 = PhysAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PhysFrame::containing_address(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = _1;
        _7 = BitAnd(move _8, const 4095_u64);
        _6 = move _7 as u16 (IntToInt);
        _0 = (_5, move _6);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::read_pcid() -> (PhysFrame, Pcid) {
    let mut _0: (structures::paging::frame::PhysFrame, instructions::tlb::Pcid);
    let _1: structures::paging::frame::PhysFrame;
    let _2: u16;
    let mut _3: (structures::paging::frame::PhysFrame, u16);
    let mut _4: instructions::tlb::Pcid;
    let mut _5: core::result::Result<instructions::tlb::Pcid, &str>;
    scope 1 {
        debug frame => _1;
        debug value => _2;
    }

    bb0: {
        _3 = control::x86_64::<impl control::Cr3>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = (_3.0: structures::paging::frame::PhysFrame);
        _2 = (_3.1: u16);
        _5 = Pcid::new(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Pcid, &str>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = (_1, move _4);
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::write(_1: PhysFrame, _2: control::Cr3Flags) -> () {
    debug frame => _1;
    debug flags => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u16;
    let mut _5: u64;
    let mut _6: &registers::control::Cr3Flags;
    scope 1 {
    }

    bb0: {
        _6 = &_2;
        _5 = control::_::<impl control::Cr3Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _5 as u16 (IntToInt);
        _3 = control::x86_64::<impl control::Cr3>::write_raw(_1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::write_pcid(_1: PhysFrame, _2: Pcid) -> () {
    debug frame => _1;
    debug pcid => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u16;
    let mut _5: &instructions::tlb::Pcid;
    scope 1 {
    }

    bb0: {
        _5 = &_2;
        _4 = Pcid::value(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = control::x86_64::<impl control::Cr3>::write_raw(_1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:289:5: 289:13>::write_raw(_1: PhysFrame, _2: u16) -> () {
    debug frame => _1;
    debug val => _2;
    let mut _0: ();
    let _3: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: u64;
    scope 1 {
        debug addr => _3;
        let _4: u64;
        scope 2 {
            debug value => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = PhysFrame::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = _2 as u64 (IntToInt);
        _4 = BitOr(move _5, move _6);
        asm!("mov cr3, {0}", in(reg) _4, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:365:5: 365:13>::read() -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;
    let mut _1: u64;

    bb0: {
        _1 = control::x86_64::<impl control::Cr4>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = control::_::<impl control::Cr4Flags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:365:5: 365:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, cr4", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:365:5: 365:13>::write(_1: control::Cr4Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::control::Cr4Flags;
    let _7: registers::control::Cr4Flags;
    let mut _9: u64;
    let mut _10: &registers::control::Cr4Flags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr4>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = control::_::<impl control::Cr4Flags>::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = control::_::<impl control::Cr4Flags>::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = control::_::<impl control::Cr4Flags>::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = control::x86_64::<impl control::Cr4>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:365:5: 365:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov cr4, {0}", in(reg) _1, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn control::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/control.rs:365:5: 365:13>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::control::Cr4Flags;
    let _3: ();
    let mut _4: (&mut registers::control::Cr4Flags,);
    let mut _5: &mut registers::control::Cr4Flags;
    let _6: ();
    let mut _7: registers::control::Cr4Flags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = control::x86_64::<impl control::Cr4>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut control::Cr4Flags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = control::x86_64::<impl control::Cr4>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr0;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr0", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr0, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr1, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr1";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr1", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr1, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr2, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr2";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr2;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr2", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr2, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:31:18: 31:23>::fmt(_1: &Dr3, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr3";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::NUM: DebugAddressRegisterNumber = {
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = DebugAddressRegisterNumber::Dr3;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::read() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug addr => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr3", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:34:9: 34:42>::write(_1: u64) -> () {
    debug addr => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr3, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:63:10: 63:15>::clone(_1: &DebugAddressRegisterNumber) -> DebugAddressRegisterNumber {
    debug self => _1;
    let mut _0: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:63:23: 63:28>::fmt(_1: &DebugAddressRegisterNumber, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb7];
    }

    bb1: {
        _8 = const "Dr3";
        _3 = _8;
        goto -> bb5;
    }

    bb2: {
        _5 = const "Dr0";
        _3 = _5;
        goto -> bb5;
    }

    bb3: {
        _6 = const "Dr1";
        _3 = _6;
        goto -> bb5;
    }

    bb4: {
        _7 = const "Dr2";
        _3 = _7;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:63:30: 63:39>::eq(_1: &DebugAddressRegisterNumber, _2: &DebugAddressRegisterNumber) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:63:41: 63:43>::assert_receiver_is_total_eq(_1: &DebugAddressRegisterNumber) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:81:1: 81:32>::new(_1: u8) -> Option<DebugAddressRegisterNumber> {
    debug n => _1;
    let mut _0: core::option::Option<registers::debug::DebugAddressRegisterNumber>;
    let mut _2: registers::debug::DebugAddressRegisterNumber;
    let mut _3: registers::debug::DebugAddressRegisterNumber;
    let mut _4: registers::debug::DebugAddressRegisterNumber;
    let mut _5: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<DebugAddressRegisterNumber>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = DebugAddressRegisterNumber::Dr0;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = DebugAddressRegisterNumber::Dr1;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = DebugAddressRegisterNumber::Dr2;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = DebugAddressRegisterNumber::Dr3;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:81:1: 81:32>::new(_1: u8) -> Option<DebugAddressRegisterNumber> {
    debug n => _1;
    let mut _0: core::option::Option<registers::debug::DebugAddressRegisterNumber>;
    let mut _2: registers::debug::DebugAddressRegisterNumber;
    let mut _3: registers::debug::DebugAddressRegisterNumber;
    let mut _4: registers::debug::DebugAddressRegisterNumber;
    let mut _5: registers::debug::DebugAddressRegisterNumber;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<DebugAddressRegisterNumber>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = DebugAddressRegisterNumber::Dr0;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = DebugAddressRegisterNumber::Dr1;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = DebugAddressRegisterNumber::Dr2;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = DebugAddressRegisterNumber::Dr3;
        _0 = Option::<DebugAddressRegisterNumber>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:81:1: 81:32>::get(_1: DebugAddressRegisterNumber) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const 3_u8;
        goto -> bb5;
    }

    bb2: {
        _0 = const 0_u8;
        goto -> bb5;
    }

    bb3: {
        _0 = const 1_u8;
        goto -> bb5;
    }

    bb4: {
        _0 = const 2_u8;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:81:1: 81:32>::get(_1: DebugAddressRegisterNumber) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 3_u8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const 0_u8;
        goto -> bb6;
    }

    bb4: {
        _0 = const 1_u8;
        goto -> bb6;
    }

    bb5: {
        _0 = const 2_u8;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:107:10: 107:15>::fmt(_1: &debug::Dr6, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr6";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:14: 113:23>::eq(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:25: 113:27>::assert_receiver_is_total_eq(_1: &debug::Dr6Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:29: 113:39>::partial_cmp(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::debug::_::InternalBitFlags;
    let _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:41: 113:44>::cmp(_1: &debug::Dr6Flags, _2: &debug::Dr6Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::debug::_::InternalBitFlags;
    let _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:46: 113:50>::hash(_1: &debug::Dr6Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:52: 113:57>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::debug::_::InternalBitFlags;
    let _6: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = const "Dr6Flags";
        _6 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:113:59: 113:64>::clone(_1: &debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP0: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP1: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP2: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP3: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr6Flags;
    let _6: registers::debug::Dr6Flags;
    let mut _7: u64;
    let mut _8: &registers::debug::Dr6Flags;
    let _9: registers::debug::Dr6Flags;
    let mut _10: u64;
    let mut _11: &registers::debug::Dr6Flags;
    let _12: registers::debug::Dr6Flags;
    let mut _13: u64;
    let mut _14: &registers::debug::Dr6Flags;
    let _15: registers::debug::Dr6Flags;
    let mut _16: &registers::debug::Dr6Flags;
    let mut _17: &registers::debug::Dr6Flags;
    let mut _18: &registers::debug::Dr6Flags;
    let mut _19: &registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _19 = const _;
        _5 = &(*_19);
        ConstEvalCounter;
        _4 = debug::_::<impl debug::Dr6Flags>::bits(move _5) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _18 = const _;
        _8 = &(*_18);
        ConstEvalCounter;
        _7 = debug::_::<impl debug::Dr6Flags>::bits(move _8) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_10);
        StorageLive(_11);
        _17 = const _;
        _11 = &(*_17);
        ConstEvalCounter;
        _10 = debug::_::<impl debug::Dr6Flags>::bits(move _11) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        StorageDead(_11);
        _2 = BitOr(move _3, move _10);
        StorageDead(_10);
        StorageDead(_3);
        StorageLive(_13);
        StorageLive(_14);
        _16 = const _;
        _14 = &(*_16);
        ConstEvalCounter;
        _13 = debug::_::<impl debug::Dr6Flags>::bits(move _14) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        StorageDead(_14);
        _1 = BitOr(move _2, move _13);
        StorageDead(_13);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        StorageDead(_1);
        return;
    }

    bb6 (cleanup): {
        resume;
    }
}

promoted[0] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ACCESS_DETECTED: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::STEP: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SWITCH: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::RTM: debug::Dr6Flags = {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<debug::Dr6Flags>] = {
    let mut _0: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let mut _1: &[bitflags::Flag<registers::debug::Dr6Flags>; 9];
    let _2: &[bitflags::Flag<registers::debug::Dr6Flags>; 9];
    let _3: [bitflags::Flag<registers::debug::Dr6Flags>; 9];
    let mut _4: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _5: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _6: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _7: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _8: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _9: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _10: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _11: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _12: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _13: &[bitflags::Flag<registers::debug::Dr6Flags>; 9];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _13 = const _;
        _2 = &(*_13);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::debug::Dr6Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<debug::Dr6Flags>; 9] = {
    let mut _0: &[bitflags::Flag<registers::debug::Dr6Flags>; 9];
    let mut _1: [bitflags::Flag<registers::debug::Dr6Flags>; 9];
    let mut _2: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _3: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _4: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _5: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _6: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _7: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _8: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _9: bitflags::Flag<registers::debug::Dr6Flags>;
    let mut _10: bitflags::Flag<registers::debug::Dr6Flags>;

    bb0: {
        _2 = Flag::<debug::Dr6Flags>::new(const "TRAP0", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<debug::Dr6Flags>::new(const "TRAP1", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<debug::Dr6Flags>::new(const "TRAP2", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<debug::Dr6Flags>::new(const "TRAP3", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<debug::Dr6Flags>::new(const "TRAP", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<debug::Dr6Flags>::new(const "ACCESS_DETECTED", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<debug::Dr6Flags>::new(const "STEP", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<debug::Dr6Flags>::new(const "SWITCH", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<debug::Dr6Flags>::new(const "RTM", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10];
        _0 = &_1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &debug::Dr6Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &debug::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &debug::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = debug::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <debug::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::Dr6Flags;
    let _4: registers::debug::Dr6Flags;
    let mut _5: registers::debug::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = debug::Dr6Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<debug::Dr6Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<debug::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::debug::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::debug::Dr6Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<debug::Dr6Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<debug::Dr6Flags, ParseError>::map::<debug::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: debug::Dr6Flags) -> debug::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::debug::_::InternalBitFlags);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &debug::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(const _);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::debug::Dr6Flags;
    let mut _5: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _6: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::debug::Dr6Flags;
    let mut _14: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _15: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::debug::Dr6Flags;
    let mut _23: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _24: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::debug::Dr6Flags;
    let mut _32: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _33: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::debug::Dr6Flags;
    let mut _41: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _42: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::debug::Dr6Flags;
    let mut _50: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _51: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::debug::Dr6Flags;
    let mut _59: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _60: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::debug::Dr6Flags;
    let mut _68: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _69: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::debug::Dr6Flags;
    let mut _77: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _78: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let mut _84: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<debug::Dr6Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::<impl debug::Dr6Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<debug::Dr6Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = debug::_::<impl debug::Dr6Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<debug::Dr6Flags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = debug::_::<impl debug::Dr6Flags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<debug::Dr6Flags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = debug::_::<impl debug::Dr6Flags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<debug::Dr6Flags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = debug::_::<impl debug::Dr6Flags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<debug::Dr6Flags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = debug::_::<impl debug::Dr6Flags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<debug::Dr6Flags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = debug::_::<impl debug::Dr6Flags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<debug::Dr6Flags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = debug::_::<impl debug::Dr6Flags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<debug::Dr6Flags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = debug::_::<impl debug::Dr6Flags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _84 = _1;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _84) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::debug::Dr6Flags;
    let _6: &registers::debug::Dr6Flags;
    let mut _7: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _8: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::debug::Dr6Flags;
    let _18: &registers::debug::Dr6Flags;
    let mut _19: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _20: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::debug::Dr6Flags;
    let _30: &registers::debug::Dr6Flags;
    let mut _31: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _32: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::debug::Dr6Flags;
    let _42: &registers::debug::Dr6Flags;
    let mut _43: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _44: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::debug::Dr6Flags;
    let _54: &registers::debug::Dr6Flags;
    let mut _55: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _56: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::debug::Dr6Flags;
    let _66: &registers::debug::Dr6Flags;
    let mut _67: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _68: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::debug::Dr6Flags;
    let _78: &registers::debug::Dr6Flags;
    let mut _79: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _80: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::debug::Dr6Flags;
    let _90: &registers::debug::Dr6Flags;
    let mut _91: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _92: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::debug::Dr6Flags;
    let _102: &registers::debug::Dr6Flags;
    let mut _103: &bitflags::Flag<registers::debug::Dr6Flags>;
    let _104: &[bitflags::Flag<registers::debug::Dr6Flags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let mut _111: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<debug::Dr6Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = debug::_::<impl debug::Dr6Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<debug::Dr6Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = debug::_::<impl debug::Dr6Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<debug::Dr6Flags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = debug::_::<impl debug::Dr6Flags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<debug::Dr6Flags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = debug::_::<impl debug::Dr6Flags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<debug::Dr6Flags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = debug::_::<impl debug::Dr6Flags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<debug::Dr6Flags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = debug::_::<impl debug::Dr6Flags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<debug::Dr6Flags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = debug::_::<impl debug::Dr6Flags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<debug::Dr6Flags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = debug::_::<impl debug::Dr6Flags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<debug::Dr6Flags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = debug::_::<impl debug::Dr6Flags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        _111 = _1;
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _111) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        StorageDead(_111);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = debug::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags(_1);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = debug::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = debug::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    let _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = debug::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = debug::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<debug::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::debug::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::debug::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::debug::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::debug::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::debug::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::debug::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::debug::_::InternalBitFlags;
    let mut _38: u64;
    scope 1 {
        debug name => _2;
        let mut _39: &registers::debug::Dr6Flags;
        let mut _40: &registers::debug::Dr6Flags;
        let mut _41: &registers::debug::Dr6Flags;
        let mut _42: &registers::debug::Dr6Flags;
        let mut _43: &registers::debug::Dr6Flags;
        let mut _44: &registers::debug::Dr6Flags;
        let mut _45: &registers::debug::Dr6Flags;
        let mut _46: &registers::debug::Dr6Flags;
        let mut _47: &registers::debug::Dr6Flags;
        let mut _48: &&str;
        let mut _49: &&str;
        let mut _50: &&str;
        let mut _51: &&str;
        let mut _52: &&str;
        let mut _53: &&str;
        let mut _54: &&str;
        let mut _55: &&str;
        let mut _56: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _56 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _56) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _39 = const _;
        _6 = debug::_::<impl debug::Dr6Flags>::bits(_39) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = debug::_::InternalBitFlags(move _6);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _5);
        goto -> bb37;
    }

    bb4: {
        _8 = &_2;
        _55 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _55) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _40 = const _;
        _10 = debug::_::<impl debug::Dr6Flags>::bits(_40) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = debug::_::InternalBitFlags(move _10);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _9);
        goto -> bb37;
    }

    bb8: {
        _12 = &_2;
        _54 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _54) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _41 = const _;
        _14 = debug::_::<impl debug::Dr6Flags>::bits(_41) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = debug::_::InternalBitFlags(move _14);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _13);
        goto -> bb37;
    }

    bb12: {
        _16 = &_2;
        _53 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _53) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _42 = const _;
        _18 = debug::_::<impl debug::Dr6Flags>::bits(_42) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = debug::_::InternalBitFlags(move _18);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _17);
        goto -> bb37;
    }

    bb16: {
        _20 = &_2;
        _52 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _52) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _43 = const _;
        _22 = debug::_::<impl debug::Dr6Flags>::bits(_43) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = debug::_::InternalBitFlags(move _22);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _21);
        goto -> bb37;
    }

    bb20: {
        _24 = &_2;
        _51 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _51) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _44 = const _;
        _26 = debug::_::<impl debug::Dr6Flags>::bits(_44) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = debug::_::InternalBitFlags(move _26);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _25);
        goto -> bb37;
    }

    bb24: {
        _28 = &_2;
        _50 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _50) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _45 = const _;
        _30 = debug::_::<impl debug::Dr6Flags>::bits(_45) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = debug::_::InternalBitFlags(move _30);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _29);
        goto -> bb37;
    }

    bb28: {
        _32 = &_2;
        _49 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _49) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _46 = const _;
        _34 = debug::_::<impl debug::Dr6Flags>::bits(_46) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = debug::_::InternalBitFlags(move _34);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _33);
        goto -> bb37;
    }

    bb32: {
        _36 = &_2;
        _48 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _48) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _47 = const _;
        _38 = debug::_::<impl debug::Dr6Flags>::bits(_47) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = debug::_::InternalBitFlags(move _38);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _37);
        goto -> bb37;
    }

    bb36: {
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb37;
    }

    bb37: {
        return;
    }
}

promoted[0] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &debug::Dr6Flags = {
    let mut _0: &registers::debug::Dr6Flags;
    let mut _1: registers::debug::Dr6Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "RTM";
        _0 = &_1;
        return;
    }
}

promoted[10] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SWITCH";
        _0 = &_1;
        return;
    }
}

promoted[11] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "STEP";
        _0 = &_1;
        return;
    }
}

promoted[12] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ACCESS_DETECTED";
        _0 = &_1;
        return;
    }
}

promoted[13] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP";
        _0 = &_1;
        return;
    }
}

promoted[14] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP3";
        _0 = &_1;
        return;
    }
}

promoted[15] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP2";
        _0 = &_1;
        return;
    }
}

promoted[16] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP1";
        _0 = &_1;
        return;
    }
}

promoted[17] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP0";
        _0 = &_1;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let _5: registers::debug::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = debug::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let _6: registers::debug::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::debug::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = debug::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = debug::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = debug::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut debug::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = debug::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> debug::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _2: registers::debug::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::debug::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <debug::_::InternalBitFlags as Extend<debug::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::_::InternalBitFlags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::_::InternalBitFlags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::_::InternalBitFlags) -> IterNames<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::_::InternalBitFlags) -> IterNames<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: debug::_::InternalBitFlags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: &registers::debug::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = debug::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut debug::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        _1 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        _1 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::Dr6Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::Dr6Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::debug::Dr6Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::Dr6Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr6Flags>;
    let mut _2: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::debug::Dr6Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<debug::Dr6Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = debug::Dr6Flags(_4);
        _0 = Option::<debug::Dr6Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::Dr6Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr6Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::debug::Dr6Flags;
    let mut _8: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<debug::Dr6Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = debug::Dr6Flags(move _8);
        StorageDead(_8);
        _0 = Option::<debug::Dr6Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let _2: u64;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = debug::Dr6Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let _2: u64;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = debug::Dr6Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<debug::Dr6Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::debug::Dr6Flags>;
    let mut _2: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::debug::Dr6Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<debug::Dr6Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = debug::Dr6Flags(_4);
        _0 = Option::<debug::Dr6Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::Dr6Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::Dr6Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::Dr6Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::Dr6Flags;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::debug::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::Dr6Flags, _2: debug::Dr6Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::Dr6Flags;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::debug::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let _3: registers::debug::Dr6Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = debug::Dr6Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let _3: registers::debug::Dr6Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = debug::Dr6Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let _3: registers::debug::Dr6Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = debug::Dr6Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;
    let _3: registers::debug::Dr6Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr6Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = debug::Dr6Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    let mut _3: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::debug::_::InternalBitFlags);
        _2 = debug::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr6Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;
    let _2: registers::debug::Dr6Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = debug::Dr6Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &debug::Dr6Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl debug::Dr6Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl debug::Dr6Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::Dr6Flags;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;
    let mut _6: &registers::debug::Dr6Flags;

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::<impl debug::Dr6Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::<impl debug::Dr6Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: debug::Dr6Flags, _2: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut debug::Dr6Flags, _2: debug::Dr6Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl debug::Dr6Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: debug::Dr6Flags) -> debug::Dr6Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut debug::Dr6Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::Dr6Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::Dr6Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::Dr6Flags);
        _5 = debug::_::<impl debug::Dr6Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> debug::Dr6Flags {
    debug iterator => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: registers::debug::Dr6Flags;
    let _3: ();
    let mut _4: &mut registers::debug::Dr6Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = debug::_::<impl debug::Dr6Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <debug::Dr6Flags as Extend<debug::Dr6Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::Dr6Flags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::<impl debug::Dr6Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::<impl debug::Dr6Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::Dr6Flags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr6Flags;
    let mut _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::<impl debug::Dr6Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::<impl debug::Dr6Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::Dr6Flags) -> IterNames<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr6Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::<impl debug::Dr6Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::<impl debug::Dr6Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::Dr6Flags) -> IterNames<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr6Flags>;
    let mut _2: registers::debug::Dr6Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr6Flags;
    let mut _5: registers::debug::Dr6Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr6Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::<impl debug::Dr6Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::<impl debug::Dr6Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<debug::Dr6Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: debug::Dr6Flags) -> bitflags::iter::Iter<debug::Dr6Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr6Flags>;
    let mut _2: &registers::debug::Dr6Flags;

    bb0: {
        _2 = &_1;
        _0 = debug::_::<impl debug::Dr6Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:153:1: 153:14>::trap(_1: DebugAddressRegisterNumber) -> debug::Dr6Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        _0 = const _;
        goto -> bb5;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:153:1: 153:14>::from_bits_unchecked(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:153:1: 153:14>::from_bits_unchecked(_1: u64) -> debug::Dr6Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr6Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:14: 174:23>::eq(_1: &Dr7Flags, _2: &Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:25: 174:27>::assert_receiver_is_total_eq(_1: &Dr7Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:29: 174:39>::partial_cmp(_1: &Dr7Flags, _2: &Dr7Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::debug::_::InternalBitFlags;
    let _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:41: 174:44>::cmp(_1: &Dr7Flags, _2: &Dr7Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::debug::_::InternalBitFlags;
    let _4: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = &((*_2).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:46: 174:50>::hash(_1: &Dr7Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:52: 174:57>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::debug::_::InternalBitFlags;
    let _6: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = const "Dr7Flags";
        _6 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:174:59: 174:64>::clone(_1: &Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LOCAL_BREAKPOINT_0_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LOCAL_BREAKPOINT_1_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LOCAL_BREAKPOINT_2_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LOCAL_BREAKPOINT_3_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL_BREAKPOINT_0_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL_BREAKPOINT_1_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL_BREAKPOINT_2_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL_BREAKPOINT_3_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LOCAL_EXACT_BREAKPOINT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL_EXACT_BREAKPOINT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::RESTRICTED_TRANSACTIONAL_MEMORY: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GENERAL_DETECT_ENABLE: Dr7Flags = {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<Dr7Flags>] = {
    let mut _0: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let mut _1: &[bitflags::Flag<registers::debug::Dr7Flags>; 12];
    let _2: &[bitflags::Flag<registers::debug::Dr7Flags>; 12];
    let _3: [bitflags::Flag<registers::debug::Dr7Flags>; 12];
    let mut _4: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _5: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _6: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _7: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _8: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _9: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _10: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _11: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _12: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _13: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _14: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _15: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _16: &[bitflags::Flag<registers::debug::Dr7Flags>; 12];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _16 = const _;
        _2 = &(*_16);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::debug::Dr7Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<Dr7Flags>; 12] = {
    let mut _0: &[bitflags::Flag<registers::debug::Dr7Flags>; 12];
    let mut _1: [bitflags::Flag<registers::debug::Dr7Flags>; 12];
    let mut _2: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _3: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _4: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _5: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _6: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _7: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _8: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _9: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _10: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _11: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _12: bitflags::Flag<registers::debug::Dr7Flags>;
    let mut _13: bitflags::Flag<registers::debug::Dr7Flags>;

    bb0: {
        _2 = Flag::<Dr7Flags>::new(const "LOCAL_BREAKPOINT_0_ENABLE", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<Dr7Flags>::new(const "LOCAL_BREAKPOINT_1_ENABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<Dr7Flags>::new(const "LOCAL_BREAKPOINT_2_ENABLE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<Dr7Flags>::new(const "LOCAL_BREAKPOINT_3_ENABLE", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<Dr7Flags>::new(const "GLOBAL_BREAKPOINT_0_ENABLE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<Dr7Flags>::new(const "GLOBAL_BREAKPOINT_1_ENABLE", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<Dr7Flags>::new(const "GLOBAL_BREAKPOINT_2_ENABLE", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<Dr7Flags>::new(const "GLOBAL_BREAKPOINT_3_ENABLE", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<Dr7Flags>::new(const "LOCAL_EXACT_BREAKPOINT_ENABLE", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<Dr7Flags>::new(const "GLOBAL_EXACT_BREAKPOINT_ENABLE", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<Dr7Flags>::new(const "RESTRICTED_TRANSACTIONAL_MEMORY", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<Dr7Flags>::new(const "GENERAL_DETECT_ENABLE", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13];
        _0 = &_1;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &Dr7Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const debug::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &debug::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &debug::_::InternalBitFlags, _2: &debug::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &debug::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = debug::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <debug::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::Dr7Flags;
    let _4: registers::debug::Dr7Flags;
    let mut _5: registers::debug::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = Dr7Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<Dr7Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<debug::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::debug::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::debug::Dr7Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<Dr7Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<Dr7Flags, ParseError>::map::<debug::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: Dr7Flags) -> debug::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::debug::_::InternalBitFlags);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &debug::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(const _);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::debug::Dr7Flags;
    let mut _5: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _6: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::debug::Dr7Flags;
    let mut _14: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _15: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::debug::Dr7Flags;
    let mut _23: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _24: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::debug::Dr7Flags;
    let mut _32: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _33: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::debug::Dr7Flags;
    let mut _41: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _42: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::debug::Dr7Flags;
    let mut _50: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _51: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::debug::Dr7Flags;
    let mut _59: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _60: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::debug::Dr7Flags;
    let mut _68: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _69: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::debug::Dr7Flags;
    let mut _77: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _78: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &registers::debug::Dr7Flags;
    let mut _86: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _87: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &registers::debug::Dr7Flags;
    let mut _95: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _96: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let _103: &registers::debug::Dr7Flags;
    let mut _104: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _105: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let mut _111: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            let _102: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<Dr7Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::<impl Dr7Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<Dr7Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = debug::_::<impl Dr7Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<Dr7Flags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = debug::_::<impl Dr7Flags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<Dr7Flags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = debug::_::<impl Dr7Flags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<Dr7Flags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = debug::_::<impl Dr7Flags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<Dr7Flags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = debug::_::<impl Dr7Flags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<Dr7Flags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = debug::_::<impl Dr7Flags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<Dr7Flags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = debug::_::<impl Dr7Flags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<Dr7Flags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = debug::_::<impl Dr7Flags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<Dr7Flags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = debug::_::<impl Dr7Flags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<Dr7Flags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = debug::_::<impl Dr7Flags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<Dr7Flags>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = debug::_::<impl Dr7Flags>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _111 = _1;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _111) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::debug::Dr7Flags;
    let _6: &registers::debug::Dr7Flags;
    let mut _7: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _8: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::debug::Dr7Flags;
    let _18: &registers::debug::Dr7Flags;
    let mut _19: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _20: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::debug::Dr7Flags;
    let _30: &registers::debug::Dr7Flags;
    let mut _31: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _32: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::debug::Dr7Flags;
    let _42: &registers::debug::Dr7Flags;
    let mut _43: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _44: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::debug::Dr7Flags;
    let _54: &registers::debug::Dr7Flags;
    let mut _55: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _56: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::debug::Dr7Flags;
    let _66: &registers::debug::Dr7Flags;
    let mut _67: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _68: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::debug::Dr7Flags;
    let _78: &registers::debug::Dr7Flags;
    let mut _79: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _80: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::debug::Dr7Flags;
    let _90: &registers::debug::Dr7Flags;
    let mut _91: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _92: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::debug::Dr7Flags;
    let _102: &registers::debug::Dr7Flags;
    let mut _103: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _104: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::debug::Dr7Flags;
    let _114: &registers::debug::Dr7Flags;
    let mut _115: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _116: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::debug::Dr7Flags;
    let _126: &registers::debug::Dr7Flags;
    let mut _127: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _128: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &registers::debug::Dr7Flags;
    let _138: &registers::debug::Dr7Flags;
    let mut _139: &bitflags::Flag<registers::debug::Dr7Flags>;
    let _140: &[bitflags::Flag<registers::debug::Dr7Flags>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u64;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let mut _147: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            let _136: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<Dr7Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = debug::_::<impl Dr7Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<Dr7Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = debug::_::<impl Dr7Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<Dr7Flags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = debug::_::<impl Dr7Flags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<Dr7Flags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = debug::_::<impl Dr7Flags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<Dr7Flags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = debug::_::<impl Dr7Flags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<Dr7Flags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = debug::_::<impl Dr7Flags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<Dr7Flags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = debug::_::<impl Dr7Flags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<Dr7Flags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = debug::_::<impl Dr7Flags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<Dr7Flags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = debug::_::<impl Dr7Flags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<Dr7Flags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = debug::_::<impl Dr7Flags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<Dr7Flags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = debug::_::<impl Dr7Flags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<Dr7Flags>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = debug::_::<impl Dr7Flags>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        _147 = _1;
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _147) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        StorageDead(_147);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &debug::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = debug::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags(_1);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<debug::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = debug::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = debug::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    let _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = debug::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = debug::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> debug::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = debug::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<debug::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::debug::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::debug::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::debug::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::debug::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::debug::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::debug::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::debug::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::debug::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::debug::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::debug::_::InternalBitFlags;
    let mut _46: u64;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: registers::debug::_::InternalBitFlags;
    let mut _50: u64;
    scope 1 {
        debug name => _2;
        let mut _51: &registers::debug::Dr7Flags;
        let mut _52: &registers::debug::Dr7Flags;
        let mut _53: &registers::debug::Dr7Flags;
        let mut _54: &registers::debug::Dr7Flags;
        let mut _55: &registers::debug::Dr7Flags;
        let mut _56: &registers::debug::Dr7Flags;
        let mut _57: &registers::debug::Dr7Flags;
        let mut _58: &registers::debug::Dr7Flags;
        let mut _59: &registers::debug::Dr7Flags;
        let mut _60: &registers::debug::Dr7Flags;
        let mut _61: &registers::debug::Dr7Flags;
        let mut _62: &registers::debug::Dr7Flags;
        let mut _63: &&str;
        let mut _64: &&str;
        let mut _65: &&str;
        let mut _66: &&str;
        let mut _67: &&str;
        let mut _68: &&str;
        let mut _69: &&str;
        let mut _70: &&str;
        let mut _71: &&str;
        let mut _72: &&str;
        let mut _73: &&str;
        let mut _74: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _74 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _74) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _51 = const _;
        _6 = debug::_::<impl Dr7Flags>::bits(_51) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = debug::_::InternalBitFlags(move _6);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _5);
        goto -> bb49;
    }

    bb4: {
        _8 = &_2;
        _73 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _73) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _52 = const _;
        _10 = debug::_::<impl Dr7Flags>::bits(_52) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = debug::_::InternalBitFlags(move _10);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _9);
        goto -> bb49;
    }

    bb8: {
        _12 = &_2;
        _72 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _72) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _53 = const _;
        _14 = debug::_::<impl Dr7Flags>::bits(_53) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = debug::_::InternalBitFlags(move _14);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _13);
        goto -> bb49;
    }

    bb12: {
        _16 = &_2;
        _71 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _71) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _54 = const _;
        _18 = debug::_::<impl Dr7Flags>::bits(_54) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = debug::_::InternalBitFlags(move _18);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _17);
        goto -> bb49;
    }

    bb16: {
        _20 = &_2;
        _70 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _70) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _55 = const _;
        _22 = debug::_::<impl Dr7Flags>::bits(_55) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = debug::_::InternalBitFlags(move _22);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _21);
        goto -> bb49;
    }

    bb20: {
        _24 = &_2;
        _69 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _69) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _56 = const _;
        _26 = debug::_::<impl Dr7Flags>::bits(_56) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = debug::_::InternalBitFlags(move _26);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _25);
        goto -> bb49;
    }

    bb24: {
        _28 = &_2;
        _68 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _68) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _57 = const _;
        _30 = debug::_::<impl Dr7Flags>::bits(_57) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = debug::_::InternalBitFlags(move _30);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _29);
        goto -> bb49;
    }

    bb28: {
        _32 = &_2;
        _67 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _67) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _58 = const _;
        _34 = debug::_::<impl Dr7Flags>::bits(_58) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = debug::_::InternalBitFlags(move _34);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _33);
        goto -> bb49;
    }

    bb32: {
        _36 = &_2;
        _66 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _66) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _59 = const _;
        _38 = debug::_::<impl Dr7Flags>::bits(_59) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = debug::_::InternalBitFlags(move _38);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _37);
        goto -> bb49;
    }

    bb36: {
        _40 = &_2;
        _65 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _65) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _60 = const _;
        _42 = debug::_::<impl Dr7Flags>::bits(_60) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = debug::_::InternalBitFlags(move _42);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _41);
        goto -> bb49;
    }

    bb40: {
        _44 = &_2;
        _64 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _64) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _61 = const _;
        _46 = debug::_::<impl Dr7Flags>::bits(_61) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = debug::_::InternalBitFlags(move _46);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _45);
        goto -> bb49;
    }

    bb44: {
        _48 = &_2;
        _63 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _63) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _62 = const _;
        _50 = debug::_::<impl Dr7Flags>::bits(_62) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = debug::_::InternalBitFlags(move _50);
        _0 = Option::<debug::_::InternalBitFlags>::Some(move _49);
        goto -> bb49;
    }

    bb48: {
        _0 = Option::<debug::_::InternalBitFlags>::None;
        goto -> bb49;
    }

    bb49: {
        return;
    }
}

promoted[0] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &Dr7Flags = {
    let mut _0: &registers::debug::Dr7Flags;
    let mut _1: registers::debug::Dr7Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GENERAL_DETECT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[13] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "RESTRICTED_TRANSACTIONAL_MEMORY";
        _0 = &_1;
        return;
    }
}

promoted[14] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL_EXACT_BREAKPOINT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[15] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LOCAL_EXACT_BREAKPOINT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[16] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL_BREAKPOINT_3_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[17] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL_BREAKPOINT_2_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[18] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL_BREAKPOINT_1_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[19] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL_BREAKPOINT_0_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[20] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LOCAL_BREAKPOINT_3_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[21] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LOCAL_BREAKPOINT_2_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[22] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LOCAL_BREAKPOINT_1_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[23] in debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LOCAL_BREAKPOINT_0_ENABLE";
        _0 = &_1;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let _5: registers::debug::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = debug::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let _6: registers::debug::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::debug::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = debug::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = debug::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = debug::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _3: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = debug::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = debug::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let _2: registers::debug::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = debug::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &debug::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::debug::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut debug::_::InternalBitFlags, _2: debug::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: debug::_::InternalBitFlags) -> debug::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut debug::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = debug::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> debug::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::debug::_::InternalBitFlags;
    let mut _2: registers::debug::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::debug::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <debug::_::InternalBitFlags as Extend<debug::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::_::InternalBitFlags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl Dr7Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<Dr7Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &debug::_::InternalBitFlags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl Dr7Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<Dr7Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::_::InternalBitFlags) -> IterNames<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl Dr7Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<Dr7Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &debug::_::InternalBitFlags) -> IterNames<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl Dr7Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<Dr7Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: debug::_::InternalBitFlags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: &registers::debug::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = debug::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut debug::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        _1 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = debug::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        _1 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;
    let mut _1: registers::debug::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = debug::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &Dr7Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &Dr7Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::debug::Dr7Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<Dr7Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Flags>;
    let mut _2: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::debug::Dr7Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<Dr7Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = Dr7Flags(_4);
        _0 = Option::<Dr7Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<Dr7Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::debug::Dr7Flags;
    let mut _8: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<Dr7Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = Dr7Flags(move _8);
        StorageDead(_8);
        _0 = Option::<Dr7Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let _2: u64;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Dr7Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let _2: u64;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Dr7Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<Dr7Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Flags>;
    let mut _2: core::option::Option<registers::debug::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::debug::Dr7Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::debug::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = debug::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<Dr7Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::debug::_::InternalBitFlags);
        _5 = Dr7Flags(_4);
        _0 = Option::<Dr7Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::Dr7Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &Dr7Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::debug::Dr7Flags;
    let mut _3: &registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::Dr7Flags;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::debug::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &Dr7Flags, _2: Dr7Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::debug::Dr7Flags;
    let mut _5: &registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::debug::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = debug::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut Dr7Flags, _2: Dr7Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _0 = debug::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let _3: registers::debug::Dr7Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = Dr7Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let _3: registers::debug::Dr7Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = Dr7Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let _3: registers::debug::Dr7Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = Dr7Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    let mut _5: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::debug::_::InternalBitFlags);
        _5 = (_2.0: registers::debug::_::InternalBitFlags);
        _3 = debug::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;
    let _3: registers::debug::Dr7Flags;
    let mut _5: registers::debug::_::InternalBitFlags;
    let mut _6: registers::debug::_::InternalBitFlags;
    let mut _7: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::debug::Dr7Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::debug::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = debug::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = Dr7Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::_::InternalBitFlags;
    let mut _3: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::debug::_::InternalBitFlags);
        _2 = debug::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Dr7Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let _2: registers::debug::Dr7Flags;
    let mut _3: registers::debug::_::InternalBitFlags;
    let mut _4: registers::debug::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::debug::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = debug::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Dr7Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &Dr7Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::debug::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::debug::_::InternalBitFlags);
        _0 = <debug::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl Dr7Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl Dr7Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::debug::Dr7Flags;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;
    let mut _6: &registers::debug::Dr7Flags;

    bb0: {
        _6 = &(*_1);
        _5 = debug::_::<impl Dr7Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = debug::_::<impl Dr7Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = debug::_::<impl Dr7Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: Dr7Flags, _2: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut Dr7Flags, _2: Dr7Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = debug::_::<impl Dr7Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: Dr7Flags) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut Dr7Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::debug::Dr7Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::debug::Dr7Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::debug::Dr7Flags);
        _5 = debug::_::<impl Dr7Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> Dr7Flags {
    debug iterator => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: registers::debug::Dr7Flags;
    let _3: ();
    let mut _4: &mut registers::debug::Dr7Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = debug::_::<impl Dr7Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <Dr7Flags as Extend<Dr7Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &Dr7Flags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::<impl Dr7Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::<impl Dr7Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl Dr7Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<Dr7Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &Dr7Flags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;
    let mut _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::<impl Dr7Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::<impl Dr7Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl Dr7Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<Dr7Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &Dr7Flags) -> IterNames<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: registers::debug::Dr7Flags;
    let mut _5: u64;

    bb0: {
        _3 = debug::_::<impl Dr7Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = debug::_::<impl Dr7Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = debug::_::<impl Dr7Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<Dr7Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &Dr7Flags) -> IterNames<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::debug::Dr7Flags>;
    let mut _2: registers::debug::Dr7Flags;
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;
    let mut _5: registers::debug::Dr7Flags;
    let mut _6: u64;
    let mut _7: &registers::debug::Dr7Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = debug::_::<impl Dr7Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = debug::_::<impl Dr7Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = debug::_::<impl Dr7Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = debug::_::<impl Dr7Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<Dr7Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn debug::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: Dr7Flags) -> bitflags::iter::Iter<Dr7Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::debug::Dr7Flags>;
    let mut _2: &registers::debug::Dr7Flags;

    bb0: {
        _2 = &_1;
        _0 = debug::_::<impl Dr7Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:222:1: 222:14>::local_breakpoint_enable(_1: DebugAddressRegisterNumber) -> Dr7Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        _0 = const _;
        goto -> bb5;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:222:1: 222:14>::global_breakpoint_enable(_1: DebugAddressRegisterNumber) -> Dr7Flags {
    debug n => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        _0 = const _;
        goto -> bb5;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:222:1: 222:14>::from_bits_unchecked(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:222:1: 222:14>::from_bits_unchecked(_1: u64) -> Dr7Flags {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

BreakpointCondition::InstructionExecution::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

BreakpointCondition::DataWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

BreakpointCondition::IoReadsWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

BreakpointCondition::DataReadsWrites::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:251:10: 251:15>::clone(_1: &BreakpointCondition) -> BreakpointCondition {
    debug self => _1;
    let mut _0: registers::debug::BreakpointCondition;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:251:23: 251:28>::fmt(_1: &BreakpointCondition, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb7];
    }

    bb1: {
        _8 = const "DataReadsWrites";
        _3 = _8;
        goto -> bb5;
    }

    bb2: {
        _5 = const "InstructionExecution";
        _3 = _5;
        goto -> bb5;
    }

    bb3: {
        _6 = const "DataWrites";
        _3 = _6;
        goto -> bb5;
    }

    bb4: {
        _7 = const "IoReadsWrites";
        _3 = _7;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:251:30: 251:39>::eq(_1: &BreakpointCondition, _2: &BreakpointCondition) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:251:41: 251:43>::assert_receiver_is_total_eq(_1: &BreakpointCondition) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:267:1: 267:25>::from_bits(_1: u64) -> Option<BreakpointCondition> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointCondition>;
    let mut _2: registers::debug::BreakpointCondition;
    let mut _3: registers::debug::BreakpointCondition;
    let mut _4: registers::debug::BreakpointCondition;
    let mut _5: registers::debug::BreakpointCondition;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointCondition>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointCondition::InstructionExecution;
        _0 = Option::<BreakpointCondition>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointCondition::DataWrites;
        _0 = Option::<BreakpointCondition>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointCondition::IoReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointCondition::DataReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:267:1: 267:25>::from_bits(_1: u64) -> Option<BreakpointCondition> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointCondition>;
    let mut _2: registers::debug::BreakpointCondition;
    let mut _3: registers::debug::BreakpointCondition;
    let mut _4: registers::debug::BreakpointCondition;
    let mut _5: registers::debug::BreakpointCondition;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointCondition>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointCondition::InstructionExecution;
        _0 = Option::<BreakpointCondition>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointCondition::DataWrites;
        _0 = Option::<BreakpointCondition>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointCondition::IoReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointCondition::DataReadsWrites;
        _0 = Option::<BreakpointCondition>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:267:1: 267:25>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: (u8, bool);
    let mut _7: (u8, bool);
    let mut _8: usize;
    let mut _9: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        _5 = DebugAddressRegisterNumber::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(const 4_u8, _5);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_6.0: u8);
        _7 = CheckedAdd(const 16_u8, _4);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", const 16_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_7.0: u8);
        _2 = move _3 as usize (IntToInt);
        _9 = CheckedAdd(_2, const 2_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: usize);
        _0 = Range::<usize> { start: _2, end: move _8 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:267:1: 267:25>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: registers::debug::DebugAddressRegisterNumber;
    let mut _7: (u8, bool);
    let mut _8: (u8, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        ConstEvalCounter;
        _5 = DebugAddressRegisterNumber::get(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        _7 = CheckedMul(const 4_u8, _5);
        assert(!move (_7.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_7.0: u8);
        StorageDead(_5);
        _8 = CheckedAdd(const 16_u8, _4);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", const 16_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_8.0: u8);
        StorageDead(_4);
        _2 = move _3 as usize (IntToInt);
        StorageDead(_3);
        StorageLive(_9);
        _9 = _2;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _2;
        _12 = CheckedAdd(_11, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = move (_12.0: usize);
        StorageDead(_11);
        _0 = Range::<usize> { start: move _9, end: move _10 };
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_2);
        return;
    }
}

BreakpointSize::Length1B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

BreakpointSize::Length2B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

BreakpointSize::Length8B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

BreakpointSize::Length4B::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:286:10: 286:15>::clone(_1: &BreakpointSize) -> BreakpointSize {
    debug self => _1;
    let mut _0: registers::debug::BreakpointSize;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:286:23: 286:28>::fmt(_1: &BreakpointSize, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb7];
    }

    bb1: {
        _8 = const "Length4B";
        _3 = _8;
        goto -> bb5;
    }

    bb2: {
        _5 = const "Length1B";
        _3 = _5;
        goto -> bb5;
    }

    bb3: {
        _6 = const "Length2B";
        _3 = _6;
        goto -> bb5;
    }

    bb4: {
        _7 = const "Length8B";
        _3 = _7;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:286:30: 286:39>::eq(_1: &BreakpointSize, _2: &BreakpointSize) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:286:41: 286:43>::assert_receiver_is_total_eq(_1: &BreakpointSize) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::new(_1: usize) -> Option<BreakpointSize> {
    debug size => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [1: bb2, 2: bb3, 8: bb4, 4: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::new(_1: usize) -> Option<BreakpointSize> {
    debug size => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [1: bb2, 2: bb3, 8: bb4, 4: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::from_bits(_1: u64) -> Option<BreakpointSize> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        goto -> bb6;
    }

    bb3: {
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        goto -> bb6;
    }

    bb4: {
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::from_bits(_1: u64) -> Option<BreakpointSize> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::BreakpointSize>;
    let mut _2: registers::debug::BreakpointSize;
    let mut _3: registers::debug::BreakpointSize;
    let mut _4: registers::debug::BreakpointSize;
    let mut _5: registers::debug::BreakpointSize;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<BreakpointSize>::None;
        goto -> bb6;
    }

    bb2: {
        StorageLive(_2);
        _2 = BreakpointSize::Length1B;
        _0 = Option::<BreakpointSize>::Some(move _2);
        StorageDead(_2);
        goto -> bb6;
    }

    bb3: {
        StorageLive(_3);
        _3 = BreakpointSize::Length2B;
        _0 = Option::<BreakpointSize>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = BreakpointSize::Length8B;
        _0 = Option::<BreakpointSize>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = BreakpointSize::Length4B;
        _0 = Option::<BreakpointSize>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: (u8, bool);
    let mut _7: (u8, bool);
    let mut _8: usize;
    let mut _9: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        _5 = DebugAddressRegisterNumber::get(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(const 4_u8, _5);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_6.0: u8);
        _7 = CheckedAdd(const 18_u8, _4);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", const 18_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_7.0: u8);
        _2 = move _3 as usize (IntToInt);
        _9 = CheckedAdd(_2, const 2_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: usize);
        _0 = Range::<usize> { start: _2, end: move _8 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:302:1: 302:20>::bit_range(_1: DebugAddressRegisterNumber) -> Range<usize> {
    debug n => _1;
    let mut _0: core::ops::Range<usize>;
    let _2: usize;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: registers::debug::DebugAddressRegisterNumber;
    let mut _7: (u8, bool);
    let mut _8: (u8, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lsb => _2;
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        ConstEvalCounter;
        _5 = DebugAddressRegisterNumber::get(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        _7 = CheckedMul(const 4_u8, _5);
        assert(!move (_7.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_u8, move _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move (_7.0: u8);
        StorageDead(_5);
        _8 = CheckedAdd(const 18_u8, _4);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", const 18_u8, move _4) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_8.0: u8);
        StorageDead(_4);
        _2 = move _3 as usize (IntToInt);
        StorageDead(_3);
        StorageLive(_9);
        _9 = _2;
        StorageLive(_10);
        StorageLive(_11);
        _11 = _2;
        _12 = CheckedAdd(_11, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, const 2_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = move (_12.0: usize);
        StorageDead(_11);
        _0 = Range::<usize> { start: move _9, end: move _10 };
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:334:10: 334:15>::clone(_1: &debug::Dr7Value) -> debug::Dr7Value {
    debug self => _1;
    let mut _0: registers::debug::Dr7Value;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:334:23: 334:28>::fmt(_1: &debug::Dr7Value, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&u64;
    let _7: &u64;

    bb0: {
        _3 = const "Dr7Value";
        _4 = const "bits";
        _7 = &((*_1).0: u64);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:334:30: 334:39>::eq(_1: &debug::Dr7Value, _2: &debug::Dr7Value) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:334:41: 334:43>::assert_receiver_is_total_eq(_1: &debug::Dr7Value) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:340:1: 340:33>::from(_1: Dr7Flags) -> debug::Dr7Value {
    debug dr7_flags => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: &registers::debug::Dr7Flags;

    bb0: {
        _3 = &_1;
        _2 = debug::_::<impl Dr7Flags>::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr7Value::from_bits_truncate(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::valid_bits() -> u64 {
    let mut _0: u64;
    let _1: u64;
    let mut _2: u64;
    let mut _3: u32;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: (u64, bool);
    let mut _10: &registers::debug::Dr7Flags;
    let _11: registers::debug::Dr7Flags;
    scope 1 {
        debug field_valid_bits => _1;
        let _9: u64;
        scope 2 {
            debug flag_valid_bits => _9;
        }
    }

    bb0: {
        _3 = const 32_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 64_u32);
        assert(move _4, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shl(const 1_u64, const 32_i32);
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const 1_u64, const 16_i32);
        _8 = CheckedSub(_2, _5);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2, move _5) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move (_8.0: u64);
        _11 = debug::_::<impl Dr7Flags>::all() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = &_11;
        _9 = debug::_::<impl Dr7Flags>::bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = BitOr(_1, _9);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::valid_bits() -> u64 {
    let mut _0: u64;
    let _1: u64;
    let mut _2: u64;
    let mut _3: u32;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: (u64, bool);
    let mut _10: &registers::debug::Dr7Flags;
    let _11: registers::debug::Dr7Flags;
    let mut _12: u64;
    let mut _13: u64;
    scope 1 {
        debug field_valid_bits => _1;
        let _9: u64;
        scope 2 {
            debug flag_valid_bits => _9;
        }
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _3 = const 32_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 64_u32);
        assert(move _4, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shl(const 1_u64, const 32_i32);
        StorageLive(_5);
        _6 = const 16_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const 1_u64, const 16_i32);
        _8 = CheckedSub(_2, _5);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2, move _5) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move (_8.0: u64);
        StorageDead(_5);
        StorageDead(_2);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        ConstEvalCounter;
        _11 = debug::_::<impl Dr7Flags>::all() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = &_11;
        ConstEvalCounter;
        _9 = debug::_::<impl Dr7Flags>::bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_10);
        StorageDead(_11);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _9;
        _0 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_9);
        StorageDead(_1);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits(_1: u64) -> Option<debug::Dr7Value> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Value>;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: registers::debug::Dr7Value;

    bb0: {
        _4 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _2 = BitAnd(_1, move _3);
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = debug::Dr7Value { bits: _1 };
        _0 = Option::<debug::Dr7Value>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<debug::Dr7Value>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits(_1: u64) -> Option<debug::Dr7Value> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::debug::Dr7Value>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: registers::debug::Dr7Value;
    let mut _8: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(move _6);
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _2 = Eq(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _1;
        _7 = debug::Dr7Value { bits: move _8 };
        StorageDead(_8);
        _0 = Option::<debug::Dr7Value>::Some(move _7);
        StorageDead(_7);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_3);
        _0 = Option::<debug::Dr7Value>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits_truncate(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(_1, move _3);
        _0 = debug::Dr7Value { bits: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits_truncate(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        ConstEvalCounter;
        _4 = debug::Dr7Value::valid_bits() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = debug::Dr7Value { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits_unchecked(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;

    bb0: {
        _0 = debug::Dr7Value { bits: _1 };
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::from_bits_unchecked(_1: u64) -> debug::Dr7Value {
    debug bits => _1;
    let mut _0: registers::debug::Dr7Value;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = debug::Dr7Value { bits: move _2 };
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::bits(_1: &debug::Dr7Value) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::bits(_1: &debug::Dr7Value) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::flags(_1: debug::Dr7Value) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        _2 = (_1.0: u64);
        _0 = debug::_::<impl Dr7Flags>::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::flags(_1: debug::Dr7Value) -> Dr7Flags {
    debug self => _1;
    let mut _0: registers::debug::Dr7Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: u64);
        ConstEvalCounter;
        _0 = debug::_::<impl Dr7Flags>::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::insert_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;

    bb0: {
        _4 = &_2;
        _3 = debug::_::<impl Dr7Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u64) = BitOr(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::remove_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::debug::Dr7Flags;

    bb0: {
        _5 = &_2;
        _4 = debug::_::<impl Dr7Flags>::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        ((*_1).0: u64) = BitAnd(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::toggle_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: &registers::debug::Dr7Flags;

    bb0: {
        _4 = &_2;
        _3 = debug::_::<impl Dr7Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u64) = BitXor(((*_1).0: u64), move _3);
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::set_flags(_1: &mut debug::Dr7Value, _2: Dr7Flags, _3: bool) -> () {
    debug self => _1;
    debug flags => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = debug::Dr7Value::insert_flags(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = debug::Dr7Value::remove_flags(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::condition(_1: &debug::Dr7Value, _2: DebugAddressRegisterNumber) -> BreakpointCondition {
    debug self => _1;
    debug n => _2;
    let mut _0: registers::debug::BreakpointCondition;
    let _3: u64;
    let mut _4: &u64;
    let mut _5: core::ops::Range<usize>;
    let mut _6: core::option::Option<registers::debug::BreakpointCondition>;
    let _7: &str;
    scope 1 {
        debug condition => _3;
    }

    bb0: {
        _4 = &((*_1).0: u64);
        _5 = BreakpointCondition::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u64 as BitField>::get_bits::<Range<usize>>(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = BreakpointCondition::from_bits(_3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = const "condition should be always valid";
        _0 = Option::<BreakpointCondition>::expect(move _6, _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::set_condition(_1: &mut debug::Dr7Value, _2: DebugAddressRegisterNumber, _3: BreakpointCondition) -> () {
    debug self => _1;
    debug n => _2;
    debug condition => _3;
    let mut _0: ();
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = &mut ((*_1).0: u64);
        _6 = BreakpointCondition::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = discriminant(_3);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u64 (IntToInt);
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::size(_1: &debug::Dr7Value, _2: DebugAddressRegisterNumber) -> BreakpointSize {
    debug self => _1;
    debug n => _2;
    let mut _0: registers::debug::BreakpointSize;
    let _3: u64;
    let mut _4: &u64;
    let mut _5: core::ops::Range<usize>;
    let mut _6: core::option::Option<registers::debug::BreakpointSize>;
    let _7: &str;
    scope 1 {
        debug size => _3;
    }

    bb0: {
        _4 = &((*_1).0: u64);
        _5 = BreakpointSize::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u64 as BitField>::get_bits::<Range<usize>>(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = BreakpointSize::from_bits(_3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = const "condition should be always valid";
        _0 = Option::<BreakpointSize>::expect(move _6, _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:346:1: 346:14>::set_size(_1: &mut debug::Dr7Value, _2: DebugAddressRegisterNumber, _3: BreakpointSize) -> () {
    debug self => _1;
    debug n => _2;
    debug size => _3;
    let mut _0: ();
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = &mut ((*_1).0: u64);
        _6 = BreakpointSize::bit_range(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = discriminant(_3);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u64 (IntToInt);
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:449:10: 449:15>::fmt(_1: &debug::Dr7, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Dr7";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:456:5: 456:13>::read() -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;
    let mut _1: u64;

    bb0: {
        _1 = debug::x86_64::<impl debug::Dr6>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::_::<impl debug::Dr6Flags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:456:5: 456:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr6", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:476:5: 476:13>::read() -> debug::Dr7Value {
    let mut _0: registers::debug::Dr7Value;
    let mut _1: u64;

    bb0: {
        _1 = debug::x86_64::<impl debug::Dr7>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = debug::Dr7Value::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:476:5: 476:13>::read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug value => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("mov {0}, dr7", out(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:476:5: 476:13>::write(_1: debug::Dr7Value) -> () {
    debug value => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _7: u64;
    let mut _8: &registers::debug::Dr7Value;
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _6: u64;
            scope 3 {
                debug new_value => _6;
            }
        }
    }

    bb0: {
        _2 = debug::x86_64::<impl debug::Dr7>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = debug::Dr7Value::valid_bits() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _8 = &_1;
        _7 = debug::Dr7Value::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = BitOr(_3, move _7);
        _0 = debug::x86_64::<impl debug::Dr7>::write_raw(_6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn debug::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/debug.rs:476:5: 476:13>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("mov dr7, {0}", in(reg) _1, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:9:10: 9:15>::fmt(_1: &model_specific::Msr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u32;
    let _6: &u32;

    bb0: {
        _3 = const "Msr";
        _6 = &((*_1).0: u32);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:12:1: 12:9>::new(_1: u32) -> model_specific::Msr {
    debug reg => _1;
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(_1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:12:1: 12:9>::new(_1: u32) -> model_specific::Msr {
    debug reg => _1;
    let mut _0: registers::model_specific::Msr;
    let mut _2: u32;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = model_specific::Msr(move _2);
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:21:10: 21:15>::fmt(_1: &model_specific::Efer, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Efer";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:25:10: 25:15>::fmt(_1: &model_specific::FsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "FsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:34:10: 34:15>::fmt(_1: &model_specific::GsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "GsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:43:10: 43:15>::fmt(_1: &model_specific::KernelGsBase, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "KernelGsBase";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:47:10: 47:15>::fmt(_1: &model_specific::Star, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Star";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:51:10: 51:15>::fmt(_1: &model_specific::LStar, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "LStar";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:55:10: 55:15>::fmt(_1: &model_specific::SFMask, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SFMask";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:59:10: 59:15>::fmt(_1: &model_specific::UCet, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "UCet";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:63:10: 63:15>::fmt(_1: &model_specific::SCet, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SCet";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:66:1: 66:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225600_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:71:1: 71:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225728_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:76:1: 76:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225729_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:81:1: 81:18>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225730_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:86:1: 86:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225601_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:91:1: 91:11>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225602_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:96:1: 96:12>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 3221225604_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:101:1: 101:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 1696_u32);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:106:1: 106:10>::MSR: model_specific::Msr = {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(const 1698_u32);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:14: 114:23>::eq(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:25: 114:27>::assert_receiver_is_total_eq(_1: &model_specific::EferFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:29: 114:39>::partial_cmp(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:41: 114:44>::cmp(_1: &model_specific::EferFlags, _2: &model_specific::EferFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:46: 114:50>::hash(_1: &model_specific::EferFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:52: 114:57>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::model_specific::_::InternalBitFlags;
    let _6: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = const "EferFlags";
        _6 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:114:59: 114:64>::clone(_1: &model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SYSTEM_CALL_EXTENSIONS: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LONG_MODE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LONG_MODE_ACTIVE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NO_EXECUTE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SECURE_VIRTUAL_MACHINE_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LONG_MODE_SEGMENT_LIMIT_ENABLE: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::FAST_FXSAVE_FXRSTOR: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRANSLATION_CACHE_EXTENSION: model_specific::EferFlags = {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<model_specific::EferFlags>] = {
    let mut _0: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let mut _1: &[bitflags::Flag<registers::model_specific::EferFlags>; 8];
    let _2: &[bitflags::Flag<registers::model_specific::EferFlags>; 8];
    let _3: [bitflags::Flag<registers::model_specific::EferFlags>; 8];
    let mut _4: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _5: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _6: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _7: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _8: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _9: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _10: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _11: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _12: &[bitflags::Flag<registers::model_specific::EferFlags>; 8];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _12 = const _;
        _2 = &(*_12);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::model_specific::EferFlags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<model_specific::EferFlags>; 8] = {
    let mut _0: &[bitflags::Flag<registers::model_specific::EferFlags>; 8];
    let mut _1: [bitflags::Flag<registers::model_specific::EferFlags>; 8];
    let mut _2: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _3: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _4: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _5: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _6: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _7: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _8: bitflags::Flag<registers::model_specific::EferFlags>;
    let mut _9: bitflags::Flag<registers::model_specific::EferFlags>;

    bb0: {
        _2 = Flag::<model_specific::EferFlags>::new(const "SYSTEM_CALL_EXTENSIONS", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<model_specific::EferFlags>::new(const "LONG_MODE_ENABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<model_specific::EferFlags>::new(const "LONG_MODE_ACTIVE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<model_specific::EferFlags>::new(const "NO_EXECUTE_ENABLE", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<model_specific::EferFlags>::new(const "SECURE_VIRTUAL_MACHINE_ENABLE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<model_specific::EferFlags>::new(const "LONG_MODE_SEGMENT_LIMIT_ENABLE", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<model_specific::EferFlags>::new(const "FAST_FXSAVE_FXRSTOR", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<model_specific::EferFlags>::new(const "TRANSLATION_CACHE_EXTENSION", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9];
        _0 = &_1;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &model_specific::EferFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &model_specific::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = model_specific::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <model_specific::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::EferFlags;
    let _4: registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = model_specific::EferFlags(move _5);
        _3 = &_4;
        _0 = to_writer::<model_specific::EferFlags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<model_specific::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::model_specific::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::model_specific::EferFlags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<model_specific::EferFlags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<model_specific::EferFlags, ParseError>::map::<model_specific::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: model_specific::EferFlags) -> model_specific::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::model_specific::_::InternalBitFlags);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &model_specific::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(const _);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::model_specific::EferFlags;
    let mut _5: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _6: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::model_specific::EferFlags;
    let mut _14: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _15: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::model_specific::EferFlags;
    let mut _23: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _24: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::model_specific::EferFlags;
    let mut _32: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _33: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::model_specific::EferFlags;
    let mut _41: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _42: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::model_specific::EferFlags;
    let mut _50: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _51: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::model_specific::EferFlags;
    let mut _59: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _60: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::model_specific::EferFlags;
    let mut _68: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _69: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let mut _75: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<model_specific::EferFlags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<model_specific::EferFlags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = model_specific::_::<impl model_specific::EferFlags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<model_specific::EferFlags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = model_specific::_::<impl model_specific::EferFlags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<model_specific::EferFlags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = model_specific::_::<impl model_specific::EferFlags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<model_specific::EferFlags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = model_specific::_::<impl model_specific::EferFlags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<model_specific::EferFlags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = model_specific::_::<impl model_specific::EferFlags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<model_specific::EferFlags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = model_specific::_::<impl model_specific::EferFlags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<model_specific::EferFlags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = model_specific::_::<impl model_specific::EferFlags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _75 = _1;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _75) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::model_specific::EferFlags;
    let _6: &registers::model_specific::EferFlags;
    let mut _7: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _8: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::model_specific::EferFlags;
    let _18: &registers::model_specific::EferFlags;
    let mut _19: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _20: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::model_specific::EferFlags;
    let _30: &registers::model_specific::EferFlags;
    let mut _31: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _32: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::model_specific::EferFlags;
    let _42: &registers::model_specific::EferFlags;
    let mut _43: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _44: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::model_specific::EferFlags;
    let _54: &registers::model_specific::EferFlags;
    let mut _55: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _56: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::model_specific::EferFlags;
    let _66: &registers::model_specific::EferFlags;
    let mut _67: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _68: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::model_specific::EferFlags;
    let _78: &registers::model_specific::EferFlags;
    let mut _79: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _80: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::model_specific::EferFlags;
    let _90: &registers::model_specific::EferFlags;
    let mut _91: &bitflags::Flag<registers::model_specific::EferFlags>;
    let _92: &[bitflags::Flag<registers::model_specific::EferFlags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let mut _99: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<model_specific::EferFlags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = model_specific::_::<impl model_specific::EferFlags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<model_specific::EferFlags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = model_specific::_::<impl model_specific::EferFlags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<model_specific::EferFlags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = model_specific::_::<impl model_specific::EferFlags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<model_specific::EferFlags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = model_specific::_::<impl model_specific::EferFlags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<model_specific::EferFlags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = model_specific::_::<impl model_specific::EferFlags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<model_specific::EferFlags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = model_specific::_::<impl model_specific::EferFlags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<model_specific::EferFlags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = model_specific::_::<impl model_specific::EferFlags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<model_specific::EferFlags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = model_specific::_::<impl model_specific::EferFlags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        _99 = _1;
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _99) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        StorageDead(_99);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = model_specific::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags(_1);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = model_specific::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = model_specific::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    let _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = model_specific::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = model_specific::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<model_specific::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::model_specific::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::model_specific::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::model_specific::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::model_specific::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::model_specific::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::model_specific::_::InternalBitFlags;
    let mut _34: u64;
    scope 1 {
        debug name => _2;
        let mut _35: &registers::model_specific::EferFlags;
        let mut _36: &registers::model_specific::EferFlags;
        let mut _37: &registers::model_specific::EferFlags;
        let mut _38: &registers::model_specific::EferFlags;
        let mut _39: &registers::model_specific::EferFlags;
        let mut _40: &registers::model_specific::EferFlags;
        let mut _41: &registers::model_specific::EferFlags;
        let mut _42: &registers::model_specific::EferFlags;
        let mut _43: &&str;
        let mut _44: &&str;
        let mut _45: &&str;
        let mut _46: &&str;
        let mut _47: &&str;
        let mut _48: &&str;
        let mut _49: &&str;
        let mut _50: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _50 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _50) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _35 = const _;
        _6 = model_specific::_::<impl model_specific::EferFlags>::bits(_35) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = model_specific::_::InternalBitFlags(move _6);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _5);
        goto -> bb33;
    }

    bb4: {
        _8 = &_2;
        _49 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _49) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _36 = const _;
        _10 = model_specific::_::<impl model_specific::EferFlags>::bits(_36) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = model_specific::_::InternalBitFlags(move _10);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _9);
        goto -> bb33;
    }

    bb8: {
        _12 = &_2;
        _48 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _48) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _37 = const _;
        _14 = model_specific::_::<impl model_specific::EferFlags>::bits(_37) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = model_specific::_::InternalBitFlags(move _14);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _13);
        goto -> bb33;
    }

    bb12: {
        _16 = &_2;
        _47 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _47) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _38 = const _;
        _18 = model_specific::_::<impl model_specific::EferFlags>::bits(_38) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = model_specific::_::InternalBitFlags(move _18);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _17);
        goto -> bb33;
    }

    bb16: {
        _20 = &_2;
        _46 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _46) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _39 = const _;
        _22 = model_specific::_::<impl model_specific::EferFlags>::bits(_39) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = model_specific::_::InternalBitFlags(move _22);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _21);
        goto -> bb33;
    }

    bb20: {
        _24 = &_2;
        _45 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _45) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _40 = const _;
        _26 = model_specific::_::<impl model_specific::EferFlags>::bits(_40) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = model_specific::_::InternalBitFlags(move _26);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _25);
        goto -> bb33;
    }

    bb24: {
        _28 = &_2;
        _44 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _44) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _41 = const _;
        _30 = model_specific::_::<impl model_specific::EferFlags>::bits(_41) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = model_specific::_::InternalBitFlags(move _30);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _29);
        goto -> bb33;
    }

    bb28: {
        _32 = &_2;
        _43 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _42 = const _;
        _34 = model_specific::_::<impl model_specific::EferFlags>::bits(_42) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = model_specific::_::InternalBitFlags(move _34);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _33);
        goto -> bb33;
    }

    bb32: {
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

promoted[0] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::EferFlags = {
    let mut _0: &registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::EferFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRANSLATION_CACHE_EXTENSION";
        _0 = &_1;
        return;
    }
}

promoted[9] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "FAST_FXSAVE_FXRSTOR";
        _0 = &_1;
        return;
    }
}

promoted[10] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LONG_MODE_SEGMENT_LIMIT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[11] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SECURE_VIRTUAL_MACHINE_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[12] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NO_EXECUTE_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[13] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LONG_MODE_ACTIVE";
        _0 = &_1;
        return;
    }
}

promoted[14] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LONG_MODE_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[15] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SYSTEM_CALL_EXTENSIONS";
        _0 = &_1;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::model_specific::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = model_specific::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = model_specific::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = model_specific::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut model_specific::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> model_specific::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::_::InternalBitFlags as Extend<model_specific::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::_::InternalBitFlags) -> IterNames<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::_::InternalBitFlags) -> IterNames<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = model_specific::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut model_specific::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _1 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _1 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::EferFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::EferFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::model_specific::EferFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::EferFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::EferFlags>;
    let mut _2: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::model_specific::EferFlags;
    scope 1 {
        debug bits => _1;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<model_specific::EferFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::EferFlags(_4);
        _0 = Option::<model_specific::EferFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::EferFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::EferFlags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::model_specific::EferFlags;
    let mut _8: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<model_specific::EferFlags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = model_specific::EferFlags(move _8);
        StorageDead(_8);
        _0 = Option::<model_specific::EferFlags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let _2: u64;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::EferFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let _2: u64;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::EferFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<model_specific::EferFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::model_specific::EferFlags>;
    let mut _2: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::model_specific::EferFlags;
    scope 1 {
        debug name => _1;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<model_specific::EferFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::EferFlags(_4);
        _0 = Option::<model_specific::EferFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::EferFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::EferFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::EferFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::EferFlags;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::EferFlags, _2: model_specific::EferFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::EferFlags;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let _3: registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::EferFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let _3: registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::EferFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let _3: registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::EferFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;
    let _3: registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::EferFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::EferFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _2 = model_specific::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::EferFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;
    let _2: registers::model_specific::EferFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::EferFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &model_specific::EferFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::EferFlags;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::EferFlags;

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::<impl model_specific::EferFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: model_specific::EferFlags, _2: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut model_specific::EferFlags, _2: model_specific::EferFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: model_specific::EferFlags) -> model_specific::EferFlags {
    debug self => _1;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut model_specific::EferFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::EferFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::EferFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::EferFlags);
        _5 = model_specific::_::<impl model_specific::EferFlags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> model_specific::EferFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: registers::model_specific::EferFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::EferFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::_::<impl model_specific::EferFlags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::EferFlags as Extend<model_specific::EferFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::EferFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::<impl model_specific::EferFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::EferFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::<impl model_specific::EferFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::<impl model_specific::EferFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::EferFlags) -> IterNames<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::EferFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::<impl model_specific::EferFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::<impl model_specific::EferFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::EferFlags) -> IterNames<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::EferFlags>;
    let mut _2: registers::model_specific::EferFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::EferFlags;
    let mut _5: registers::model_specific::EferFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::EferFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::<impl model_specific::EferFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::<impl model_specific::EferFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<model_specific::EferFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: model_specific::EferFlags) -> bitflags::iter::Iter<model_specific::EferFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::EferFlags>;
    let mut _2: &registers::model_specific::EferFlags;

    bb0: {
        _2 = &_1;
        _0 = model_specific::_::<impl model_specific::EferFlags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:135:1: 135:15>::from_bits_unchecked(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:135:1: 135:15>::from_bits_unchecked(_1: u64) -> model_specific::EferFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::EferFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:14: 147:23>::eq(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:25: 147:27>::assert_receiver_is_total_eq(_1: &model_specific::CetFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:29: 147:39>::partial_cmp(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:41: 147:44>::cmp(_1: &model_specific::CetFlags, _2: &model_specific::CetFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let _4: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:46: 147:50>::hash(_1: &model_specific::CetFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:52: 147:57>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::model_specific::_::InternalBitFlags;
    let _6: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = const "CetFlags";
        _6 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:147:59: 147:64>::clone(_1: &model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 0_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 0_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 0_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SS_WRITE_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_LEGACY_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_NO_TRACK_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_LEGACY_SUPPRESS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_SUPPRESS_ENABLE: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IBT_TRACKED: model_specific::CetFlags = {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<model_specific::CetFlags>] = {
    let mut _0: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let mut _1: &[bitflags::Flag<registers::model_specific::CetFlags>; 8];
    let _2: &[bitflags::Flag<registers::model_specific::CetFlags>; 8];
    let _3: [bitflags::Flag<registers::model_specific::CetFlags>; 8];
    let mut _4: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _5: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _6: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _7: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _8: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _9: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _10: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _11: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _12: &[bitflags::Flag<registers::model_specific::CetFlags>; 8];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _12 = const _;
        _2 = &(*_12);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::model_specific::CetFlags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<model_specific::CetFlags>; 8] = {
    let mut _0: &[bitflags::Flag<registers::model_specific::CetFlags>; 8];
    let mut _1: [bitflags::Flag<registers::model_specific::CetFlags>; 8];
    let mut _2: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _3: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _4: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _5: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _6: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _7: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _8: bitflags::Flag<registers::model_specific::CetFlags>;
    let mut _9: bitflags::Flag<registers::model_specific::CetFlags>;

    bb0: {
        _2 = Flag::<model_specific::CetFlags>::new(const "SS_ENABLE", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<model_specific::CetFlags>::new(const "SS_WRITE_ENABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<model_specific::CetFlags>::new(const "IBT_ENABLE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<model_specific::CetFlags>::new(const "IBT_LEGACY_ENABLE", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<model_specific::CetFlags>::new(const "IBT_NO_TRACK_ENABLE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<model_specific::CetFlags>::new(const "IBT_LEGACY_SUPPRESS_ENABLE", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<model_specific::CetFlags>::new(const "IBT_SUPPRESS_ENABLE", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<model_specific::CetFlags>::new(const "IBT_TRACKED", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9];
        _0 = &_1;
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &model_specific::CetFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const model_specific::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &model_specific::_::InternalBitFlags, _2: &model_specific::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &model_specific::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = model_specific::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <model_specific::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::CetFlags;
    let _4: registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = model_specific::CetFlags(move _5);
        _3 = &_4;
        _0 = to_writer::<model_specific::CetFlags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<model_specific::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::model_specific::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::model_specific::CetFlags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<model_specific::CetFlags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<model_specific::CetFlags, ParseError>::map::<model_specific::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: model_specific::CetFlags) -> model_specific::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::model_specific::_::InternalBitFlags);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &model_specific::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(const _);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::model_specific::CetFlags;
    let mut _5: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _6: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::model_specific::CetFlags;
    let mut _14: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _15: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::model_specific::CetFlags;
    let mut _23: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _24: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::model_specific::CetFlags;
    let mut _32: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _33: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::model_specific::CetFlags;
    let mut _41: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _42: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::model_specific::CetFlags;
    let mut _50: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _51: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::model_specific::CetFlags;
    let mut _59: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _60: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::model_specific::CetFlags;
    let mut _68: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _69: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let mut _75: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<model_specific::CetFlags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<model_specific::CetFlags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = model_specific::_::<impl model_specific::CetFlags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<model_specific::CetFlags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = model_specific::_::<impl model_specific::CetFlags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<model_specific::CetFlags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = model_specific::_::<impl model_specific::CetFlags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<model_specific::CetFlags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = model_specific::_::<impl model_specific::CetFlags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<model_specific::CetFlags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = model_specific::_::<impl model_specific::CetFlags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<model_specific::CetFlags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = model_specific::_::<impl model_specific::CetFlags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<model_specific::CetFlags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = model_specific::_::<impl model_specific::CetFlags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _75 = _1;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _75) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::model_specific::CetFlags;
    let _6: &registers::model_specific::CetFlags;
    let mut _7: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _8: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::model_specific::CetFlags;
    let _18: &registers::model_specific::CetFlags;
    let mut _19: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _20: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::model_specific::CetFlags;
    let _30: &registers::model_specific::CetFlags;
    let mut _31: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _32: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::model_specific::CetFlags;
    let _42: &registers::model_specific::CetFlags;
    let mut _43: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _44: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::model_specific::CetFlags;
    let _54: &registers::model_specific::CetFlags;
    let mut _55: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _56: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::model_specific::CetFlags;
    let _66: &registers::model_specific::CetFlags;
    let mut _67: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _68: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::model_specific::CetFlags;
    let _78: &registers::model_specific::CetFlags;
    let mut _79: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _80: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::model_specific::CetFlags;
    let _90: &registers::model_specific::CetFlags;
    let mut _91: &bitflags::Flag<registers::model_specific::CetFlags>;
    let _92: &[bitflags::Flag<registers::model_specific::CetFlags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let mut _99: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<model_specific::CetFlags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = model_specific::_::<impl model_specific::CetFlags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<model_specific::CetFlags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = model_specific::_::<impl model_specific::CetFlags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<model_specific::CetFlags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = model_specific::_::<impl model_specific::CetFlags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<model_specific::CetFlags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = model_specific::_::<impl model_specific::CetFlags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<model_specific::CetFlags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = model_specific::_::<impl model_specific::CetFlags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<model_specific::CetFlags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = model_specific::_::<impl model_specific::CetFlags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<model_specific::CetFlags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = model_specific::_::<impl model_specific::CetFlags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<model_specific::CetFlags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = model_specific::_::<impl model_specific::CetFlags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        _99 = _1;
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _99) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        StorageDead(_99);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = model_specific::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags(_1);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = model_specific::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = model_specific::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    let _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = model_specific::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = model_specific::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = model_specific::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<model_specific::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::model_specific::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::model_specific::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::model_specific::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::model_specific::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::model_specific::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::model_specific::_::InternalBitFlags;
    let mut _34: u64;
    scope 1 {
        debug name => _2;
        let mut _35: &registers::model_specific::CetFlags;
        let mut _36: &registers::model_specific::CetFlags;
        let mut _37: &registers::model_specific::CetFlags;
        let mut _38: &registers::model_specific::CetFlags;
        let mut _39: &registers::model_specific::CetFlags;
        let mut _40: &registers::model_specific::CetFlags;
        let mut _41: &registers::model_specific::CetFlags;
        let mut _42: &registers::model_specific::CetFlags;
        let mut _43: &&str;
        let mut _44: &&str;
        let mut _45: &&str;
        let mut _46: &&str;
        let mut _47: &&str;
        let mut _48: &&str;
        let mut _49: &&str;
        let mut _50: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _50 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _50) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _35 = const _;
        _6 = model_specific::_::<impl model_specific::CetFlags>::bits(_35) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = model_specific::_::InternalBitFlags(move _6);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _5);
        goto -> bb33;
    }

    bb4: {
        _8 = &_2;
        _49 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _49) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _36 = const _;
        _10 = model_specific::_::<impl model_specific::CetFlags>::bits(_36) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = model_specific::_::InternalBitFlags(move _10);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _9);
        goto -> bb33;
    }

    bb8: {
        _12 = &_2;
        _48 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _48) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _37 = const _;
        _14 = model_specific::_::<impl model_specific::CetFlags>::bits(_37) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = model_specific::_::InternalBitFlags(move _14);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _13);
        goto -> bb33;
    }

    bb12: {
        _16 = &_2;
        _47 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _47) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _38 = const _;
        _18 = model_specific::_::<impl model_specific::CetFlags>::bits(_38) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = model_specific::_::InternalBitFlags(move _18);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _17);
        goto -> bb33;
    }

    bb16: {
        _20 = &_2;
        _46 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _46) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _39 = const _;
        _22 = model_specific::_::<impl model_specific::CetFlags>::bits(_39) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = model_specific::_::InternalBitFlags(move _22);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _21);
        goto -> bb33;
    }

    bb20: {
        _24 = &_2;
        _45 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _45) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _40 = const _;
        _26 = model_specific::_::<impl model_specific::CetFlags>::bits(_40) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = model_specific::_::InternalBitFlags(move _26);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _25);
        goto -> bb33;
    }

    bb24: {
        _28 = &_2;
        _44 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _44) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _41 = const _;
        _30 = model_specific::_::<impl model_specific::CetFlags>::bits(_41) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = model_specific::_::InternalBitFlags(move _30);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _29);
        goto -> bb33;
    }

    bb28: {
        _32 = &_2;
        _43 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _42 = const _;
        _34 = model_specific::_::<impl model_specific::CetFlags>::bits(_42) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = model_specific::_::InternalBitFlags(move _34);
        _0 = Option::<model_specific::_::InternalBitFlags>::Some(move _33);
        goto -> bb33;
    }

    bb32: {
        _0 = Option::<model_specific::_::InternalBitFlags>::None;
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

promoted[0] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &model_specific::CetFlags = {
    let mut _0: &registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::CetFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_TRACKED";
        _0 = &_1;
        return;
    }
}

promoted[9] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_SUPPRESS_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[10] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_LEGACY_SUPPRESS_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[11] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_NO_TRACK_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[12] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_LEGACY_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[13] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IBT_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[14] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SS_WRITE_ENABLE";
        _0 = &_1;
        return;
    }
}

promoted[15] in model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SS_ENABLE";
        _0 = &_1;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::model_specific::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = model_specific::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = model_specific::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = model_specific::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _3: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = model_specific::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = model_specific::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = model_specific::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &model_specific::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut model_specific::_::InternalBitFlags, _2: model_specific::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: model_specific::_::InternalBitFlags) -> model_specific::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut model_specific::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> model_specific::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::_::InternalBitFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::_::InternalBitFlags as Extend<model_specific::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::_::InternalBitFlags) -> IterNames<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::_::InternalBitFlags) -> IterNames<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: model_specific::_::InternalBitFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = model_specific::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut model_specific::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _1 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = model_specific::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _1 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;
    let mut _1: registers::model_specific::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = model_specific::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::CetFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &model_specific::CetFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::model_specific::CetFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::CetFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::CetFlags>;
    let mut _2: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::model_specific::CetFlags;
    scope 1 {
        debug bits => _1;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<model_specific::CetFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::CetFlags(_4);
        _0 = Option::<model_specific::CetFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<model_specific::CetFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::model_specific::CetFlags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::model_specific::CetFlags;
    let mut _8: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<model_specific::CetFlags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = model_specific::CetFlags(move _8);
        StorageDead(_8);
        _0 = Option::<model_specific::CetFlags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let _2: u64;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::CetFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let _2: u64;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::CetFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<model_specific::CetFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::model_specific::CetFlags>;
    let mut _2: core::option::Option<registers::model_specific::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::model_specific::CetFlags;
    scope 1 {
        debug name => _1;
        let _4: registers::model_specific::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = model_specific::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<model_specific::CetFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::model_specific::_::InternalBitFlags);
        _5 = model_specific::CetFlags(_4);
        _0 = Option::<model_specific::CetFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::CetFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &model_specific::CetFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::model_specific::CetFlags;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::CetFlags;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &model_specific::CetFlags, _2: model_specific::CetFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::model_specific::CetFlags;
    let mut _5: &registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = model_specific::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _0 = model_specific::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let _3: registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::CetFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let _3: registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::CetFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let _3: registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::CetFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _5 = (_2.0: registers::model_specific::_::InternalBitFlags);
        _3 = model_specific::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;
    let _3: registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::_::InternalBitFlags;
    let mut _6: registers::model_specific::_::InternalBitFlags;
    let mut _7: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::model_specific::CetFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::model_specific::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = model_specific::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = model_specific::CetFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::_::InternalBitFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::model_specific::_::InternalBitFlags);
        _2 = model_specific::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::CetFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;
    let _2: registers::model_specific::CetFlags;
    let mut _3: registers::model_specific::_::InternalBitFlags;
    let mut _4: registers::model_specific::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::model_specific::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = model_specific::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = model_specific::CetFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &model_specific::CetFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::model_specific::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::model_specific::_::InternalBitFlags);
        _0 = <model_specific::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::model_specific::CetFlags;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;
    let mut _6: &registers::model_specific::CetFlags;

    bb0: {
        _6 = &(*_1);
        _5 = model_specific::_::<impl model_specific::CetFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: model_specific::CetFlags, _2: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut model_specific::CetFlags, _2: model_specific::CetFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: model_specific::CetFlags) -> model_specific::CetFlags {
    debug self => _1;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut model_specific::CetFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::model_specific::CetFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::model_specific::CetFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::model_specific::CetFlags);
        _5 = model_specific::_::<impl model_specific::CetFlags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> model_specific::CetFlags {
    debug iterator => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: registers::model_specific::CetFlags;
    let _3: ();
    let mut _4: &mut registers::model_specific::CetFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <model_specific::CetFlags as Extend<model_specific::CetFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::CetFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::<impl model_specific::CetFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &model_specific::CetFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::<impl model_specific::CetFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::<impl model_specific::CetFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::CetFlags) -> IterNames<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: registers::model_specific::CetFlags;
    let mut _5: u64;

    bb0: {
        _3 = model_specific::_::<impl model_specific::CetFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = model_specific::_::<impl model_specific::CetFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &model_specific::CetFlags) -> IterNames<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::model_specific::CetFlags>;
    let mut _2: registers::model_specific::CetFlags;
    let mut _3: u64;
    let mut _4: &registers::model_specific::CetFlags;
    let mut _5: registers::model_specific::CetFlags;
    let mut _6: u64;
    let mut _7: &registers::model_specific::CetFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = model_specific::_::<impl model_specific::CetFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = model_specific::_::<impl model_specific::CetFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<model_specific::CetFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn model_specific::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: model_specific::CetFlags) -> bitflags::iter::Iter<model_specific::CetFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::model_specific::CetFlags>;
    let mut _2: &registers::model_specific::CetFlags;

    bb0: {
        _2 = &_1;
        _0 = model_specific::_::<impl model_specific::CetFlags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:168:1: 168:14>::from_bits_unchecked(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn model_specific::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:168:1: 168:14>::from_bits_unchecked(_1: u64) -> model_specific::CetFlags {
    debug bits => _1;
    let mut _0: registers::model_specific::CetFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = model_specific::_::<impl model_specific::CetFlags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:195:5: 195:13>::read(_1: &model_specific::Msr) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: u32;
    let _3: u32;
    let mut _4: u32;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: u32;
    scope 1 {
        debug high => _2;
        debug low => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = ((*_1).0: u32);
        asm!("rdmsr", in("cx") move _4, out("ax") _3, out("dx") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _2;
        _6 = move _7 as u64 (IntToInt);
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(move _6, const 32_i32);
        _11 = _3;
        _10 = move _11 as u64 (IntToInt);
        _0 = BitOr(move _5, move _10);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:195:5: 195:13>::write(_1: &mut model_specific::Msr, _2: u64) -> () {
    debug self => _1;
    debug value => _2;
    let mut _0: ();
    let _3: u32;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u32;
    scope 1 {
        debug low => _3;
        let _4: u32;
        scope 2 {
            debug high => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = _2 as u32 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(_2, const 32_i32);
        _4 = move _5 as u32 (IntToInt);
        _8 = ((*_1).0: u32);
        asm!("wrmsr", in("cx") move _8, in("ax") _3, in("dx") _4, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::read() -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;
    let mut _1: u64;

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::Efer>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = model_specific::_::<impl model_specific::EferFlags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::write(_1: model_specific::EferFlags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::EferFlags;
    let _7: registers::model_specific::EferFlags;
    let mut _9: u64;
    let mut _10: &registers::model_specific::EferFlags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = model_specific::x86_64::<impl model_specific::Efer>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = model_specific::_::<impl model_specific::EferFlags>::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = model_specific::_::<impl model_specific::EferFlags>::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = model_specific::_::<impl model_specific::EferFlags>::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = model_specific::x86_64::<impl model_specific::Efer>::write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::write_raw(_1: u64) -> () {
    debug flags => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:238:5: 238:14>::update(_1: F) -> () {
    debug f => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::EferFlags;
    let _3: ();
    let mut _4: (&mut registers::model_specific::EferFlags,);
    let mut _5: &mut registers::model_specific::EferFlags;
    let _6: ();
    let mut _7: registers::model_specific::EferFlags;
    scope 1 {
        debug flags => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = model_specific::x86_64::<impl model_specific::Efer>::read() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _2;
        _4 = (_5,);
        _3 = <F as FnOnce<(&mut model_specific::EferFlags,)>>::call_once(move _1, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _2;
        _6 = model_specific::x86_64::<impl model_specific::Efer>::write(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:307:5: 307:16>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:307:5: 307:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:307:5: 307:16>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:328:5: 328:16>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:328:5: 328:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:328:5: 328:16>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:349:5: 349:22>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:349:5: 349:22>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:349:5: 349:22>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::read_raw() -> (u16, u16) {
    let mut _0: (u16, u16);
    let _1: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _6: &u64;
    let mut _7: core::ops::Range<usize>;
    let mut _8: u16;
    let mut _9: core::result::Result<u16, core::num::TryFromIntError>;
    let mut _10: u16;
    let mut _11: core::result::Result<u16, core::num::TryFromIntError>;
    scope 1 {
        debug msr_value => _1;
        let _2: u64;
        scope 3 {
            debug sysret => _2;
            let _5: u64;
            scope 4 {
                debug syscall => _5;
            }
        }
    }
    scope 2 {
        let mut _12: &registers::model_specific::Msr;
    }

    bb0: {
        _12 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_12) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_1;
        _4 = Range::<usize> { start: const 48_usize, end: const 64_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_1;
        _7 = Range::<usize> { start: const 32_usize, end: const 48_usize };
        _5 = <u64 as BitField>::get_bits::<Range<usize>>(move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = <u64 as TryInto<u16>>::try_into(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Result::<u16, TryFromIntError>::unwrap(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = <u64 as TryInto<u16>>::try_into(_5) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = Result::<u16, TryFromIntError>::unwrap(move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = (move _8, move _10);
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::read() -> (SegmentSelector, SegmentSelector, SegmentSelector, SegmentSelector) {
    let mut _0: (registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector, registers::segmentation::SegmentSelector);
    let _1: (u16, u16);
    let mut _2: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: (u16, bool);
    let mut _6: registers::segmentation::SegmentSelector;
    let mut _7: u16;
    let mut _8: u16;
    let mut _9: (u16, bool);
    let mut _10: registers::segmentation::SegmentSelector;
    let mut _11: u16;
    let mut _12: registers::segmentation::SegmentSelector;
    let mut _13: u16;
    let mut _14: u16;
    let mut _15: (u16, bool);
    scope 1 {
        debug raw => _1;
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::Star>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_1.0: u16);
        _5 = CheckedAdd(_4, const 16_u16);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 16_u16) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_5.0: u16);
        _2 = SegmentSelector(move _3);
        _8 = (_1.0: u16);
        _9 = CheckedAdd(_8, const 8_u16);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 8_u16) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = move (_9.0: u16);
        _6 = SegmentSelector(move _7);
        _11 = (_1.1: u16);
        _10 = SegmentSelector(move _11);
        _14 = (_1.1: u16);
        _15 = CheckedAdd(_14, const 8_u16);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", move _14, const 8_u16) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = move (_15.0: u16);
        _12 = SegmentSelector(move _13);
        _0 = (move _2, move _6, move _10, move _12);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::write_raw(_1: u16, _2: u16) -> () {
    debug sysret => _1;
    debug syscall => _2;
    let mut _0: ();
    let mut _3: u64;
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let _8: &mut u64;
    let mut _9: &mut u64;
    let mut _10: core::ops::Range<usize>;
    let mut _11: u64;
    let _13: ();
    let mut _14: &mut registers::model_specific::Msr;
    let mut _15: u64;
    scope 1 {
        debug msr_value => _3;
        let mut _12: registers::model_specific::Msr;
        scope 2 {
            debug msr => _12;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = const 0_u64;
        _5 = &mut _3;
        _6 = Range::<usize> { start: const 48_usize, end: const 64_usize };
        _7 = <u16 as Into<u64>>::into(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &mut _3;
        _10 = Range::<usize> { start: const 32_usize, end: const 48_usize };
        _11 = <u16 as Into<u64>>::into(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <u64 as BitField>::set_bits::<Range<usize>>(move _9, move _10, move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = const _;
        _14 = &mut _12;
        _15 = _3;
        _13 = model_specific::x86_64::<impl model_specific::Msr>::write(move _14, move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::write(_1: SegmentSelector, _2: SegmentSelector, _3: SegmentSelector, _4: SegmentSelector) -> Result<(), &str> {
    debug cs_sysret => _1;
    debug ss_sysret => _2;
    debug cs_syscall => _3;
    debug ss_syscall => _4;
    let mut _0: core::result::Result<(), &str>;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, u16>;
    let mut _6: core::result::Result<u16, &str>;
    let mut _7: core::option::Option<u16>;
    let mut _8: u16;
    let mut _9: isize;
    let _10: core::result::Result<core::convert::Infallible, &str>;
    let _11: u16;
    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, u16>;
    let mut _13: core::result::Result<u16, &str>;
    let mut _14: core::option::Option<u16>;
    let mut _15: u16;
    let mut _16: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, u16>;
    let mut _21: core::result::Result<u16, &str>;
    let mut _22: core::option::Option<u16>;
    let mut _23: u16;
    let mut _24: isize;
    let mut _27: bool;
    let _28: &str;
    let mut _29: bool;
    let _30: &str;
    let mut _31: bool;
    let mut _32: &PrivilegeLevel;
    let _33: PrivilegeLevel;
    let _34: &str;
    let mut _35: bool;
    let mut _36: &PrivilegeLevel;
    let _37: PrivilegeLevel;
    let _38: &str;
    let _39: ();
    let mut _40: u16;
    let mut _41: u16;
    let mut _42: (u16, bool);
    let mut _43: u16;
    scope 1 {
        debug cs_sysret_cmp => _11;
        let _17: core::result::Result<core::convert::Infallible, &str>;
        let _18: u16;
        scope 6 {
            debug ss_sysret_cmp => _18;
            let _19: u16;
            scope 11 {
                debug cs_syscall_cmp => _19;
                let _25: core::result::Result<core::convert::Infallible, &str>;
                let _26: u16;
                scope 12 {
                    debug ss_syscall_cmp => _26;
                    let mut _44: &PrivilegeLevel;
                    let mut _45: &PrivilegeLevel;
                    scope 17 {
                    }
                }
                scope 13 {
                    debug residual => _25;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _26;
                    scope 16 {
                    }
                }
            }
        }
        scope 7 {
            debug residual => _17;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _18;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _8 = (_1.0: u16);
        _7 = core::num::<impl u16>::checked_sub(move _8, const 16_u16) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Option::<u16>::ok_or::<&str>(move _7, const "Sysret CS is not at least 16.") -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = <Result<u16, &str> as Try>::branch(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = discriminant(_5);
        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb31];
    }

    bb4: {
        _11 = ((_5 as Continue).0: u16);
        _15 = (_2.0: u16);
        _14 = core::num::<impl u16>::checked_sub(move _15, const 8_u16) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _10 = ((_5 as Break).0: core::result::Result<core::convert::Infallible, &str>);
        _0 = <Result<(), &str> as FromResidual<Result<Infallible, &str>>>::from_residual(_10) -> [return: bb30, unwind unreachable];
    }

    bb6: {
        _13 = Option::<u16>::ok_or::<&str>(move _14, const "Sysret SS is not at least 8.") -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = <Result<u16, &str> as Try>::branch(move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = discriminant(_12);
        switchInt(move _16) -> [0: bb9, 1: bb10, otherwise: bb31];
    }

    bb9: {
        _18 = ((_12 as Continue).0: u16);
        _19 = (_3.0: u16);
        _23 = (_4.0: u16);
        _22 = core::num::<impl u16>::checked_sub(move _23, const 8_u16) -> [return: bb11, unwind unreachable];
    }

    bb10: {
        _17 = ((_12 as Break).0: core::result::Result<core::convert::Infallible, &str>);
        _0 = <Result<(), &str> as FromResidual<Result<Infallible, &str>>>::from_residual(_17) -> [return: bb30, unwind unreachable];
    }

    bb11: {
        _21 = Option::<u16>::ok_or::<&str>(move _22, const "Syscall SS is not at least 8.") -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _20 = <Result<u16, &str> as Try>::branch(move _21) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _24 = discriminant(_20);
        switchInt(move _24) -> [0: bb14, 1: bb15, otherwise: bb31];
    }

    bb14: {
        _26 = ((_20 as Continue).0: u16);
        _27 = Ne(_11, _18);
        switchInt(move _27) -> [0: bb17, otherwise: bb16];
    }

    bb15: {
        _25 = ((_20 as Break).0: core::result::Result<core::convert::Infallible, &str>);
        _0 = <Result<(), &str> as FromResidual<Result<Infallible, &str>>>::from_residual(_25) -> [return: bb30, unwind unreachable];
    }

    bb16: {
        _28 = const "Sysret CS and SS is not offset by 8.";
        _0 = Result::<(), &str>::Err(_28);
        goto -> bb30;
    }

    bb17: {
        _29 = Ne(_19, _26);
        switchInt(move _29) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _30 = const "Syscall CS and SS is not offset by 8.";
        _0 = Result::<(), &str>::Err(_30);
        goto -> bb30;
    }

    bb19: {
        _33 = SegmentSelector::rpl(_2) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _32 = &_33;
        _45 = const _;
        _31 = <PrivilegeLevel as PartialEq>::ne(move _32, _45) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _31) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _34 = const "Sysret's segment must be a Ring3 segment.";
        _0 = Result::<(), &str>::Err(_34);
        goto -> bb30;
    }

    bb23: {
        _37 = SegmentSelector::rpl(_4) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _36 = &_37;
        _44 = const _;
        _35 = <PrivilegeLevel as PartialEq>::ne(move _36, _44) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _35) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _38 = const "Syscall's segment must be a Ring0 segment.";
        _0 = Result::<(), &str>::Err(_38);
        goto -> bb30;
    }

    bb27: {
        _41 = (_2.0: u16);
        _42 = CheckedSub(_41, const 8_u16);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", move _41, const 8_u16) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _40 = move (_42.0: u16);
        _43 = (_3.0: u16);
        _39 = model_specific::x86_64::<impl model_specific::Star>::write_raw(move _40, move _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _0 = Result::<(), &str>::Ok(const ());
        goto -> bb30;
    }

    bb30: {
        return;
    }

    bb31: {
        unreachable;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::write: &PrivilegeLevel = {
    let mut _0: &PrivilegeLevel;
    let mut _1: PrivilegeLevel;

    bb0: {
        _1 = PrivilegeLevel::Ring0;
        _0 = &_1;
        return;
    }
}

promoted[1] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:364:5: 364:14>::write: &PrivilegeLevel = {
    let mut _0: &PrivilegeLevel;
    let mut _1: PrivilegeLevel;

    bb0: {
        _1 = PrivilegeLevel::Ring3;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:482:5: 482:15>::read() -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;
    let mut _1: u64;
    scope 1 {
        let mut _2: &registers::model_specific::Msr;
    }

    bb0: {
        _2 = const _;
        _1 = model_specific::x86_64::<impl model_specific::Msr>::read(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:482:5: 482:15>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:482:5: 482:15>::write(_1: addr::VirtAddr) -> () {
    debug address => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _5 = addr::VirtAddr::as_u64(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:499:5: 499:16>::read() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: core::option::Option<registers::rflags::RFlags>;
    let mut _2: u64;
    scope 1 {
        let mut _3: &registers::model_specific::Msr;
    }

    bb0: {
        _3 = const _;
        _2 = model_specific::x86_64::<impl model_specific::Msr>::read(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = rflags::_::<impl rflags::RFlags>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Option::<rflags::RFlags>::unwrap(move _1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:499:5: 499:16>::read: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:499:5: 499:16>::write(_1: rflags::RFlags) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    let mut _5: u64;
    let mut _6: &registers::rflags::RFlags;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _6 = &_1;
        _5 = rflags::_::<impl rflags::RFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:526:5: 526:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:526:5: 526:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:526:5: 526:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:526:5: 526:14>::read() -> (model_specific::CetFlags, Page) {
    let mut _0: (registers::model_specific::CetFlags, structures::paging::page::Page);
    let _1: u64;
    let mut _4: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    scope 1 {
        debug value => _1;
        let _2: registers::model_specific::CetFlags;
        scope 2 {
            debug cet_flags => _2;
            let _3: structures::paging::page::Page;
            scope 3 {
                debug legacy_bitmap => _3;
            }
        }
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::UCet>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_truncate(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = move (_9.0: u64);
        _7 = Not(move _8);
        _6 = BitAnd(_1, move _7);
        _5 = addr::VirtAddr::new(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Page::from_start_address(move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Result::<Page, AddressNotAligned>::unwrap(move _4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = (_2, _3);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:526:5: 526:14>::write(_1: model_specific::CetFlags, _2: Page) -> () {
    debug flags => _1;
    debug legacy_bitmap => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::CetFlags;
    let mut _7: u64;
    let mut _8: addr::VirtAddr;

    bb0: {
        _6 = &_1;
        _5 = model_specific::_::<impl model_specific::CetFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Page::start_address(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = addr::VirtAddr::as_u64(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = BitOr(move _5, move _7);
        _3 = model_specific::x86_64::<impl model_specific::UCet>::write_raw(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:561:5: 561:14>::read_raw() -> u64 {
    let mut _0: u64;
    scope 1 {
        let mut _1: &registers::model_specific::Msr;
    }

    bb0: {
        _1 = const _;
        _0 = model_specific::x86_64::<impl model_specific::Msr>::read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:561:5: 561:14>::read_raw: &model_specific::Msr = {
    let mut _0: &registers::model_specific::Msr;
    let mut _1: registers::model_specific::Msr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:561:5: 561:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let mut _2: registers::model_specific::Msr;
    let _3: ();
    let mut _4: &mut registers::model_specific::Msr;
    scope 1 {
        debug msr => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const _;
        _4 = &mut _2;
        _3 = model_specific::x86_64::<impl model_specific::Msr>::write(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:561:5: 561:14>::read() -> (model_specific::CetFlags, Page) {
    let mut _0: (registers::model_specific::CetFlags, structures::paging::page::Page);
    let _1: u64;
    let mut _4: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _5: addr::VirtAddr;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: (u64, bool);
    scope 1 {
        debug value => _1;
        let _2: registers::model_specific::CetFlags;
        scope 2 {
            debug cet_flags => _2;
            let _3: structures::paging::page::Page;
            scope 3 {
                debug legacy_bitmap => _3;
            }
        }
    }

    bb0: {
        _1 = model_specific::x86_64::<impl model_specific::SCet>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = model_specific::_::<impl model_specific::CetFlags>::from_bits_truncate(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = move (_9.0: u64);
        _7 = Not(move _8);
        _6 = BitAnd(_1, move _7);
        _5 = addr::VirtAddr::new(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Page::from_start_address(move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Result::<Page, AddressNotAligned>::unwrap(move _4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = (_2, _3);
        return;
    }
}

fn model_specific::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/model_specific.rs:561:5: 561:14>::write(_1: model_specific::CetFlags, _2: Page) -> () {
    debug flags => _1;
    debug legacy_bitmap => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::model_specific::CetFlags;
    let mut _7: u64;
    let mut _8: addr::VirtAddr;

    bb0: {
        _6 = &_1;
        _5 = model_specific::_::<impl model_specific::CetFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Page::start_address(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = addr::VirtAddr::as_u64(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = BitOr(move _5, move _7);
        _3 = model_specific::x86_64::<impl model_specific::SCet>::write_raw(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:14: 11:23>::eq(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:25: 11:27>::assert_receiver_is_total_eq(_1: &mxcsr::MxCsr) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:29: 11:39>::partial_cmp(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::mxcsr::_::InternalBitFlags;
    let _4: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:41: 11:44>::cmp(_1: &mxcsr::MxCsr, _2: &mxcsr::MxCsr) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::mxcsr::_::InternalBitFlags;
    let _4: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:46: 11:50>::hash(_1: &mxcsr::MxCsr, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:52: 11:57>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::mxcsr::_::InternalBitFlags;
    let _6: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = const "MxCsr";
        _6 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:11:59: 11:64>::clone(_1: &mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::INVALID_OPERATION: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 0_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 0_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 0_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DENORMAL: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 1_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DIVIDE_BY_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 2_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OVERFLOW: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 3_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::UNDERFLOW: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 4_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PRECISION: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 5_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DENORMALS_ARE_ZEROS: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 6_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::INVALID_OPERATION_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 7_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DENORMAL_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 8_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DIVIDE_BY_ZERO_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 9_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OVERFLOW_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 10_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::UNDERFLOW_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 11_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PRECISION_MASK: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 12_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ROUNDING_CONTROL_NEGATIVE: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 13_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ROUNDING_CONTROL_POSITIVE: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 14_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ROUNDING_CONTROL_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 3_u32, const 13_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::FLUSH_TO_ZERO: mxcsr::MxCsr = {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const 15_i32);
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<mxcsr::MxCsr>] = {
    let mut _0: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let mut _1: &[bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    let _2: &[bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    let _3: [bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    let mut _4: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _5: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _6: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _7: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _8: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _9: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _10: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _11: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _12: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _13: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _14: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _15: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _16: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _17: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _18: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _19: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _20: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _21: &[bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }
    scope 16 {
    }
    scope 17 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _21 = const _;
        _2 = &(*_21);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::mxcsr::MxCsr>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<mxcsr::MxCsr>; 17] = {
    let mut _0: &[bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    let mut _1: [bitflags::Flag<registers::mxcsr::MxCsr>; 17];
    let mut _2: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _3: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _4: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _5: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _6: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _7: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _8: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _9: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _10: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _11: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _12: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _13: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _14: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _15: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _16: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _17: bitflags::Flag<registers::mxcsr::MxCsr>;
    let mut _18: bitflags::Flag<registers::mxcsr::MxCsr>;

    bb0: {
        _2 = Flag::<mxcsr::MxCsr>::new(const "INVALID_OPERATION", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<mxcsr::MxCsr>::new(const "DENORMAL", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<mxcsr::MxCsr>::new(const "DIVIDE_BY_ZERO", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<mxcsr::MxCsr>::new(const "OVERFLOW", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<mxcsr::MxCsr>::new(const "UNDERFLOW", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<mxcsr::MxCsr>::new(const "PRECISION", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<mxcsr::MxCsr>::new(const "DENORMALS_ARE_ZEROS", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<mxcsr::MxCsr>::new(const "INVALID_OPERATION_MASK", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<mxcsr::MxCsr>::new(const "DENORMAL_MASK", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<mxcsr::MxCsr>::new(const "DIVIDE_BY_ZERO_MASK", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<mxcsr::MxCsr>::new(const "OVERFLOW_MASK", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<mxcsr::MxCsr>::new(const "UNDERFLOW_MASK", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Flag::<mxcsr::MxCsr>::new(const "PRECISION_MASK", const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Flag::<mxcsr::MxCsr>::new(const "ROUNDING_CONTROL_NEGATIVE", const _) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Flag::<mxcsr::MxCsr>::new(const "ROUNDING_CONTROL_POSITIVE", const _) -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = Flag::<mxcsr::MxCsr>::new(const "ROUNDING_CONTROL_ZERO", const _) -> [return: bb16, unwind continue];
    }

    bb16: {
        _18 = Flag::<mxcsr::MxCsr>::new(const "FLUSH_TO_ZERO", const _) -> [return: bb17, unwind continue];
    }

    bb17: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16, move _17, move _18];
        _0 = &_1;
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &mxcsr::MxCsr) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const mxcsr::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &mxcsr::_::InternalBitFlags, _2: &mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _3 = ((*_1).0: u32);
        _4 = ((*_2).0: u32);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &mxcsr::_::InternalBitFlags, _2: &mxcsr::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u32;
    let _4: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _4 = &((*_2).0: u32);
        _0 = <u32 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &mxcsr::_::InternalBitFlags, _2: &mxcsr::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u32;
    let _4: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _4 = &((*_2).0: u32);
        _0 = <u32 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &mxcsr::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u32;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u32>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <mxcsr::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u32 = {
    let mut _0: &u32;
    let mut _1: u32;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::mxcsr::MxCsr;
    let _4: registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = mxcsr::MxCsr(move _5);
        _3 = &_4;
        _0 = to_writer::<mxcsr::MxCsr, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<mxcsr::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::mxcsr::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::mxcsr::MxCsr, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<mxcsr::MxCsr>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<mxcsr::MxCsr, ParseError>::map::<mxcsr::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: mxcsr::MxCsr) -> mxcsr::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &mxcsr::_::InternalBitFlags) -> &u32 {
    debug self => _1;
    let mut _0: &u32;

    bb0: {
        _0 = &((*_1).0: u32);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u32) -> mxcsr::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags(const _);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let mut _1: u32;
    let _4: &registers::mxcsr::MxCsr;
    let mut _5: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _6: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: (usize, bool);
    let _13: &registers::mxcsr::MxCsr;
    let mut _14: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _15: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: (usize, bool);
    let _22: &registers::mxcsr::MxCsr;
    let mut _23: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _24: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: (usize, bool);
    let _31: &registers::mxcsr::MxCsr;
    let mut _32: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _33: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u32;
    let mut _38: (usize, bool);
    let _40: &registers::mxcsr::MxCsr;
    let mut _41: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _42: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: (usize, bool);
    let _49: &registers::mxcsr::MxCsr;
    let mut _50: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _51: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u32;
    let mut _56: (usize, bool);
    let _58: &registers::mxcsr::MxCsr;
    let mut _59: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _60: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u32;
    let mut _65: (usize, bool);
    let _67: &registers::mxcsr::MxCsr;
    let mut _68: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _69: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u32;
    let mut _74: (usize, bool);
    let _76: &registers::mxcsr::MxCsr;
    let mut _77: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _78: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u32;
    let mut _83: (usize, bool);
    let _85: &registers::mxcsr::MxCsr;
    let mut _86: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _87: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u32;
    let mut _92: (usize, bool);
    let _94: &registers::mxcsr::MxCsr;
    let mut _95: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _96: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u32;
    let mut _101: (usize, bool);
    let _103: &registers::mxcsr::MxCsr;
    let mut _104: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _105: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u32;
    let mut _110: (usize, bool);
    let _112: &registers::mxcsr::MxCsr;
    let mut _113: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _114: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: u32;
    let mut _119: (usize, bool);
    let _121: &registers::mxcsr::MxCsr;
    let mut _122: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _123: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _124: usize;
    let mut _125: usize;
    let mut _126: bool;
    let mut _127: u32;
    let mut _128: (usize, bool);
    let _130: &registers::mxcsr::MxCsr;
    let mut _131: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _132: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _133: usize;
    let mut _134: usize;
    let mut _135: bool;
    let mut _136: u32;
    let mut _137: (usize, bool);
    let _139: &registers::mxcsr::MxCsr;
    let mut _140: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _141: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _142: usize;
    let mut _143: usize;
    let mut _144: bool;
    let mut _145: u32;
    let mut _146: (usize, bool);
    let _148: &registers::mxcsr::MxCsr;
    let mut _149: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _150: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _151: usize;
    let mut _152: usize;
    let mut _153: bool;
    let mut _154: u32;
    let mut _155: (usize, bool);
    let mut _156: u32;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u32;
            let _12: u32;
            let _21: u32;
            let _30: u32;
            let _39: u32;
            let _48: u32;
            let _57: u32;
            let _66: u32;
            let _75: u32;
            let _84: u32;
            let _93: u32;
            let _102: u32;
            let _111: u32;
            let _120: u32;
            let _129: u32;
            let _138: u32;
            let _147: u32;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
                debug flag => _111;
            }
            scope 16 {
                debug flag => _120;
            }
            scope 17 {
                debug flag => _129;
            }
            scope 18 {
                debug flag => _138;
            }
            scope 19 {
                debug flag => _147;
            }
            scope 20 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<mxcsr::MxCsr>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<mxcsr::MxCsr>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<mxcsr::MxCsr>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<mxcsr::MxCsr>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<mxcsr::MxCsr>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<mxcsr::MxCsr>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<mxcsr::MxCsr>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<mxcsr::MxCsr>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<mxcsr::MxCsr>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<mxcsr::MxCsr>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<mxcsr::MxCsr>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<mxcsr::MxCsr>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _114 = const _;
        _115 = _2;
        _116 = Len((*_114));
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _113 = &(*_114)[_115];
        _112 = Flag::<mxcsr::MxCsr>::value(move _113) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _111 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _118 = _1;
        _1 = BitOr(move _118, _111);
        _119 = CheckedAdd(_2, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_119.0: usize);
        _123 = const _;
        _124 = _2;
        _125 = Len((*_123));
        _126 = Lt(_124, _125);
        assert(move _126, "index out of bounds: the length is {} but the index is {}", move _125, _124) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _122 = &(*_123)[_124];
        _121 = Flag::<mxcsr::MxCsr>::value(move _122) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _120 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_121) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = _1;
        _1 = BitOr(move _127, _120);
        _128 = CheckedAdd(_2, const 1_usize);
        assert(!move (_128.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_128.0: usize);
        _132 = const _;
        _133 = _2;
        _134 = Len((*_132));
        _135 = Lt(_133, _134);
        assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _133) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _131 = &(*_132)[_133];
        _130 = Flag::<mxcsr::MxCsr>::value(move _131) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _129 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_130) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _136 = _1;
        _1 = BitOr(move _136, _129);
        _137 = CheckedAdd(_2, const 1_usize);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_137.0: usize);
        _141 = const _;
        _142 = _2;
        _143 = Len((*_141));
        _144 = Lt(_142, _143);
        assert(move _144, "index out of bounds: the length is {} but the index is {}", move _143, _142) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _140 = &(*_141)[_142];
        _139 = Flag::<mxcsr::MxCsr>::value(move _140) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _138 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_139) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _145 = _1;
        _1 = BitOr(move _145, _138);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_146.0: usize);
        _150 = const _;
        _151 = _2;
        _152 = Len((*_150));
        _153 = Lt(_151, _152);
        assert(move _153, "index out of bounds: the length is {} but the index is {}", move _152, _151) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _149 = &(*_150)[_151];
        _148 = Flag::<mxcsr::MxCsr>::value(move _149) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _147 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_148) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _154 = _1;
        _1 = BitOr(move _154, _147);
        _155 = CheckedAdd(_2, const 1_usize);
        assert(!move (_155.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_155.0: usize);
        _156 = _1;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _156) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let mut _1: u32;
    let _3: ();
    let mut _5: &registers::mxcsr::MxCsr;
    let _6: &registers::mxcsr::MxCsr;
    let mut _7: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _8: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::mxcsr::MxCsr;
    let _18: &registers::mxcsr::MxCsr;
    let mut _19: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _20: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::mxcsr::MxCsr;
    let _30: &registers::mxcsr::MxCsr;
    let mut _31: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _32: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u32;
    let mut _37: u32;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::mxcsr::MxCsr;
    let _42: &registers::mxcsr::MxCsr;
    let mut _43: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _44: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u32;
    let mut _49: u32;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::mxcsr::MxCsr;
    let _54: &registers::mxcsr::MxCsr;
    let mut _55: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _56: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u32;
    let mut _61: u32;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::mxcsr::MxCsr;
    let _66: &registers::mxcsr::MxCsr;
    let mut _67: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _68: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u32;
    let mut _73: u32;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::mxcsr::MxCsr;
    let _78: &registers::mxcsr::MxCsr;
    let mut _79: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _80: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u32;
    let mut _85: u32;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::mxcsr::MxCsr;
    let _90: &registers::mxcsr::MxCsr;
    let mut _91: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _92: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u32;
    let mut _97: u32;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::mxcsr::MxCsr;
    let _102: &registers::mxcsr::MxCsr;
    let mut _103: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _104: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u32;
    let mut _109: u32;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::mxcsr::MxCsr;
    let _114: &registers::mxcsr::MxCsr;
    let mut _115: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _116: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u32;
    let mut _121: u32;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::mxcsr::MxCsr;
    let _126: &registers::mxcsr::MxCsr;
    let mut _127: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _128: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u32;
    let mut _133: u32;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &registers::mxcsr::MxCsr;
    let _138: &registers::mxcsr::MxCsr;
    let mut _139: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _140: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u32;
    let mut _145: u32;
    let mut _146: (usize, bool);
    let _147: ();
    let mut _149: &registers::mxcsr::MxCsr;
    let _150: &registers::mxcsr::MxCsr;
    let mut _151: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _152: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _156: u32;
    let mut _157: u32;
    let mut _158: (usize, bool);
    let _159: ();
    let mut _161: &registers::mxcsr::MxCsr;
    let _162: &registers::mxcsr::MxCsr;
    let mut _163: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _164: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _165: usize;
    let mut _166: usize;
    let mut _167: bool;
    let mut _168: u32;
    let mut _169: u32;
    let mut _170: (usize, bool);
    let _171: ();
    let mut _173: &registers::mxcsr::MxCsr;
    let _174: &registers::mxcsr::MxCsr;
    let mut _175: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _176: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _177: usize;
    let mut _178: usize;
    let mut _179: bool;
    let mut _180: u32;
    let mut _181: u32;
    let mut _182: (usize, bool);
    let _183: ();
    let mut _185: &registers::mxcsr::MxCsr;
    let _186: &registers::mxcsr::MxCsr;
    let mut _187: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _188: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _189: usize;
    let mut _190: usize;
    let mut _191: bool;
    let mut _192: u32;
    let mut _193: u32;
    let mut _194: (usize, bool);
    let _195: ();
    let mut _197: &registers::mxcsr::MxCsr;
    let _198: &registers::mxcsr::MxCsr;
    let mut _199: &bitflags::Flag<registers::mxcsr::MxCsr>;
    let _200: &[bitflags::Flag<registers::mxcsr::MxCsr>];
    let _201: usize;
    let mut _202: usize;
    let mut _203: bool;
    let mut _204: u32;
    let mut _205: u32;
    let mut _206: (usize, bool);
    let mut _207: u32;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u32;
            let _16: u32;
            let _28: u32;
            let _40: u32;
            let _52: u32;
            let _64: u32;
            let _76: u32;
            let _88: u32;
            let _100: u32;
            let _112: u32;
            let _124: u32;
            let _136: u32;
            let _148: u32;
            let _160: u32;
            let _172: u32;
            let _184: u32;
            let _196: u32;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
                debug flag => _148;
            }
            scope 16 {
                debug flag => _160;
            }
            scope 17 {
                debug flag => _172;
            }
            scope 18 {
                debug flag => _184;
            }
            scope 19 {
                debug flag => _196;
            }
            scope 20 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<mxcsr::MxCsr>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<mxcsr::MxCsr>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<mxcsr::MxCsr>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<mxcsr::MxCsr>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<mxcsr::MxCsr>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<mxcsr::MxCsr>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<mxcsr::MxCsr>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<mxcsr::MxCsr>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<mxcsr::MxCsr>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<mxcsr::MxCsr>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<mxcsr::MxCsr>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<mxcsr::MxCsr>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        StorageLive(_148);
        StorageLive(_149);
        StorageLive(_150);
        StorageLive(_151);
        StorageLive(_152);
        _152 = const _;
        StorageLive(_153);
        _153 = _2;
        _154 = Len((*_152));
        _155 = Lt(_153, _154);
        assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _153) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _151 = &(*_152)[_153];
        ConstEvalCounter;
        _150 = Flag::<mxcsr::MxCsr>::value(move _151) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _149 = &(*_150);
        StorageDead(_151);
        ConstEvalCounter;
        _148 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _149) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        StorageDead(_149);
        StorageDead(_153);
        StorageDead(_152);
        StorageDead(_150);
        StorageLive(_156);
        _156 = _1;
        StorageLive(_157);
        _157 = _148;
        _1 = BitOr(move _156, move _157);
        StorageDead(_157);
        StorageDead(_156);
        _158 = CheckedAdd(_2, const 1_usize);
        assert(!move (_158.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_158.0: usize);
        _147 = const ();
        StorageDead(_148);
        StorageDead(_147);
        StorageLive(_159);
        StorageLive(_160);
        StorageLive(_161);
        StorageLive(_162);
        StorageLive(_163);
        StorageLive(_164);
        _164 = const _;
        StorageLive(_165);
        _165 = _2;
        _166 = Len((*_164));
        _167 = Lt(_165, _166);
        assert(move _167, "index out of bounds: the length is {} but the index is {}", move _166, _165) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _163 = &(*_164)[_165];
        ConstEvalCounter;
        _162 = Flag::<mxcsr::MxCsr>::value(move _163) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _161 = &(*_162);
        StorageDead(_163);
        ConstEvalCounter;
        _160 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _161) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        StorageDead(_161);
        StorageDead(_165);
        StorageDead(_164);
        StorageDead(_162);
        StorageLive(_168);
        _168 = _1;
        StorageLive(_169);
        _169 = _160;
        _1 = BitOr(move _168, move _169);
        StorageDead(_169);
        StorageDead(_168);
        _170 = CheckedAdd(_2, const 1_usize);
        assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_170.0: usize);
        _159 = const ();
        StorageDead(_160);
        StorageDead(_159);
        StorageLive(_171);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        StorageLive(_175);
        StorageLive(_176);
        _176 = const _;
        StorageLive(_177);
        _177 = _2;
        _178 = Len((*_176));
        _179 = Lt(_177, _178);
        assert(move _179, "index out of bounds: the length is {} but the index is {}", move _178, _177) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _175 = &(*_176)[_177];
        ConstEvalCounter;
        _174 = Flag::<mxcsr::MxCsr>::value(move _175) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _173 = &(*_174);
        StorageDead(_175);
        ConstEvalCounter;
        _172 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _173) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        StorageDead(_173);
        StorageDead(_177);
        StorageDead(_176);
        StorageDead(_174);
        StorageLive(_180);
        _180 = _1;
        StorageLive(_181);
        _181 = _172;
        _1 = BitOr(move _180, move _181);
        StorageDead(_181);
        StorageDead(_180);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_182.0: usize);
        _171 = const ();
        StorageDead(_172);
        StorageDead(_171);
        StorageLive(_183);
        StorageLive(_184);
        StorageLive(_185);
        StorageLive(_186);
        StorageLive(_187);
        StorageLive(_188);
        _188 = const _;
        StorageLive(_189);
        _189 = _2;
        _190 = Len((*_188));
        _191 = Lt(_189, _190);
        assert(move _191, "index out of bounds: the length is {} but the index is {}", move _190, _189) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _187 = &(*_188)[_189];
        ConstEvalCounter;
        _186 = Flag::<mxcsr::MxCsr>::value(move _187) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _185 = &(*_186);
        StorageDead(_187);
        ConstEvalCounter;
        _184 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _185) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        StorageDead(_185);
        StorageDead(_189);
        StorageDead(_188);
        StorageDead(_186);
        StorageLive(_192);
        _192 = _1;
        StorageLive(_193);
        _193 = _184;
        _1 = BitOr(move _192, move _193);
        StorageDead(_193);
        StorageDead(_192);
        _194 = CheckedAdd(_2, const 1_usize);
        assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_194.0: usize);
        _183 = const ();
        StorageDead(_184);
        StorageDead(_183);
        StorageLive(_195);
        StorageLive(_196);
        StorageLive(_197);
        StorageLive(_198);
        StorageLive(_199);
        StorageLive(_200);
        _200 = const _;
        StorageLive(_201);
        _201 = _2;
        _202 = Len((*_200));
        _203 = Lt(_201, _202);
        assert(move _203, "index out of bounds: the length is {} but the index is {}", move _202, _201) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _199 = &(*_200)[_201];
        ConstEvalCounter;
        _198 = Flag::<mxcsr::MxCsr>::value(move _199) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _197 = &(*_198);
        StorageDead(_199);
        ConstEvalCounter;
        _196 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _197) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        StorageDead(_197);
        StorageDead(_201);
        StorageDead(_200);
        StorageDead(_198);
        StorageLive(_204);
        _204 = _1;
        StorageLive(_205);
        _205 = _196;
        _1 = BitOr(move _204, move _205);
        StorageDead(_205);
        StorageDead(_204);
        _206 = CheckedAdd(_2, const 1_usize);
        assert(!move (_206.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_206.0: usize);
        _195 = const ();
        StorageDead(_196);
        StorageDead(_195);
        StorageLive(_207);
        _207 = _1;
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _207) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        StorageDead(_207);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &mxcsr::_::InternalBitFlags) -> u32 {
    debug self => _1;
    let mut _0: u32;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u32);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &mxcsr::_::InternalBitFlags) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let _2: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u32);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u32) -> Option<mxcsr::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u32;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u32);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = mxcsr::_::InternalBitFlags(_1);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<mxcsr::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u32) -> Option<mxcsr::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let _2: u32;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: registers::mxcsr::_::InternalBitFlags;
    let mut _10: u32;
    scope 1 {
        debug bits => _2;
        let _3: u32;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = mxcsr::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u32);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = mxcsr::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<mxcsr::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u32) -> mxcsr::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;
    let _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = mxcsr::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = mxcsr::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u32) -> mxcsr::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::_::InternalBitFlags;
    let _7: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = mxcsr::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = mxcsr::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u32) -> mxcsr::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = mxcsr::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u32) -> mxcsr::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _2: u32;
    let mut _3: u32;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = mxcsr::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<mxcsr::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::mxcsr::_::InternalBitFlags;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::mxcsr::_::InternalBitFlags;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::mxcsr::_::InternalBitFlags;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::mxcsr::_::InternalBitFlags;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::mxcsr::_::InternalBitFlags;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::mxcsr::_::InternalBitFlags;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::mxcsr::_::InternalBitFlags;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::mxcsr::_::InternalBitFlags;
    let mut _38: u32;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::mxcsr::_::InternalBitFlags;
    let mut _42: u32;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::mxcsr::_::InternalBitFlags;
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: registers::mxcsr::_::InternalBitFlags;
    let mut _50: u32;
    let mut _51: bool;
    let mut _52: &&str;
    let mut _53: registers::mxcsr::_::InternalBitFlags;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: &&str;
    let mut _57: registers::mxcsr::_::InternalBitFlags;
    let mut _58: u32;
    let mut _59: bool;
    let mut _60: &&str;
    let mut _61: registers::mxcsr::_::InternalBitFlags;
    let mut _62: u32;
    let mut _63: bool;
    let mut _64: &&str;
    let mut _65: registers::mxcsr::_::InternalBitFlags;
    let mut _66: u32;
    let mut _67: bool;
    let mut _68: &&str;
    let mut _69: registers::mxcsr::_::InternalBitFlags;
    let mut _70: u32;
    scope 1 {
        debug name => _2;
        let mut _71: &registers::mxcsr::MxCsr;
        let mut _72: &registers::mxcsr::MxCsr;
        let mut _73: &registers::mxcsr::MxCsr;
        let mut _74: &registers::mxcsr::MxCsr;
        let mut _75: &registers::mxcsr::MxCsr;
        let mut _76: &registers::mxcsr::MxCsr;
        let mut _77: &registers::mxcsr::MxCsr;
        let mut _78: &registers::mxcsr::MxCsr;
        let mut _79: &registers::mxcsr::MxCsr;
        let mut _80: &registers::mxcsr::MxCsr;
        let mut _81: &registers::mxcsr::MxCsr;
        let mut _82: &registers::mxcsr::MxCsr;
        let mut _83: &registers::mxcsr::MxCsr;
        let mut _84: &registers::mxcsr::MxCsr;
        let mut _85: &registers::mxcsr::MxCsr;
        let mut _86: &registers::mxcsr::MxCsr;
        let mut _87: &registers::mxcsr::MxCsr;
        let mut _88: &&str;
        let mut _89: &&str;
        let mut _90: &&str;
        let mut _91: &&str;
        let mut _92: &&str;
        let mut _93: &&str;
        let mut _94: &&str;
        let mut _95: &&str;
        let mut _96: &&str;
        let mut _97: &&str;
        let mut _98: &&str;
        let mut _99: &&str;
        let mut _100: &&str;
        let mut _101: &&str;
        let mut _102: &&str;
        let mut _103: &&str;
        let mut _104: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _104 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _104) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _71 = const _;
        _6 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_71) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = mxcsr::_::InternalBitFlags(move _6);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _5);
        goto -> bb69;
    }

    bb4: {
        _8 = &_2;
        _103 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _103) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _72 = const _;
        _10 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_72) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = mxcsr::_::InternalBitFlags(move _10);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _9);
        goto -> bb69;
    }

    bb8: {
        _12 = &_2;
        _102 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _102) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _73 = const _;
        _14 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_73) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = mxcsr::_::InternalBitFlags(move _14);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _13);
        goto -> bb69;
    }

    bb12: {
        _16 = &_2;
        _101 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _101) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _74 = const _;
        _18 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_74) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = mxcsr::_::InternalBitFlags(move _18);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _17);
        goto -> bb69;
    }

    bb16: {
        _20 = &_2;
        _100 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _100) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _75 = const _;
        _22 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_75) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = mxcsr::_::InternalBitFlags(move _22);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _21);
        goto -> bb69;
    }

    bb20: {
        _24 = &_2;
        _99 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _99) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _76 = const _;
        _26 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_76) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = mxcsr::_::InternalBitFlags(move _26);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _25);
        goto -> bb69;
    }

    bb24: {
        _28 = &_2;
        _98 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _98) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _77 = const _;
        _30 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = mxcsr::_::InternalBitFlags(move _30);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _29);
        goto -> bb69;
    }

    bb28: {
        _32 = &_2;
        _97 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _97) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _78 = const _;
        _34 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_78) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = mxcsr::_::InternalBitFlags(move _34);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _33);
        goto -> bb69;
    }

    bb32: {
        _36 = &_2;
        _96 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _96) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _79 = const _;
        _38 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_79) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = mxcsr::_::InternalBitFlags(move _38);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _37);
        goto -> bb69;
    }

    bb36: {
        _40 = &_2;
        _95 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _95) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _80 = const _;
        _42 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_80) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = mxcsr::_::InternalBitFlags(move _42);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _41);
        goto -> bb69;
    }

    bb40: {
        _44 = &_2;
        _94 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _94) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _81 = const _;
        _46 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_81) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = mxcsr::_::InternalBitFlags(move _46);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _45);
        goto -> bb69;
    }

    bb44: {
        _48 = &_2;
        _93 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _93) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _82 = const _;
        _50 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_82) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = mxcsr::_::InternalBitFlags(move _50);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _49);
        goto -> bb69;
    }

    bb48: {
        _52 = &_2;
        _92 = const _;
        _51 = <&str as PartialEq>::eq(move _52, _92) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _51) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _83 = const _;
        _54 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_83) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _53 = mxcsr::_::InternalBitFlags(move _54);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _53);
        goto -> bb69;
    }

    bb52: {
        _56 = &_2;
        _91 = const _;
        _55 = <&str as PartialEq>::eq(move _56, _91) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _55) -> [0: bb56, otherwise: bb54];
    }

    bb54: {
        _84 = const _;
        _58 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_84) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _57 = mxcsr::_::InternalBitFlags(move _58);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _57);
        goto -> bb69;
    }

    bb56: {
        _60 = &_2;
        _90 = const _;
        _59 = <&str as PartialEq>::eq(move _60, _90) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _59) -> [0: bb60, otherwise: bb58];
    }

    bb58: {
        _85 = const _;
        _62 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_85) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _61 = mxcsr::_::InternalBitFlags(move _62);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _61);
        goto -> bb69;
    }

    bb60: {
        _64 = &_2;
        _89 = const _;
        _63 = <&str as PartialEq>::eq(move _64, _89) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        switchInt(move _63) -> [0: bb64, otherwise: bb62];
    }

    bb62: {
        _86 = const _;
        _66 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_86) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _65 = mxcsr::_::InternalBitFlags(move _66);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _65);
        goto -> bb69;
    }

    bb64: {
        _68 = &_2;
        _88 = const _;
        _67 = <&str as PartialEq>::eq(move _68, _88) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        switchInt(move _67) -> [0: bb68, otherwise: bb66];
    }

    bb66: {
        _87 = const _;
        _70 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_87) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _69 = mxcsr::_::InternalBitFlags(move _70);
        _0 = Option::<mxcsr::_::InternalBitFlags>::Some(move _69);
        goto -> bb69;
    }

    bb68: {
        _0 = Option::<mxcsr::_::InternalBitFlags>::None;
        goto -> bb69;
    }

    bb69: {
        return;
    }
}

promoted[0] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[14] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[16] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &mxcsr::MxCsr = {
    let mut _0: &registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[17] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "FLUSH_TO_ZERO";
        _0 = &_1;
        return;
    }
}

promoted[18] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ROUNDING_CONTROL_ZERO";
        _0 = &_1;
        return;
    }
}

promoted[19] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ROUNDING_CONTROL_POSITIVE";
        _0 = &_1;
        return;
    }
}

promoted[20] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ROUNDING_CONTROL_NEGATIVE";
        _0 = &_1;
        return;
    }
}

promoted[21] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PRECISION_MASK";
        _0 = &_1;
        return;
    }
}

promoted[22] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "UNDERFLOW_MASK";
        _0 = &_1;
        return;
    }
}

promoted[23] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OVERFLOW_MASK";
        _0 = &_1;
        return;
    }
}

promoted[24] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DIVIDE_BY_ZERO_MASK";
        _0 = &_1;
        return;
    }
}

promoted[25] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DENORMAL_MASK";
        _0 = &_1;
        return;
    }
}

promoted[26] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "INVALID_OPERATION_MASK";
        _0 = &_1;
        return;
    }
}

promoted[27] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DENORMALS_ARE_ZEROS";
        _0 = &_1;
        return;
    }
}

promoted[28] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PRECISION";
        _0 = &_1;
        return;
    }
}

promoted[29] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "UNDERFLOW";
        _0 = &_1;
        return;
    }
}

promoted[30] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OVERFLOW";
        _0 = &_1;
        return;
    }
}

promoted[31] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DIVIDE_BY_ZERO";
        _0 = &_1;
        return;
    }
}

promoted[32] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DENORMAL";
        _0 = &_1;
        return;
    }
}

promoted[33] in mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "INVALID_OPERATION";
        _0 = &_1;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::mxcsr::_::InternalBitFlags;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;
    let _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: u32;
    let mut _7: u32;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = mxcsr::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::mxcsr::_::InternalBitFlags;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: &registers::mxcsr::_::InternalBitFlags;
    let _6: registers::mxcsr::_::InternalBitFlags;
    let mut _7: u32;
    let mut _8: &registers::mxcsr::_::InternalBitFlags;
    let mut _9: u32;
    let mut _10: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = mxcsr::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = mxcsr::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = mxcsr::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    let mut _10: u32;
    let mut _11: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = mxcsr::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = mxcsr::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = mxcsr::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = mxcsr::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = mxcsr::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = mxcsr::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = mxcsr::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _3: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;
    let mut _8: u32;
    let mut _9: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = mxcsr::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _2: registers::mxcsr::_::InternalBitFlags;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = mxcsr::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = mxcsr::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let _2: registers::mxcsr::_::InternalBitFlags;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = mxcsr::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &mxcsr::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u32;

    bb0: {
        _3 = &((*_1).0: u32);
        _0 = <u32 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = mxcsr::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = mxcsr::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut mxcsr::_::InternalBitFlags, _2: mxcsr::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: mxcsr::_::InternalBitFlags) -> mxcsr::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut mxcsr::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::mxcsr::_::InternalBitFlags);
        _5 = mxcsr::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> mxcsr::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::mxcsr::_::InternalBitFlags;
    let mut _2: registers::mxcsr::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <mxcsr::_::InternalBitFlags as Extend<mxcsr::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &mxcsr::_::InternalBitFlags) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &mxcsr::_::InternalBitFlags) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &mxcsr::_::InternalBitFlags) -> IterNames<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;

    bb0: {
        _3 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &mxcsr::_::InternalBitFlags) -> IterNames<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = mxcsr::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: mxcsr::_::InternalBitFlags) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = mxcsr::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut mxcsr::_::InternalBitFlags) -> &mut u32 {
    debug self => _1;
    let mut _0: &mut u32;

    bb0: {
        _0 = &mut ((*_1).0: u32);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _1 = mxcsr::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = mxcsr::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _1);
        StorageDead(_1);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _1 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = mxcsr::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _1);
        StorageDead(_1);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &mxcsr::MxCsr) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &mxcsr::MxCsr) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let _2: &registers::mxcsr::MxCsr;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u32) -> Option<mxcsr::MxCsr> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _2: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::mxcsr::MxCsr;
    scope 1 {
        debug bits => _1;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<mxcsr::MxCsr>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::mxcsr::_::InternalBitFlags);
        _5 = mxcsr::MxCsr(_4);
        _0 = Option::<mxcsr::MxCsr>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u32) -> Option<mxcsr::MxCsr> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::mxcsr::MxCsr>;
    let _2: u32;
    let mut _3: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let mut _4: u32;
    let mut _5: isize;
    let mut _7: registers::mxcsr::MxCsr;
    let mut _8: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<mxcsr::MxCsr>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = mxcsr::MxCsr(move _8);
        StorageDead(_8);
        _0 = Option::<mxcsr::MxCsr>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let _2: u32;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: u32;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = mxcsr::MxCsr(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let _2: u32;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: u32;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = mxcsr::MxCsr(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<mxcsr::MxCsr> {
    debug name => _1;
    let mut _0: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _2: core::option::Option<registers::mxcsr::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::mxcsr::MxCsr;
    scope 1 {
        debug name => _1;
        let _4: registers::mxcsr::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = mxcsr::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<mxcsr::MxCsr>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::mxcsr::_::InternalBitFlags);
        _5 = mxcsr::MxCsr(_4);
        _0 = Option::<mxcsr::MxCsr>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::mxcsr::MxCsr;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &mxcsr::MxCsr) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::mxcsr::MxCsr;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::mxcsr::MxCsr;
    let mut _5: &registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &mxcsr::MxCsr, _2: mxcsr::MxCsr) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::mxcsr::MxCsr;
    let mut _5: &registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = mxcsr::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _5 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _0 = mxcsr::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::mxcsr::_::InternalBitFlags);
        _5 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _3 = mxcsr::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let _3: registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    let mut _7: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = mxcsr::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = mxcsr::MxCsr(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::mxcsr::_::InternalBitFlags);
        _5 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _3 = mxcsr::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let _3: registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    let mut _7: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = mxcsr::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = mxcsr::MxCsr(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::mxcsr::_::InternalBitFlags);
        _5 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _3 = mxcsr::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let _3: registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    let mut _7: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = mxcsr::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = mxcsr::MxCsr(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::mxcsr::_::InternalBitFlags);
        _5 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        _3 = mxcsr::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _3);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;
    let _3: registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::_::InternalBitFlags;
    let mut _6: registers::mxcsr::_::InternalBitFlags;
    let mut _7: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::mxcsr::MxCsr;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::mxcsr::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = mxcsr::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = mxcsr::MxCsr(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::_::InternalBitFlags;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::mxcsr::_::InternalBitFlags);
        _2 = mxcsr::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mxcsr::MxCsr(move _2);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let _2: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::_::InternalBitFlags;
    let mut _4: registers::mxcsr::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::mxcsr::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = mxcsr::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = mxcsr::MxCsr(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &mxcsr::MxCsr, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::mxcsr::_::InternalBitFlags);
        _0 = <mxcsr::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;
    let mut _6: &registers::mxcsr::MxCsr;

    bb0: {
        _6 = &(*_1);
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: mxcsr::MxCsr, _2: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut mxcsr::MxCsr, _2: mxcsr::MxCsr) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: mxcsr::MxCsr) -> mxcsr::MxCsr {
    debug self => _1;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut mxcsr::MxCsr, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::mxcsr::MxCsr>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::mxcsr::MxCsr;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::mxcsr::MxCsr);
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> mxcsr::MxCsr {
    debug iterator => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::MxCsr;
    let _3: ();
    let mut _4: &mut registers::mxcsr::MxCsr;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <mxcsr::MxCsr as Extend<mxcsr::MxCsr>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &mxcsr::MxCsr) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;

    bb0: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &mxcsr::MxCsr) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &mxcsr::MxCsr) -> IterNames<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: registers::mxcsr::MxCsr;
    let mut _5: u32;

    bb0: {
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &mxcsr::MxCsr) -> IterNames<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::mxcsr::MxCsr>;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: u32;
    let mut _4: &registers::mxcsr::MxCsr;
    let mut _5: registers::mxcsr::MxCsr;
    let mut _6: u32;
    let mut _7: &registers::mxcsr::MxCsr;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = mxcsr::_::<impl mxcsr::MxCsr>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<mxcsr::MxCsr>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn mxcsr::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: mxcsr::MxCsr) -> bitflags::iter::Iter<mxcsr::MxCsr> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::mxcsr::MxCsr>;
    let mut _2: &registers::mxcsr::MxCsr;

    bb0: {
        _2 = &_1;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:50:1: 50:23>::default() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: registers::mxcsr::MxCsr;
    let mut _2: registers::mxcsr::MxCsr;
    let mut _3: registers::mxcsr::MxCsr;
    let mut _4: registers::mxcsr::MxCsr;

    bb0: {
        _4 = <mxcsr::MxCsr as BitOr>::bitor(const _, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <mxcsr::MxCsr as BitOr>::bitor(move _4, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = <mxcsr::MxCsr as BitOr>::bitor(move _3, const _) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = <mxcsr::MxCsr as BitOr>::bitor(move _2, const _) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <mxcsr::MxCsr as BitOr>::bitor(move _1, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:63:1: 63:11>::from_bits_unchecked(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/mxcsr.rs:63:1: 63:11>::from_bits_unchecked(_1: u32) -> mxcsr::MxCsr {
    debug bits => _1;
    let mut _0: registers::mxcsr::MxCsr;
    let mut _2: u32;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn mxcsr::x86_64::read() -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;
    let mut _1: u32;
    let mut _2: *mut u32;
    let mut _3: &mut u32;
    let mut _4: u32;
    scope 1 {
        debug mxcsr => _1;
        scope 2 {
        }
    }

    bb0: {
        _1 = const 0_u32;
        _3 = &mut _1;
        _2 = &raw mut (*_3);
        asm!("stmxcsr [{0}]", in(reg) move _2, options(PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _0 = mxcsr::_::<impl mxcsr::MxCsr>::from_bits_truncate(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mxcsr::x86_64::write(_1: mxcsr::MxCsr) -> () {
    debug mxcsr => _1;
    let mut _0: ();
    let mut _2: *const registers::mxcsr::MxCsr;
    let _3: &registers::mxcsr::MxCsr;
    scope 1 {
    }

    bb0: {
        _3 = &_1;
        _2 = &raw const (*_3);
        asm!("ldmxcsr [{0}]", in(reg) move _2, options(READONLY | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:14: 11:23>::eq(_1: &rflags::RFlags, _2: &rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    let mut _4: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:25: 11:27>::assert_receiver_is_total_eq(_1: &rflags::RFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:29: 11:39>::partial_cmp(_1: &rflags::RFlags, _2: &rflags::RFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::rflags::_::InternalBitFlags;
    let _4: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:41: 11:44>::cmp(_1: &rflags::RFlags, _2: &rflags::RFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::rflags::_::InternalBitFlags;
    let _4: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:46: 11:50>::hash(_1: &rflags::RFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:52: 11:57>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::rflags::_::InternalBitFlags;
    let _6: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = const "RFlags";
        _6 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:11:59: 11:64>::clone(_1: &rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ID: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 21_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 21_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 21_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::VIRTUAL_INTERRUPT_PENDING: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 20_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 20_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::VIRTUAL_INTERRUPT: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 19_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 19_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 19_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ALIGNMENT_CHECK: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 18_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 18_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::VIRTUAL_8086_MODE: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 17_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 17_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 17_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::RESUME_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 16_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NESTED_TASK: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 14_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 14_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 14_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IOPL_HIGH: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 13_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 13_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 13_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::IOPL_LOW: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 12_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 12_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OVERFLOW_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DIRECTION_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::INTERRUPT_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::TRAP_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SIGN_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ZERO_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::AUXILIARY_CARRY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PARITY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::CARRY_FLAG: rflags::RFlags = {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<rflags::RFlags>] = {
    let mut _0: &[bitflags::Flag<registers::rflags::RFlags>];
    let mut _1: &[bitflags::Flag<registers::rflags::RFlags>; 18];
    let _2: &[bitflags::Flag<registers::rflags::RFlags>; 18];
    let _3: [bitflags::Flag<registers::rflags::RFlags>; 18];
    let mut _4: bitflags::Flag<registers::rflags::RFlags>;
    let mut _5: bitflags::Flag<registers::rflags::RFlags>;
    let mut _6: bitflags::Flag<registers::rflags::RFlags>;
    let mut _7: bitflags::Flag<registers::rflags::RFlags>;
    let mut _8: bitflags::Flag<registers::rflags::RFlags>;
    let mut _9: bitflags::Flag<registers::rflags::RFlags>;
    let mut _10: bitflags::Flag<registers::rflags::RFlags>;
    let mut _11: bitflags::Flag<registers::rflags::RFlags>;
    let mut _12: bitflags::Flag<registers::rflags::RFlags>;
    let mut _13: bitflags::Flag<registers::rflags::RFlags>;
    let mut _14: bitflags::Flag<registers::rflags::RFlags>;
    let mut _15: bitflags::Flag<registers::rflags::RFlags>;
    let mut _16: bitflags::Flag<registers::rflags::RFlags>;
    let mut _17: bitflags::Flag<registers::rflags::RFlags>;
    let mut _18: bitflags::Flag<registers::rflags::RFlags>;
    let mut _19: bitflags::Flag<registers::rflags::RFlags>;
    let mut _20: bitflags::Flag<registers::rflags::RFlags>;
    let mut _21: bitflags::Flag<registers::rflags::RFlags>;
    let mut _22: &[bitflags::Flag<registers::rflags::RFlags>; 18];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }
    scope 16 {
    }
    scope 17 {
    }
    scope 18 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _22 = const _;
        _2 = &(*_22);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::rflags::RFlags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<rflags::RFlags>; 18] = {
    let mut _0: &[bitflags::Flag<registers::rflags::RFlags>; 18];
    let mut _1: [bitflags::Flag<registers::rflags::RFlags>; 18];
    let mut _2: bitflags::Flag<registers::rflags::RFlags>;
    let mut _3: bitflags::Flag<registers::rflags::RFlags>;
    let mut _4: bitflags::Flag<registers::rflags::RFlags>;
    let mut _5: bitflags::Flag<registers::rflags::RFlags>;
    let mut _6: bitflags::Flag<registers::rflags::RFlags>;
    let mut _7: bitflags::Flag<registers::rflags::RFlags>;
    let mut _8: bitflags::Flag<registers::rflags::RFlags>;
    let mut _9: bitflags::Flag<registers::rflags::RFlags>;
    let mut _10: bitflags::Flag<registers::rflags::RFlags>;
    let mut _11: bitflags::Flag<registers::rflags::RFlags>;
    let mut _12: bitflags::Flag<registers::rflags::RFlags>;
    let mut _13: bitflags::Flag<registers::rflags::RFlags>;
    let mut _14: bitflags::Flag<registers::rflags::RFlags>;
    let mut _15: bitflags::Flag<registers::rflags::RFlags>;
    let mut _16: bitflags::Flag<registers::rflags::RFlags>;
    let mut _17: bitflags::Flag<registers::rflags::RFlags>;
    let mut _18: bitflags::Flag<registers::rflags::RFlags>;
    let mut _19: bitflags::Flag<registers::rflags::RFlags>;

    bb0: {
        _2 = Flag::<rflags::RFlags>::new(const "ID", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<rflags::RFlags>::new(const "VIRTUAL_INTERRUPT_PENDING", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<rflags::RFlags>::new(const "VIRTUAL_INTERRUPT", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<rflags::RFlags>::new(const "ALIGNMENT_CHECK", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<rflags::RFlags>::new(const "VIRTUAL_8086_MODE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<rflags::RFlags>::new(const "RESUME_FLAG", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<rflags::RFlags>::new(const "NESTED_TASK", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<rflags::RFlags>::new(const "IOPL_HIGH", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<rflags::RFlags>::new(const "IOPL_LOW", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<rflags::RFlags>::new(const "OVERFLOW_FLAG", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<rflags::RFlags>::new(const "DIRECTION_FLAG", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<rflags::RFlags>::new(const "INTERRUPT_FLAG", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Flag::<rflags::RFlags>::new(const "TRAP_FLAG", const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Flag::<rflags::RFlags>::new(const "SIGN_FLAG", const _) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Flag::<rflags::RFlags>::new(const "ZERO_FLAG", const _) -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = Flag::<rflags::RFlags>::new(const "AUXILIARY_CARRY_FLAG", const _) -> [return: bb16, unwind continue];
    }

    bb16: {
        _18 = Flag::<rflags::RFlags>::new(const "PARITY_FLAG", const _) -> [return: bb17, unwind continue];
    }

    bb17: {
        _19 = Flag::<rflags::RFlags>::new(const "CARRY_FLAG", const _) -> [return: bb18, unwind continue];
    }

    bb18: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16, move _17, move _18, move _19];
        _0 = &_1;
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &rflags::RFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const rflags::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &rflags::_::InternalBitFlags, _2: &rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &rflags::_::InternalBitFlags, _2: &rflags::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &rflags::_::InternalBitFlags, _2: &rflags::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &rflags::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = rflags::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <rflags::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::rflags::RFlags;
    let _4: registers::rflags::RFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = rflags::RFlags(move _5);
        _3 = &_4;
        _0 = to_writer::<rflags::RFlags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<rflags::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::rflags::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::rflags::RFlags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<rflags::RFlags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<rflags::RFlags, ParseError>::map::<rflags::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: rflags::RFlags) -> rflags::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::rflags::_::InternalBitFlags);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &rflags::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> rflags::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags(const _);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::rflags::RFlags;
    let mut _5: &bitflags::Flag<registers::rflags::RFlags>;
    let _6: &[bitflags::Flag<registers::rflags::RFlags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::rflags::RFlags;
    let mut _14: &bitflags::Flag<registers::rflags::RFlags>;
    let _15: &[bitflags::Flag<registers::rflags::RFlags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::rflags::RFlags;
    let mut _23: &bitflags::Flag<registers::rflags::RFlags>;
    let _24: &[bitflags::Flag<registers::rflags::RFlags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::rflags::RFlags;
    let mut _32: &bitflags::Flag<registers::rflags::RFlags>;
    let _33: &[bitflags::Flag<registers::rflags::RFlags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::rflags::RFlags;
    let mut _41: &bitflags::Flag<registers::rflags::RFlags>;
    let _42: &[bitflags::Flag<registers::rflags::RFlags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::rflags::RFlags;
    let mut _50: &bitflags::Flag<registers::rflags::RFlags>;
    let _51: &[bitflags::Flag<registers::rflags::RFlags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::rflags::RFlags;
    let mut _59: &bitflags::Flag<registers::rflags::RFlags>;
    let _60: &[bitflags::Flag<registers::rflags::RFlags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::rflags::RFlags;
    let mut _68: &bitflags::Flag<registers::rflags::RFlags>;
    let _69: &[bitflags::Flag<registers::rflags::RFlags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::rflags::RFlags;
    let mut _77: &bitflags::Flag<registers::rflags::RFlags>;
    let _78: &[bitflags::Flag<registers::rflags::RFlags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &registers::rflags::RFlags;
    let mut _86: &bitflags::Flag<registers::rflags::RFlags>;
    let _87: &[bitflags::Flag<registers::rflags::RFlags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &registers::rflags::RFlags;
    let mut _95: &bitflags::Flag<registers::rflags::RFlags>;
    let _96: &[bitflags::Flag<registers::rflags::RFlags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let _103: &registers::rflags::RFlags;
    let mut _104: &bitflags::Flag<registers::rflags::RFlags>;
    let _105: &[bitflags::Flag<registers::rflags::RFlags>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _112: &registers::rflags::RFlags;
    let mut _113: &bitflags::Flag<registers::rflags::RFlags>;
    let _114: &[bitflags::Flag<registers::rflags::RFlags>];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: u64;
    let mut _119: (usize, bool);
    let _121: &registers::rflags::RFlags;
    let mut _122: &bitflags::Flag<registers::rflags::RFlags>;
    let _123: &[bitflags::Flag<registers::rflags::RFlags>];
    let _124: usize;
    let mut _125: usize;
    let mut _126: bool;
    let mut _127: u64;
    let mut _128: (usize, bool);
    let _130: &registers::rflags::RFlags;
    let mut _131: &bitflags::Flag<registers::rflags::RFlags>;
    let _132: &[bitflags::Flag<registers::rflags::RFlags>];
    let _133: usize;
    let mut _134: usize;
    let mut _135: bool;
    let mut _136: u64;
    let mut _137: (usize, bool);
    let _139: &registers::rflags::RFlags;
    let mut _140: &bitflags::Flag<registers::rflags::RFlags>;
    let _141: &[bitflags::Flag<registers::rflags::RFlags>];
    let _142: usize;
    let mut _143: usize;
    let mut _144: bool;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _148: &registers::rflags::RFlags;
    let mut _149: &bitflags::Flag<registers::rflags::RFlags>;
    let _150: &[bitflags::Flag<registers::rflags::RFlags>];
    let _151: usize;
    let mut _152: usize;
    let mut _153: bool;
    let mut _154: u64;
    let mut _155: (usize, bool);
    let _157: &registers::rflags::RFlags;
    let mut _158: &bitflags::Flag<registers::rflags::RFlags>;
    let _159: &[bitflags::Flag<registers::rflags::RFlags>];
    let _160: usize;
    let mut _161: usize;
    let mut _162: bool;
    let mut _163: u64;
    let mut _164: (usize, bool);
    let mut _165: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            let _102: u64;
            let _111: u64;
            let _120: u64;
            let _129: u64;
            let _138: u64;
            let _147: u64;
            let _156: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
                debug flag => _111;
            }
            scope 16 {
                debug flag => _120;
            }
            scope 17 {
                debug flag => _129;
            }
            scope 18 {
                debug flag => _138;
            }
            scope 19 {
                debug flag => _147;
            }
            scope 20 {
                debug flag => _156;
            }
            scope 21 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<rflags::RFlags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::<impl rflags::RFlags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<rflags::RFlags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = rflags::_::<impl rflags::RFlags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<rflags::RFlags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = rflags::_::<impl rflags::RFlags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<rflags::RFlags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = rflags::_::<impl rflags::RFlags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<rflags::RFlags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = rflags::_::<impl rflags::RFlags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<rflags::RFlags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = rflags::_::<impl rflags::RFlags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<rflags::RFlags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = rflags::_::<impl rflags::RFlags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<rflags::RFlags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = rflags::_::<impl rflags::RFlags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<rflags::RFlags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = rflags::_::<impl rflags::RFlags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<rflags::RFlags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = rflags::_::<impl rflags::RFlags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<rflags::RFlags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = rflags::_::<impl rflags::RFlags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<rflags::RFlags>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = rflags::_::<impl rflags::RFlags>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _114 = const _;
        _115 = _2;
        _116 = Len((*_114));
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _113 = &(*_114)[_115];
        _112 = Flag::<rflags::RFlags>::value(move _113) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _111 = rflags::_::<impl rflags::RFlags>::bits(_112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _118 = _1;
        _1 = BitOr(move _118, _111);
        _119 = CheckedAdd(_2, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_119.0: usize);
        _123 = const _;
        _124 = _2;
        _125 = Len((*_123));
        _126 = Lt(_124, _125);
        assert(move _126, "index out of bounds: the length is {} but the index is {}", move _125, _124) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _122 = &(*_123)[_124];
        _121 = Flag::<rflags::RFlags>::value(move _122) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _120 = rflags::_::<impl rflags::RFlags>::bits(_121) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = _1;
        _1 = BitOr(move _127, _120);
        _128 = CheckedAdd(_2, const 1_usize);
        assert(!move (_128.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_128.0: usize);
        _132 = const _;
        _133 = _2;
        _134 = Len((*_132));
        _135 = Lt(_133, _134);
        assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _133) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _131 = &(*_132)[_133];
        _130 = Flag::<rflags::RFlags>::value(move _131) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _129 = rflags::_::<impl rflags::RFlags>::bits(_130) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _136 = _1;
        _1 = BitOr(move _136, _129);
        _137 = CheckedAdd(_2, const 1_usize);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_137.0: usize);
        _141 = const _;
        _142 = _2;
        _143 = Len((*_141));
        _144 = Lt(_142, _143);
        assert(move _144, "index out of bounds: the length is {} but the index is {}", move _143, _142) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _140 = &(*_141)[_142];
        _139 = Flag::<rflags::RFlags>::value(move _140) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _138 = rflags::_::<impl rflags::RFlags>::bits(_139) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _145 = _1;
        _1 = BitOr(move _145, _138);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_146.0: usize);
        _150 = const _;
        _151 = _2;
        _152 = Len((*_150));
        _153 = Lt(_151, _152);
        assert(move _153, "index out of bounds: the length is {} but the index is {}", move _152, _151) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _149 = &(*_150)[_151];
        _148 = Flag::<rflags::RFlags>::value(move _149) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _147 = rflags::_::<impl rflags::RFlags>::bits(_148) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _154 = _1;
        _1 = BitOr(move _154, _147);
        _155 = CheckedAdd(_2, const 1_usize);
        assert(!move (_155.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_155.0: usize);
        _159 = const _;
        _160 = _2;
        _161 = Len((*_159));
        _162 = Lt(_160, _161);
        assert(move _162, "index out of bounds: the length is {} but the index is {}", move _161, _160) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _158 = &(*_159)[_160];
        _157 = Flag::<rflags::RFlags>::value(move _158) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _156 = rflags::_::<impl rflags::RFlags>::bits(_157) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _163 = _1;
        _1 = BitOr(move _163, _156);
        _164 = CheckedAdd(_2, const 1_usize);
        assert(!move (_164.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_164.0: usize);
        _165 = _1;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _165) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::rflags::RFlags;
    let _6: &registers::rflags::RFlags;
    let mut _7: &bitflags::Flag<registers::rflags::RFlags>;
    let _8: &[bitflags::Flag<registers::rflags::RFlags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::rflags::RFlags;
    let _18: &registers::rflags::RFlags;
    let mut _19: &bitflags::Flag<registers::rflags::RFlags>;
    let _20: &[bitflags::Flag<registers::rflags::RFlags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::rflags::RFlags;
    let _30: &registers::rflags::RFlags;
    let mut _31: &bitflags::Flag<registers::rflags::RFlags>;
    let _32: &[bitflags::Flag<registers::rflags::RFlags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::rflags::RFlags;
    let _42: &registers::rflags::RFlags;
    let mut _43: &bitflags::Flag<registers::rflags::RFlags>;
    let _44: &[bitflags::Flag<registers::rflags::RFlags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::rflags::RFlags;
    let _54: &registers::rflags::RFlags;
    let mut _55: &bitflags::Flag<registers::rflags::RFlags>;
    let _56: &[bitflags::Flag<registers::rflags::RFlags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::rflags::RFlags;
    let _66: &registers::rflags::RFlags;
    let mut _67: &bitflags::Flag<registers::rflags::RFlags>;
    let _68: &[bitflags::Flag<registers::rflags::RFlags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::rflags::RFlags;
    let _78: &registers::rflags::RFlags;
    let mut _79: &bitflags::Flag<registers::rflags::RFlags>;
    let _80: &[bitflags::Flag<registers::rflags::RFlags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::rflags::RFlags;
    let _90: &registers::rflags::RFlags;
    let mut _91: &bitflags::Flag<registers::rflags::RFlags>;
    let _92: &[bitflags::Flag<registers::rflags::RFlags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::rflags::RFlags;
    let _102: &registers::rflags::RFlags;
    let mut _103: &bitflags::Flag<registers::rflags::RFlags>;
    let _104: &[bitflags::Flag<registers::rflags::RFlags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::rflags::RFlags;
    let _114: &registers::rflags::RFlags;
    let mut _115: &bitflags::Flag<registers::rflags::RFlags>;
    let _116: &[bitflags::Flag<registers::rflags::RFlags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::rflags::RFlags;
    let _126: &registers::rflags::RFlags;
    let mut _127: &bitflags::Flag<registers::rflags::RFlags>;
    let _128: &[bitflags::Flag<registers::rflags::RFlags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &registers::rflags::RFlags;
    let _138: &registers::rflags::RFlags;
    let mut _139: &bitflags::Flag<registers::rflags::RFlags>;
    let _140: &[bitflags::Flag<registers::rflags::RFlags>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u64;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _147: ();
    let mut _149: &registers::rflags::RFlags;
    let _150: &registers::rflags::RFlags;
    let mut _151: &bitflags::Flag<registers::rflags::RFlags>;
    let _152: &[bitflags::Flag<registers::rflags::RFlags>];
    let _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: (usize, bool);
    let _159: ();
    let mut _161: &registers::rflags::RFlags;
    let _162: &registers::rflags::RFlags;
    let mut _163: &bitflags::Flag<registers::rflags::RFlags>;
    let _164: &[bitflags::Flag<registers::rflags::RFlags>];
    let _165: usize;
    let mut _166: usize;
    let mut _167: bool;
    let mut _168: u64;
    let mut _169: u64;
    let mut _170: (usize, bool);
    let _171: ();
    let mut _173: &registers::rflags::RFlags;
    let _174: &registers::rflags::RFlags;
    let mut _175: &bitflags::Flag<registers::rflags::RFlags>;
    let _176: &[bitflags::Flag<registers::rflags::RFlags>];
    let _177: usize;
    let mut _178: usize;
    let mut _179: bool;
    let mut _180: u64;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let _183: ();
    let mut _185: &registers::rflags::RFlags;
    let _186: &registers::rflags::RFlags;
    let mut _187: &bitflags::Flag<registers::rflags::RFlags>;
    let _188: &[bitflags::Flag<registers::rflags::RFlags>];
    let _189: usize;
    let mut _190: usize;
    let mut _191: bool;
    let mut _192: u64;
    let mut _193: u64;
    let mut _194: (usize, bool);
    let _195: ();
    let mut _197: &registers::rflags::RFlags;
    let _198: &registers::rflags::RFlags;
    let mut _199: &bitflags::Flag<registers::rflags::RFlags>;
    let _200: &[bitflags::Flag<registers::rflags::RFlags>];
    let _201: usize;
    let mut _202: usize;
    let mut _203: bool;
    let mut _204: u64;
    let mut _205: u64;
    let mut _206: (usize, bool);
    let _207: ();
    let mut _209: &registers::rflags::RFlags;
    let _210: &registers::rflags::RFlags;
    let mut _211: &bitflags::Flag<registers::rflags::RFlags>;
    let _212: &[bitflags::Flag<registers::rflags::RFlags>];
    let _213: usize;
    let mut _214: usize;
    let mut _215: bool;
    let mut _216: u64;
    let mut _217: u64;
    let mut _218: (usize, bool);
    let mut _219: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            let _136: u64;
            let _148: u64;
            let _160: u64;
            let _172: u64;
            let _184: u64;
            let _196: u64;
            let _208: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
                debug flag => _148;
            }
            scope 16 {
                debug flag => _160;
            }
            scope 17 {
                debug flag => _172;
            }
            scope 18 {
                debug flag => _184;
            }
            scope 19 {
                debug flag => _196;
            }
            scope 20 {
                debug flag => _208;
            }
            scope 21 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<rflags::RFlags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = rflags::_::<impl rflags::RFlags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<rflags::RFlags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = rflags::_::<impl rflags::RFlags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<rflags::RFlags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = rflags::_::<impl rflags::RFlags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<rflags::RFlags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = rflags::_::<impl rflags::RFlags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<rflags::RFlags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = rflags::_::<impl rflags::RFlags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<rflags::RFlags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = rflags::_::<impl rflags::RFlags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<rflags::RFlags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = rflags::_::<impl rflags::RFlags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<rflags::RFlags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = rflags::_::<impl rflags::RFlags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<rflags::RFlags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = rflags::_::<impl rflags::RFlags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<rflags::RFlags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = rflags::_::<impl rflags::RFlags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<rflags::RFlags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = rflags::_::<impl rflags::RFlags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<rflags::RFlags>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = rflags::_::<impl rflags::RFlags>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        StorageLive(_148);
        StorageLive(_149);
        StorageLive(_150);
        StorageLive(_151);
        StorageLive(_152);
        _152 = const _;
        StorageLive(_153);
        _153 = _2;
        _154 = Len((*_152));
        _155 = Lt(_153, _154);
        assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _153) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _151 = &(*_152)[_153];
        ConstEvalCounter;
        _150 = Flag::<rflags::RFlags>::value(move _151) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _149 = &(*_150);
        StorageDead(_151);
        ConstEvalCounter;
        _148 = rflags::_::<impl rflags::RFlags>::bits(move _149) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        StorageDead(_149);
        StorageDead(_153);
        StorageDead(_152);
        StorageDead(_150);
        StorageLive(_156);
        _156 = _1;
        StorageLive(_157);
        _157 = _148;
        _1 = BitOr(move _156, move _157);
        StorageDead(_157);
        StorageDead(_156);
        _158 = CheckedAdd(_2, const 1_usize);
        assert(!move (_158.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_158.0: usize);
        _147 = const ();
        StorageDead(_148);
        StorageDead(_147);
        StorageLive(_159);
        StorageLive(_160);
        StorageLive(_161);
        StorageLive(_162);
        StorageLive(_163);
        StorageLive(_164);
        _164 = const _;
        StorageLive(_165);
        _165 = _2;
        _166 = Len((*_164));
        _167 = Lt(_165, _166);
        assert(move _167, "index out of bounds: the length is {} but the index is {}", move _166, _165) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _163 = &(*_164)[_165];
        ConstEvalCounter;
        _162 = Flag::<rflags::RFlags>::value(move _163) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _161 = &(*_162);
        StorageDead(_163);
        ConstEvalCounter;
        _160 = rflags::_::<impl rflags::RFlags>::bits(move _161) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        StorageDead(_161);
        StorageDead(_165);
        StorageDead(_164);
        StorageDead(_162);
        StorageLive(_168);
        _168 = _1;
        StorageLive(_169);
        _169 = _160;
        _1 = BitOr(move _168, move _169);
        StorageDead(_169);
        StorageDead(_168);
        _170 = CheckedAdd(_2, const 1_usize);
        assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_170.0: usize);
        _159 = const ();
        StorageDead(_160);
        StorageDead(_159);
        StorageLive(_171);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        StorageLive(_175);
        StorageLive(_176);
        _176 = const _;
        StorageLive(_177);
        _177 = _2;
        _178 = Len((*_176));
        _179 = Lt(_177, _178);
        assert(move _179, "index out of bounds: the length is {} but the index is {}", move _178, _177) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _175 = &(*_176)[_177];
        ConstEvalCounter;
        _174 = Flag::<rflags::RFlags>::value(move _175) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _173 = &(*_174);
        StorageDead(_175);
        ConstEvalCounter;
        _172 = rflags::_::<impl rflags::RFlags>::bits(move _173) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        StorageDead(_173);
        StorageDead(_177);
        StorageDead(_176);
        StorageDead(_174);
        StorageLive(_180);
        _180 = _1;
        StorageLive(_181);
        _181 = _172;
        _1 = BitOr(move _180, move _181);
        StorageDead(_181);
        StorageDead(_180);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_182.0: usize);
        _171 = const ();
        StorageDead(_172);
        StorageDead(_171);
        StorageLive(_183);
        StorageLive(_184);
        StorageLive(_185);
        StorageLive(_186);
        StorageLive(_187);
        StorageLive(_188);
        _188 = const _;
        StorageLive(_189);
        _189 = _2;
        _190 = Len((*_188));
        _191 = Lt(_189, _190);
        assert(move _191, "index out of bounds: the length is {} but the index is {}", move _190, _189) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _187 = &(*_188)[_189];
        ConstEvalCounter;
        _186 = Flag::<rflags::RFlags>::value(move _187) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _185 = &(*_186);
        StorageDead(_187);
        ConstEvalCounter;
        _184 = rflags::_::<impl rflags::RFlags>::bits(move _185) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        StorageDead(_185);
        StorageDead(_189);
        StorageDead(_188);
        StorageDead(_186);
        StorageLive(_192);
        _192 = _1;
        StorageLive(_193);
        _193 = _184;
        _1 = BitOr(move _192, move _193);
        StorageDead(_193);
        StorageDead(_192);
        _194 = CheckedAdd(_2, const 1_usize);
        assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_194.0: usize);
        _183 = const ();
        StorageDead(_184);
        StorageDead(_183);
        StorageLive(_195);
        StorageLive(_196);
        StorageLive(_197);
        StorageLive(_198);
        StorageLive(_199);
        StorageLive(_200);
        _200 = const _;
        StorageLive(_201);
        _201 = _2;
        _202 = Len((*_200));
        _203 = Lt(_201, _202);
        assert(move _203, "index out of bounds: the length is {} but the index is {}", move _202, _201) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _199 = &(*_200)[_201];
        ConstEvalCounter;
        _198 = Flag::<rflags::RFlags>::value(move _199) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _197 = &(*_198);
        StorageDead(_199);
        ConstEvalCounter;
        _196 = rflags::_::<impl rflags::RFlags>::bits(move _197) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        StorageDead(_197);
        StorageDead(_201);
        StorageDead(_200);
        StorageDead(_198);
        StorageLive(_204);
        _204 = _1;
        StorageLive(_205);
        _205 = _196;
        _1 = BitOr(move _204, move _205);
        StorageDead(_205);
        StorageDead(_204);
        _206 = CheckedAdd(_2, const 1_usize);
        assert(!move (_206.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_206.0: usize);
        _195 = const ();
        StorageDead(_196);
        StorageDead(_195);
        StorageLive(_207);
        StorageLive(_208);
        StorageLive(_209);
        StorageLive(_210);
        StorageLive(_211);
        StorageLive(_212);
        _212 = const _;
        StorageLive(_213);
        _213 = _2;
        _214 = Len((*_212));
        _215 = Lt(_213, _214);
        assert(move _215, "index out of bounds: the length is {} but the index is {}", move _214, _213) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _211 = &(*_212)[_213];
        ConstEvalCounter;
        _210 = Flag::<rflags::RFlags>::value(move _211) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _209 = &(*_210);
        StorageDead(_211);
        ConstEvalCounter;
        _208 = rflags::_::<impl rflags::RFlags>::bits(move _209) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        StorageDead(_209);
        StorageDead(_213);
        StorageDead(_212);
        StorageDead(_210);
        StorageLive(_216);
        _216 = _1;
        StorageLive(_217);
        _217 = _208;
        _1 = BitOr(move _216, move _217);
        StorageDead(_217);
        StorageDead(_216);
        _218 = CheckedAdd(_2, const 1_usize);
        assert(!move (_218.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_218.0: usize);
        _207 = const ();
        StorageDead(_208);
        StorageDead(_207);
        StorageLive(_219);
        _219 = _1;
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _219) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        StorageDead(_219);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &rflags::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &rflags::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<rflags::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = rflags::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = rflags::_::InternalBitFlags(_1);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<rflags::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<rflags::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::rflags::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = rflags::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = rflags::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<rflags::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> rflags::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::rflags::_::InternalBitFlags;
    let _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = rflags::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = rflags::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> rflags::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::rflags::_::InternalBitFlags;
    let _7: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = rflags::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = rflags::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> rflags::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = rflags::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> rflags::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = rflags::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<rflags::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::rflags::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::rflags::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::rflags::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::rflags::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::rflags::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::rflags::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::rflags::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::rflags::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::rflags::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::rflags::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::rflags::_::InternalBitFlags;
    let mut _46: u64;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: registers::rflags::_::InternalBitFlags;
    let mut _50: u64;
    let mut _51: bool;
    let mut _52: &&str;
    let mut _53: registers::rflags::_::InternalBitFlags;
    let mut _54: u64;
    let mut _55: bool;
    let mut _56: &&str;
    let mut _57: registers::rflags::_::InternalBitFlags;
    let mut _58: u64;
    let mut _59: bool;
    let mut _60: &&str;
    let mut _61: registers::rflags::_::InternalBitFlags;
    let mut _62: u64;
    let mut _63: bool;
    let mut _64: &&str;
    let mut _65: registers::rflags::_::InternalBitFlags;
    let mut _66: u64;
    let mut _67: bool;
    let mut _68: &&str;
    let mut _69: registers::rflags::_::InternalBitFlags;
    let mut _70: u64;
    let mut _71: bool;
    let mut _72: &&str;
    let mut _73: registers::rflags::_::InternalBitFlags;
    let mut _74: u64;
    scope 1 {
        debug name => _2;
        let mut _75: &registers::rflags::RFlags;
        let mut _76: &registers::rflags::RFlags;
        let mut _77: &registers::rflags::RFlags;
        let mut _78: &registers::rflags::RFlags;
        let mut _79: &registers::rflags::RFlags;
        let mut _80: &registers::rflags::RFlags;
        let mut _81: &registers::rflags::RFlags;
        let mut _82: &registers::rflags::RFlags;
        let mut _83: &registers::rflags::RFlags;
        let mut _84: &registers::rflags::RFlags;
        let mut _85: &registers::rflags::RFlags;
        let mut _86: &registers::rflags::RFlags;
        let mut _87: &registers::rflags::RFlags;
        let mut _88: &registers::rflags::RFlags;
        let mut _89: &registers::rflags::RFlags;
        let mut _90: &registers::rflags::RFlags;
        let mut _91: &registers::rflags::RFlags;
        let mut _92: &registers::rflags::RFlags;
        let mut _93: &&str;
        let mut _94: &&str;
        let mut _95: &&str;
        let mut _96: &&str;
        let mut _97: &&str;
        let mut _98: &&str;
        let mut _99: &&str;
        let mut _100: &&str;
        let mut _101: &&str;
        let mut _102: &&str;
        let mut _103: &&str;
        let mut _104: &&str;
        let mut _105: &&str;
        let mut _106: &&str;
        let mut _107: &&str;
        let mut _108: &&str;
        let mut _109: &&str;
        let mut _110: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _110 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _110) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _75 = const _;
        _6 = rflags::_::<impl rflags::RFlags>::bits(_75) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = rflags::_::InternalBitFlags(move _6);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _5);
        goto -> bb73;
    }

    bb4: {
        _8 = &_2;
        _109 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _109) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _76 = const _;
        _10 = rflags::_::<impl rflags::RFlags>::bits(_76) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = rflags::_::InternalBitFlags(move _10);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _9);
        goto -> bb73;
    }

    bb8: {
        _12 = &_2;
        _108 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _108) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _77 = const _;
        _14 = rflags::_::<impl rflags::RFlags>::bits(_77) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = rflags::_::InternalBitFlags(move _14);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _13);
        goto -> bb73;
    }

    bb12: {
        _16 = &_2;
        _107 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _107) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _78 = const _;
        _18 = rflags::_::<impl rflags::RFlags>::bits(_78) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = rflags::_::InternalBitFlags(move _18);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _17);
        goto -> bb73;
    }

    bb16: {
        _20 = &_2;
        _106 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _106) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _79 = const _;
        _22 = rflags::_::<impl rflags::RFlags>::bits(_79) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = rflags::_::InternalBitFlags(move _22);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _21);
        goto -> bb73;
    }

    bb20: {
        _24 = &_2;
        _105 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _105) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _80 = const _;
        _26 = rflags::_::<impl rflags::RFlags>::bits(_80) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = rflags::_::InternalBitFlags(move _26);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _25);
        goto -> bb73;
    }

    bb24: {
        _28 = &_2;
        _104 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _104) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _81 = const _;
        _30 = rflags::_::<impl rflags::RFlags>::bits(_81) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = rflags::_::InternalBitFlags(move _30);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _29);
        goto -> bb73;
    }

    bb28: {
        _32 = &_2;
        _103 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _103) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _82 = const _;
        _34 = rflags::_::<impl rflags::RFlags>::bits(_82) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = rflags::_::InternalBitFlags(move _34);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _33);
        goto -> bb73;
    }

    bb32: {
        _36 = &_2;
        _102 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _102) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _83 = const _;
        _38 = rflags::_::<impl rflags::RFlags>::bits(_83) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = rflags::_::InternalBitFlags(move _38);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _37);
        goto -> bb73;
    }

    bb36: {
        _40 = &_2;
        _101 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _101) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _84 = const _;
        _42 = rflags::_::<impl rflags::RFlags>::bits(_84) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = rflags::_::InternalBitFlags(move _42);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _41);
        goto -> bb73;
    }

    bb40: {
        _44 = &_2;
        _100 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _100) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _85 = const _;
        _46 = rflags::_::<impl rflags::RFlags>::bits(_85) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = rflags::_::InternalBitFlags(move _46);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _45);
        goto -> bb73;
    }

    bb44: {
        _48 = &_2;
        _99 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _99) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _86 = const _;
        _50 = rflags::_::<impl rflags::RFlags>::bits(_86) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = rflags::_::InternalBitFlags(move _50);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _49);
        goto -> bb73;
    }

    bb48: {
        _52 = &_2;
        _98 = const _;
        _51 = <&str as PartialEq>::eq(move _52, _98) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _51) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _87 = const _;
        _54 = rflags::_::<impl rflags::RFlags>::bits(_87) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _53 = rflags::_::InternalBitFlags(move _54);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _53);
        goto -> bb73;
    }

    bb52: {
        _56 = &_2;
        _97 = const _;
        _55 = <&str as PartialEq>::eq(move _56, _97) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _55) -> [0: bb56, otherwise: bb54];
    }

    bb54: {
        _88 = const _;
        _58 = rflags::_::<impl rflags::RFlags>::bits(_88) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _57 = rflags::_::InternalBitFlags(move _58);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _57);
        goto -> bb73;
    }

    bb56: {
        _60 = &_2;
        _96 = const _;
        _59 = <&str as PartialEq>::eq(move _60, _96) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _59) -> [0: bb60, otherwise: bb58];
    }

    bb58: {
        _89 = const _;
        _62 = rflags::_::<impl rflags::RFlags>::bits(_89) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _61 = rflags::_::InternalBitFlags(move _62);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _61);
        goto -> bb73;
    }

    bb60: {
        _64 = &_2;
        _95 = const _;
        _63 = <&str as PartialEq>::eq(move _64, _95) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        switchInt(move _63) -> [0: bb64, otherwise: bb62];
    }

    bb62: {
        _90 = const _;
        _66 = rflags::_::<impl rflags::RFlags>::bits(_90) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _65 = rflags::_::InternalBitFlags(move _66);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _65);
        goto -> bb73;
    }

    bb64: {
        _68 = &_2;
        _94 = const _;
        _67 = <&str as PartialEq>::eq(move _68, _94) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        switchInt(move _67) -> [0: bb68, otherwise: bb66];
    }

    bb66: {
        _91 = const _;
        _70 = rflags::_::<impl rflags::RFlags>::bits(_91) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _69 = rflags::_::InternalBitFlags(move _70);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _69);
        goto -> bb73;
    }

    bb68: {
        _72 = &_2;
        _93 = const _;
        _71 = <&str as PartialEq>::eq(move _72, _93) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        switchInt(move _71) -> [0: bb72, otherwise: bb70];
    }

    bb70: {
        _92 = const _;
        _74 = rflags::_::<impl rflags::RFlags>::bits(_92) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _73 = rflags::_::InternalBitFlags(move _74);
        _0 = Option::<rflags::_::InternalBitFlags>::Some(move _73);
        goto -> bb73;
    }

    bb72: {
        _0 = Option::<rflags::_::InternalBitFlags>::None;
        goto -> bb73;
    }

    bb73: {
        return;
    }
}

promoted[0] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[14] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[16] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[17] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &rflags::RFlags = {
    let mut _0: &registers::rflags::RFlags;
    let mut _1: registers::rflags::RFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[18] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "CARRY_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[19] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PARITY_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[20] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "AUXILIARY_CARRY_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[21] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ZERO_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[22] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SIGN_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[23] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "TRAP_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[24] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "INTERRUPT_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[25] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DIRECTION_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[26] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OVERFLOW_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[27] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IOPL_LOW";
        _0 = &_1;
        return;
    }
}

promoted[28] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "IOPL_HIGH";
        _0 = &_1;
        return;
    }
}

promoted[29] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NESTED_TASK";
        _0 = &_1;
        return;
    }
}

promoted[30] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "RESUME_FLAG";
        _0 = &_1;
        return;
    }
}

promoted[31] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "VIRTUAL_8086_MODE";
        _0 = &_1;
        return;
    }
}

promoted[32] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ALIGNMENT_CHECK";
        _0 = &_1;
        return;
    }
}

promoted[33] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "VIRTUAL_INTERRUPT";
        _0 = &_1;
        return;
    }
}

promoted[34] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "VIRTUAL_INTERRUPT_PENDING";
        _0 = &_1;
        return;
    }
}

promoted[35] in rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ID";
        _0 = &_1;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::rflags::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::rflags::_::InternalBitFlags;
    let _5: registers::rflags::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = rflags::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::rflags::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::rflags::_::InternalBitFlags;
    let _6: registers::rflags::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::rflags::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = rflags::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = rflags::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = rflags::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = rflags::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = rflags::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = rflags::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = rflags::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = rflags::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = rflags::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = rflags::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = rflags::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _3: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = rflags::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _2: registers::rflags::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = rflags::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = rflags::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let _2: registers::rflags::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = rflags::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &rflags::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = rflags::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = rflags::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut rflags::_::InternalBitFlags, _2: rflags::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: rflags::_::InternalBitFlags) -> rflags::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut rflags::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::rflags::_::InternalBitFlags);
        _5 = rflags::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> rflags::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::rflags::_::InternalBitFlags;
    let mut _2: registers::rflags::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <rflags::_::InternalBitFlags as Extend<rflags::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &rflags::_::InternalBitFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;

    bb0: {
        _3 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<rflags::RFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &rflags::_::InternalBitFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: &registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<rflags::RFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &rflags::_::InternalBitFlags) -> IterNames<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;

    bb0: {
        _3 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = rflags::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<rflags::RFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &rflags::_::InternalBitFlags) -> IterNames<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: &registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: &registers::rflags::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = rflags::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<rflags::RFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: rflags::_::InternalBitFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = rflags::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut rflags::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: registers::rflags::_::InternalBitFlags;

    bb0: {
        _1 = rflags::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: registers::rflags::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = rflags::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: registers::rflags::_::InternalBitFlags;

    bb0: {
        _1 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: registers::rflags::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = rflags::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &rflags::RFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &rflags::RFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::rflags::RFlags;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<rflags::RFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::RFlags>;
    let mut _2: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::rflags::RFlags;
    scope 1 {
        debug bits => _1;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<rflags::RFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::rflags::_::InternalBitFlags);
        _5 = rflags::RFlags(_4);
        _0 = Option::<rflags::RFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<rflags::RFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::rflags::RFlags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::rflags::RFlags;
    let mut _8: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<rflags::RFlags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::rflags::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = rflags::RFlags(move _8);
        StorageDead(_8);
        _0 = Option::<rflags::RFlags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let _2: u64;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = rflags::RFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let _2: u64;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = rflags::RFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<rflags::RFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::rflags::RFlags>;
    let mut _2: core::option::Option<registers::rflags::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::rflags::RFlags;
    scope 1 {
        debug name => _1;
        let _4: registers::rflags::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = rflags::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<rflags::RFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::rflags::_::InternalBitFlags);
        _5 = rflags::RFlags(_4);
        _0 = Option::<rflags::RFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::rflags::RFlags;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &rflags::RFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::rflags::RFlags;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::rflags::RFlags;
    let mut _5: &registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::rflags::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &rflags::RFlags, _2: rflags::RFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::rflags::RFlags;
    let mut _5: &registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::rflags::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = rflags::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::rflags::_::InternalBitFlags);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut rflags::RFlags, _2: rflags::RFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::rflags::_::InternalBitFlags);
        _5 = (_2.0: registers::rflags::_::InternalBitFlags);
        _0 = rflags::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::rflags::_::InternalBitFlags);
        _5 = (_2.0: registers::rflags::_::InternalBitFlags);
        _3 = rflags::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let _3: registers::rflags::RFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    let mut _7: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::rflags::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = rflags::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = rflags::RFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::rflags::_::InternalBitFlags);
        _5 = (_2.0: registers::rflags::_::InternalBitFlags);
        _3 = rflags::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let _3: registers::rflags::RFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    let mut _7: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::rflags::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = rflags::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = rflags::RFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::rflags::_::InternalBitFlags);
        _5 = (_2.0: registers::rflags::_::InternalBitFlags);
        _3 = rflags::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let _3: registers::rflags::RFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    let mut _7: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::rflags::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = rflags::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = rflags::RFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::rflags::_::InternalBitFlags);
        _5 = (_2.0: registers::rflags::_::InternalBitFlags);
        _3 = rflags::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;
    let _3: registers::rflags::RFlags;
    let mut _5: registers::rflags::_::InternalBitFlags;
    let mut _6: registers::rflags::_::InternalBitFlags;
    let mut _7: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::rflags::RFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::rflags::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = rflags::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = rflags::RFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::_::InternalBitFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::rflags::_::InternalBitFlags);
        _2 = rflags::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::RFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;
    let _2: registers::rflags::RFlags;
    let mut _3: registers::rflags::_::InternalBitFlags;
    let mut _4: registers::rflags::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::rflags::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = rflags::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = rflags::RFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &rflags::RFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::rflags::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::rflags::_::InternalBitFlags);
        _0 = <rflags::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::<impl rflags::RFlags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::<impl rflags::RFlags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::rflags::RFlags;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;
    let mut _6: &registers::rflags::RFlags;

    bb0: {
        _6 = &(*_1);
        _5 = rflags::_::<impl rflags::RFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = rflags::_::<impl rflags::RFlags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: rflags::RFlags, _2: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut rflags::RFlags, _2: rflags::RFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = rflags::_::<impl rflags::RFlags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: rflags::RFlags) -> rflags::RFlags {
    debug self => _1;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut rflags::RFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::rflags::RFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::rflags::RFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::rflags::RFlags);
        _5 = rflags::_::<impl rflags::RFlags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> rflags::RFlags {
    debug iterator => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: registers::rflags::RFlags;
    let _3: ();
    let mut _4: &mut registers::rflags::RFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = rflags::_::<impl rflags::RFlags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <rflags::RFlags as Extend<rflags::RFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &rflags::RFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;

    bb0: {
        _3 = rflags::_::<impl rflags::RFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = rflags::_::<impl rflags::RFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<rflags::RFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &rflags::RFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: &registers::rflags::RFlags;
    let mut _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: &registers::rflags::RFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = rflags::_::<impl rflags::RFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = rflags::_::<impl rflags::RFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<rflags::RFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &rflags::RFlags) -> IterNames<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: registers::rflags::RFlags;
    let mut _5: u64;

    bb0: {
        _3 = rflags::_::<impl rflags::RFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = rflags::_::<impl rflags::RFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<rflags::RFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &rflags::RFlags) -> IterNames<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::rflags::RFlags>;
    let mut _2: registers::rflags::RFlags;
    let mut _3: u64;
    let mut _4: &registers::rflags::RFlags;
    let mut _5: registers::rflags::RFlags;
    let mut _6: u64;
    let mut _7: &registers::rflags::RFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = rflags::_::<impl rflags::RFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = rflags::_::<impl rflags::RFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<rflags::RFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn rflags::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: rflags::RFlags) -> bitflags::iter::Iter<rflags::RFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::rflags::RFlags>;
    let mut _2: &registers::rflags::RFlags;

    bb0: {
        _2 = &_1;
        _0 = rflags::_::<impl rflags::RFlags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:67:1: 67:12>::from_bits_unchecked(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn rflags::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/rflags.rs:67:1: 67:12>::from_bits_unchecked(_1: u64) -> rflags::RFlags {
    debug bits => _1;
    let mut _0: registers::rflags::RFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn rflags::x86_64::read() -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;
    let mut _1: u64;

    bb0: {
        _1 = read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = rflags::_::<impl rflags::RFlags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn read_raw() -> u64 {
    let mut _0: u64;
    let _1: u64;
    scope 1 {
        debug r => _1;
        scope 2 {
        }
    }

    bb0: {
        asm!("pushfq; pop {0}", out(reg) _1, options(NOMEM | PRESERVES_FLAGS)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn rflags::x86_64::write(_1: rflags::RFlags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::rflags::RFlags;
    let _7: registers::rflags::RFlags;
    let mut _9: u64;
    let mut _10: &registers::rflags::RFlags;
    let _11: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = rflags::_::<impl rflags::RFlags>::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = rflags::_::<impl rflags::RFlags>::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = rflags::_::<impl rflags::RFlags>::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _11 = write_raw(_8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn write_raw(_1: u64) -> () {
    debug val => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        asm!("push {0}; popfq", in(reg) _1, options(NOMEM | PRESERVES_FLAGS)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:10: 67:15>::clone(_1: &SegmentSelector) -> SegmentSelector {
    debug self => _1;
    let mut _0: registers::segmentation::SegmentSelector;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:23: 67:32>::eq(_1: &SegmentSelector, _2: &SegmentSelector) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:34: 67:36>::assert_receiver_is_total_eq(_1: &SegmentSelector) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:38: 67:48>::partial_cmp(_1: &SegmentSelector, _2: &SegmentSelector) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:50: 67:53>::cmp(_1: &SegmentSelector, _2: &SegmentSelector) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:67:55: 67:59>::hash(_1: &SegmentSelector, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::new(_1: u16, _2: PrivilegeLevel) -> SegmentSelector {
    debug index => _1;
    debug rpl => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u16;
    let mut _8: u8;
    let mut _9: bool;

    bb0: {
        _5 = const 3_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 16_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(_1, const 3_i32);
        _8 = discriminant(_2);
        _9 = Le(_8, const 3_u8);
        assume(move _9);
        _7 = _8 as u16 (IntToInt);
        _3 = BitOr(move _4, move _7);
        _0 = SegmentSelector(move _3);
        return;
    }
}

// MIR FOR CTFE
fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::new(_1: u16, _2: PrivilegeLevel) -> SegmentSelector {
    debug index => _1;
    debug rpl => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u16;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u16;
    let _9: PrivilegeLevel;
    let mut _10: u8;
    let mut _11: u8;
    let mut _12: bool;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        _6 = const 3_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 16_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(move _5, const 3_i32);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _2;
        _10 = discriminant(_9);
        _11 = _10 as u8 (IntToInt);
        _12 = Le(_11, const 3_u8);
        assume(move _12);
        _8 = move _10 as u16 (IntToInt);
        StorageDead(_9);
        _3 = BitOr(move _4, move _8);
        StorageDead(_8);
        StorageDead(_4);
        _0 = SegmentSelector(move _3);
        StorageDead(_3);
        return;
    }
}

const registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::NULL: SegmentSelector = {
    let mut _0: registers::segmentation::SegmentSelector;
    let mut _1: PrivilegeLevel;

    bb0: {
        StorageLive(_1);
        _1 = PrivilegeLevel::Ring0;
        ConstEvalCounter;
        _0 = SegmentSelector::new(const 0_u16, move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        StorageDead(_1);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::index(_1: SegmentSelector) -> u16 {
    debug self => _1;
    let mut _0: u16;
    let mut _2: u16;
    let mut _3: u32;
    let mut _4: bool;

    bb0: {
        _2 = (_1.0: u16);
        _3 = const 3_i32 as u32 (IntToInt);
        _4 = Lt(move _3, const 16_u32);
        assert(move _4, "attempt to shift right by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shr(move _2, const 3_i32);
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::rpl(_1: SegmentSelector) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;
    let mut _2: u16;
    let mut _3: &u16;
    let mut _4: core::ops::Range<usize>;

    bb0: {
        _3 = &(_1.0: u16);
        _4 = Range::<usize> { start: const 0_usize, end: const 2_usize };
        _2 = <u16 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PrivilegeLevel::from_u16(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:71:1: 71:21>::set_rpl(_1: &mut SegmentSelector, _2: PrivilegeLevel) -> () {
    debug self => _1;
    debug rpl => _2;
    let mut _0: ();
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: u8;
    let mut _8: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 0_usize, end: const 2_usize };
        _7 = discriminant(_2);
        _8 = Le(_7, const 3_u8);
        assume(move _8);
        _6 = _7 as u16 (IntToInt);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:105:1: 105:36>::fmt(_1: &SegmentSelector, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &u16;
    let _10: u16;
    let mut _11: registers::segmentation::SegmentSelector;
    let _12: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _13: &mut core::fmt::DebugStruct<'_, '_>;
    let _14: &str;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &PrivilegeLevel;
    let _17: PrivilegeLevel;
    let mut _18: registers::segmentation::SegmentSelector;
    let mut _19: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "SegmentSelector";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "index";
        _11 = (*_1);
        _10 = SegmentSelector::index(move _11) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = &mut _3;
        _14 = const "rpl";
        _18 = (*_1);
        _17 = SegmentSelector::rpl(move _18) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _12 = DebugStruct::<'_, '_>::field(move _13, _14, move _15) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:129:10: 129:15>::fmt(_1: &CS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "CS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:143:10: 143:15>::fmt(_1: &SS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "SS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:149:10: 149:15>::fmt(_1: &DS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "DS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:155:10: 155:15>::fmt(_1: &ES, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "ES";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:162:10: 162:15>::fmt(_1: &FS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "FS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn registers::segmentation::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/segmentation.rs:169:10: 169:15>::fmt(_1: &GS, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "GS";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:5:10: 5:15>::fmt(_1: &xcontrol::XCr0, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "XCr0";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:14: 14:23>::eq(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:25: 14:27>::assert_receiver_is_total_eq(_1: &xcontrol::XCr0Flags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:29: 14:39>::partial_cmp(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &registers::xcontrol::_::InternalBitFlags;
    let _4: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:41: 14:44>::cmp(_1: &xcontrol::XCr0Flags, _2: &xcontrol::XCr0Flags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &registers::xcontrol::_::InternalBitFlags;
    let _4: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:46: 14:50>::hash(_1: &xcontrol::XCr0Flags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:52: 14:57>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&registers::xcontrol::_::InternalBitFlags;
    let _6: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = const "XCr0Flags";
        _6 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:14:59: 14:64>::clone(_1: &xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::X87: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SSE: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::AVX: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::YMM: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BNDREG: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BNDCSR: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::OPMASK: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ZMM_HI256: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::HI16_ZMM: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::MPK: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LWP: xcontrol::XCr0Flags = {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 62_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 62_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 62_i32);
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<xcontrol::XCr0Flags>] = {
    let mut _0: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let mut _1: &[bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    let _2: &[bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    let _3: [bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    let mut _4: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _5: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _6: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _7: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _8: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _9: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _10: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _11: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _12: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _13: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _14: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _15: &[bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _15 = const _;
        _2 = &(*_15);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<registers::xcontrol::XCr0Flags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<xcontrol::XCr0Flags>; 11] = {
    let mut _0: &[bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    let mut _1: [bitflags::Flag<registers::xcontrol::XCr0Flags>; 11];
    let mut _2: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _3: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _4: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _5: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _6: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _7: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _8: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _9: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _10: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _11: bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let mut _12: bitflags::Flag<registers::xcontrol::XCr0Flags>;

    bb0: {
        _2 = Flag::<xcontrol::XCr0Flags>::new(const "X87", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<xcontrol::XCr0Flags>::new(const "SSE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<xcontrol::XCr0Flags>::new(const "AVX", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<xcontrol::XCr0Flags>::new(const "YMM", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<xcontrol::XCr0Flags>::new(const "BNDREG", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<xcontrol::XCr0Flags>::new(const "BNDCSR", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<xcontrol::XCr0Flags>::new(const "OPMASK", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<xcontrol::XCr0Flags>::new(const "ZMM_HI256", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<xcontrol::XCr0Flags>::new(const "HI16_ZMM", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<xcontrol::XCr0Flags>::new(const "MPK", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<xcontrol::XCr0Flags>::new(const "LWP", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12];
        _0 = &_1;
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &xcontrol::XCr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const xcontrol::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &xcontrol::_::InternalBitFlags, _2: &xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &xcontrol::_::InternalBitFlags, _2: &xcontrol::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &xcontrol::_::InternalBitFlags, _2: &xcontrol::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &xcontrol::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <xcontrol::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::xcontrol::XCr0Flags;
    let _4: registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = xcontrol::XCr0Flags(move _5);
        _3 = &_4;
        _0 = to_writer::<xcontrol::XCr0Flags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<xcontrol::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<registers::xcontrol::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<registers::xcontrol::XCr0Flags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<xcontrol::XCr0Flags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<xcontrol::XCr0Flags, ParseError>::map::<xcontrol::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: xcontrol::XCr0Flags) -> xcontrol::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &xcontrol::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> xcontrol::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags(const _);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &registers::xcontrol::XCr0Flags;
    let mut _5: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _6: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &registers::xcontrol::XCr0Flags;
    let mut _14: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _15: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &registers::xcontrol::XCr0Flags;
    let mut _23: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _24: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &registers::xcontrol::XCr0Flags;
    let mut _32: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _33: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &registers::xcontrol::XCr0Flags;
    let mut _41: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _42: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &registers::xcontrol::XCr0Flags;
    let mut _50: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _51: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &registers::xcontrol::XCr0Flags;
    let mut _59: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _60: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &registers::xcontrol::XCr0Flags;
    let mut _68: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _69: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &registers::xcontrol::XCr0Flags;
    let mut _77: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _78: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &registers::xcontrol::XCr0Flags;
    let mut _86: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _87: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &registers::xcontrol::XCr0Flags;
    let mut _95: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _96: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let mut _102: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<xcontrol::XCr0Flags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<xcontrol::XCr0Flags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<xcontrol::XCr0Flags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<xcontrol::XCr0Flags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<xcontrol::XCr0Flags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<xcontrol::XCr0Flags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<xcontrol::XCr0Flags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<xcontrol::XCr0Flags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<xcontrol::XCr0Flags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<xcontrol::XCr0Flags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<xcontrol::XCr0Flags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _102 = _1;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _102) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &registers::xcontrol::XCr0Flags;
    let _6: &registers::xcontrol::XCr0Flags;
    let mut _7: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _8: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &registers::xcontrol::XCr0Flags;
    let _18: &registers::xcontrol::XCr0Flags;
    let mut _19: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _20: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &registers::xcontrol::XCr0Flags;
    let _30: &registers::xcontrol::XCr0Flags;
    let mut _31: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _32: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &registers::xcontrol::XCr0Flags;
    let _42: &registers::xcontrol::XCr0Flags;
    let mut _43: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _44: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &registers::xcontrol::XCr0Flags;
    let _54: &registers::xcontrol::XCr0Flags;
    let mut _55: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _56: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &registers::xcontrol::XCr0Flags;
    let _66: &registers::xcontrol::XCr0Flags;
    let mut _67: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _68: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &registers::xcontrol::XCr0Flags;
    let _78: &registers::xcontrol::XCr0Flags;
    let mut _79: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _80: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &registers::xcontrol::XCr0Flags;
    let _90: &registers::xcontrol::XCr0Flags;
    let mut _91: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _92: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &registers::xcontrol::XCr0Flags;
    let _102: &registers::xcontrol::XCr0Flags;
    let mut _103: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _104: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &registers::xcontrol::XCr0Flags;
    let _114: &registers::xcontrol::XCr0Flags;
    let mut _115: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _116: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &registers::xcontrol::XCr0Flags;
    let _126: &registers::xcontrol::XCr0Flags;
    let mut _127: &bitflags::Flag<registers::xcontrol::XCr0Flags>;
    let _128: &[bitflags::Flag<registers::xcontrol::XCr0Flags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let mut _135: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<xcontrol::XCr0Flags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<xcontrol::XCr0Flags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<xcontrol::XCr0Flags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<xcontrol::XCr0Flags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<xcontrol::XCr0Flags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<xcontrol::XCr0Flags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<xcontrol::XCr0Flags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<xcontrol::XCr0Flags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<xcontrol::XCr0Flags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<xcontrol::XCr0Flags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<xcontrol::XCr0Flags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        _135 = _1;
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _135) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        StorageDead(_135);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &xcontrol::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &xcontrol::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<xcontrol::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = xcontrol::_::InternalBitFlags(_1);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<xcontrol::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<xcontrol::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: registers::xcontrol::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = xcontrol::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = xcontrol::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<xcontrol::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> xcontrol::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;
    let _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = xcontrol::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = xcontrol::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> xcontrol::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::_::InternalBitFlags;
    let _7: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = xcontrol::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = xcontrol::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> xcontrol::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = xcontrol::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> xcontrol::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = xcontrol::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<xcontrol::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: registers::xcontrol::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: registers::xcontrol::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: registers::xcontrol::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: registers::xcontrol::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: registers::xcontrol::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: registers::xcontrol::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: registers::xcontrol::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: registers::xcontrol::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: registers::xcontrol::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: registers::xcontrol::_::InternalBitFlags;
    let mut _46: u64;
    scope 1 {
        debug name => _2;
        let mut _47: &registers::xcontrol::XCr0Flags;
        let mut _48: &registers::xcontrol::XCr0Flags;
        let mut _49: &registers::xcontrol::XCr0Flags;
        let mut _50: &registers::xcontrol::XCr0Flags;
        let mut _51: &registers::xcontrol::XCr0Flags;
        let mut _52: &registers::xcontrol::XCr0Flags;
        let mut _53: &registers::xcontrol::XCr0Flags;
        let mut _54: &registers::xcontrol::XCr0Flags;
        let mut _55: &registers::xcontrol::XCr0Flags;
        let mut _56: &registers::xcontrol::XCr0Flags;
        let mut _57: &registers::xcontrol::XCr0Flags;
        let mut _58: &&str;
        let mut _59: &&str;
        let mut _60: &&str;
        let mut _61: &&str;
        let mut _62: &&str;
        let mut _63: &&str;
        let mut _64: &&str;
        let mut _65: &&str;
        let mut _66: &&str;
        let mut _67: &&str;
        let mut _68: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _68 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _68) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _47 = const _;
        _6 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_47) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = xcontrol::_::InternalBitFlags(move _6);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _5);
        goto -> bb45;
    }

    bb4: {
        _8 = &_2;
        _67 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _67) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _48 = const _;
        _10 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_48) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = xcontrol::_::InternalBitFlags(move _10);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _9);
        goto -> bb45;
    }

    bb8: {
        _12 = &_2;
        _66 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _66) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _49 = const _;
        _14 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_49) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = xcontrol::_::InternalBitFlags(move _14);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _13);
        goto -> bb45;
    }

    bb12: {
        _16 = &_2;
        _65 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _65) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _50 = const _;
        _18 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_50) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = xcontrol::_::InternalBitFlags(move _18);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _17);
        goto -> bb45;
    }

    bb16: {
        _20 = &_2;
        _64 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _64) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _51 = const _;
        _22 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_51) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = xcontrol::_::InternalBitFlags(move _22);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _21);
        goto -> bb45;
    }

    bb20: {
        _24 = &_2;
        _63 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _63) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _52 = const _;
        _26 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_52) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = xcontrol::_::InternalBitFlags(move _26);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _25);
        goto -> bb45;
    }

    bb24: {
        _28 = &_2;
        _62 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _62) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _53 = const _;
        _30 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_53) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = xcontrol::_::InternalBitFlags(move _30);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _29);
        goto -> bb45;
    }

    bb28: {
        _32 = &_2;
        _61 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _61) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _54 = const _;
        _34 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_54) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = xcontrol::_::InternalBitFlags(move _34);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _33);
        goto -> bb45;
    }

    bb32: {
        _36 = &_2;
        _60 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _60) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _55 = const _;
        _38 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_55) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = xcontrol::_::InternalBitFlags(move _38);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _37);
        goto -> bb45;
    }

    bb36: {
        _40 = &_2;
        _59 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _59) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _56 = const _;
        _42 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_56) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = xcontrol::_::InternalBitFlags(move _42);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _41);
        goto -> bb45;
    }

    bb40: {
        _44 = &_2;
        _58 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _58) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _57 = const _;
        _46 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_57) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = xcontrol::_::InternalBitFlags(move _46);
        _0 = Option::<xcontrol::_::InternalBitFlags>::Some(move _45);
        goto -> bb45;
    }

    bb44: {
        _0 = Option::<xcontrol::_::InternalBitFlags>::None;
        goto -> bb45;
    }

    bb45: {
        return;
    }
}

promoted[0] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &xcontrol::XCr0Flags = {
    let mut _0: &registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::XCr0Flags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LWP";
        _0 = &_1;
        return;
    }
}

promoted[12] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "MPK";
        _0 = &_1;
        return;
    }
}

promoted[13] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "HI16_ZMM";
        _0 = &_1;
        return;
    }
}

promoted[14] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ZMM_HI256";
        _0 = &_1;
        return;
    }
}

promoted[15] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "OPMASK";
        _0 = &_1;
        return;
    }
}

promoted[16] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BNDCSR";
        _0 = &_1;
        return;
    }
}

promoted[17] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BNDREG";
        _0 = &_1;
        return;
    }
}

promoted[18] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "YMM";
        _0 = &_1;
        return;
    }
}

promoted[19] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "AVX";
        _0 = &_1;
        return;
    }
}

promoted[20] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SSE";
        _0 = &_1;
        return;
    }
}

promoted[21] in xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "X87";
        _0 = &_1;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::xcontrol::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;
    let _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = xcontrol::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::xcontrol::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::xcontrol::_::InternalBitFlags;
    let _6: registers::xcontrol::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &registers::xcontrol::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = xcontrol::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = xcontrol::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = xcontrol::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = xcontrol::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = xcontrol::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = xcontrol::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = xcontrol::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = xcontrol::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = xcontrol::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = xcontrol::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _3: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = xcontrol::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _2: registers::xcontrol::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = xcontrol::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = xcontrol::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let _2: registers::xcontrol::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = xcontrol::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &xcontrol::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = xcontrol::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = xcontrol::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut xcontrol::_::InternalBitFlags, _2: xcontrol::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: xcontrol::_::InternalBitFlags) -> xcontrol::_::InternalBitFlags {
    debug self => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut xcontrol::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::xcontrol::_::InternalBitFlags);
        _5 = xcontrol::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> xcontrol::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: registers::xcontrol::_::InternalBitFlags;
    let mut _2: registers::xcontrol::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <xcontrol::_::InternalBitFlags as Extend<xcontrol::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &xcontrol::_::InternalBitFlags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &xcontrol::_::InternalBitFlags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &xcontrol::_::InternalBitFlags) -> IterNames<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &xcontrol::_::InternalBitFlags) -> IterNames<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = xcontrol::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: xcontrol::_::InternalBitFlags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = xcontrol::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut xcontrol::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _1 = xcontrol::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = xcontrol::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _1 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = xcontrol::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _1);
        StorageDead(_1);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &xcontrol::XCr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &xcontrol::XCr0Flags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &registers::xcontrol::XCr0Flags;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<xcontrol::XCr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _2: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::xcontrol::XCr0Flags;
    scope 1 {
        debug bits => _1;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<xcontrol::XCr0Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::xcontrol::_::InternalBitFlags);
        _5 = xcontrol::XCr0Flags(_4);
        _0 = Option::<xcontrol::XCr0Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<xcontrol::XCr0Flags> {
    debug bits => _1;
    let mut _0: core::option::Option<registers::xcontrol::XCr0Flags>;
    let _2: u64;
    let mut _3: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: registers::xcontrol::XCr0Flags;
    let mut _8: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<xcontrol::XCr0Flags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = xcontrol::XCr0Flags(move _8);
        StorageDead(_8);
        _0 = Option::<xcontrol::XCr0Flags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _2: u64;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _2: u64;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<xcontrol::XCr0Flags> {
    debug name => _1;
    let mut _0: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _2: core::option::Option<registers::xcontrol::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: registers::xcontrol::XCr0Flags;
    scope 1 {
        debug name => _1;
        let _4: registers::xcontrol::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = xcontrol::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<xcontrol::XCr0Flags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: registers::xcontrol::_::InternalBitFlags);
        _5 = xcontrol::XCr0Flags(_4);
        _0 = Option::<xcontrol::XCr0Flags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::xcontrol::XCr0Flags;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &registers::xcontrol::XCr0Flags;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::xcontrol::XCr0Flags;
    let mut _5: &registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &registers::xcontrol::XCr0Flags;
    let mut _5: &registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = xcontrol::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _5 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _0 = xcontrol::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::xcontrol::_::InternalBitFlags);
        _5 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _3 = xcontrol::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _3: registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    let mut _7: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = xcontrol::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = xcontrol::XCr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::xcontrol::_::InternalBitFlags);
        _5 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _3 = xcontrol::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _3: registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    let mut _7: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = xcontrol::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = xcontrol::XCr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::xcontrol::_::InternalBitFlags);
        _5 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _3 = xcontrol::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _3: registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    let mut _7: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = xcontrol::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = xcontrol::XCr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: registers::xcontrol::_::InternalBitFlags);
        _5 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        _3 = xcontrol::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _3: registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::_::InternalBitFlags;
    let mut _6: registers::xcontrol::_::InternalBitFlags;
    let mut _7: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: registers::xcontrol::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = xcontrol::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = xcontrol::XCr0Flags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::_::InternalBitFlags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: registers::xcontrol::_::InternalBitFlags);
        _2 = xcontrol::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::XCr0Flags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let _2: registers::xcontrol::XCr0Flags;
    let mut _3: registers::xcontrol::_::InternalBitFlags;
    let mut _4: registers::xcontrol::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: registers::xcontrol::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = xcontrol::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = xcontrol::XCr0Flags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &xcontrol::XCr0Flags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: registers::xcontrol::_::InternalBitFlags);
        _0 = <xcontrol::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: registers::xcontrol::XCr0Flags;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::XCr0Flags;

    bb0: {
        _6 = &(*_1);
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    debug other => _2;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut xcontrol::XCr0Flags, _2: xcontrol::XCr0Flags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: xcontrol::XCr0Flags) -> xcontrol::XCr0Flags {
    debug self => _1;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut xcontrol::XCr0Flags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<registers::xcontrol::XCr0Flags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: registers::xcontrol::XCr0Flags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: registers::xcontrol::XCr0Flags);
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> xcontrol::XCr0Flags {
    debug iterator => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: registers::xcontrol::XCr0Flags;
    let _3: ();
    let mut _4: &mut registers::xcontrol::XCr0Flags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <xcontrol::XCr0Flags as Extend<xcontrol::XCr0Flags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &xcontrol::XCr0Flags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &xcontrol::XCr0Flags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &xcontrol::XCr0Flags) -> IterNames<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: registers::xcontrol::XCr0Flags;
    let mut _5: u64;

    bb0: {
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &xcontrol::XCr0Flags) -> IterNames<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<registers::xcontrol::XCr0Flags>;
    let mut _2: registers::xcontrol::XCr0Flags;
    let mut _3: u64;
    let mut _4: &registers::xcontrol::XCr0Flags;
    let mut _5: registers::xcontrol::XCr0Flags;
    let mut _6: u64;
    let mut _7: &registers::xcontrol::XCr0Flags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<xcontrol::XCr0Flags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn xcontrol::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: xcontrol::XCr0Flags) -> bitflags::iter::Iter<xcontrol::XCr0Flags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<registers::xcontrol::XCr0Flags>;
    let mut _2: &registers::xcontrol::XCr0Flags;

    bb0: {
        _2 = &_1;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:56:1: 56:15>::from_bits_unchecked(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:56:1: 56:15>::from_bits_unchecked(_1: u64) -> xcontrol::XCr0Flags {
    debug bits => _1;
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:69:5: 69:14>::read() -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;
    let mut _1: u64;

    bb0: {
        _1 = xcontrol::x86_64::<impl xcontrol::XCr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = xcontrol::_::<impl xcontrol::XCr0Flags>::from_bits_truncate(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:69:5: 69:14>::read_raw() -> u64 {
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u64;
    let mut _9: u32;
    scope 1 {
        let _1: u32;
        let _2: u32;
        scope 2 {
            debug low => _1;
            debug high => _2;
        }
    }

    bb0: {
        asm!("xgetbv", in("cx") const 0_i32, out("ax") _1, out("dx") _2, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = _2;
        _4 = move _5 as u64 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Shl(move _4, const 32_i32);
        _9 = _1;
        _8 = move _9 as u64 (IntToInt);
        _0 = BitOr(move _3, move _8);
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:69:5: 69:14>::write(_1: xcontrol::XCr0Flags) -> () {
    debug flags => _1;
    let mut _0: ();
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &registers::xcontrol::XCr0Flags;
    let _7: registers::xcontrol::XCr0Flags;
    let mut _9: u64;
    let mut _10: &registers::xcontrol::XCr0Flags;
    let mut _11: bool;
    let mut _12: &registers::xcontrol::XCr0Flags;
    let mut _13: !;
    let mut _14: bool;
    let mut _15: &registers::xcontrol::XCr0Flags;
    let mut _16: bool;
    let mut _17: &registers::xcontrol::XCr0Flags;
    let mut _18: !;
    let mut _20: bool;
    let mut _21: &registers::xcontrol::XCr0Flags;
    let mut _22: bool;
    let mut _23: &registers::xcontrol::XCr0Flags;
    let mut _24: !;
    let mut _26: registers::xcontrol::XCr0Flags;
    let mut _27: bool;
    let mut _28: &registers::xcontrol::XCr0Flags;
    let mut _29: bool;
    let mut _30: &registers::xcontrol::XCr0Flags;
    let mut _31: !;
    let mut _32: bool;
    let mut _33: &registers::xcontrol::XCr0Flags;
    let mut _34: !;
    let _35: ();
    scope 1 {
        debug old_value => _2;
        let _3: u64;
        scope 2 {
            debug reserved => _3;
            let _8: u64;
            scope 3 {
                debug new_value => _8;
                let _19: registers::xcontrol::XCr0Flags;
                scope 4 {
                    debug mpx => _19;
                    let _25: registers::xcontrol::XCr0Flags;
                    scope 5 {
                        debug avx512 => _25;
                        scope 6 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = xcontrol::x86_64::<impl xcontrol::XCr0>::read_raw() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = xcontrol::_::<impl xcontrol::XCr0Flags>::all() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &_7;
        _5 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Not(move _5);
        _3 = BitAnd(_2, move _4);
        _10 = &_1;
        _9 = xcontrol::_::<impl xcontrol::XCr0Flags>::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = BitOr(_3, move _9);
        _12 = &_1;
        _11 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _12, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _11) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _15 = &_1;
        _14 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _15, const _) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _13 = panic(const "The X87 flag must be set") -> unwind unreachable;
    }

    bb8: {
        switchInt(move _14) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _17 = &_1;
        _16 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _17, const _) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb11, otherwise: bb12];
    }

    bb11: {
        _18 = panic(const "AVX cannot be enabled without enabling SSE") -> unwind unreachable;
    }

    bb12: {
        _19 = <xcontrol::XCr0Flags as BitOr>::bitor(const _, const _) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = &_1;
        _20 = xcontrol::_::<impl xcontrol::XCr0Flags>::intersects(move _21, _19) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        switchInt(move _20) -> [0: bb18, otherwise: bb15];
    }

    bb15: {
        _23 = &_1;
        _22 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _23, _19) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _22) -> [0: bb17, otherwise: bb18];
    }

    bb17: {
        _24 = panic(const "MPX flags XCr0.BNDREG and XCr0.BNDCSR must be set and unset together") -> unwind unreachable;
    }

    bb18: {
        _26 = <xcontrol::XCr0Flags as BitOr>::bitor(const _, const _) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = <xcontrol::XCr0Flags as BitOr>::bitor(move _26, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _28 = &_1;
        _27 = xcontrol::_::<impl xcontrol::XCr0Flags>::intersects(move _28, _25) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _27) -> [0: bb28, otherwise: bb22];
    }

    bb22: {
        _30 = &_1;
        _29 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _30, const _) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        switchInt(move _29) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _33 = &_1;
        _32 = xcontrol::_::<impl xcontrol::XCr0Flags>::contains(move _33, _25) -> [return: bb26, unwind unreachable];
    }

    bb25: {
        _31 = panic(const "AVX-512 cannot be enabled without enabling AVX") -> unwind unreachable;
    }

    bb26: {
        switchInt(move _32) -> [0: bb27, otherwise: bb28];
    }

    bb27: {
        _34 = panic(const "AVX-512 flags XCR0.opmask, XCR0.ZMM_Hi256, and XCR0.Hi16_ZMM must be set and unset together") -> unwind unreachable;
    }

    bb28: {
        _35 = xcontrol::x86_64::<impl xcontrol::XCr0>::write_raw(_8) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        return;
    }
}

fn xcontrol::x86_64::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/registers/xcontrol.rs:69:5: 69:14>::write_raw(_1: u64) -> () {
    debug value => _1;
    let mut _0: ();
    let _2: u32;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    scope 1 {
        debug low => _2;
        let _3: u32;
        scope 2 {
            debug high => _3;
            scope 3 {
            }
        }
    }

    bb0: {
        _2 = _1 as u32 (IntToInt);
        _5 = const 32_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 32_i32);
        _3 = move _4 as u32 (IntToInt);
        asm!("xsetbv", in("cx") const 0_i32, in("ax") _2, in("dx") _3, options(NOMEM | PRESERVES_FLAGS | NOSTACK)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

GlobalDescriptorTable::table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:47:10: 47:15>::fmt(_1: &GlobalDescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &[u64; 8];
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&usize;
    let _10: &usize;

    bb0: {
        _3 = const "GlobalDescriptorTable";
        _4 = const "table";
        _6 = &((*_1).0: [u64; 8]);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "len";
        _10 = &((*_1).1: usize);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:47:17: 47:22>::clone(_1: &GlobalDescriptorTable) -> GlobalDescriptorTable {
    debug self => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _2: [u64; 8];
    let _3: &[u64; 8];
    let mut _4: usize;
    let _5: &usize;

    bb0: {
        _3 = &((*_1).0: [u64; 8]);
        _2 = (*_3);
        _5 = &((*_1).1: usize);
        _4 = (*_5);
        _0 = GlobalDescriptorTable { table: move _2, len: move _4 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::new() -> GlobalDescriptorTable {
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _1: [u64; 8];

    bb0: {
        _1 = [const 0_u64; 8];
        _0 = GlobalDescriptorTable { table: move _1, len: const 1_usize };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::new() -> GlobalDescriptorTable {
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let mut _1: [u64; 8];

    bb0: {
        StorageLive(_1);
        _1 = [const 0_u64; 8];
        _0 = GlobalDescriptorTable { table: move _1, len: const 1_usize };
        StorageDead(_1);
        return;
    }
}

gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice(_1: &[u64]) -> GlobalDescriptorTable {
    debug slice => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let _2: usize;
    let mut _5: bool;
    let mut _6: !;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: u64;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let _13: usize;
    let mut _14: usize;
    let mut _15: bool;
    let mut _16: (usize, bool);
    let mut _17: [u64; 8];
    scope 1 {
        debug len => _2;
        let mut _3: [u64; 8];
        scope 2 {
            debug table => _3;
            let mut _4: usize;
            scope 3 {
                debug idx => _4;
            }
        }
    }

    bb0: {
        _2 = Len((*_1));
        _3 = [const 0_u64; 8];
        _4 = const 0_usize;
        _5 = Le(_2, const 8_usize);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = panic(const "initializing a GDT from a slice requires it to be **at most** 8 elements.") -> unwind unreachable;
    }

    bb2: {
        _8 = _4;
        _7 = Lt(move _8, _2);
        switchInt(move _7) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _10 = _4;
        _11 = Len((*_1));
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _9 = (*_1)[_10];
        _13 = _4;
        _14 = const 8_usize;
        _15 = Lt(_13, _14);
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _13) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3[_13] = move _9;
        _16 = CheckedAdd(_4, const 1_usize);
        assert(!move (_16.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _4 = move (_16.0: usize);
        goto -> bb2;
    }

    bb7: {
        _17 = _3;
        _0 = GlobalDescriptorTable { table: move _17, len: _2 };
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice(_1: &[u64]) -> GlobalDescriptorTable {
    debug slice => _1;
    let mut _0: structures::gdt::GlobalDescriptorTable;
    let _2: usize;
    let mut _3: &[u64];
    let _6: ();
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: !;
    let _10: ();
    let mut _11: ();
    let mut _12: bool;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: u64;
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: (usize, bool);
    let mut _23: !;
    let _24: ();
    let mut _25: !;
    let mut _26: [u64; 8];
    let mut _27: usize;
    scope 1 {
        debug len => _2;
        let mut _4: [u64; 8];
        scope 2 {
            debug table => _4;
            let mut _5: usize;
            scope 3 {
                debug idx => _5;
            }
        }
    }

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = &(*_1);
        ConstEvalCounter;
        _2 = slice::<impl [u64]>::len(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_4);
        _4 = [const 0_u64; 8];
        StorageLive(_5);
        _5 = const 0_usize;
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _2;
        _7 = Le(move _8, const 8_usize);
        switchInt(move _7) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        _6 = const ();
        StorageDead(_7);
        StorageDead(_6);
        StorageLive(_10);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageLive(_9);
        ConstEvalCounter;
        _9 = panic(const "initializing a GDT from a slice requires it to be **at most** 8 elements.") -> unwind unreachable;
    }

    bb4: {
        StorageLive(_12);
        StorageLive(_13);
        _13 = _5;
        StorageLive(_14);
        _14 = _2;
        _12 = Lt(move _13, move _14);
        switchInt(move _12) -> [0: bb9, otherwise: bb5];
    }

    bb5: {
        StorageDead(_14);
        StorageDead(_13);
        StorageLive(_15);
        StorageLive(_16);
        _16 = _5;
        _17 = Len((*_1));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _15 = (*_1)[_16];
        StorageLive(_19);
        _19 = _5;
        _20 = Len(_4);
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _4[_19] = move _15;
        StorageDead(_15);
        StorageDead(_19);
        StorageDead(_16);
        _22 = CheckedAdd(_5, const 1_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _5 = move (_22.0: usize);
        _11 = const ();
        StorageDead(_12);
        ConstEvalCounter;
        goto -> bb4;
    }

    bb9: {
        StorageDead(_14);
        StorageDead(_13);
        StorageLive(_24);
        _10 = const ();
        StorageDead(_24);
        StorageDead(_12);
        StorageDead(_10);
        StorageLive(_26);
        _26 = _4;
        StorageLive(_27);
        _27 = _2;
        _0 = GlobalDescriptorTable { table: move _26, len: move _27 };
        StorageDead(_27);
        StorageDead(_26);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_2);
        return;
    }
}

gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::from_raw_slice::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::as_raw_slice(_1: &GlobalDescriptorTable) -> &[u64] {
    debug self => _1;
    let mut _0: &[u64];
    let mut _2: &[u64; 8];
    let mut _3: core::ops::RangeTo<usize>;
    let mut _4: usize;

    bb0: {
        _2 = &((*_1).0: [u64; 8]);
        _4 = ((*_1).1: usize);
        _3 = RangeTo::<usize> { end: move _4 };
        _0 = <[u64; 8] as Index<RangeTo<usize>>>::index(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::add_entry(_1: &mut GlobalDescriptorTable, _2: Descriptor) -> SegmentSelector {
    debug self => _1;
    debug entry => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let _3: usize;
    let mut _4: isize;
    let _5: u64;
    let mut _6: bool;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: &[u64];
    let mut _11: &[u64; 8];
    let mut _12: !;
    let _13: u64;
    let _14: u64;
    let mut _15: bool;
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: &[u64];
    let mut _20: &[u64; 8];
    let mut _21: !;
    let _23: usize;
    let mut _24: u16;
    let mut _25: usize;
    let mut _26: PrivilegeLevel;
    scope 1 {
        debug index => _3;
    }
    scope 2 {
        debug value => _5;
    }
    scope 3 {
        debug value_low => _13;
        debug value_high => _14;
        let _22: usize;
        scope 4 {
            debug index => _22;
        }
    }

    bb0: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb14];
    }

    bb1: {
        _13 = ((_2 as SystemSegment).0: u64);
        _14 = ((_2 as SystemSegment).1: u64);
        _16 = ((*_1).1: usize);
        _20 = &((*_1).0: [u64; 8]);
        _19 = move _20 as &[u64] (PointerCoercion(Unsize));
        _18 = Len((*_19));
        _17 = core::num::<impl usize>::saturating_sub(move _18, const 2_usize) -> [return: bb6, unwind unreachable];
    }

    bb2: {
        _5 = ((_2 as UserSegment).0: u64);
        _7 = ((*_1).1: usize);
        _11 = &((*_1).0: [u64; 8]);
        _10 = move _11 as &[u64] (PointerCoercion(Unsize));
        _9 = Len((*_10));
        _8 = core::num::<impl usize>::saturating_sub(move _9, const 1_usize) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Gt(move _7, move _8);
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _12 = panic(const "GDT full") -> unwind unreachable;
    }

    bb5: {
        _3 = GlobalDescriptorTable::push(_1, _5) -> [return: bb11, unwind unreachable];
    }

    bb6: {
        _15 = Gt(move _16, move _17);
        switchInt(move _15) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _21 = panic(const "GDT requires two free spaces to hold a SystemSegment") -> unwind unreachable;
    }

    bb8: {
        _22 = GlobalDescriptorTable::push(_1, _13) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _23 = GlobalDescriptorTable::push(_1, _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _3 = _22;
        goto -> bb11;
    }

    bb11: {
        _25 = _3;
        _24 = move _25 as u16 (IntToInt);
        _26 = Descriptor::dpl(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _0 = SegmentSelector::new(move _24, move _26) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        return;
    }

    bb14: {
        unreachable;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::add_entry(_1: &mut GlobalDescriptorTable, _2: Descriptor) -> SegmentSelector {
    debug self => _1;
    debug entry => _2;
    let mut _0: registers::segmentation::SegmentSelector;
    let _3: usize;
    let mut _4: isize;
    let _5: u64;
    let _6: ();
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &[u64];
    let mut _12: &[u64; 8];
    let mut _13: !;
    let mut _14: &mut structures::gdt::GlobalDescriptorTable;
    let mut _15: u64;
    let _16: u64;
    let _17: u64;
    let _18: ();
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: &[u64];
    let mut _24: &[u64; 8];
    let mut _25: !;
    let mut _27: &mut structures::gdt::GlobalDescriptorTable;
    let mut _28: u64;
    let _29: usize;
    let mut _30: &mut structures::gdt::GlobalDescriptorTable;
    let mut _31: u64;
    let mut _32: u16;
    let mut _33: usize;
    let mut _34: PrivilegeLevel;
    let mut _35: structures::gdt::Descriptor;
    scope 1 {
        debug index => _3;
    }
    scope 2 {
        debug value => _5;
    }
    scope 3 {
        debug value_low => _16;
        debug value_high => _17;
        let _26: usize;
        scope 4 {
            debug index => _26;
        }
    }

    bb0: {
        StorageLive(_3);
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        StorageLive(_16);
        _16 = ((_2 as SystemSegment).0: u64);
        StorageLive(_17);
        _17 = ((_2 as SystemSegment).1: u64);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = ((*_1).1: usize);
        StorageLive(_21);
        StorageLive(_22);
        StorageLive(_23);
        StorageLive(_24);
        _24 = &((*_1).0: [u64; 8]);
        _23 = move _24 as &[u64] (PointerCoercion(Unsize));
        StorageDead(_24);
        ConstEvalCounter;
        _22 = slice::<impl [u64]>::len(move _23) -> [return: bb9, unwind unreachable];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_5);
        _5 = ((_2 as UserSegment).0: u64);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = ((*_1).1: usize);
        StorageLive(_9);
        StorageLive(_10);
        StorageLive(_11);
        StorageLive(_12);
        _12 = &((*_1).0: [u64; 8]);
        _11 = move _12 as &[u64] (PointerCoercion(Unsize));
        StorageDead(_12);
        ConstEvalCounter;
        _10 = slice::<impl [u64]>::len(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_11);
        ConstEvalCounter;
        _9 = core::num::<impl usize>::saturating_sub(move _10, const 1_usize) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_10);
        _7 = Gt(move _8, move _9);
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_9);
        StorageDead(_8);
        StorageLive(_13);
        ConstEvalCounter;
        _13 = panic(const "GDT full") -> unwind unreachable;
    }

    bb7: {
        StorageDead(_9);
        StorageDead(_8);
        _6 = const ();
        StorageDead(_7);
        StorageDead(_6);
        StorageLive(_14);
        _14 = &mut (*_1);
        StorageLive(_15);
        _15 = _5;
        ConstEvalCounter;
        _3 = GlobalDescriptorTable::push(move _14, move _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        StorageDead(_15);
        StorageDead(_14);
        StorageDead(_5);
        goto -> bb15;
    }

    bb9: {
        StorageDead(_23);
        ConstEvalCounter;
        _21 = core::num::<impl usize>::saturating_sub(move _22, const 2_usize) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        StorageDead(_22);
        _19 = Gt(move _20, move _21);
        switchInt(move _19) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        StorageDead(_21);
        StorageDead(_20);
        StorageLive(_25);
        ConstEvalCounter;
        _25 = panic(const "GDT requires two free spaces to hold a SystemSegment") -> unwind unreachable;
    }

    bb12: {
        StorageDead(_21);
        StorageDead(_20);
        _18 = const ();
        StorageDead(_19);
        StorageDead(_18);
        StorageLive(_26);
        StorageLive(_27);
        _27 = &mut (*_1);
        StorageLive(_28);
        _28 = _16;
        ConstEvalCounter;
        _26 = GlobalDescriptorTable::push(move _27, move _28) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_29);
        StorageLive(_30);
        _30 = &mut (*_1);
        StorageLive(_31);
        _31 = _17;
        ConstEvalCounter;
        _29 = GlobalDescriptorTable::push(move _30, move _31) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        StorageDead(_31);
        StorageDead(_30);
        StorageDead(_29);
        _3 = _26;
        StorageDead(_26);
        StorageDead(_17);
        StorageDead(_16);
        goto -> bb15;
    }

    bb15: {
        StorageLive(_32);
        StorageLive(_33);
        _33 = _3;
        _32 = move _33 as u16 (IntToInt);
        StorageDead(_33);
        StorageLive(_34);
        StorageLive(_35);
        _35 = _2;
        ConstEvalCounter;
        _34 = Descriptor::dpl(move _35) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        StorageDead(_35);
        ConstEvalCounter;
        _0 = SegmentSelector::new(move _32, move _34) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        StorageDead(_34);
        StorageDead(_32);
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::load(_1: &GlobalDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    scope 1 {
    }

    bb0: {
        _2 = GlobalDescriptorTable::load_unsafe(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::load_unsafe(_1: &GlobalDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let _3: &structures::DescriptorTablePointer;
    let _4: structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _4 = GlobalDescriptorTable::pointer(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = lgdt(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::push(_1: &mut GlobalDescriptorTable, _2: u64) -> usize {
    debug self => _1;
    debug value => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: bool;
    let mut _5: (usize, bool);
    scope 1 {
        debug index => _0;
    }

    bb0: {
        _0 = ((*_1).1: usize);
        _3 = const 8_usize;
        _4 = Lt(_0, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _0) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: [u64; 8])[_0] = _2;
        _5 = CheckedAdd(((*_1).1: usize), const 1_usize);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).1: usize), const 1_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        ((*_1).1: usize) = move (_5.0: usize);
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::push(_1: &mut GlobalDescriptorTable, _2: u64) -> usize {
    debug self => _1;
    debug value => _2;
    let mut _0: usize;
    let _3: usize;
    let mut _4: u64;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: (usize, bool);
    scope 1 {
        debug index => _3;
    }

    bb0: {
        StorageLive(_3);
        _3 = ((*_1).1: usize);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = _3;
        _6 = Len(((*_1).0: [u64; 8]));
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: [u64; 8])[_5] = move _4;
        StorageDead(_4);
        StorageDead(_5);
        _8 = CheckedAdd(((*_1).1: usize), const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).1: usize), const 1_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        ((*_1).1: usize) = move (_8.0: usize);
        _0 = _3;
        StorageDead(_3);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:53:1: 53:27>::pointer(_1: &GlobalDescriptorTable) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: *const u64;
    let mut _5: &[u64];
    let mut _6: &[u64; 8];
    let mut _7: u16;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: (usize, bool);
    let mut _13: (usize, bool);

    bb0: {
        _6 = &((*_1).0: [u64; 8]);
        _5 = move _6 as &[u64] (PointerCoercion(Unsize));
        _4 = slice::<impl [u64]>::as_ptr(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _4 as u64 (PointerExposeAddress);
        _2 = addr::VirtAddr::new(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = ((*_1).1: usize);
        _11 = core::mem::size_of::<u64>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = CheckedMul(_10, _11);
        assert(!move (_12.1: bool), "attempt to compute `{} * {}`, which would overflow", move _10, move _11) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _9 = move (_12.0: usize);
        _13 = CheckedSub(_9, const 1_usize);
        assert(!move (_13.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = move (_13.0: usize);
        _7 = move _8 as u16 (IntToInt);
        _0 = DescriptorTablePointer { limit: move _7, base: move _2 };
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:177:10: 177:15>::fmt(_1: &Descriptor, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &u64;
    let _5: &str;
    let mut _6: &dyn core::fmt::Debug;
    let _7: &&u64;
    let _8: &u64;
    let _9: &u64;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &&u64;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
        debug __self_1 => _9;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _8 = &(((*_1) as SystemSegment).0: u64);
        _9 = &(((*_1) as SystemSegment).1: u64);
        _10 = const "SystemSegment";
        _11 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = &_9;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _10, move _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _4 = &(((*_1) as UserSegment).0: u64);
        _5 = const "UserSegment";
        _7 = &_4;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:177:17: 177:22>::clone(_1: &Descriptor) -> Descriptor {
    debug self => _1;
    let mut _0: structures::gdt::Descriptor;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:14: 190:23>::eq(_1: &DescriptorFlags, _2: &DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    let mut _4: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:25: 190:27>::assert_receiver_is_total_eq(_1: &DescriptorFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:29: 190:39>::partial_cmp(_1: &DescriptorFlags, _2: &DescriptorFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &structures::gdt::_::InternalBitFlags;
    let _4: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:41: 190:44>::cmp(_1: &DescriptorFlags, _2: &DescriptorFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &structures::gdt::_::InternalBitFlags;
    let _4: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:46: 190:50>::hash(_1: &DescriptorFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:52: 190:57>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&structures::gdt::_::InternalBitFlags;
    let _6: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = const "DescriptorFlags";
        _6 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:190:59: 190:64>::clone(_1: &DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ACCESSED: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 40_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 40_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 40_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::WRITABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 41_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 41_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 41_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::CONFORMING: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 42_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 42_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 42_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::EXECUTABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 43_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 43_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 43_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::USER_SEGMENT: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 44_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 44_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 44_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DPL_RING_3: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 45_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 45_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 3_u64, const 45_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PRESENT: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 47_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 47_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 47_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::AVAILABLE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 52_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 52_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LONG_MODE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 53_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 53_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DEFAULT_SIZE: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 54_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 54_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 54_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GRANULARITY: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 55_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 55_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 55_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LIMIT_0_15: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(const 65535_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::LIMIT_16_19: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 48_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 48_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 15_u64, const 48_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BASE_0_23: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 16_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 16777215_u64, const 16_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BASE_24_31: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 56_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 56_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 255_u64, const 56_i32);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<DescriptorFlags>] = {
    let mut _0: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let mut _1: &[bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    let _2: &[bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    let _3: [bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    let mut _4: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _5: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _6: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _7: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _8: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _9: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _10: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _11: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _12: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _13: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _14: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _15: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _16: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _17: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _18: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _19: &[bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _19 = const _;
        _2 = &(*_19);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<structures::gdt::DescriptorFlags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<DescriptorFlags>; 15] = {
    let mut _0: &[bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    let mut _1: [bitflags::Flag<structures::gdt::DescriptorFlags>; 15];
    let mut _2: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _3: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _4: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _5: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _6: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _7: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _8: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _9: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _10: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _11: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _12: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _13: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _14: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _15: bitflags::Flag<structures::gdt::DescriptorFlags>;
    let mut _16: bitflags::Flag<structures::gdt::DescriptorFlags>;

    bb0: {
        _2 = Flag::<DescriptorFlags>::new(const "ACCESSED", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<DescriptorFlags>::new(const "WRITABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<DescriptorFlags>::new(const "CONFORMING", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<DescriptorFlags>::new(const "EXECUTABLE", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<DescriptorFlags>::new(const "USER_SEGMENT", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<DescriptorFlags>::new(const "DPL_RING_3", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<DescriptorFlags>::new(const "PRESENT", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<DescriptorFlags>::new(const "AVAILABLE", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<DescriptorFlags>::new(const "LONG_MODE", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<DescriptorFlags>::new(const "DEFAULT_SIZE", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<DescriptorFlags>::new(const "GRANULARITY", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<DescriptorFlags>::new(const "LIMIT_0_15", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Flag::<DescriptorFlags>::new(const "LIMIT_16_19", const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Flag::<DescriptorFlags>::new(const "BASE_0_23", const _) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Flag::<DescriptorFlags>::new(const "BASE_24_31", const _) -> [return: bb15, unwind continue];
    }

    bb15: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16];
        _0 = &_1;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &DescriptorFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const gdt::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &gdt::_::InternalBitFlags, _2: &gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &gdt::_::InternalBitFlags, _2: &gdt::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &gdt::_::InternalBitFlags, _2: &gdt::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &gdt::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = gdt::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <gdt::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = DescriptorFlags(move _5);
        _3 = &_4;
        _0 = to_writer::<DescriptorFlags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<gdt::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<structures::gdt::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<structures::gdt::DescriptorFlags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<DescriptorFlags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<DescriptorFlags, ParseError>::map::<gdt::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: DescriptorFlags) -> gdt::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: structures::gdt::_::InternalBitFlags);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &gdt::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> gdt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags(const _);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &structures::gdt::DescriptorFlags;
    let mut _5: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _6: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &structures::gdt::DescriptorFlags;
    let mut _14: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _15: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &structures::gdt::DescriptorFlags;
    let mut _23: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _24: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &structures::gdt::DescriptorFlags;
    let mut _32: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _33: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &structures::gdt::DescriptorFlags;
    let mut _41: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _42: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &structures::gdt::DescriptorFlags;
    let mut _50: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _51: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &structures::gdt::DescriptorFlags;
    let mut _59: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _60: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &structures::gdt::DescriptorFlags;
    let mut _68: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _69: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &structures::gdt::DescriptorFlags;
    let mut _77: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _78: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &structures::gdt::DescriptorFlags;
    let mut _86: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _87: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &structures::gdt::DescriptorFlags;
    let mut _95: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _96: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let _103: &structures::gdt::DescriptorFlags;
    let mut _104: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _105: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _112: &structures::gdt::DescriptorFlags;
    let mut _113: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _114: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: u64;
    let mut _119: (usize, bool);
    let _121: &structures::gdt::DescriptorFlags;
    let mut _122: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _123: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _124: usize;
    let mut _125: usize;
    let mut _126: bool;
    let mut _127: u64;
    let mut _128: (usize, bool);
    let _130: &structures::gdt::DescriptorFlags;
    let mut _131: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _132: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _133: usize;
    let mut _134: usize;
    let mut _135: bool;
    let mut _136: u64;
    let mut _137: (usize, bool);
    let mut _138: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            let _102: u64;
            let _111: u64;
            let _120: u64;
            let _129: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
                debug flag => _111;
            }
            scope 16 {
                debug flag => _120;
            }
            scope 17 {
                debug flag => _129;
            }
            scope 18 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<DescriptorFlags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::<impl DescriptorFlags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<DescriptorFlags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = gdt::_::<impl DescriptorFlags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<DescriptorFlags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = gdt::_::<impl DescriptorFlags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<DescriptorFlags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = gdt::_::<impl DescriptorFlags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<DescriptorFlags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = gdt::_::<impl DescriptorFlags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<DescriptorFlags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = gdt::_::<impl DescriptorFlags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<DescriptorFlags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = gdt::_::<impl DescriptorFlags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<DescriptorFlags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = gdt::_::<impl DescriptorFlags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<DescriptorFlags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = gdt::_::<impl DescriptorFlags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<DescriptorFlags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = gdt::_::<impl DescriptorFlags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<DescriptorFlags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = gdt::_::<impl DescriptorFlags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<DescriptorFlags>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = gdt::_::<impl DescriptorFlags>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _114 = const _;
        _115 = _2;
        _116 = Len((*_114));
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _113 = &(*_114)[_115];
        _112 = Flag::<DescriptorFlags>::value(move _113) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _111 = gdt::_::<impl DescriptorFlags>::bits(_112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _118 = _1;
        _1 = BitOr(move _118, _111);
        _119 = CheckedAdd(_2, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_119.0: usize);
        _123 = const _;
        _124 = _2;
        _125 = Len((*_123));
        _126 = Lt(_124, _125);
        assert(move _126, "index out of bounds: the length is {} but the index is {}", move _125, _124) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _122 = &(*_123)[_124];
        _121 = Flag::<DescriptorFlags>::value(move _122) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _120 = gdt::_::<impl DescriptorFlags>::bits(_121) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = _1;
        _1 = BitOr(move _127, _120);
        _128 = CheckedAdd(_2, const 1_usize);
        assert(!move (_128.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_128.0: usize);
        _132 = const _;
        _133 = _2;
        _134 = Len((*_132));
        _135 = Lt(_133, _134);
        assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _133) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _131 = &(*_132)[_133];
        _130 = Flag::<DescriptorFlags>::value(move _131) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _129 = gdt::_::<impl DescriptorFlags>::bits(_130) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _136 = _1;
        _1 = BitOr(move _136, _129);
        _137 = CheckedAdd(_2, const 1_usize);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_137.0: usize);
        _138 = _1;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _138) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &structures::gdt::DescriptorFlags;
    let _6: &structures::gdt::DescriptorFlags;
    let mut _7: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _8: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &structures::gdt::DescriptorFlags;
    let _18: &structures::gdt::DescriptorFlags;
    let mut _19: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _20: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &structures::gdt::DescriptorFlags;
    let _30: &structures::gdt::DescriptorFlags;
    let mut _31: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _32: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &structures::gdt::DescriptorFlags;
    let _42: &structures::gdt::DescriptorFlags;
    let mut _43: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _44: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &structures::gdt::DescriptorFlags;
    let _54: &structures::gdt::DescriptorFlags;
    let mut _55: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _56: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &structures::gdt::DescriptorFlags;
    let _66: &structures::gdt::DescriptorFlags;
    let mut _67: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _68: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &structures::gdt::DescriptorFlags;
    let _78: &structures::gdt::DescriptorFlags;
    let mut _79: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _80: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &structures::gdt::DescriptorFlags;
    let _90: &structures::gdt::DescriptorFlags;
    let mut _91: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _92: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &structures::gdt::DescriptorFlags;
    let _102: &structures::gdt::DescriptorFlags;
    let mut _103: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _104: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &structures::gdt::DescriptorFlags;
    let _114: &structures::gdt::DescriptorFlags;
    let mut _115: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _116: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &structures::gdt::DescriptorFlags;
    let _126: &structures::gdt::DescriptorFlags;
    let mut _127: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _128: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &structures::gdt::DescriptorFlags;
    let _138: &structures::gdt::DescriptorFlags;
    let mut _139: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _140: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u64;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _147: ();
    let mut _149: &structures::gdt::DescriptorFlags;
    let _150: &structures::gdt::DescriptorFlags;
    let mut _151: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _152: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: (usize, bool);
    let _159: ();
    let mut _161: &structures::gdt::DescriptorFlags;
    let _162: &structures::gdt::DescriptorFlags;
    let mut _163: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _164: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _165: usize;
    let mut _166: usize;
    let mut _167: bool;
    let mut _168: u64;
    let mut _169: u64;
    let mut _170: (usize, bool);
    let _171: ();
    let mut _173: &structures::gdt::DescriptorFlags;
    let _174: &structures::gdt::DescriptorFlags;
    let mut _175: &bitflags::Flag<structures::gdt::DescriptorFlags>;
    let _176: &[bitflags::Flag<structures::gdt::DescriptorFlags>];
    let _177: usize;
    let mut _178: usize;
    let mut _179: bool;
    let mut _180: u64;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let mut _183: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            let _136: u64;
            let _148: u64;
            let _160: u64;
            let _172: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
                debug flag => _148;
            }
            scope 16 {
                debug flag => _160;
            }
            scope 17 {
                debug flag => _172;
            }
            scope 18 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<DescriptorFlags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = gdt::_::<impl DescriptorFlags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<DescriptorFlags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = gdt::_::<impl DescriptorFlags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<DescriptorFlags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = gdt::_::<impl DescriptorFlags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<DescriptorFlags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = gdt::_::<impl DescriptorFlags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<DescriptorFlags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = gdt::_::<impl DescriptorFlags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<DescriptorFlags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = gdt::_::<impl DescriptorFlags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<DescriptorFlags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = gdt::_::<impl DescriptorFlags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<DescriptorFlags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = gdt::_::<impl DescriptorFlags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<DescriptorFlags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = gdt::_::<impl DescriptorFlags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<DescriptorFlags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = gdt::_::<impl DescriptorFlags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<DescriptorFlags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = gdt::_::<impl DescriptorFlags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<DescriptorFlags>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = gdt::_::<impl DescriptorFlags>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        StorageLive(_148);
        StorageLive(_149);
        StorageLive(_150);
        StorageLive(_151);
        StorageLive(_152);
        _152 = const _;
        StorageLive(_153);
        _153 = _2;
        _154 = Len((*_152));
        _155 = Lt(_153, _154);
        assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _153) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _151 = &(*_152)[_153];
        ConstEvalCounter;
        _150 = Flag::<DescriptorFlags>::value(move _151) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _149 = &(*_150);
        StorageDead(_151);
        ConstEvalCounter;
        _148 = gdt::_::<impl DescriptorFlags>::bits(move _149) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        StorageDead(_149);
        StorageDead(_153);
        StorageDead(_152);
        StorageDead(_150);
        StorageLive(_156);
        _156 = _1;
        StorageLive(_157);
        _157 = _148;
        _1 = BitOr(move _156, move _157);
        StorageDead(_157);
        StorageDead(_156);
        _158 = CheckedAdd(_2, const 1_usize);
        assert(!move (_158.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_158.0: usize);
        _147 = const ();
        StorageDead(_148);
        StorageDead(_147);
        StorageLive(_159);
        StorageLive(_160);
        StorageLive(_161);
        StorageLive(_162);
        StorageLive(_163);
        StorageLive(_164);
        _164 = const _;
        StorageLive(_165);
        _165 = _2;
        _166 = Len((*_164));
        _167 = Lt(_165, _166);
        assert(move _167, "index out of bounds: the length is {} but the index is {}", move _166, _165) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _163 = &(*_164)[_165];
        ConstEvalCounter;
        _162 = Flag::<DescriptorFlags>::value(move _163) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _161 = &(*_162);
        StorageDead(_163);
        ConstEvalCounter;
        _160 = gdt::_::<impl DescriptorFlags>::bits(move _161) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        StorageDead(_161);
        StorageDead(_165);
        StorageDead(_164);
        StorageDead(_162);
        StorageLive(_168);
        _168 = _1;
        StorageLive(_169);
        _169 = _160;
        _1 = BitOr(move _168, move _169);
        StorageDead(_169);
        StorageDead(_168);
        _170 = CheckedAdd(_2, const 1_usize);
        assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_170.0: usize);
        _159 = const ();
        StorageDead(_160);
        StorageDead(_159);
        StorageLive(_171);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        StorageLive(_175);
        StorageLive(_176);
        _176 = const _;
        StorageLive(_177);
        _177 = _2;
        _178 = Len((*_176));
        _179 = Lt(_177, _178);
        assert(move _179, "index out of bounds: the length is {} but the index is {}", move _178, _177) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _175 = &(*_176)[_177];
        ConstEvalCounter;
        _174 = Flag::<DescriptorFlags>::value(move _175) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _173 = &(*_174);
        StorageDead(_175);
        ConstEvalCounter;
        _172 = gdt::_::<impl DescriptorFlags>::bits(move _173) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        StorageDead(_173);
        StorageDead(_177);
        StorageDead(_176);
        StorageDead(_174);
        StorageLive(_180);
        _180 = _1;
        StorageLive(_181);
        _181 = _172;
        _1 = BitOr(move _180, move _181);
        StorageDead(_181);
        StorageDead(_180);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_182.0: usize);
        _171 = const ();
        StorageDead(_172);
        StorageDead(_171);
        StorageLive(_183);
        _183 = _1;
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _183) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        StorageDead(_183);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &gdt::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &gdt::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<gdt::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = gdt::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = gdt::_::InternalBitFlags(_1);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<gdt::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<gdt::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: structures::gdt::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = gdt::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = gdt::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<gdt::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> gdt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::_::InternalBitFlags;
    let _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = gdt::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = gdt::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> gdt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &structures::gdt::_::InternalBitFlags;
    let _7: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = gdt::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = gdt::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> gdt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = gdt::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> gdt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = gdt::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<gdt::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: structures::gdt::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: structures::gdt::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: structures::gdt::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: structures::gdt::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: structures::gdt::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: structures::gdt::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: structures::gdt::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: structures::gdt::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: structures::gdt::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: structures::gdt::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: structures::gdt::_::InternalBitFlags;
    let mut _46: u64;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: structures::gdt::_::InternalBitFlags;
    let mut _50: u64;
    let mut _51: bool;
    let mut _52: &&str;
    let mut _53: structures::gdt::_::InternalBitFlags;
    let mut _54: u64;
    let mut _55: bool;
    let mut _56: &&str;
    let mut _57: structures::gdt::_::InternalBitFlags;
    let mut _58: u64;
    let mut _59: bool;
    let mut _60: &&str;
    let mut _61: structures::gdt::_::InternalBitFlags;
    let mut _62: u64;
    scope 1 {
        debug name => _2;
        let mut _63: &structures::gdt::DescriptorFlags;
        let mut _64: &structures::gdt::DescriptorFlags;
        let mut _65: &structures::gdt::DescriptorFlags;
        let mut _66: &structures::gdt::DescriptorFlags;
        let mut _67: &structures::gdt::DescriptorFlags;
        let mut _68: &structures::gdt::DescriptorFlags;
        let mut _69: &structures::gdt::DescriptorFlags;
        let mut _70: &structures::gdt::DescriptorFlags;
        let mut _71: &structures::gdt::DescriptorFlags;
        let mut _72: &structures::gdt::DescriptorFlags;
        let mut _73: &structures::gdt::DescriptorFlags;
        let mut _74: &structures::gdt::DescriptorFlags;
        let mut _75: &structures::gdt::DescriptorFlags;
        let mut _76: &structures::gdt::DescriptorFlags;
        let mut _77: &structures::gdt::DescriptorFlags;
        let mut _78: &&str;
        let mut _79: &&str;
        let mut _80: &&str;
        let mut _81: &&str;
        let mut _82: &&str;
        let mut _83: &&str;
        let mut _84: &&str;
        let mut _85: &&str;
        let mut _86: &&str;
        let mut _87: &&str;
        let mut _88: &&str;
        let mut _89: &&str;
        let mut _90: &&str;
        let mut _91: &&str;
        let mut _92: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _92 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _92) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _63 = const _;
        _6 = gdt::_::<impl DescriptorFlags>::bits(_63) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = gdt::_::InternalBitFlags(move _6);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _5);
        goto -> bb61;
    }

    bb4: {
        _8 = &_2;
        _91 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _91) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _64 = const _;
        _10 = gdt::_::<impl DescriptorFlags>::bits(_64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = gdt::_::InternalBitFlags(move _10);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _9);
        goto -> bb61;
    }

    bb8: {
        _12 = &_2;
        _90 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _90) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _65 = const _;
        _14 = gdt::_::<impl DescriptorFlags>::bits(_65) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = gdt::_::InternalBitFlags(move _14);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _13);
        goto -> bb61;
    }

    bb12: {
        _16 = &_2;
        _89 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _89) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _66 = const _;
        _18 = gdt::_::<impl DescriptorFlags>::bits(_66) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = gdt::_::InternalBitFlags(move _18);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _17);
        goto -> bb61;
    }

    bb16: {
        _20 = &_2;
        _88 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _88) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _67 = const _;
        _22 = gdt::_::<impl DescriptorFlags>::bits(_67) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = gdt::_::InternalBitFlags(move _22);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _21);
        goto -> bb61;
    }

    bb20: {
        _24 = &_2;
        _87 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _87) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _68 = const _;
        _26 = gdt::_::<impl DescriptorFlags>::bits(_68) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = gdt::_::InternalBitFlags(move _26);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _25);
        goto -> bb61;
    }

    bb24: {
        _28 = &_2;
        _86 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _86) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _69 = const _;
        _30 = gdt::_::<impl DescriptorFlags>::bits(_69) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = gdt::_::InternalBitFlags(move _30);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _29);
        goto -> bb61;
    }

    bb28: {
        _32 = &_2;
        _85 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _85) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _70 = const _;
        _34 = gdt::_::<impl DescriptorFlags>::bits(_70) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = gdt::_::InternalBitFlags(move _34);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _33);
        goto -> bb61;
    }

    bb32: {
        _36 = &_2;
        _84 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _84) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _71 = const _;
        _38 = gdt::_::<impl DescriptorFlags>::bits(_71) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = gdt::_::InternalBitFlags(move _38);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _37);
        goto -> bb61;
    }

    bb36: {
        _40 = &_2;
        _83 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _83) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _72 = const _;
        _42 = gdt::_::<impl DescriptorFlags>::bits(_72) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = gdt::_::InternalBitFlags(move _42);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _41);
        goto -> bb61;
    }

    bb40: {
        _44 = &_2;
        _82 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _82) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _73 = const _;
        _46 = gdt::_::<impl DescriptorFlags>::bits(_73) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = gdt::_::InternalBitFlags(move _46);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _45);
        goto -> bb61;
    }

    bb44: {
        _48 = &_2;
        _81 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _81) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _74 = const _;
        _50 = gdt::_::<impl DescriptorFlags>::bits(_74) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = gdt::_::InternalBitFlags(move _50);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _49);
        goto -> bb61;
    }

    bb48: {
        _52 = &_2;
        _80 = const _;
        _51 = <&str as PartialEq>::eq(move _52, _80) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _51) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _75 = const _;
        _54 = gdt::_::<impl DescriptorFlags>::bits(_75) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _53 = gdt::_::InternalBitFlags(move _54);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _53);
        goto -> bb61;
    }

    bb52: {
        _56 = &_2;
        _79 = const _;
        _55 = <&str as PartialEq>::eq(move _56, _79) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _55) -> [0: bb56, otherwise: bb54];
    }

    bb54: {
        _76 = const _;
        _58 = gdt::_::<impl DescriptorFlags>::bits(_76) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _57 = gdt::_::InternalBitFlags(move _58);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _57);
        goto -> bb61;
    }

    bb56: {
        _60 = &_2;
        _78 = const _;
        _59 = <&str as PartialEq>::eq(move _60, _78) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _59) -> [0: bb60, otherwise: bb58];
    }

    bb58: {
        _77 = const _;
        _62 = gdt::_::<impl DescriptorFlags>::bits(_77) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _61 = gdt::_::InternalBitFlags(move _62);
        _0 = Option::<gdt::_::InternalBitFlags>::Some(move _61);
        goto -> bb61;
    }

    bb60: {
        _0 = Option::<gdt::_::InternalBitFlags>::None;
        goto -> bb61;
    }

    bb61: {
        return;
    }
}

promoted[0] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[14] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BASE_24_31";
        _0 = &_1;
        return;
    }
}

promoted[16] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BASE_0_23";
        _0 = &_1;
        return;
    }
}

promoted[17] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LIMIT_16_19";
        _0 = &_1;
        return;
    }
}

promoted[18] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LIMIT_0_15";
        _0 = &_1;
        return;
    }
}

promoted[19] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GRANULARITY";
        _0 = &_1;
        return;
    }
}

promoted[20] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DEFAULT_SIZE";
        _0 = &_1;
        return;
    }
}

promoted[21] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "LONG_MODE";
        _0 = &_1;
        return;
    }
}

promoted[22] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "AVAILABLE";
        _0 = &_1;
        return;
    }
}

promoted[23] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PRESENT";
        _0 = &_1;
        return;
    }
}

promoted[24] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DPL_RING_3";
        _0 = &_1;
        return;
    }
}

promoted[25] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "USER_SEGMENT";
        _0 = &_1;
        return;
    }
}

promoted[26] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "EXECUTABLE";
        _0 = &_1;
        return;
    }
}

promoted[27] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "CONFORMING";
        _0 = &_1;
        return;
    }
}

promoted[28] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "WRITABLE";
        _0 = &_1;
        return;
    }
}

promoted[29] in gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ACCESSED";
        _0 = &_1;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::gdt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::_::InternalBitFlags;
    let _5: structures::gdt::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = gdt::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::gdt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::gdt::_::InternalBitFlags;
    let _6: structures::gdt::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &structures::gdt::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = gdt::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = gdt::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = gdt::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = gdt::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = gdt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = gdt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = gdt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = gdt::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = gdt::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = gdt::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = gdt::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _3: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = gdt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _2: structures::gdt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = gdt::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = gdt::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let _2: structures::gdt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = gdt::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &gdt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = gdt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = gdt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut gdt::_::InternalBitFlags, _2: gdt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: gdt::_::InternalBitFlags) -> gdt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut gdt::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::gdt::_::InternalBitFlags);
        _5 = gdt::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> gdt::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: structures::gdt::_::InternalBitFlags;
    let mut _2: structures::gdt::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <gdt::_::InternalBitFlags as Extend<gdt::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &gdt::_::InternalBitFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;

    bb0: {
        _3 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<DescriptorFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &gdt::_::InternalBitFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: &structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<DescriptorFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &gdt::_::InternalBitFlags) -> IterNames<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;

    bb0: {
        _3 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = gdt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<DescriptorFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &gdt::_::InternalBitFlags) -> IterNames<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: &structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = gdt::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<DescriptorFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: gdt::_::InternalBitFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = gdt::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut gdt::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::_::InternalBitFlags;

    bb0: {
        _1 = gdt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = gdt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::_::InternalBitFlags;

    bb0: {
        _1 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = gdt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &DescriptorFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &DescriptorFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::gdt::DescriptorFlags;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<DescriptorFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _2: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::gdt::DescriptorFlags;
    scope 1 {
        debug bits => _1;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<DescriptorFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::gdt::_::InternalBitFlags);
        _5 = DescriptorFlags(_4);
        _0 = Option::<DescriptorFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<DescriptorFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::gdt::DescriptorFlags>;
    let _2: u64;
    let mut _3: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: structures::gdt::DescriptorFlags;
    let mut _8: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<DescriptorFlags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: structures::gdt::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = DescriptorFlags(move _8);
        StorageDead(_8);
        _0 = Option::<DescriptorFlags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let _2: u64;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = DescriptorFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let _2: u64;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = DescriptorFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<DescriptorFlags> {
    debug name => _1;
    let mut _0: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _2: core::option::Option<structures::gdt::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::gdt::DescriptorFlags;
    scope 1 {
        debug name => _1;
        let _4: structures::gdt::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = gdt::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<DescriptorFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::gdt::_::InternalBitFlags);
        _5 = DescriptorFlags(_4);
        _0 = Option::<DescriptorFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::gdt::DescriptorFlags;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &DescriptorFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::gdt::DescriptorFlags;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::gdt::DescriptorFlags;
    let mut _5: &structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::gdt::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &DescriptorFlags, _2: DescriptorFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::gdt::DescriptorFlags;
    let mut _5: &structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::gdt::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = gdt::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::gdt::_::InternalBitFlags);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut DescriptorFlags, _2: DescriptorFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::gdt::_::InternalBitFlags);
        _5 = (_2.0: structures::gdt::_::InternalBitFlags);
        _0 = gdt::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::gdt::_::InternalBitFlags);
        _5 = (_2.0: structures::gdt::_::InternalBitFlags);
        _3 = gdt::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    let mut _7: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::gdt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = gdt::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = DescriptorFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::gdt::_::InternalBitFlags);
        _5 = (_2.0: structures::gdt::_::InternalBitFlags);
        _3 = gdt::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    let mut _7: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::gdt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = gdt::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = DescriptorFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::gdt::_::InternalBitFlags);
        _5 = (_2.0: structures::gdt::_::InternalBitFlags);
        _3 = gdt::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    let mut _7: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::gdt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = gdt::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = DescriptorFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::gdt::_::InternalBitFlags);
        _5 = (_2.0: structures::gdt::_::InternalBitFlags);
        _3 = gdt::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::_::InternalBitFlags;
    let mut _6: structures::gdt::_::InternalBitFlags;
    let mut _7: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::gdt::DescriptorFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::gdt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = gdt::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = DescriptorFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::_::InternalBitFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: structures::gdt::_::InternalBitFlags);
        _2 = gdt::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = DescriptorFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let _2: structures::gdt::DescriptorFlags;
    let mut _3: structures::gdt::_::InternalBitFlags;
    let mut _4: structures::gdt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: structures::gdt::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = gdt::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = DescriptorFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &DescriptorFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::gdt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::gdt::_::InternalBitFlags);
        _0 = <gdt::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::<impl DescriptorFlags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::<impl DescriptorFlags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::gdt::DescriptorFlags;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;

    bb0: {
        _6 = &(*_1);
        _5 = gdt::_::<impl DescriptorFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = gdt::_::<impl DescriptorFlags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: DescriptorFlags, _2: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut DescriptorFlags, _2: DescriptorFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = gdt::_::<impl DescriptorFlags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: DescriptorFlags) -> DescriptorFlags {
    debug self => _1;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut DescriptorFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::gdt::DescriptorFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::gdt::DescriptorFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::gdt::DescriptorFlags);
        _5 = gdt::_::<impl DescriptorFlags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> DescriptorFlags {
    debug iterator => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: structures::gdt::DescriptorFlags;
    let _3: ();
    let mut _4: &mut structures::gdt::DescriptorFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = gdt::_::<impl DescriptorFlags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <DescriptorFlags as Extend<DescriptorFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &DescriptorFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;

    bb0: {
        _3 = gdt::_::<impl DescriptorFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = gdt::_::<impl DescriptorFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<DescriptorFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &DescriptorFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = gdt::_::<impl DescriptorFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = gdt::_::<impl DescriptorFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<DescriptorFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &DescriptorFlags) -> IterNames<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;

    bb0: {
        _3 = gdt::_::<impl DescriptorFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = gdt::_::<impl DescriptorFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<DescriptorFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &DescriptorFlags) -> IterNames<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::gdt::DescriptorFlags>;
    let mut _2: structures::gdt::DescriptorFlags;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let mut _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = gdt::_::<impl DescriptorFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = gdt::_::<impl DescriptorFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<DescriptorFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn gdt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: DescriptorFlags) -> bitflags::iter::Iter<DescriptorFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::gdt::DescriptorFlags>;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = &_1;
        _0 = gdt::_::<impl DescriptorFlags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: &structures::gdt::DescriptorFlags;
    let _9: structures::gdt::DescriptorFlags;
    let mut _10: u64;
    let mut _11: &structures::gdt::DescriptorFlags;
    let _12: structures::gdt::DescriptorFlags;
    let mut _13: u64;
    let mut _14: &structures::gdt::DescriptorFlags;
    let _15: structures::gdt::DescriptorFlags;
    let mut _16: u64;
    let mut _17: &structures::gdt::DescriptorFlags;
    let _18: structures::gdt::DescriptorFlags;
    let mut _19: u64;
    let mut _20: &structures::gdt::DescriptorFlags;
    let _21: structures::gdt::DescriptorFlags;
    let mut _22: u64;
    let mut _23: &structures::gdt::DescriptorFlags;
    let _24: structures::gdt::DescriptorFlags;
    let mut _25: u64;
    let mut _26: &structures::gdt::DescriptorFlags;
    let _27: structures::gdt::DescriptorFlags;
    let mut _28: &structures::gdt::DescriptorFlags;
    let mut _29: &structures::gdt::DescriptorFlags;
    let mut _30: &structures::gdt::DescriptorFlags;
    let mut _31: &structures::gdt::DescriptorFlags;
    let mut _32: &structures::gdt::DescriptorFlags;
    let mut _33: &structures::gdt::DescriptorFlags;
    let mut _34: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _34 = const _;
        _8 = &(*_34);
        ConstEvalCounter;
        _7 = gdt::_::<impl DescriptorFlags>::bits(move _8) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        StorageDead(_8);
        StorageLive(_10);
        StorageLive(_11);
        _33 = const _;
        _11 = &(*_33);
        ConstEvalCounter;
        _10 = gdt::_::<impl DescriptorFlags>::bits(move _11) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_11);
        _6 = BitOr(move _7, move _10);
        StorageDead(_10);
        StorageDead(_7);
        StorageLive(_13);
        StorageLive(_14);
        _32 = const _;
        _14 = &(*_32);
        ConstEvalCounter;
        _13 = gdt::_::<impl DescriptorFlags>::bits(move _14) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        StorageDead(_14);
        _5 = BitOr(move _6, move _13);
        StorageDead(_13);
        StorageDead(_6);
        StorageLive(_16);
        StorageLive(_17);
        _31 = const _;
        _17 = &(*_31);
        ConstEvalCounter;
        _16 = gdt::_::<impl DescriptorFlags>::bits(move _17) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        StorageDead(_17);
        _4 = BitOr(move _5, move _16);
        StorageDead(_16);
        StorageDead(_5);
        StorageLive(_19);
        StorageLive(_20);
        _30 = const _;
        _20 = &(*_30);
        ConstEvalCounter;
        _19 = gdt::_::<impl DescriptorFlags>::bits(move _20) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        StorageDead(_20);
        _3 = BitOr(move _4, move _19);
        StorageDead(_19);
        StorageDead(_4);
        StorageLive(_22);
        StorageLive(_23);
        _29 = const _;
        _23 = &(*_29);
        ConstEvalCounter;
        _22 = gdt::_::<impl DescriptorFlags>::bits(move _23) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        StorageDead(_23);
        _2 = BitOr(move _3, move _22);
        StorageDead(_22);
        StorageDead(_3);
        StorageLive(_25);
        StorageLive(_26);
        _28 = const _;
        _26 = &(*_28);
        ConstEvalCounter;
        _25 = gdt::_::<impl DescriptorFlags>::bits(move _26) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        StorageDead(_26);
        _1 = BitOr(move _2, move _25);
        StorageDead(_25);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb8, unwind: bb9];
    }

    bb8: {
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::COMMON: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_DATA: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE32: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;
    let _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: &structures::gdt::DescriptorFlags;
    let _11: structures::gdt::DescriptorFlags;
    let mut _12: &structures::gdt::DescriptorFlags;
    let mut _13: &structures::gdt::DescriptorFlags;
    let mut _14: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _14 = const _;
        _4 = &(*_14);
        ConstEvalCounter;
        _3 = gdt::_::<impl DescriptorFlags>::bits(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _13 = const _;
        _7 = &(*_13);
        ConstEvalCounter;
        _6 = gdt::_::<impl DescriptorFlags>::bits(move _7) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        StorageDead(_7);
        _2 = BitOr(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _12 = const _;
        _10 = &(*_12);
        ConstEvalCounter;
        _9 = gdt::_::<impl DescriptorFlags>::bits(move _10) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        StorageDead(_10);
        _1 = BitOr(move _2, move _9);
        StorageDead(_9);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        StorageDead(_1);
        return;
    }

    bb5 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE64: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::gdt::DescriptorFlags;
    let _5: structures::gdt::DescriptorFlags;
    let mut _6: u64;
    let mut _7: &structures::gdt::DescriptorFlags;
    let _8: structures::gdt::DescriptorFlags;
    let mut _9: u64;
    let mut _10: &structures::gdt::DescriptorFlags;
    let _11: structures::gdt::DescriptorFlags;
    let mut _12: &structures::gdt::DescriptorFlags;
    let mut _13: &structures::gdt::DescriptorFlags;
    let mut _14: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _14 = const _;
        _4 = &(*_14);
        ConstEvalCounter;
        _3 = gdt::_::<impl DescriptorFlags>::bits(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _13 = const _;
        _7 = &(*_13);
        ConstEvalCounter;
        _6 = gdt::_::<impl DescriptorFlags>::bits(move _7) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        StorageDead(_7);
        _2 = BitOr(move _3, move _6);
        StorageDead(_6);
        StorageDead(_3);
        StorageLive(_9);
        StorageLive(_10);
        _12 = const _;
        _10 = &(*_12);
        ConstEvalCounter;
        _9 = gdt::_::<impl DescriptorFlags>::bits(move _10) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        StorageDead(_10);
        _1 = BitOr(move _2, move _9);
        StorageDead(_9);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        StorageDead(_1);
        return;
    }

    bb5 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::KERNEL_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_DATA: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_DATA: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE32: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE32: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE64: DescriptorFlags = {
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _1: u64;
    let mut _2: u64;
    let mut _3: &structures::gdt::DescriptorFlags;
    let _4: structures::gdt::DescriptorFlags;
    let mut _5: u64;
    let mut _6: &structures::gdt::DescriptorFlags;
    let _7: structures::gdt::DescriptorFlags;
    let mut _8: &structures::gdt::DescriptorFlags;
    let mut _9: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _9 = const _;
        _3 = &(*_9);
        ConstEvalCounter;
        _2 = gdt::_::<impl DescriptorFlags>::bits(move _3) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _8 = const _;
        _6 = &(*_8);
        ConstEvalCounter;
        _5 = gdt::_::<impl DescriptorFlags>::bits(move _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_6);
        _1 = BitOr(move _2, move _5);
        StorageDead(_5);
        StorageDead(_2);
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_truncate(move _1) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::USER_CODE64: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::from_bits_unchecked(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:241:1: 241:21>::from_bits_unchecked(_1: u64) -> DescriptorFlags {
    debug bits => _1;
    let mut _0: structures::gdt::DescriptorFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = gdt::_::<impl DescriptorFlags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::dpl(_1: Descriptor) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;
    let _2: u64;
    let mut _3: isize;
    let _4: u64;
    let _5: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u16;
    scope 1 {
        debug value_low => _2;
        let _6: u64;
        let mut _13: &structures::gdt::DescriptorFlags;
        scope 4 {
            debug dpl => _6;
        }
    }
    scope 2 {
        debug v => _4;
    }
    scope 3 {
        debug v => _5;
    }

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb7];
    }

    bb1: {
        _5 = ((_1 as SystemSegment).0: u64);
        _2 = _5;
        goto -> bb3;
    }

    bb2: {
        _4 = ((_1 as UserSegment).0: u64);
        _2 = _4;
        goto -> bb3;
    }

    bb3: {
        _8 = _2;
        _13 = const _;
        _9 = gdt::_::<impl DescriptorFlags>::bits(_13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = BitAnd(move _8, move _9);
        _10 = const 45_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 45_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _6 = Shr(move _7, const 45_i32);
        _12 = _6 as u16 (IntToInt);
        _0 = PrivilegeLevel::from_u16(move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::dpl: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::dpl(_1: Descriptor) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;
    let _2: u64;
    let mut _3: isize;
    let _4: u64;
    let _5: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::gdt::DescriptorFlags;
    let _11: structures::gdt::DescriptorFlags;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u16;
    let mut _15: u64;
    scope 1 {
        debug value_low => _2;
        let _6: u64;
        let mut _16: &structures::gdt::DescriptorFlags;
        scope 4 {
            debug dpl => _6;
        }
    }
    scope 2 {
        debug v => _4;
    }
    scope 3 {
        debug v => _5;
    }

    bb0: {
        StorageLive(_2);
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        StorageLive(_5);
        _5 = ((_1 as SystemSegment).0: u64);
        _2 = _5;
        StorageDead(_5);
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_4);
        _4 = ((_1 as UserSegment).0: u64);
        _2 = _4;
        StorageDead(_4);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _2;
        StorageLive(_9);
        StorageLive(_10);
        _16 = const _;
        _10 = &(*_16);
        ConstEvalCounter;
        _9 = gdt::_::<impl DescriptorFlags>::bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_10);
        _7 = BitAnd(move _8, move _9);
        StorageDead(_9);
        StorageDead(_8);
        _12 = const 45_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 45_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _6 = Shr(move _7, const 45_i32);
        StorageDead(_7);
        StorageLive(_14);
        StorageLive(_15);
        _15 = _6;
        _14 = move _15 as u16 (IntToInt);
        StorageDead(_15);
        ConstEvalCounter;
        _0 = PrivilegeLevel::from_u16(move _14) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_14);
        StorageDead(_6);
        StorageDead(_2);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = gdt::_::<impl DescriptorFlags>::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_code_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = gdt::_::<impl DescriptorFlags>::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = gdt::_::<impl DescriptorFlags>::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_data_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::kernel_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = gdt::_::<impl DescriptorFlags>::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = gdt::_::<impl DescriptorFlags>::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_data_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_data_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = gdt::_::<impl DescriptorFlags>::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;

    bb0: {
        _2 = const _;
        _1 = gdt::_::<impl DescriptorFlags>::bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_code_segment: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

// MIR FOR CTFE
fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::user_code_segment() -> Descriptor {
    let mut _0: structures::gdt::Descriptor;
    let mut _1: u64;
    let mut _2: &structures::gdt::DescriptorFlags;
    let _3: structures::gdt::DescriptorFlags;
    let mut _4: &structures::gdt::DescriptorFlags;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        ConstEvalCounter;
        _1 = gdt::_::<impl DescriptorFlags>::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        _0 = Descriptor::UserSegment(move _1);
        StorageDead(_1);
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::tss_segment(_1: &TaskStateSegment) -> Descriptor {
    debug tss => _1;
    let mut _0: structures::gdt::Descriptor;
    let mut _2: *const structures::tss::TaskStateSegment;
    scope 1 {
    }

    bb0: {
        _2 = &raw const (*_1);
        _0 = Descriptor::tss_segment_unchecked(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::tss_segment_unchecked(_1: *const TaskStateSegment) -> Descriptor {
    debug tss => _1;
    let mut _0: structures::gdt::Descriptor;
    let _2: u64;
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let mut _8: &u64;
    let mut _9: core::ops::Range<usize>;
    let _10: &mut u64;
    let mut _11: &mut u64;
    let mut _12: core::ops::Range<usize>;
    let mut _13: u64;
    let mut _14: &u64;
    let mut _15: core::ops::Range<usize>;
    let _16: &mut u64;
    let mut _17: &mut u64;
    let mut _18: core::ops::Range<usize>;
    let mut _19: u64;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: (usize, bool);
    let _23: &mut u64;
    let mut _24: &mut u64;
    let mut _25: core::ops::Range<usize>;
    let _27: &mut u64;
    let mut _28: &mut u64;
    let mut _29: core::ops::Range<usize>;
    let mut _30: u64;
    let mut _31: &u64;
    let mut _32: core::ops::Range<usize>;
    let mut _33: u64;
    let mut _34: u64;
    scope 1 {
        debug ptr => _2;
        let mut _3: u64;
        let mut _35: &structures::gdt::DescriptorFlags;
        scope 2 {
            debug low => _3;
            let mut _26: u64;
            scope 3 {
                debug high => _26;
            }
        }
    }

    bb0: {
        _2 = _1 as u64 (PointerExposeAddress);
        _35 = const _;
        _3 = gdt::_::<impl DescriptorFlags>::bits(_35) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _3;
        _6 = Range::<usize> { start: const 16_usize, end: const 40_usize };
        _8 = &_2;
        _9 = Range::<usize> { start: const 0_usize, end: const 24_usize };
        _7 = <u64 as BitField>::get_bits::<Range<usize>>(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = &mut _3;
        _12 = Range::<usize> { start: const 56_usize, end: const 64_usize };
        _14 = &_2;
        _15 = Range::<usize> { start: const 24_usize, end: const 32_usize };
        _13 = <u64 as BitField>::get_bits::<Range<usize>>(move _14, move _15) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <u64 as BitField>::set_bits::<Range<usize>>(move _11, move _12, move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _17 = &mut _3;
        _18 = Range::<usize> { start: const 0_usize, end: const 16_usize };
        _21 = core::mem::size_of::<TaskStateSegment>() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _22 = CheckedSub(_21, const 1_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", move _21, const 1_usize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _20 = move (_22.0: usize);
        _19 = move _20 as u64 (IntToInt);
        _16 = <u64 as BitField>::set_bits::<Range<usize>>(move _17, move _18, move _19) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _24 = &mut _3;
        _25 = Range::<usize> { start: const 40_usize, end: const 44_usize };
        _23 = <u64 as BitField>::set_bits::<Range<usize>>(move _24, move _25, const 9_u64) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _26 = const 0_u64;
        _28 = &mut _26;
        _29 = Range::<usize> { start: const 0_usize, end: const 32_usize };
        _31 = &_2;
        _32 = Range::<usize> { start: const 32_usize, end: const 64_usize };
        _30 = <u64 as BitField>::get_bits::<Range<usize>>(move _31, move _32) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _27 = <u64 as BitField>::set_bits::<Range<usize>>(move _28, move _29, move _30) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _33 = _3;
        _34 = _26;
        _0 = Descriptor::SystemSegment(move _33, move _34);
        return;
    }
}

promoted[0] in gdt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/gdt.rs:280:1: 280:16>::tss_segment_unchecked: &DescriptorFlags = {
    let mut _0: &structures::gdt::DescriptorFlags;
    let mut _1: structures::gdt::DescriptorFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

InterruptDescriptorTable::reserved_2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

InterruptDescriptorTable::interrupts::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const 256_usize, const 32_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const 256_usize, const 32_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:47:10: 47:15>::clone(_1: &InterruptDescriptorTable) -> InterruptDescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _3: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _5: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _7: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _9: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _23: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _25: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _27: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _29: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _30: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let _31: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _32: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _33: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _34: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _35: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _36: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _37: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _38: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let _39: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _40: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _41: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _42: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _43: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _44: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _45: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _46: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6];
    let _47: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6];
    let mut _48: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _49: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _50: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _51: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _52: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let _53: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _54: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _55: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _56: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _57: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];

    bb0: {
        _3 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _2 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _4 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _6 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _8 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _10 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _12 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _15 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _14 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _17 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _16 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _19 = &((*_1).8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>);
        _18 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !> as Clone>::clone(_19) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _20 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _23 = &((*_1).10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _22 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_23) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _25 = &((*_1).11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _24 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _27 = &((*_1).12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _26 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_27) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _29 = &((*_1).13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _28 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_29) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _31 = &((*_1).14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>);
        _30 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)> as Clone>::clone(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _33 = &((*_1).15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _32 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_33) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _35 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _34 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_35) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _37 = &((*_1).17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _36 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_37) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = &((*_1).18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>);
        _38 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame) -> !> as Clone>::clone(_39) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _41 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _40 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_41) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _43 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _42 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_43) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _45 = &((*_1).21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _44 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_45) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _47 = &((*_1).22: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6]);
        _46 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 6] as Clone>::clone(_47) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _49 = &((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _48 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_49) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _51 = &((*_1).24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _50 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_51) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _53 = &((*_1).25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _52 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)> as Clone>::clone(_53) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _55 = &((*_1).26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _54 = <Entry<extern "x86-interrupt" fn(InterruptStackFrame)> as Clone>::clone(_55) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _57 = &((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _56 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as Clone>::clone(_57) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _0 = InterruptDescriptorTable { divide_error: move _2, debug: move _4, non_maskable_interrupt: move _6, breakpoint: move _8, overflow: move _10, bound_range_exceeded: move _12, invalid_opcode: move _14, device_not_available: move _16, double_fault: move _18, coprocessor_segment_overrun: move _20, invalid_tss: move _22, segment_not_present: move _24, stack_segment_fault: move _26, general_protection_fault: move _28, page_fault: move _30, reserved_1: move _32, x87_floating_point: move _34, alignment_check: move _36, machine_check: move _38, simd_floating_point: move _40, virtualization: move _42, cp_protection_exception: move _44, reserved_2: move _46, hv_injection_exception: move _48, vmm_communication_exception: move _50, security_exception: move _52, reserved_3: move _54, interrupts: move _56 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:47:17: 47:22>::fmt(_1: &InterruptDescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _4: &[&dyn core::fmt::Debug; 28];
    let _5: [&dyn core::fmt::Debug; 28];
    let mut _6: &dyn core::fmt::Debug;
    let _7: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: &dyn core::fmt::Debug;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _20: &dyn core::fmt::Debug;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: &dyn core::fmt::Debug;
    let _23: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _24: &dyn core::fmt::Debug;
    let _25: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _26: &dyn core::fmt::Debug;
    let _27: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: &dyn core::fmt::Debug;
    let _29: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _30: &dyn core::fmt::Debug;
    let _31: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _32: &dyn core::fmt::Debug;
    let _33: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _34: &dyn core::fmt::Debug;
    let _35: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _36: &dyn core::fmt::Debug;
    let _37: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _38: &dyn core::fmt::Debug;
    let _39: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _40: &dyn core::fmt::Debug;
    let _41: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _42: &dyn core::fmt::Debug;
    let _43: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _44: &dyn core::fmt::Debug;
    let _45: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _46: &dyn core::fmt::Debug;
    let _47: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _48: &dyn core::fmt::Debug;
    let _49: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _50: &dyn core::fmt::Debug;
    let _51: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6];
    let mut _52: &dyn core::fmt::Debug;
    let _53: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _54: &dyn core::fmt::Debug;
    let _55: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _56: &dyn core::fmt::Debug;
    let _57: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _58: &dyn core::fmt::Debug;
    let _59: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _60: &dyn core::fmt::Debug;
    let _61: &&[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _62: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let _63: &str;
    let mut _64: &[&str];
    let mut _65: &[&str; 28];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn core::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _65 = const _;
        _7 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _16 = _17 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _20 = _21 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>);
        _22 = _23 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _25 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _24 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = &((*_1).10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _26 = _27 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _29 = &((*_1).11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _28 = _29 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _31 = &((*_1).12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _30 = _31 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _33 = &((*_1).13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _32 = _33 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _35 = &((*_1).14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>);
        _34 = _35 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _37 = &((*_1).15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _36 = _37 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _39 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _38 = _39 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _41 = &((*_1).17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _40 = _41 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _43 = &((*_1).18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>);
        _42 = _43 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _45 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _44 = _45 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _47 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _46 = _47 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _49 = &((*_1).21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _48 = _49 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _51 = &((*_1).22: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6]);
        _50 = _51 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _53 = &((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _52 = _53 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _55 = &((*_1).24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _54 = _55 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _57 = &((*_1).25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>);
        _56 = _57 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _59 = &((*_1).26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _58 = _59 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _62 = &((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _61 = &_62;
        _60 = _61 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50, move _52, move _54, move _56, move _58, move _60];
        _4 = &_5;
        _3 = _4 as &[&dyn core::fmt::Debug] (PointerCoercion(Unsize));
        _63 = const "InterruptDescriptorTable";
        _64 = _65 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _63, move _64, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:47:17: 47:22>::fmt: &[&str; 28] = {
    let mut _0: &[&str; 28];
    let mut _1: [&str; 28];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;
    let mut _40: &str;
    let mut _41: &str;
    let mut _42: &str;
    let mut _43: &str;
    let mut _44: &str;
    let mut _45: &str;
    let mut _46: &str;
    let mut _47: &str;
    let mut _48: &str;
    let mut _49: &str;
    let mut _50: &str;
    let mut _51: &str;
    let mut _52: &str;
    let mut _53: &str;
    let mut _54: &str;
    let mut _55: &str;

    bb0: {
        _3 = const "debug";
        _2 = &(*_3);
        _5 = const "non_maskable_interrupt";
        _4 = &(*_5);
        _7 = const "breakpoint";
        _6 = &(*_7);
        _9 = const "overflow";
        _8 = &(*_9);
        _11 = const "bound_range_exceeded";
        _10 = &(*_11);
        _13 = const "invalid_opcode";
        _12 = &(*_13);
        _15 = const "device_not_available";
        _14 = &(*_15);
        _17 = const "double_fault";
        _16 = &(*_17);
        _19 = const "coprocessor_segment_overrun";
        _18 = &(*_19);
        _21 = const "invalid_tss";
        _20 = &(*_21);
        _23 = const "segment_not_present";
        _22 = &(*_23);
        _25 = const "stack_segment_fault";
        _24 = &(*_25);
        _27 = const "general_protection_fault";
        _26 = &(*_27);
        _29 = const "page_fault";
        _28 = &(*_29);
        _31 = const "reserved_1";
        _30 = &(*_31);
        _33 = const "x87_floating_point";
        _32 = &(*_33);
        _35 = const "alignment_check";
        _34 = &(*_35);
        _37 = const "machine_check";
        _36 = &(*_37);
        _39 = const "simd_floating_point";
        _38 = &(*_39);
        _41 = const "virtualization";
        _40 = &(*_41);
        _43 = const "cp_protection_exception";
        _42 = &(*_43);
        _45 = const "reserved_2";
        _44 = &(*_45);
        _47 = const "hv_injection_exception";
        _46 = &(*_47);
        _49 = const "vmm_communication_exception";
        _48 = &(*_49);
        _51 = const "security_exception";
        _50 = &(*_51);
        _53 = const "reserved_3";
        _52 = &(*_53);
        _55 = const "interrupts";
        _54 = &(*_55);
        _1 = [const "divide_error", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50, move _52, move _54];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::new() -> InterruptDescriptorTable {
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _23: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6];
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _27: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _29: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _30: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;

    bb0: {
        _1 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _5 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _7 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _8 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _9 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::missing() -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _11 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _12 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _13 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _14 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _15 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::missing() -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _16 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _17 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _18 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _19 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::missing() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _20 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _21 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _22 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _24 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _23 = [move _24; 6];
        _25 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _26 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _27 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _28 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _30 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = [move _30; 224];
        _0 = InterruptDescriptorTable { divide_error: move _1, debug: move _2, non_maskable_interrupt: move _3, breakpoint: move _4, overflow: move _5, bound_range_exceeded: move _6, invalid_opcode: move _7, device_not_available: move _8, double_fault: move _9, coprocessor_segment_overrun: move _10, invalid_tss: move _11, segment_not_present: move _12, stack_segment_fault: move _13, general_protection_fault: move _14, page_fault: move _15, reserved_1: move _16, x87_floating_point: move _17, alignment_check: move _18, machine_check: move _19, simd_floating_point: move _20, virtualization: move _21, cp_protection_exception: move _22, reserved_2: move _23, hv_injection_exception: move _25, vmm_communication_exception: move _26, security_exception: move _27, reserved_3: move _28, interrupts: move _29 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::new() -> InterruptDescriptorTable {
    let mut _0: structures::idt::InterruptDescriptorTable;
    let mut _1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _8: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64) -> !>;
    let mut _10: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _12: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _13: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _14: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _15: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, structures::idt::PageFaultErrorCode)>;
    let mut _16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame) -> !>;
    let mut _20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _23: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 6];
    let mut _24: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _25: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _26: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _27: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame, u64)>;
    let mut _28: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _29: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _30: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_2);
        ConstEvalCounter;
        _2 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageLive(_3);
        ConstEvalCounter;
        _3 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageLive(_4);
        ConstEvalCounter;
        _4 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageLive(_5);
        ConstEvalCounter;
        _5 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageLive(_6);
        ConstEvalCounter;
        _6 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb6, unwind unreachable];
    }

    bb6: {
        StorageLive(_7);
        ConstEvalCounter;
        _7 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageLive(_8);
        ConstEvalCounter;
        _8 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb8, unwind unreachable];
    }

    bb8: {
        StorageLive(_9);
        ConstEvalCounter;
        _9 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::missing() -> [return: bb9, unwind unreachable];
    }

    bb9: {
        StorageLive(_10);
        ConstEvalCounter;
        _10 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb10, unwind unreachable];
    }

    bb10: {
        StorageLive(_11);
        ConstEvalCounter;
        _11 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageLive(_12);
        ConstEvalCounter;
        _12 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb12, unwind unreachable];
    }

    bb12: {
        StorageLive(_13);
        ConstEvalCounter;
        _13 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        StorageLive(_14);
        ConstEvalCounter;
        _14 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        StorageLive(_15);
        ConstEvalCounter;
        _15 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::missing() -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageLive(_16);
        ConstEvalCounter;
        _16 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb16, unwind unreachable];
    }

    bb16: {
        StorageLive(_17);
        ConstEvalCounter;
        _17 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb17, unwind unreachable];
    }

    bb17: {
        StorageLive(_18);
        ConstEvalCounter;
        _18 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb18, unwind unreachable];
    }

    bb18: {
        StorageLive(_19);
        ConstEvalCounter;
        _19 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::missing() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageLive(_20);
        ConstEvalCounter;
        _20 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb20, unwind unreachable];
    }

    bb20: {
        StorageLive(_21);
        ConstEvalCounter;
        _21 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb21, unwind unreachable];
    }

    bb21: {
        StorageLive(_22);
        ConstEvalCounter;
        _22 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb22, unwind unreachable];
    }

    bb22: {
        StorageLive(_23);
        StorageLive(_24);
        ConstEvalCounter;
        _24 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _23 = [move _24; 6];
        StorageDead(_24);
        StorageLive(_25);
        ConstEvalCounter;
        _25 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb24, unwind unreachable];
    }

    bb24: {
        StorageLive(_26);
        ConstEvalCounter;
        _26 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb25, unwind unreachable];
    }

    bb25: {
        StorageLive(_27);
        ConstEvalCounter;
        _27 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::missing() -> [return: bb26, unwind unreachable];
    }

    bb26: {
        StorageLive(_28);
        ConstEvalCounter;
        _28 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageLive(_29);
        StorageLive(_30);
        ConstEvalCounter;
        _30 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::missing() -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _29 = [move _30; 224];
        StorageDead(_30);
        _0 = InterruptDescriptorTable { divide_error: move _1, debug: move _2, non_maskable_interrupt: move _3, breakpoint: move _4, overflow: move _5, bound_range_exceeded: move _6, invalid_opcode: move _7, device_not_available: move _8, double_fault: move _9, coprocessor_segment_overrun: move _10, invalid_tss: move _11, segment_not_present: move _12, stack_segment_fault: move _13, general_protection_fault: move _14, page_fault: move _15, reserved_1: move _16, x87_floating_point: move _17, alignment_check: move _18, machine_check: move _19, simd_floating_point: move _20, virtualization: move _21, cp_protection_exception: move _22, reserved_2: move _23, hv_injection_exception: move _25, vmm_communication_exception: move _26, security_exception: move _27, reserved_3: move _28, interrupts: move _29 };
        StorageDead(_29);
        StorageDead(_28);
        StorageDead(_27);
        StorageDead(_26);
        StorageDead(_25);
        StorageDead(_23);
        StorageDead(_22);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_19);
        StorageDead(_18);
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_15);
        StorageDead(_14);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_11);
        StorageDead(_10);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_7);
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::new::{constant#1}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const 256_usize, const 32_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const 256_usize, const 32_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::reset(_1: &mut InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: structures::idt::InterruptDescriptorTable;

    bb0: {
        _2 = InterruptDescriptorTable::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _2;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::load(_1: &InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        _0 = InterruptDescriptorTable::load_unsafe(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::load_unsafe(_1: &InterruptDescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let _3: &structures::DescriptorTablePointer;
    let _4: structures::DescriptorTablePointer;
    scope 1 {
    }

    bb0: {
        _4 = InterruptDescriptorTable::pointer(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = lidt(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::pointer(_1: &InterruptDescriptorTable) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    let mut _2: addr::VirtAddr;
    let mut _3: u64;
    let mut _4: *const structures::idt::InterruptDescriptorTable;
    let mut _5: u16;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: (usize, bool);

    bb0: {
        _4 = &raw const (*_1);
        _3 = _4 as u64 (PointerExposeAddress);
        _2 = addr::VirtAddr::new(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = core::mem::size_of::<InterruptDescriptorTable>() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = CheckedSub(_7, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", move _7, const 1_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = move (_8.0: usize);
        _5 = move _6 as u16 (IntToInt);
        _0 = DescriptorTablePointer { limit: move _5, base: move _2 };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::condition_slice_bounds(_1: &InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> (usize, usize) {
    debug self => _1;
    debug bounds => _2;
    let mut _0: (usize, usize);
    let _3: usize;
    let mut _4: core::ops::Bound<&usize>;
    let mut _5: &impl RangeBounds<usize>;
    let mut _6: isize;
    let _7: &usize;
    let _8: &usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _12: core::ops::Bound<&usize>;
    let mut _13: &impl RangeBounds<usize>;
    let mut _14: isize;
    let mut _16: usize;
    let mut _17: (usize, bool);
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: usize;
    let _23: !;
    let mut _24: core::fmt::Arguments<'_>;
    let mut _25: &[&str];
    let mut _26: &[core::fmt::rt::Argument<'_>];
    let _27: &[core::fmt::rt::Argument<'_>; 2];
    let _28: [core::fmt::rt::Argument<'_>; 2];
    let mut _29: core::fmt::rt::Argument<'_>;
    let _30: &usize;
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &usize;
    let mut _33: bool;
    let mut _34: usize;
    let _35: !;
    let mut _36: usize;
    let mut _37: usize;
    scope 1 {
        debug lower_idx => _3;
        let _11: usize;
        let _15: &usize;
        let _18: &usize;
        scope 4 {
            debug upper_idx => _11;
            let mut _38: &[&str; 3];
        }
        scope 5 {
            debug end => _15;
        }
        scope 6 {
            debug end => _18;
        }
    }
    scope 2 {
        debug start => _7;
    }
    scope 3 {
        debug start => _8;
    }

    bb0: {
        _5 = &_2;
        _4 = <impl RangeBounds<usize> as RangeBounds<usize>>::start_bound(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb4, 2: bb2, otherwise: bb22];
    }

    bb2: {
        _3 = const 0_usize;
        goto -> bb6;
    }

    bb3: {
        _7 = ((_4 as Included).0: &usize);
        _3 = (*_7);
        goto -> bb6;
    }

    bb4: {
        _8 = ((_4 as Excluded).0: &usize);
        _9 = (*_8);
        _10 = CheckedAdd(_9, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _9, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move (_10.0: usize);
        goto -> bb6;
    }

    bb6: {
        _13 = &_2;
        _12 = <impl RangeBounds<usize> as RangeBounds<usize>>::end_bound(move _13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb9, 1: bb11, 2: bb8, otherwise: bb22];
    }

    bb8: {
        _11 = const 256_usize;
        goto -> bb12;
    }

    bb9: {
        _15 = ((_12 as Included).0: &usize);
        _16 = (*_15);
        _17 = CheckedAdd(_16, const 1_usize);
        assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", move _16, const 1_usize) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _11 = move (_17.0: usize);
        goto -> bb12;
    }

    bb11: {
        _18 = ((_12 as Excluded).0: &usize);
        _11 = (*_18);
        goto -> bb12;
    }

    bb12: {
        _20 = _3;
        _19 = Gt(move _20, const 256_usize);
        switchInt(move _19) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _22 = _11;
        _21 = Gt(move _22, const 256_usize);
        switchInt(move _21) -> [0: bb18, otherwise: bb14];
    }

    bb14: {
        _38 = const _;
        _25 = _38 as &[&str] (PointerCoercion(Unsize));
        _30 = &_3;
        _29 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_30) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _32 = &_11;
        _31 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_32) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _28 = [move _29, move _31];
        _27 = &_28;
        _26 = _27 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _24 = Arguments::<'_>::new_v1(move _25, move _26) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _23 = panic_fmt(move _24) -> unwind unreachable;
    }

    bb18: {
        _34 = _3;
        _33 = Lt(move _34, const 32_usize);
        switchInt(move _33) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _35 = panic(const "Cannot return slice from traps, faults, and exception handlers") -> unwind unreachable;
    }

    bb20: {
        _36 = _3;
        _37 = _11;
        _0 = (move _36, move _37);
        drop(_2) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        return;
    }

    bb22: {
        unreachable;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::condition_slice_bounds: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Index out of range [", const "..", const "]"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::slice(_1: &InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> &[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>] {
    debug self => _1;
    debug bounds => _2;
    let mut _0: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>];
    let _3: usize;
    let _4: usize;
    let mut _5: (usize, usize);
    let mut _6: &[structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _7: core::ops::Range<usize>;
    let mut _8: usize;
    let mut _9: (usize, bool);
    let mut _10: usize;
    let mut _11: (usize, bool);
    scope 1 {
        debug lower_idx => _3;
        debug upper_idx => _4;
    }

    bb0: {
        _5 = InterruptDescriptorTable::condition_slice_bounds::<impl RangeBounds<usize>>(_1, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_5.0: usize);
        _4 = (_5.1: usize);
        _6 = &((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _9 = CheckedSub(_3, const 32_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 32_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = move (_9.0: usize);
        _11 = CheckedSub(_4, const 32_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 32_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _10 = move (_11.0: usize);
        _7 = Range::<usize> { start: move _8, end: move _10 };
        _0 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as Index<Range<usize>>>::index(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:442:1: 442:30>::slice_mut(_1: &mut InterruptDescriptorTable, _2: impl RangeBounds<usize>) -> &mut [Entry<extern "x86-interrupt" fn(InterruptStackFrame)>] {
    debug self => _1;
    debug bounds => _2;
    let mut _0: &mut [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>];
    let _3: usize;
    let _4: usize;
    let mut _5: (usize, usize);
    let mut _6: &structures::idt::InterruptDescriptorTable;
    let mut _7: &mut [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224];
    let mut _8: core::ops::Range<usize>;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: usize;
    let mut _12: (usize, bool);
    scope 1 {
        debug lower_idx => _3;
        debug upper_idx => _4;
    }

    bb0: {
        _6 = &(*_1);
        _5 = InterruptDescriptorTable::condition_slice_bounds::<impl RangeBounds<usize>>(move _6, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = (_5.0: usize);
        _4 = (_5.1: usize);
        _7 = &mut ((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224]);
        _10 = CheckedSub(_3, const 32_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 32_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = move (_10.0: usize);
        _12 = CheckedSub(_4, const 32_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 32_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _11 = move (_12.0: usize);
        _8 = Range::<usize> { start: move _9, end: move _11 };
        _0 = <[Entry<extern "x86-interrupt" fn(InterruptStackFrame)>; 224] as IndexMut<Range<usize>>>::index_mut(move _7, move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:568:1: 568:47>::index(_1: &InterruptDescriptorTable, _2: usize) -> &Entry<extern "x86-interrupt" fn(InterruptStackFrame)> {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _3: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let _10: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _11: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _12: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _13: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _14: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _15: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _16: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _17: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _18: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _19: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _20: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _21: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _22: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _23: &structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _24: usize;
    let mut _25: (usize, bool);
    let mut _26: usize;
    let mut _27: bool;
    let _28: usize;
    let _29: !;
    let mut _30: core::fmt::Arguments<'_>;
    let mut _31: &[&str];
    let mut _32: &[core::fmt::rt::Argument<'_>];
    let _33: &[core::fmt::rt::Argument<'_>; 1];
    let _34: [core::fmt::rt::Argument<'_>; 1];
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &usize;
    let _37: usize;
    let _38: !;
    let mut _39: core::fmt::Arguments<'_>;
    let mut _40: &[&str];
    let mut _41: &[core::fmt::rt::Argument<'_>];
    let _42: &[core::fmt::rt::Argument<'_>; 1];
    let _43: [core::fmt::rt::Argument<'_>; 1];
    let mut _44: core::fmt::rt::Argument<'_>;
    let _45: &usize;
    let _46: usize;
    let _47: !;
    let mut _48: core::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 1];
    let _52: [core::fmt::rt::Argument<'_>; 1];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &usize;
    let _55: usize;
    let _56: !;
    let mut _57: core::fmt::Arguments<'_>;
    let mut _58: &[&str];
    let mut _59: &[core::fmt::rt::Argument<'_>];
    let _60: &[core::fmt::rt::Argument<'_>; 1];
    let _61: [core::fmt::rt::Argument<'_>; 1];
    let mut _62: core::fmt::rt::Argument<'_>;
    let _63: &usize;
    scope 1 {
        debug i => _2;
    }
    scope 2 {
        debug i => _28;
        let mut _67: &[&str; 2];
    }
    scope 3 {
        debug i => _37;
        let mut _66: &[&str; 2];
    }
    scope 4 {
        debug i => _46;
        let mut _65: &[&str; 2];
    }
    scope 5 {
        debug i => _55;
        let mut _64: &[&str; 1];
    }

    bb0: {
        switchInt(_2) -> [0: bb11, 1: bb12, 2: bb13, 3: bb14, 4: bb15, 5: bb16, 6: bb17, 7: bb18, 9: bb19, 16: bb20, 19: bb21, 20: bb22, 28: bb23, 15: bb27, 31: bb28, 8: bb32, 17: bb33, 21: bb34, 29: bb35, 30: bb36, 18: bb39, otherwise: bb1];
    }

    bb1: {
        _8 = Le(const 32_usize, _2);
        switchInt(move _8) -> [0: bb3, otherwise: bb10];
    }

    bb2: {
        _25 = CheckedSub(_2, const 32_usize);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 32_usize) -> [success: bb24, unwind unreachable];
    }

    bb3: {
        _6 = Le(const 22_usize, _2);
        switchInt(move _6) -> [0: bb5, otherwise: bb9];
    }

    bb4: {
        _28 = _2;
        goto -> bb26;
    }

    bb5: {
        _4 = Le(const 10_usize, _2);
        switchInt(move _4) -> [0: bb7, otherwise: bb8];
    }

    bb6: {
        _37 = _2;
        goto -> bb31;
    }

    bb7: {
        _55 = _2;
        _64 = const _;
        _58 = _64 as &[&str] (PointerCoercion(Unsize));
        _63 = &_55;
        _62 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_63) -> [return: bb42, unwind unreachable];
    }

    bb8: {
        _5 = Le(_2, const 14_usize);
        switchInt(move _5) -> [0: bb7, otherwise: bb6];
    }

    bb9: {
        _7 = Le(_2, const 27_usize);
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _9 = Le(_2, const 255_usize);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb11: {
        _10 = &((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _10;
        goto -> bb44;
    }

    bb12: {
        _11 = &((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _11;
        goto -> bb44;
    }

    bb13: {
        _12 = &((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _12;
        goto -> bb44;
    }

    bb14: {
        _13 = &((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _13;
        goto -> bb44;
    }

    bb15: {
        _14 = &((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _14;
        goto -> bb44;
    }

    bb16: {
        _15 = &((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _15;
        goto -> bb44;
    }

    bb17: {
        _16 = &((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _16;
        goto -> bb44;
    }

    bb18: {
        _17 = &((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _17;
        goto -> bb44;
    }

    bb19: {
        _18 = &((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _18;
        goto -> bb44;
    }

    bb20: {
        _19 = &((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _19;
        goto -> bb44;
    }

    bb21: {
        _20 = &((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _20;
        goto -> bb44;
    }

    bb22: {
        _21 = &((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _21;
        goto -> bb44;
    }

    bb23: {
        _22 = &((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _22;
        goto -> bb44;
    }

    bb24: {
        _24 = move (_25.0: usize);
        _26 = const 224_usize;
        _27 = Lt(_24, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _24) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _23 = &((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224])[_24];
        _3 = _23;
        goto -> bb44;
    }

    bb26: {
        _67 = const _;
        _31 = _67 as &[&str] (PointerCoercion(Unsize));
        _36 = &_28;
        _35 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_36) -> [return: bb29, unwind unreachable];
    }

    bb27: {
        _28 = _2;
        goto -> bb26;
    }

    bb28: {
        _28 = _2;
        goto -> bb26;
    }

    bb29: {
        _34 = [move _35];
        _33 = &_34;
        _32 = _33 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _30 = Arguments::<'_>::new_v1(move _31, move _32) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _29 = panic_fmt(move _30) -> unwind unreachable;
    }

    bb31: {
        _66 = const _;
        _40 = _66 as &[&str] (PointerCoercion(Unsize));
        _45 = &_37;
        _44 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_45) -> [return: bb37, unwind unreachable];
    }

    bb32: {
        _37 = _2;
        goto -> bb31;
    }

    bb33: {
        _37 = _2;
        goto -> bb31;
    }

    bb34: {
        _37 = _2;
        goto -> bb31;
    }

    bb35: {
        _37 = _2;
        goto -> bb31;
    }

    bb36: {
        _37 = _2;
        goto -> bb31;
    }

    bb37: {
        _43 = [move _44];
        _42 = &_43;
        _41 = _42 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = Arguments::<'_>::new_v1(move _40, move _41) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _38 = panic_fmt(move _39) -> unwind unreachable;
    }

    bb39: {
        _46 = _2;
        _65 = const _;
        _49 = _65 as &[&str] (PointerCoercion(Unsize));
        _54 = &_46;
        _53 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_54) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _52 = [move _53];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _47 = panic_fmt(move _48) -> unwind unreachable;
    }

    bb42: {
        _61 = [move _62];
        _60 = &_61;
        _59 = _60 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _57 = Arguments::<'_>::new_v1(move _58, move _59) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _56 = panic_fmt(move _57) -> unwind unreachable;
    }

    bb44: {
        _0 = _3;
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:568:1: 568:47>::index: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "no entry with index "];
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:568:1: 568:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an diverging exception (must not return)"];
        _0 = &_1;
        return;
    }
}

promoted[2] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:568:1: 568:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an exception with error code"];
        _0 = &_1;
        return;
    }
}

promoted[3] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:568:1: 568:47>::index: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is reserved"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:602:1: 602:50>::index_mut(_1: &mut InterruptDescriptorTable, _2: usize) -> &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame)> {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _3: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _11: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _12: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _13: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _14: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _15: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _16: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _17: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _18: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _19: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _20: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _21: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _22: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let mut _23: &mut structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>;
    let _24: usize;
    let mut _25: (usize, bool);
    let mut _26: usize;
    let mut _27: bool;
    let _28: usize;
    let _29: !;
    let mut _30: core::fmt::Arguments<'_>;
    let mut _31: &[&str];
    let mut _32: &[core::fmt::rt::Argument<'_>];
    let _33: &[core::fmt::rt::Argument<'_>; 1];
    let _34: [core::fmt::rt::Argument<'_>; 1];
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &usize;
    let _37: usize;
    let _38: !;
    let mut _39: core::fmt::Arguments<'_>;
    let mut _40: &[&str];
    let mut _41: &[core::fmt::rt::Argument<'_>];
    let _42: &[core::fmt::rt::Argument<'_>; 1];
    let _43: [core::fmt::rt::Argument<'_>; 1];
    let mut _44: core::fmt::rt::Argument<'_>;
    let _45: &usize;
    let _46: usize;
    let _47: !;
    let mut _48: core::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 1];
    let _52: [core::fmt::rt::Argument<'_>; 1];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &usize;
    let _55: usize;
    let _56: !;
    let mut _57: core::fmt::Arguments<'_>;
    let mut _58: &[&str];
    let mut _59: &[core::fmt::rt::Argument<'_>];
    let _60: &[core::fmt::rt::Argument<'_>; 1];
    let _61: [core::fmt::rt::Argument<'_>; 1];
    let mut _62: core::fmt::rt::Argument<'_>;
    let _63: &usize;
    scope 1 {
        debug i => _2;
    }
    scope 2 {
        debug i => _28;
        let mut _67: &[&str; 2];
    }
    scope 3 {
        debug i => _37;
        let mut _66: &[&str; 2];
    }
    scope 4 {
        debug i => _46;
        let mut _65: &[&str; 2];
    }
    scope 5 {
        debug i => _55;
        let mut _64: &[&str; 1];
    }

    bb0: {
        switchInt(_2) -> [0: bb11, 1: bb12, 2: bb13, 3: bb14, 4: bb15, 5: bb16, 6: bb17, 7: bb18, 9: bb19, 16: bb20, 19: bb21, 20: bb22, 28: bb23, 15: bb27, 31: bb28, 8: bb32, 17: bb33, 21: bb34, 29: bb35, 30: bb36, 18: bb39, otherwise: bb1];
    }

    bb1: {
        _8 = Le(const 32_usize, _2);
        switchInt(move _8) -> [0: bb3, otherwise: bb10];
    }

    bb2: {
        _25 = CheckedSub(_2, const 32_usize);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 32_usize) -> [success: bb24, unwind unreachable];
    }

    bb3: {
        _6 = Le(const 22_usize, _2);
        switchInt(move _6) -> [0: bb5, otherwise: bb9];
    }

    bb4: {
        _28 = _2;
        goto -> bb26;
    }

    bb5: {
        _4 = Le(const 10_usize, _2);
        switchInt(move _4) -> [0: bb7, otherwise: bb8];
    }

    bb6: {
        _37 = _2;
        goto -> bb31;
    }

    bb7: {
        _55 = _2;
        _64 = const _;
        _58 = _64 as &[&str] (PointerCoercion(Unsize));
        _63 = &_55;
        _62 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_63) -> [return: bb42, unwind unreachable];
    }

    bb8: {
        _5 = Le(_2, const 14_usize);
        switchInt(move _5) -> [0: bb7, otherwise: bb6];
    }

    bb9: {
        _7 = Le(_2, const 27_usize);
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb10: {
        _9 = Le(_2, const 255_usize);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb11: {
        _10 = &mut ((*_1).0: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _10;
        goto -> bb44;
    }

    bb12: {
        _11 = &mut ((*_1).1: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _11;
        goto -> bb44;
    }

    bb13: {
        _12 = &mut ((*_1).2: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _12;
        goto -> bb44;
    }

    bb14: {
        _13 = &mut ((*_1).3: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _13;
        goto -> bb44;
    }

    bb15: {
        _14 = &mut ((*_1).4: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _14;
        goto -> bb44;
    }

    bb16: {
        _15 = &mut ((*_1).5: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _15;
        goto -> bb44;
    }

    bb17: {
        _16 = &mut ((*_1).6: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _16;
        goto -> bb44;
    }

    bb18: {
        _17 = &mut ((*_1).7: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _17;
        goto -> bb44;
    }

    bb19: {
        _18 = &mut ((*_1).9: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _18;
        goto -> bb44;
    }

    bb20: {
        _19 = &mut ((*_1).16: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _19;
        goto -> bb44;
    }

    bb21: {
        _20 = &mut ((*_1).19: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _20;
        goto -> bb44;
    }

    bb22: {
        _21 = &mut ((*_1).20: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _21;
        goto -> bb44;
    }

    bb23: {
        _22 = &mut ((*_1).23: structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>);
        _3 = _22;
        goto -> bb44;
    }

    bb24: {
        _24 = move (_25.0: usize);
        _26 = const 224_usize;
        _27 = Lt(_24, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _24) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _23 = &mut ((*_1).27: [structures::idt::Entry<extern "x86-interrupt" fn(structures::idt::InterruptStackFrame)>; 224])[_24];
        _3 = _23;
        goto -> bb44;
    }

    bb26: {
        _67 = const _;
        _31 = _67 as &[&str] (PointerCoercion(Unsize));
        _36 = &_28;
        _35 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_36) -> [return: bb29, unwind unreachable];
    }

    bb27: {
        _28 = _2;
        goto -> bb26;
    }

    bb28: {
        _28 = _2;
        goto -> bb26;
    }

    bb29: {
        _34 = [move _35];
        _33 = &_34;
        _32 = _33 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _30 = Arguments::<'_>::new_v1(move _31, move _32) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _29 = panic_fmt(move _30) -> unwind unreachable;
    }

    bb31: {
        _66 = const _;
        _40 = _66 as &[&str] (PointerCoercion(Unsize));
        _45 = &_37;
        _44 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_45) -> [return: bb37, unwind unreachable];
    }

    bb32: {
        _37 = _2;
        goto -> bb31;
    }

    bb33: {
        _37 = _2;
        goto -> bb31;
    }

    bb34: {
        _37 = _2;
        goto -> bb31;
    }

    bb35: {
        _37 = _2;
        goto -> bb31;
    }

    bb36: {
        _37 = _2;
        goto -> bb31;
    }

    bb37: {
        _43 = [move _44];
        _42 = &_43;
        _41 = _42 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = Arguments::<'_>::new_v1(move _40, move _41) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _38 = panic_fmt(move _39) -> unwind unreachable;
    }

    bb39: {
        _46 = _2;
        _65 = const _;
        _49 = _65 as &[&str] (PointerCoercion(Unsize));
        _54 = &_46;
        _53 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_54) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _52 = [move _53];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _47 = panic_fmt(move _48) -> unwind unreachable;
    }

    bb42: {
        _61 = [move _62];
        _60 = &_61;
        _59 = _60 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _57 = Arguments::<'_>::new_v1(move _58, move _59) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _56 = panic_fmt(move _57) -> unwind unreachable;
    }

    bb44: {
        _0 = _3;
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:602:1: 602:50>::index_mut: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "no entry with index "];
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:602:1: 602:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an diverging exception (must not return)"];
        _0 = &_1;
        return;
    }
}

promoted[2] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:602:1: 602:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is an exception with error code"];
        _0 = &_1;
        return;
    }
}

promoted[3] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:602:1: 602:50>::index_mut: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "entry ", const " is reserved"];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:638:10: 638:15>::clone(_1: &Entry<F>) -> Entry<F> {
    debug self => _1;
    let mut _0: structures::idt::Entry<F>;
    let mut _2: u16;
    let _3: &u16;
    let mut _4: u16;
    let _5: &u16;
    let mut _6: structures::idt::EntryOptions;
    let _7: &structures::idt::EntryOptions;
    let mut _8: u16;
    let _9: &u16;
    let mut _10: u32;
    let _11: &u32;
    let mut _12: u32;
    let _13: &u32;
    let mut _14: core::marker::PhantomData<F>;
    let _15: &core::marker::PhantomData<F>;

    bb0: {
        _3 = &((*_1).0: u16);
        _2 = (*_3);
        _5 = &((*_1).1: u16);
        _4 = (*_5);
        _7 = &((*_1).2: structures::idt::EntryOptions);
        _6 = <EntryOptions as Clone>::clone(_7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &((*_1).3: u16);
        _8 = (*_9);
        _11 = &((*_1).4: u32);
        _10 = (*_11);
        _13 = &((*_1).5: u32);
        _12 = (*_13);
        _15 = &((*_1).6: core::marker::PhantomData<F>);
        _14 = <PhantomData<F> as Clone>::clone(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Entry::<F> { pointer_low: move _2, gdt_selector: move _4, options: move _6, pointer_middle: move _8, pointer_high: move _10, reserved: move _12, phantom: const ZeroSized: PhantomData<F> };
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:650:1: 650:32>::fmt(_1: &Entry<T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _7: core::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &core::fmt::Arguments<'_>;
    let _12: core::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &addr::VirtAddr;
    let _19: addr::VirtAddr;
    let mut _20: &[core::fmt::rt::Placeholder];
    let _21: &[core::fmt::rt::Placeholder; 1];
    let _22: [core::fmt::rt::Placeholder; 1];
    let mut _23: core::fmt::rt::Placeholder;
    let mut _24: core::fmt::rt::Alignment;
    let mut _25: core::fmt::rt::Count;
    let mut _26: core::fmt::rt::Count;
    let mut _27: core::fmt::rt::UnsafeArg;
    let _28: &str;
    let mut _29: &dyn core::fmt::Debug;
    let _30: &u16;
    let _31: &str;
    let mut _32: &dyn core::fmt::Debug;
    let _33: &structures::idt::EntryOptions;
    let mut _34: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _8 = const "Entry";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "handler_addr";
        _34 = const _;
        _13 = _34 as &[&str] (PointerCoercion(Unsize));
        _19 = Entry::<T>::handler_addr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _18 = &_19;
        _17 = core::fmt::rt::Argument::<'_>::new_lower_hex::<addr::VirtAddr>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _24 = core::fmt::rt::Alignment::Unknown;
        _25 = core::fmt::rt::Count::Implied;
        _26 = core::fmt::rt::Count::Implied;
        _23 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _24, const 4_u32, move _25, move _26) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _22 = [move _23];
        _21 = &_22;
        _20 = _21 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _27 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _12 = Arguments::<'_>::new_v1_formatted(move _13, move _14, move _20, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = &_12;
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _28 = const "gdt_selector";
        _30 = &((*_1).1: u16);
        _29 = _30 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _28, move _29) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _31 = const "options";
        _33 = &((*_1).2: structures::idt::EntryOptions);
        _32 = _33 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _31, move _32) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:650:1: 650:32>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:660:1: 660:31>::eq(_1: &Entry<T>, _2: &Entry<T>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u16;
    let mut _5: u16;
    let mut _6: bool;
    let mut _7: u16;
    let mut _8: u16;
    let mut _9: bool;
    let mut _10: &structures::idt::EntryOptions;
    let mut _11: &structures::idt::EntryOptions;
    let mut _12: bool;
    let mut _13: u16;
    let mut _14: u16;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;

    bb0: {
        _4 = ((*_1).0: u16);
        _5 = ((*_2).0: u16);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb7, otherwise: bb1];
    }

    bb1: {
        _7 = ((*_1).1: u16);
        _8 = ((*_2).1: u16);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _10 = &((*_1).2: structures::idt::EntryOptions);
        _11 = &((*_2).2: structures::idt::EntryOptions);
        _9 = <EntryOptions as PartialEq>::eq(move _10, move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _9) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _13 = ((*_1).3: u16);
        _14 = ((*_2).3: u16);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        _16 = ((*_1).4: u32);
        _17 = ((*_2).4: u32);
        _15 = Eq(move _16, move _17);
        switchInt(move _15) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _18 = ((*_1).5: u32);
        _19 = ((*_2).5: u32);
        _0 = Eq(move _18, move _19);
        goto -> bb8;
    }

    bb7: {
        _0 = const false;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:726:1: 726:17>::missing() -> Entry<F> {
    let mut _0: structures::idt::Entry<F>;
    let mut _1: structures::idt::EntryOptions;

    bb0: {
        _1 = EntryOptions::minimal() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<F> { pointer_low: const 0_u16, gdt_selector: const 0_u16, options: move _1, pointer_middle: const 0_u16, pointer_high: const 0_u32, reserved: const 0_u32, phantom: const ZeroSized: PhantomData<F> };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:726:1: 726:17>::missing() -> Entry<F> {
    let mut _0: structures::idt::Entry<F>;
    let mut _1: structures::idt::EntryOptions;
    let mut _2: core::marker::PhantomData<F>;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = EntryOptions::minimal() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_2);
        _2 = PhantomData::<F>;
        _0 = Entry::<F> { pointer_low: const 0_u16, gdt_selector: const 0_u16, options: move _1, pointer_middle: const 0_u16, pointer_high: const 0_u32, reserved: const 0_u32, phantom: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:726:1: 726:17>::set_handler_addr(_1: &mut Entry<F>, _2: addr::VirtAddr) -> &mut EntryOptions {
    debug self => _1;
    debug addr => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: u64;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u16;
    let mut _11: registers::segmentation::SegmentSelector;
    let _12: &mut structures::idt::EntryOptions;
    let mut _13: &mut structures::idt::EntryOptions;
    scope 1 {
        debug addr => _3;
    }

    bb0: {
        _3 = addr::VirtAddr::as_u64(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        ((*_1).0: u16) = _3 as u16 (IntToInt);
        _5 = const 16_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(_3, const 16_i32);
        ((*_1).3: u16) = move _4 as u16 (IntToInt);
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Shr(_3, const 32_i32);
        ((*_1).4: u32) = move _7 as u32 (IntToInt);
        _11 = <CS as Segment>::get_reg() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = (_11.0: u16);
        ((*_1).1: u16) = move _10;
        _13 = &mut ((*_1).2: structures::idt::EntryOptions);
        _12 = EntryOptions::set_present(move _13, const true) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = &mut ((*_1).2: structures::idt::EntryOptions);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:726:1: 726:17>::handler_addr(_1: &Entry<F>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u16;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u16;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    scope 1 {
        debug addr => _2;
    }

    bb0: {
        _5 = ((*_1).0: u16);
        _4 = move _5 as u64 (IntToInt);
        _8 = ((*_1).3: u16);
        _7 = move _8 as u64 (IntToInt);
        _9 = const 16_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shl(move _7, const 16_i32);
        _3 = BitOr(move _4, move _6);
        _13 = ((*_1).4: u32);
        _12 = move _13 as u64 (IntToInt);
        _14 = const 32_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Shl(move _12, const 32_i32);
        _2 = BitOr(move _3, move _11);
        _0 = addr::VirtAddr::new_truncate(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:785:9: 785:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame)>, _2: extern "x86-interrupt" fn(InterruptStackFrame)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:785:9: 785:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64)>, _2: extern "x86-interrupt" fn(InterruptStackFrame, u64)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:785:9: 785:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>, _2: extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, PageFaultErrorCode)>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:785:9: 785:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame) -> !>, _2: extern "x86-interrupt" fn(InterruptStackFrame) -> !) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame) -> !>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:785:9: 785:23>::set_handler_fn(_1: &mut Entry<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>, _2: extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !) -> &mut EntryOptions {
    debug self => _1;
    debug handler => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: addr::VirtAddr;
    let mut _4: u64;
    scope 1 {
        debug handler => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = _2 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Entry::<extern "x86-interrupt" fn(InterruptStackFrame, u64) -> !>::set_handler_addr(_1, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:813:10: 813:15>::clone(_1: &EntryOptions) -> EntryOptions {
    debug self => _1;
    let mut _0: structures::idt::EntryOptions;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:813:23: 813:32>::eq(_1: &EntryOptions, _2: &EntryOptions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:816:1: 816:33>::fmt(_1: &EntryOptions, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _4: &mut core::fmt::DebugTuple<'_, '_>;
    let mut _5: core::fmt::DebugTuple<'_, '_>;
    let _6: &str;
    let mut _7: &dyn core::fmt::Debug;
    let _8: &core::fmt::Arguments<'_>;
    let _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &u16;
    let mut _16: &[core::fmt::rt::Placeholder];
    let _17: &[core::fmt::rt::Placeholder; 1];
    let _18: [core::fmt::rt::Placeholder; 1];
    let mut _19: core::fmt::rt::Placeholder;
    let mut _20: core::fmt::rt::Alignment;
    let mut _21: core::fmt::rt::Count;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::UnsafeArg;
    let mut _24: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _6 = const "EntryOptions";
        _5 = Formatter::<'_>::debug_tuple(_2, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _24 = const _;
        _10 = _24 as &[&str] (PointerCoercion(Unsize));
        _15 = &((*_1).0: u16);
        _14 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u16>(_15) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::Alignment::Unknown;
        _21 = core::fmt::rt::Count::Implied;
        _22 = core::fmt::rt::Count::Is(const 6_usize);
        _19 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _20, const 12_u32, move _21, move _22) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _23 = core::fmt::rt::UnsafeArg::new() -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = Arguments::<'_>::new_v1_formatted(move _10, move _11, move _16, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = &_9;
        _7 = _8 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugTuple::<'_, '_>::field(move _4, move _7) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = DebugTuple::<'_, '_>::finish(_3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:816:1: 816:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::minimal() -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(const 3584_u16);
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::minimal() -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(const 3584_u16);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::set_present(_1: &mut EntryOptions, _2: bool) -> &mut EntryOptions {
    debug self => _1;
    debug present => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _3 = <u16 as BitField>::set_bit(move _4, const 15_usize, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::disable_interrupts(_1: &mut EntryOptions, _2: bool) -> &mut EntryOptions {
    debug self => _1;
    debug disable => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Not(_2);
        _3 = <u16 as BitField>::set_bit(move _4, const 8_usize, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::set_privilege_level(_1: &mut EntryOptions, _2: PrivilegeLevel) -> &mut EntryOptions {
    debug self => _1;
    debug dpl => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: u8;
    let mut _8: bool;

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 13_usize, end: const 15_usize };
        _7 = discriminant(_2);
        _8 = Le(_7, const 3_u8);
        assume(move _8);
        _6 = _7 as u16 (IntToInt);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:824:1: 824:18>::set_stack_index(_1: &mut EntryOptions, _2: u16) -> &mut EntryOptions {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::idt::EntryOptions;
    let _3: &mut u16;
    let mut _4: &mut u16;
    let mut _5: core::ops::Range<usize>;
    let mut _6: u16;
    let mut _7: (u16, bool);

    bb0: {
        _4 = &mut ((*_1).0: u16);
        _5 = Range::<usize> { start: const 0_usize, end: const 3_usize };
        _7 = CheckedAdd(_2, const 1_u16);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_u16) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move (_7.0: u16);
        _3 = <u16 as BitField>::set_bits::<Range<usize>>(move _4, move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:888:1: 888:25>::as_mut(_1: &mut InterruptStackFrame) -> Volatile<&mut InterruptStackFrameValue> {
    debug self => _1;
    let mut _0: volatile::Volatile<&mut structures::idt::InterruptStackFrameValue>;
    let mut _2: &mut structures::idt::InterruptStackFrameValue;

    bb0: {
        _2 = &mut ((*_1).0: structures::idt::InterruptStackFrameValue);
        _0 = Volatile::<&mut InterruptStackFrameValue>::new(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:909:1: 909:35>::deref(_1: &InterruptStackFrame) -> &InterruptStackFrameValue {
    debug self => _1;
    let mut _0: &structures::idt::InterruptStackFrameValue;

    bb0: {
        _0 = &((*_1).0: structures::idt::InterruptStackFrameValue);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:918:1: 918:40>::fmt(_1: &InterruptStackFrame, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &structures::idt::InterruptStackFrameValue;

    bb0: {
        _3 = &((*_1).0: structures::idt::InterruptStackFrameValue);
        _0 = <InterruptStackFrameValue as Debug>::fmt(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:926:10: 926:15>::clone(_1: &InterruptStackFrameValue) -> InterruptStackFrameValue {
    debug self => _1;
    let mut _0: structures::idt::InterruptStackFrameValue;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:945:1: 945:30>::iretq(_1: &InterruptStackFrameValue) -> ! {
    debug self => _1;
    let mut _0: !;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: addr::VirtAddr;
    let mut _7: u64;
    let mut _8: u64;
    scope 1 {
    }

    bb0: {
        _2 = ((*_1).2: u64);
        _4 = ((*_1).0: addr::VirtAddr);
        _3 = addr::VirtAddr::as_u64(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = ((*_1).3: addr::VirtAddr);
        _5 = addr::VirtAddr::as_u64(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = ((*_1).1: u64);
        _8 = ((*_1).4: u64);
        asm!("push {4}
push {2}
push {0}
push {3}
push {1}
iretq", in(reg) move _2, in(reg) move _3, in(reg) move _5, in(reg) move _7, in(reg) move _8, options(NORETURN)) -> unwind unreachable;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:979:1: 979:45>::fmt(_1: &InterruptStackFrameValue, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &addr::VirtAddr;
    let _10: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _11: &mut core::fmt::DebugStruct<'_, '_>;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &u64;
    let _15: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _16: &mut core::fmt::DebugStruct<'_, '_>;
    let _17: &str;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &<structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;
    let _20: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;
    let mut _21: u64;
    let _22: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _23: &mut core::fmt::DebugStruct<'_, '_>;
    let _24: &str;
    let mut _25: &dyn core::fmt::Debug;
    let _26: &addr::VirtAddr;
    let _27: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _28: &mut core::fmt::DebugStruct<'_, '_>;
    let _29: &str;
    let mut _30: &dyn core::fmt::Debug;
    let _31: &u64;
    let mut _32: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "InterruptStackFrame";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "instruction_pointer";
        _9 = &((*_1).0: addr::VirtAddr);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = &mut _3;
        _12 = const "code_segment";
        _14 = &((*_1).1: u64);
        _13 = _14 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = DebugStruct::<'_, '_>::field(move _11, _12, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = &mut _3;
        _17 = const "cpu_flags";
        _21 = ((*_1).2: u64);
        _20 = Hex(move _21);
        _19 = &_20;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _15 = DebugStruct::<'_, '_>::field(move _16, _17, move _18) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _23 = &mut _3;
        _24 = const "stack_pointer";
        _26 = &((*_1).3: addr::VirtAddr);
        _25 = _26 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _22 = DebugStruct::<'_, '_>::field(move _23, _24, move _25) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _28 = &mut _3;
        _29 = const "stack_segment";
        _31 = &((*_1).4: u64);
        _30 = _31 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = DebugStruct::<'_, '_>::field(move _28, _29, move _30) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _32 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _32) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:979:1: 979:45>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:982:9: 982:32>::fmt(_1: &Hex, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &u64;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _18 = const _;
        _4 = _18 as &[&str] (PointerCoercion(Unsize));
        _9 = &((*_1).0: u64);
        _8 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:979:1: 979:45>::fmt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:982:9: 982:32>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:14: 1005:23>::eq(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::idt::_::InternalBitFlags;
    let mut _4: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:25: 1005:27>::assert_receiver_is_total_eq(_1: &PageFaultErrorCode) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:29: 1005:39>::partial_cmp(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &structures::idt::_::InternalBitFlags;
    let _4: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:41: 1005:44>::cmp(_1: &PageFaultErrorCode, _2: &PageFaultErrorCode) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &structures::idt::_::InternalBitFlags;
    let _4: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = &((*_2).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:46: 1005:50>::hash(_1: &PageFaultErrorCode, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:52: 1005:57>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&structures::idt::_::InternalBitFlags;
    let _6: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = const "PageFaultErrorCode";
        _6 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1005:59: 1005:64>::clone(_1: &PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTION_VIOLATION: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::CAUSED_BY_WRITE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::USER_MODE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::MALFORMED_TABLE: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::INSTRUCTION_FETCH: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PROTECTION_KEY: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SHADOW_STACK: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::SGX: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 15_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 15_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 15_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::RMP: PageFaultErrorCode = {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 31_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 31_i32);
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<PageFaultErrorCode>] = {
    let mut _0: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let mut _1: &[bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    let _2: &[bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    let _3: [bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    let mut _4: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _5: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _6: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _7: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _8: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _9: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _10: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _11: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _12: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _13: &[bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _13 = const _;
        _2 = &(*_13);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<structures::idt::PageFaultErrorCode>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<PageFaultErrorCode>; 9] = {
    let mut _0: &[bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    let mut _1: [bitflags::Flag<structures::idt::PageFaultErrorCode>; 9];
    let mut _2: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _3: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _4: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _5: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _6: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _7: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _8: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _9: bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let mut _10: bitflags::Flag<structures::idt::PageFaultErrorCode>;

    bb0: {
        _2 = Flag::<PageFaultErrorCode>::new(const "PROTECTION_VIOLATION", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<PageFaultErrorCode>::new(const "CAUSED_BY_WRITE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<PageFaultErrorCode>::new(const "USER_MODE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<PageFaultErrorCode>::new(const "MALFORMED_TABLE", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<PageFaultErrorCode>::new(const "INSTRUCTION_FETCH", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<PageFaultErrorCode>::new(const "PROTECTION_KEY", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<PageFaultErrorCode>::new(const "SHADOW_STACK", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<PageFaultErrorCode>::new(const "SGX", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<PageFaultErrorCode>::new(const "RMP", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10];
        _0 = &_1;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &PageFaultErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const idt::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &idt::_::InternalBitFlags, _2: &idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &idt::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &idt::_::InternalBitFlags, _2: &idt::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &idt::_::InternalBitFlags, _2: &idt::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &idt::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = idt::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <idt::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::idt::PageFaultErrorCode;
    let _4: structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = PageFaultErrorCode(move _5);
        _3 = &_4;
        _0 = to_writer::<PageFaultErrorCode, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<idt::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<structures::idt::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<structures::idt::PageFaultErrorCode, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<PageFaultErrorCode>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<PageFaultErrorCode, ParseError>::map::<idt::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: PageFaultErrorCode) -> idt::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: structures::idt::_::InternalBitFlags);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &idt::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> idt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags(const _);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &structures::idt::PageFaultErrorCode;
    let mut _5: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _6: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &structures::idt::PageFaultErrorCode;
    let mut _14: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _15: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &structures::idt::PageFaultErrorCode;
    let mut _23: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _24: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &structures::idt::PageFaultErrorCode;
    let mut _32: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _33: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &structures::idt::PageFaultErrorCode;
    let mut _41: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _42: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &structures::idt::PageFaultErrorCode;
    let mut _50: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _51: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &structures::idt::PageFaultErrorCode;
    let mut _59: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _60: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &structures::idt::PageFaultErrorCode;
    let mut _68: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _69: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &structures::idt::PageFaultErrorCode;
    let mut _77: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _78: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let mut _84: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<PageFaultErrorCode>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::<impl PageFaultErrorCode>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<PageFaultErrorCode>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = idt::_::<impl PageFaultErrorCode>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<PageFaultErrorCode>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = idt::_::<impl PageFaultErrorCode>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<PageFaultErrorCode>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = idt::_::<impl PageFaultErrorCode>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<PageFaultErrorCode>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = idt::_::<impl PageFaultErrorCode>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<PageFaultErrorCode>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = idt::_::<impl PageFaultErrorCode>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<PageFaultErrorCode>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = idt::_::<impl PageFaultErrorCode>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<PageFaultErrorCode>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = idt::_::<impl PageFaultErrorCode>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<PageFaultErrorCode>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = idt::_::<impl PageFaultErrorCode>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _84 = _1;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _84) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &structures::idt::PageFaultErrorCode;
    let _6: &structures::idt::PageFaultErrorCode;
    let mut _7: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _8: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &structures::idt::PageFaultErrorCode;
    let _18: &structures::idt::PageFaultErrorCode;
    let mut _19: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _20: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &structures::idt::PageFaultErrorCode;
    let _30: &structures::idt::PageFaultErrorCode;
    let mut _31: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _32: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &structures::idt::PageFaultErrorCode;
    let _42: &structures::idt::PageFaultErrorCode;
    let mut _43: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _44: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &structures::idt::PageFaultErrorCode;
    let _54: &structures::idt::PageFaultErrorCode;
    let mut _55: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _56: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &structures::idt::PageFaultErrorCode;
    let _66: &structures::idt::PageFaultErrorCode;
    let mut _67: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _68: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &structures::idt::PageFaultErrorCode;
    let _78: &structures::idt::PageFaultErrorCode;
    let mut _79: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _80: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &structures::idt::PageFaultErrorCode;
    let _90: &structures::idt::PageFaultErrorCode;
    let mut _91: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _92: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &structures::idt::PageFaultErrorCode;
    let _102: &structures::idt::PageFaultErrorCode;
    let mut _103: &bitflags::Flag<structures::idt::PageFaultErrorCode>;
    let _104: &[bitflags::Flag<structures::idt::PageFaultErrorCode>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let mut _111: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<PageFaultErrorCode>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = idt::_::<impl PageFaultErrorCode>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<PageFaultErrorCode>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = idt::_::<impl PageFaultErrorCode>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<PageFaultErrorCode>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = idt::_::<impl PageFaultErrorCode>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<PageFaultErrorCode>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = idt::_::<impl PageFaultErrorCode>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<PageFaultErrorCode>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = idt::_::<impl PageFaultErrorCode>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<PageFaultErrorCode>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = idt::_::<impl PageFaultErrorCode>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<PageFaultErrorCode>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = idt::_::<impl PageFaultErrorCode>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<PageFaultErrorCode>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = idt::_::<impl PageFaultErrorCode>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<PageFaultErrorCode>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = idt::_::<impl PageFaultErrorCode>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        _111 = _1;
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _111) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        StorageDead(_111);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &idt::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &idt::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<idt::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::_::InternalBitFlags>;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = idt::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = idt::_::InternalBitFlags(_1);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<idt::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<idt::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: structures::idt::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = idt::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = idt::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<idt::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> idt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::idt::_::InternalBitFlags;
    let _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = idt::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = idt::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> idt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &structures::idt::_::InternalBitFlags;
    let _7: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = idt::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = idt::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> idt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = idt::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> idt::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = idt::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<idt::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<structures::idt::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: structures::idt::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: structures::idt::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: structures::idt::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: structures::idt::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: structures::idt::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: structures::idt::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: structures::idt::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: structures::idt::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: structures::idt::_::InternalBitFlags;
    let mut _38: u64;
    scope 1 {
        debug name => _2;
        let mut _39: &structures::idt::PageFaultErrorCode;
        let mut _40: &structures::idt::PageFaultErrorCode;
        let mut _41: &structures::idt::PageFaultErrorCode;
        let mut _42: &structures::idt::PageFaultErrorCode;
        let mut _43: &structures::idt::PageFaultErrorCode;
        let mut _44: &structures::idt::PageFaultErrorCode;
        let mut _45: &structures::idt::PageFaultErrorCode;
        let mut _46: &structures::idt::PageFaultErrorCode;
        let mut _47: &structures::idt::PageFaultErrorCode;
        let mut _48: &&str;
        let mut _49: &&str;
        let mut _50: &&str;
        let mut _51: &&str;
        let mut _52: &&str;
        let mut _53: &&str;
        let mut _54: &&str;
        let mut _55: &&str;
        let mut _56: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _56 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _56) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _39 = const _;
        _6 = idt::_::<impl PageFaultErrorCode>::bits(_39) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = idt::_::InternalBitFlags(move _6);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _5);
        goto -> bb37;
    }

    bb4: {
        _8 = &_2;
        _55 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _55) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _40 = const _;
        _10 = idt::_::<impl PageFaultErrorCode>::bits(_40) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = idt::_::InternalBitFlags(move _10);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _9);
        goto -> bb37;
    }

    bb8: {
        _12 = &_2;
        _54 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _54) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _41 = const _;
        _14 = idt::_::<impl PageFaultErrorCode>::bits(_41) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = idt::_::InternalBitFlags(move _14);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _13);
        goto -> bb37;
    }

    bb12: {
        _16 = &_2;
        _53 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _53) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _42 = const _;
        _18 = idt::_::<impl PageFaultErrorCode>::bits(_42) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = idt::_::InternalBitFlags(move _18);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _17);
        goto -> bb37;
    }

    bb16: {
        _20 = &_2;
        _52 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _52) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _43 = const _;
        _22 = idt::_::<impl PageFaultErrorCode>::bits(_43) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = idt::_::InternalBitFlags(move _22);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _21);
        goto -> bb37;
    }

    bb20: {
        _24 = &_2;
        _51 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _51) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _44 = const _;
        _26 = idt::_::<impl PageFaultErrorCode>::bits(_44) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = idt::_::InternalBitFlags(move _26);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _25);
        goto -> bb37;
    }

    bb24: {
        _28 = &_2;
        _50 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _50) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _45 = const _;
        _30 = idt::_::<impl PageFaultErrorCode>::bits(_45) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = idt::_::InternalBitFlags(move _30);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _29);
        goto -> bb37;
    }

    bb28: {
        _32 = &_2;
        _49 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _49) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _46 = const _;
        _34 = idt::_::<impl PageFaultErrorCode>::bits(_46) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = idt::_::InternalBitFlags(move _34);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _33);
        goto -> bb37;
    }

    bb32: {
        _36 = &_2;
        _48 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _48) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _47 = const _;
        _38 = idt::_::<impl PageFaultErrorCode>::bits(_47) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = idt::_::InternalBitFlags(move _38);
        _0 = Option::<idt::_::InternalBitFlags>::Some(move _37);
        goto -> bb37;
    }

    bb36: {
        _0 = Option::<idt::_::InternalBitFlags>::None;
        goto -> bb37;
    }

    bb37: {
        return;
    }
}

promoted[0] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageFaultErrorCode = {
    let mut _0: &structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::PageFaultErrorCode;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "RMP";
        _0 = &_1;
        return;
    }
}

promoted[10] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SGX";
        _0 = &_1;
        return;
    }
}

promoted[11] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "SHADOW_STACK";
        _0 = &_1;
        return;
    }
}

promoted[12] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTION_KEY";
        _0 = &_1;
        return;
    }
}

promoted[13] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "INSTRUCTION_FETCH";
        _0 = &_1;
        return;
    }
}

promoted[14] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "MALFORMED_TABLE";
        _0 = &_1;
        return;
    }
}

promoted[15] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "USER_MODE";
        _0 = &_1;
        return;
    }
}

promoted[16] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "CAUSED_BY_WRITE";
        _0 = &_1;
        return;
    }
}

promoted[17] in idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PROTECTION_VIOLATION";
        _0 = &_1;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::idt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::idt::_::InternalBitFlags;
    let _5: structures::idt::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = idt::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = idt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = idt::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::idt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::idt::_::InternalBitFlags;
    let _6: structures::idt::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &structures::idt::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = idt::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = idt::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = idt::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = idt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = idt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = idt::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = idt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = idt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = idt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = idt::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = idt::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = idt::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = idt::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _3: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = idt::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _2: structures::idt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = idt::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = idt::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let _2: structures::idt::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = idt::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &idt::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::idt::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = idt::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = idt::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut idt::_::InternalBitFlags, _2: idt::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: idt::_::InternalBitFlags) -> idt::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut idt::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::idt::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::idt::_::InternalBitFlags);
        _5 = idt::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> idt::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: structures::idt::_::InternalBitFlags;
    let mut _2: structures::idt::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut structures::idt::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <idt::_::InternalBitFlags as Extend<idt::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &idt::_::InternalBitFlags) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;

    bb0: {
        _3 = idt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = idt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &idt::_::InternalBitFlags) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: &structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &idt::_::InternalBitFlags) -> IterNames<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;

    bb0: {
        _3 = idt::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = idt::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &idt::_::InternalBitFlags) -> IterNames<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: &structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: &structures::idt::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = idt::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: idt::_::InternalBitFlags) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: &structures::idt::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = idt::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut idt::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::_::InternalBitFlags;

    bb0: {
        _1 = idt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _1);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = idt::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _1);
        StorageDead(_1);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::_::InternalBitFlags;

    bb0: {
        _1 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _1);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _1: structures::idt::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = idt::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _1);
        StorageDead(_1);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &PageFaultErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &PageFaultErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::idt::PageFaultErrorCode;
    let mut _3: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<PageFaultErrorCode> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _2: core::option::Option<structures::idt::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::idt::PageFaultErrorCode;
    scope 1 {
        debug bits => _1;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<PageFaultErrorCode>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::idt::_::InternalBitFlags);
        _5 = PageFaultErrorCode(_4);
        _0 = Option::<PageFaultErrorCode>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<PageFaultErrorCode> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::idt::PageFaultErrorCode>;
    let _2: u64;
    let mut _3: core::option::Option<structures::idt::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: structures::idt::PageFaultErrorCode;
    let mut _8: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<PageFaultErrorCode>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: structures::idt::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = PageFaultErrorCode(move _8);
        StorageDead(_8);
        _0 = Option::<PageFaultErrorCode>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _2);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _2: u64;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageFaultErrorCode(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _2);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _2: u64;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageFaultErrorCode(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<PageFaultErrorCode> {
    debug name => _1;
    let mut _0: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _2: core::option::Option<structures::idt::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::idt::PageFaultErrorCode;
    scope 1 {
        debug name => _1;
        let _4: structures::idt::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = idt::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<PageFaultErrorCode>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::idt::_::InternalBitFlags);
        _5 = PageFaultErrorCode(_4);
        _0 = Option::<PageFaultErrorCode>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::idt::PageFaultErrorCode;
    let mut _3: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &PageFaultErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::idt::PageFaultErrorCode;
    let mut _3: &structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::idt::PageFaultErrorCode;
    let mut _5: &structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::idt::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &PageFaultErrorCode, _2: PageFaultErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::idt::PageFaultErrorCode;
    let mut _5: &structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::idt::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = idt::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::idt::_::InternalBitFlags);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::idt::_::InternalBitFlags);
        _5 = (_2.0: structures::idt::_::InternalBitFlags);
        _0 = idt::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::idt::_::InternalBitFlags);
        _5 = (_2.0: structures::idt::_::InternalBitFlags);
        _3 = idt::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _3: structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    let mut _7: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::idt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = idt::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageFaultErrorCode(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::idt::_::InternalBitFlags);
        _5 = (_2.0: structures::idt::_::InternalBitFlags);
        _3 = idt::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _3: structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    let mut _7: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::idt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = idt::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageFaultErrorCode(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::idt::_::InternalBitFlags);
        _5 = (_2.0: structures::idt::_::InternalBitFlags);
        _3 = idt::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _3: structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    let mut _7: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::idt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = idt::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageFaultErrorCode(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    let mut _5: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::idt::_::InternalBitFlags);
        _5 = (_2.0: structures::idt::_::InternalBitFlags);
        _3 = idt::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _3);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _3: structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::_::InternalBitFlags;
    let mut _6: structures::idt::_::InternalBitFlags;
    let mut _7: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::idt::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = idt::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageFaultErrorCode(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::_::InternalBitFlags;
    let mut _3: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: structures::idt::_::InternalBitFlags);
        _2 = idt::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageFaultErrorCode(move _2);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let _2: structures::idt::PageFaultErrorCode;
    let mut _3: structures::idt::_::InternalBitFlags;
    let mut _4: structures::idt::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: structures::idt::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = idt::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageFaultErrorCode(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &PageFaultErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::idt::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::idt::_::InternalBitFlags);
        _0 = <idt::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::<impl PageFaultErrorCode>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::<impl PageFaultErrorCode>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::idt::PageFaultErrorCode;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;
    let mut _6: &structures::idt::PageFaultErrorCode;

    bb0: {
        _6 = &(*_1);
        _5 = idt::_::<impl PageFaultErrorCode>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = idt::_::<impl PageFaultErrorCode>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: PageFaultErrorCode, _2: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut PageFaultErrorCode, _2: PageFaultErrorCode) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = idt::_::<impl PageFaultErrorCode>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: PageFaultErrorCode) -> PageFaultErrorCode {
    debug self => _1;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut PageFaultErrorCode, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::idt::PageFaultErrorCode>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::idt::PageFaultErrorCode;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::idt::PageFaultErrorCode);
        _5 = idt::_::<impl PageFaultErrorCode>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> PageFaultErrorCode {
    debug iterator => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: structures::idt::PageFaultErrorCode;
    let _3: ();
    let mut _4: &mut structures::idt::PageFaultErrorCode;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = idt::_::<impl PageFaultErrorCode>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <PageFaultErrorCode as Extend<PageFaultErrorCode>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &PageFaultErrorCode) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;

    bb0: {
        _3 = idt::_::<impl PageFaultErrorCode>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = idt::_::<impl PageFaultErrorCode>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &PageFaultErrorCode) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: &structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: &structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = idt::_::<impl PageFaultErrorCode>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = idt::_::<impl PageFaultErrorCode>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &PageFaultErrorCode) -> IterNames<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: structures::idt::PageFaultErrorCode;
    let mut _5: u64;

    bb0: {
        _3 = idt::_::<impl PageFaultErrorCode>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = idt::_::<impl PageFaultErrorCode>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &PageFaultErrorCode) -> IterNames<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::idt::PageFaultErrorCode>;
    let mut _2: structures::idt::PageFaultErrorCode;
    let mut _3: u64;
    let mut _4: &structures::idt::PageFaultErrorCode;
    let mut _5: structures::idt::PageFaultErrorCode;
    let mut _6: u64;
    let mut _7: &structures::idt::PageFaultErrorCode;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = idt::_::<impl PageFaultErrorCode>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = idt::_::<impl PageFaultErrorCode>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<PageFaultErrorCode>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn idt::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: PageFaultErrorCode) -> bitflags::iter::Iter<PageFaultErrorCode> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::idt::PageFaultErrorCode>;
    let mut _2: &structures::idt::PageFaultErrorCode;

    bb0: {
        _2 = &_1;
        _0 = idt::_::<impl PageFaultErrorCode>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1046:1: 1046:24>::from_bits_unchecked(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1046:1: 1046:24>::from_bits_unchecked(_1: u64) -> PageFaultErrorCode {
    debug bits => _1;
    let mut _0: structures::idt::PageFaultErrorCode;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = idt::_::<impl PageFaultErrorCode>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1055:10: 1055:15>::clone(_1: &SelectorErrorCode) -> SelectorErrorCode {
    debug self => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1055:23: 1055:32>::eq(_1: &SelectorErrorCode, _2: &SelectorErrorCode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1055:34: 1055:36>::assert_receiver_is_total_eq(_1: &SelectorErrorCode) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1055:38: 1055:42>::hash(_1: &SelectorErrorCode, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::new(_1: u64) -> Option<SelectorErrorCode> {
    debug value => _1;
    let mut _0: core::option::Option<structures::idt::SelectorErrorCode>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: structures::idt::SelectorErrorCode;

    bb0: {
        _3 = const _ as u64 (IntToInt);
        _2 = Gt(_1, move _3);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<SelectorErrorCode>::None;
        goto -> bb3;
    }

    bb2: {
        _4 = SelectorErrorCode { flags: _1 };
        _0 = Option::<SelectorErrorCode>::Some(move _4);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::new(_1: u64) -> Option<SelectorErrorCode> {
    debug value => _1;
    let mut _0: core::option::Option<structures::idt::SelectorErrorCode>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: structures::idt::SelectorErrorCode;
    let mut _6: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = const _ as u64 (IntToInt);
        _2 = Gt(move _3, move _4);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        StorageDead(_4);
        StorageDead(_3);
        _0 = Option::<SelectorErrorCode>::None;
        goto -> bb3;
    }

    bb2: {
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = SelectorErrorCode { flags: move _6 };
        StorageDead(_6);
        _0 = Option::<SelectorErrorCode>::Some(move _5);
        StorageDead(_5);
        goto -> bb3;
    }

    bb3: {
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::new_truncate(_1: u64) -> SelectorErrorCode {
    debug value => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    let mut _2: u64;
    let mut _3: u16;

    bb0: {
        _3 = _1 as u16 (IntToInt);
        _2 = move _3 as u64 (IntToInt);
        _0 = SelectorErrorCode { flags: move _2 };
        return;
    }
}

// MIR FOR CTFE
fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::new_truncate(_1: u64) -> SelectorErrorCode {
    debug value => _1;
    let mut _0: structures::idt::SelectorErrorCode;
    let mut _2: u64;
    let mut _3: u16;
    let mut _4: u64;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        _3 = move _4 as u16 (IntToInt);
        StorageDead(_4);
        _2 = move _3 as u64 (IntToInt);
        StorageDead(_3);
        _0 = SelectorErrorCode { flags: move _2 };
        StorageDead(_2);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::external(_1: &SelectorErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &u64;

    bb0: {
        _2 = &((*_1).0: u64);
        _0 = <u64 as BitField>::get_bit(move _2, const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::descriptor_table(_1: &SelectorErrorCode) -> DescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::DescriptorTable;
    let mut _2: u64;
    let mut _3: &u64;
    let mut _4: core::ops::Range<usize>;
    let mut _5: !;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = Range::<usize> { start: const 1_usize, end: const 3_usize };
        _2 = <u64 as BitField>::get_bits::<Range<usize>>(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, otherwise: bb2];
    }

    bb2: {
        _5 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb3: {
        _0 = DescriptorTable::Gdt;
        goto -> bb7;
    }

    bb4: {
        _0 = DescriptorTable::Idt;
        goto -> bb7;
    }

    bb5: {
        _0 = DescriptorTable::Ldt;
        goto -> bb7;
    }

    bb6: {
        _0 = DescriptorTable::Idt;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::index(_1: &SelectorErrorCode) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &u64;
    let mut _3: core::ops::Range<usize>;

    bb0: {
        _2 = &((*_1).0: u64);
        _3 = Range::<usize> { start: const 3_usize, end: const 16_usize };
        _0 = <u64 as BitField>::get_bits::<Range<usize>>(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1061:1: 1061:23>::is_null(_1: &SelectorErrorCode) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1106:1: 1106:38>::fmt(_1: &SelectorErrorCode, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &bool;
    let _10: bool;
    let _11: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::idt::DescriptorTable;
    let _16: structures::idt::DescriptorTable;
    let _17: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _18: &mut core::fmt::DebugStruct<'_, '_>;
    let _19: &str;
    let mut _20: &dyn core::fmt::Debug;
    let _21: &u64;
    let _22: u64;
    let mut _23: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _4 = const "Selector Error";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "external";
        _10 = SelectorErrorCode::external(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &mut _3;
        _13 = const "descriptor table";
        _16 = SelectorErrorCode::descriptor_table(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = DebugStruct::<'_, '_>::field(move _12, _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _18 = &mut _3;
        _19 = const "index";
        _22 = SelectorErrorCode::index(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _21 = &_22;
        _20 = _21 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = DebugStruct::<'_, '_>::field(move _18, _19, move _20) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _23 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _23) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1119:10: 1119:15>::fmt(_1: &DescriptorTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb6];
    }

    bb1: {
        _7 = const "Ldt";
        _3 = _7;
        goto -> bb4;
    }

    bb2: {
        _5 = const "Gdt";
        _3 = _5;
        goto -> bb4;
    }

    bb3: {
        _6 = const "Idt";
        _3 = _6;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1119:17: 1119:22>::clone(_1: &DescriptorTable) -> DescriptorTable {
    debug self => _1;
    let mut _0: structures::idt::DescriptorTable;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1119:30: 1119:39>::eq(_1: &DescriptorTable, _2: &DescriptorTable) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1119:41: 1119:43>::assert_receiver_is_total_eq(_1: &DescriptorTable) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1119:45: 1119:49>::hash(_1: &DescriptorTable, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: isize;
    let _4: &isize;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <isize as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

ExceptionVector::Division::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

ExceptionVector::Debug::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

ExceptionVector::NonMaskableInterrupt::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

ExceptionVector::Breakpoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

ExceptionVector::Overflow::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 4_u8;
        return;
    }
}

ExceptionVector::BoundRange::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 5_u8;
        return;
    }
}

ExceptionVector::InvalidOpcode::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 6_u8;
        return;
    }
}

ExceptionVector::DeviceNotAvailable::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 7_u8;
        return;
    }
}

ExceptionVector::Double::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 8_u8;
        return;
    }
}

ExceptionVector::InvalidTss::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 10_u8;
        return;
    }
}

ExceptionVector::SegmentNotPresent::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 11_u8;
        return;
    }
}

ExceptionVector::Stack::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 12_u8;
        return;
    }
}

ExceptionVector::GeneralProtection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 13_u8;
        return;
    }
}

ExceptionVector::Page::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 14_u8;
        return;
    }
}

ExceptionVector::X87FloatingPoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 16_u8;
        return;
    }
}

ExceptionVector::AlignmentCheck::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 17_u8;
        return;
    }
}

ExceptionVector::MachineCheck::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 18_u8;
        return;
    }
}

ExceptionVector::SimdFloatingPoint::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 19_u8;
        return;
    }
}

ExceptionVector::Virtualization::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 20_u8;
        return;
    }
}

ExceptionVector::ControlProtection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 21_u8;
        return;
    }
}

ExceptionVector::HypervisorInjection::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 28_u8;
        return;
    }
}

ExceptionVector::VmmCommunication::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 29_u8;
        return;
    }
}

ExceptionVector::Security::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 30_u8;
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1136:16: 1136:21>::clone(_1: &ExceptionVector) -> ExceptionVector {
    debug self => _1;
    let mut _0: structures::idt::ExceptionVector;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1136:23: 1136:28>::fmt(_1: &ExceptionVector, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;
    let _11: &str;
    let _12: &str;
    let _13: &str;
    let _14: &str;
    let _15: &str;
    let _16: &str;
    let _17: &str;
    let _18: &str;
    let _19: &str;
    let _20: &str;
    let _21: &str;
    let _22: &str;
    let _23: &str;
    let _24: &str;
    let _25: &str;
    let _26: &str;
    let _27: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, 4: bb6, 5: bb7, 6: bb8, 7: bb9, 8: bb10, 10: bb11, 11: bb12, 12: bb13, 13: bb14, 14: bb15, 16: bb16, 17: bb17, 18: bb18, 19: bb19, 20: bb20, 21: bb21, 28: bb22, 29: bb23, 30: bb1, otherwise: bb26];
    }

    bb1: {
        _27 = const "Security";
        _3 = _27;
        goto -> bb24;
    }

    bb2: {
        _5 = const "Division";
        _3 = _5;
        goto -> bb24;
    }

    bb3: {
        _6 = const "Debug";
        _3 = _6;
        goto -> bb24;
    }

    bb4: {
        _7 = const "NonMaskableInterrupt";
        _3 = _7;
        goto -> bb24;
    }

    bb5: {
        _8 = const "Breakpoint";
        _3 = _8;
        goto -> bb24;
    }

    bb6: {
        _9 = const "Overflow";
        _3 = _9;
        goto -> bb24;
    }

    bb7: {
        _10 = const "BoundRange";
        _3 = _10;
        goto -> bb24;
    }

    bb8: {
        _11 = const "InvalidOpcode";
        _3 = _11;
        goto -> bb24;
    }

    bb9: {
        _12 = const "DeviceNotAvailable";
        _3 = _12;
        goto -> bb24;
    }

    bb10: {
        _13 = const "Double";
        _3 = _13;
        goto -> bb24;
    }

    bb11: {
        _14 = const "InvalidTss";
        _3 = _14;
        goto -> bb24;
    }

    bb12: {
        _15 = const "SegmentNotPresent";
        _3 = _15;
        goto -> bb24;
    }

    bb13: {
        _16 = const "Stack";
        _3 = _16;
        goto -> bb24;
    }

    bb14: {
        _17 = const "GeneralProtection";
        _3 = _17;
        goto -> bb24;
    }

    bb15: {
        _18 = const "Page";
        _3 = _18;
        goto -> bb24;
    }

    bb16: {
        _19 = const "X87FloatingPoint";
        _3 = _19;
        goto -> bb24;
    }

    bb17: {
        _20 = const "AlignmentCheck";
        _3 = _20;
        goto -> bb24;
    }

    bb18: {
        _21 = const "MachineCheck";
        _3 = _21;
        goto -> bb24;
    }

    bb19: {
        _22 = const "SimdFloatingPoint";
        _3 = _22;
        goto -> bb24;
    }

    bb20: {
        _23 = const "Virtualization";
        _3 = _23;
        goto -> bb24;
    }

    bb21: {
        _24 = const "ControlProtection";
        _3 = _24;
        goto -> bb24;
    }

    bb22: {
        _25 = const "HypervisorInjection";
        _3 = _25;
        goto -> bb24;
    }

    bb23: {
        _26 = const "VmmCommunication";
        _3 = _26;
        goto -> bb24;
    }

    bb24: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        return;
    }

    bb26: {
        unreachable;
    }
}

fn idt::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/idt.rs:1136:30: 1136:39>::eq(_1: &ExceptionVector, _2: &ExceptionVector) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:10: 11:15>::clone(_1: &PhysFrame<S>) -> PhysFrame<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;
    let _3: &addr::PhysAddr;
    let mut _4: core::marker::PhantomData<S>;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _3 = &((*_1).0: addr::PhysAddr);
        _2 = <PhysAddr as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _4 = <PhantomData<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrame::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:23: 11:32>::eq(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &addr::PhysAddr;
    let mut _5: &addr::PhysAddr;
    let mut _6: &core::marker::PhantomData<S>;
    let mut _7: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: core::marker::PhantomData<S>);
        _7 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:34: 11:36>::assert_receiver_is_total_eq(_1: &PhysFrame<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:38: 11:48>::partial_cmp(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let mut _3: core::option::Option<core::cmp::Ordering>;
    let _4: &addr::PhysAddr;
    let _5: &addr::PhysAddr;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &core::marker::PhantomData<S>;
    let _9: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: core::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: core::marker::PhantomData<S>);
        _9 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:50: 11:53>::cmp(_1: &PhysFrame<S>, _2: &PhysFrame<S>) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let mut _3: core::cmp::Ordering;
    let _4: &addr::PhysAddr;
    let _5: &addr::PhysAddr;
    let mut _6: i8;
    let _7: &core::marker::PhantomData<S>;
    let _8: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _5 = &((*_2).0: addr::PhysAddr);
        _3 = <PhysAddr as Ord>::cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb4;
    }

    bb3: {
        _7 = &((*_1).1: core::marker::PhantomData<S>);
        _8 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Ord>::cmp(_7, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:11:55: 11:59>::hash(_1: &PhysFrame<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &addr::PhysAddr;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::PhysAddr);
        _3 = <PhysAddr as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address(_1: PhysAddr) -> Result<PhysFrame<S>, AddressNotAligned> {
    debug address => _1;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<S>, structures::paging::page::AddressNotAligned>;
    let mut _2: bool;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    scope 1 {
    }

    bb0: {
        _2 = PhysAddr::is_aligned::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = PhysFrame::<S>::from_start_address_unchecked(_1) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = Result::<PhysFrame<S>, AddressNotAligned>::Err(const AddressNotAligned);
        goto -> bb5;
    }

    bb4: {
        _0 = Result::<PhysFrame<S>, AddressNotAligned>::Ok(move _3);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address_unchecked(_1: PhysAddr) -> PhysFrame<S> {
    debug start_address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _0 = PhysFrame::<S> { start_address: _1, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::from_start_address_unchecked(_1: PhysAddr) -> PhysFrame<S> {
    debug start_address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;
    let mut _3: core::marker::PhantomData<S>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<S>;
        _0 = PhysFrame::<S> { start_address: move _2, size: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::containing_address(_1: PhysAddr) -> PhysFrame<S> {
    debug address => _1;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _2: addr::PhysAddr;

    bb0: {
        _2 = PhysAddr::align_down::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PhysFrame::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::start_address(_1: PhysFrame<S>) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = (_1.0: addr::PhysAddr);
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::start_address(_1: PhysFrame<S>) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = (_1.0: addr::PhysAddr);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::size(_1: PhysFrame<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::size(_1: PhysFrame<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::range(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;

    bb0: {
        _0 = PhysFrameRange::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::range(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PhysFrameRange::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::range_inclusive(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;

    bb0: {
        _0 = PhysFrameRangeInclusive::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:19:1: 19:31>::range_inclusive(_1: PhysFrame<S>, _2: PhysFrame<S>) -> PhysFrameRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PhysFrameRangeInclusive::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:85:1: 85:46>::fmt(_1: &PhysFrame<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &u64;
    let _11: u64;
    let mut _12: addr::PhysAddr;
    let mut _13: structures::paging::frame::PhysFrame<S>;
    let mut _14: &[core::fmt::rt::Placeholder];
    let _15: &[core::fmt::rt::Placeholder; 2];
    let _16: [core::fmt::rt::Placeholder; 2];
    let mut _17: core::fmt::rt::Placeholder;
    let mut _18: core::fmt::rt::Alignment;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::Count;
    let mut _21: core::fmt::rt::Placeholder;
    let mut _22: core::fmt::rt::Alignment;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::Count;
    let mut _25: core::fmt::rt::UnsafeArg;
    let mut _26: &&str;
    let mut _27: &[&str; 3];
    scope 1 {
    }

    bb0: {
        _27 = const _;
        _4 = _27 as &[&str] (PointerCoercion(Unsize));
        _26 = const _;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _13 = (*_1);
        _12 = PhysFrame::<S>::start_address(move _13) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = PhysAddr::as_u64(move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = [move _8, move _9];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = core::fmt::rt::Alignment::Unknown;
        _19 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Count::Implied;
        _17 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _18, const 0_u32, move _19, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = core::fmt::rt::Alignment::Unknown;
        _23 = core::fmt::rt::Count::Implied;
        _24 = core::fmt::rt::Count::Implied;
        _21 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _22, const 4_u32, move _23, move _24) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _16 = [move _17, move _21];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::UnsafeArg::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _14, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:85:1: 85:46>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:85:1: 85:46>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "PhysFrame[", const "](", const ")"];
        _0 = &_1;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:95:1: 95:44>::add(_1: PhysFrame<S>, _2: u64) -> PhysFrame<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = PhysFrame::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <PhysAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = PhysFrame::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:103:1: 103:50>::add_assign(_1: &mut PhysFrame<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = (*_1);
        _3 = <PhysFrame<S> as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:110:1: 110:44>::sub(_1: PhysFrame<S>, _2: u64) -> PhysFrame<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::frame::PhysFrame<S>;
    let mut _3: addr::PhysAddr;
    let mut _4: addr::PhysAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = PhysFrame::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <PhysAddr as Sub<u64>>::sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = PhysFrame::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:118:1: 118:50>::sub_assign(_1: &mut PhysFrame<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = (*_1);
        _3 = <PhysFrame<S> as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:125:1: 125:53>::sub(_1: PhysFrame<S>, _2: PhysFrame<S>) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: addr::PhysAddr;
    let mut _5: addr::PhysAddr;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: addr::PhysAddr);
        _5 = (_2.0: addr::PhysAddr);
        _3 = <PhysAddr as Sub>::sub(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Eq(const _, const 0_u64);
        assert(!move _6, "attempt to divide `{}` by zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Div(move _3, const _);
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:134:10: 134:15>::clone(_1: &PhysFrameRange<S>) -> PhysFrameRange<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrameRange<S>;
    let mut _2: structures::paging::frame::PhysFrame<S>;
    let _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _4 = <PhysFrame<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrameRange::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:134:23: 134:32>::eq(_1: &PhysFrameRange<S>, _2: &PhysFrameRange<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let mut _5: &structures::paging::frame::PhysFrame<S>;
    let mut _6: &structures::paging::frame::PhysFrame<S>;
    let mut _7: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _5 = &((*_2).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _7 = &((*_2).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:134:34: 134:36>::assert_receiver_is_total_eq(_1: &PhysFrameRange<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:134:38: 134:42>::hash(_1: &PhysFrameRange<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:143:1: 143:36>::is_empty(_1: &PhysFrameRange<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::frame::PhysFrame<S>;
    let mut _3: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialOrd>::ge(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:151:1: 151:49>::next(_1: &mut PhysFrameRange<S>) -> Option<PhysFrame<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::frame::PhysFrame<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let _5: structures::paging::frame::PhysFrame<S>;
    let _6: ();
    let mut _7: &mut structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug frame => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _4 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as PartialOrd>::lt(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _7 = &mut ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _6 = <PhysFrame<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<PhysFrame<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PhysFrame<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:166:1: 166:51>::fmt(_1: &PhysFrameRange<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::frame::PhysFrame<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _7 = const "PhysFrameRange";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:176:10: 176:15>::clone(_1: &PhysFrameRangeInclusive<S>) -> PhysFrameRangeInclusive<S> {
    debug self => _1;
    let mut _0: structures::paging::frame::PhysFrameRangeInclusive<S>;
    let mut _2: structures::paging::frame::PhysFrame<S>;
    let _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _4 = <PhysFrame<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PhysFrameRangeInclusive::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:176:23: 176:32>::eq(_1: &PhysFrameRangeInclusive<S>, _2: &PhysFrameRangeInclusive<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let mut _5: &structures::paging::frame::PhysFrame<S>;
    let mut _6: &structures::paging::frame::PhysFrame<S>;
    let mut _7: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _5 = &((*_2).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _7 = &((*_2).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:176:34: 176:36>::assert_receiver_is_total_eq(_1: &PhysFrameRangeInclusive<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:176:38: 176:42>::hash(_1: &PhysFrameRangeInclusive<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::frame::PhysFrame<S>;
    let _5: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = <PhysFrame<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:185:1: 185:45>::is_empty(_1: &PhysFrameRangeInclusive<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::frame::PhysFrame<S>;
    let mut _3: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _3 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _0 = <PhysFrame<S> as PartialOrd>::gt(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:193:1: 193:58>::next(_1: &mut PhysFrameRangeInclusive<S>) -> Option<PhysFrame<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::frame::PhysFrame<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::frame::PhysFrame<S>;
    let mut _4: &structures::paging::frame::PhysFrame<S>;
    let _5: structures::paging::frame::PhysFrame<S>;
    let _6: ();
    let mut _7: &mut structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug frame => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _4 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _2 = <PhysFrame<S> as PartialOrd>::le(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _7 = &mut ((*_1).0: structures::paging::frame::PhysFrame<S>);
        _6 = <PhysFrame<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<PhysFrame<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<PhysFrame<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn frame::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/frame.rs:208:1: 208:60>::fmt(_1: &PhysFrameRangeInclusive<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::frame::PhysFrame<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::frame::PhysFrame<S>;

    bb0: {
        _7 = const "PhysFrameRangeInclusive";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::frame::PhysFrame<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::frame::PhysFrame<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:16:10: 16:15>::fmt(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&&mut structures::paging::page_table::PageTable;
    let _10: &&mut structures::paging::page_table::PageTable;

    bb0: {
        _3 = const "MappedPageTable";
        _4 = const "page_table_walker";
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "level_4_table";
        _10 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::new(_1: &mut PageTable, _2: P) -> mapped_page_table::MappedPageTable<'_, P> {
    debug level_4_table => _1;
    debug page_table_frame_mapping => _2;
    let mut _0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, P>;
    let mut _3: structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    scope 1 {
    }

    bb0: {
        _3 = PageTableWalker::<P>::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapped_page_table::MappedPageTable::<'_, P> { page_table_walker: move _3, level_4_table: _1 };
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::level_4_table(_1: &mut mapped_page_table::MappedPageTable<'_, P>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut &mut structures::paging::page_table::PageTable;

    bb0: {
        _2 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _0 = deref_copy (*_2);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::page_table_frame_mapping(_1: &mapped_page_table::MappedPageTable<'_, P>) -> &P {
    debug self => _1;
    let mut _0: &P;

    bb0: {
        _0 = &(((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>).0: P);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_1gib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: bool;
    let _17: &structures::paging::page_table::PageTableEntry;
    let mut _18: &structures::paging::page_table::PageTable;
    let mut _19: structures::paging::page_table::PageTableIndex;
    let mut _20: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let _21: ();
    let mut _22: &mut structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _24: addr::PhysAddr;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _27: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _27 = deref_copy (*_7);
        _12 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_27, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb6, otherwise: bb19];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &(*_15);
        _19 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb18, unwind unreachable];
    }

    bb7: {
        _17 = <PageTable as Index<PageTableIndex>>::index(move _18, move _19) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = PageTableEntry::is_unused(_17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _23 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _20 = mapper::MapToError::<page::Size1GiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Err(move _20);
        goto -> bb18;
    }

    bb12: {
        _22 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _23) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _24 = PhysFrame::<page::Size1GiB>::start_address(_3) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _25 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = PageTableEntry::set_addr(_22, move _24, move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Ok(move _26);
        goto -> bb18;
    }

    bb18: {
        return;
    }

    bb19: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_2mib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _17: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _18: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: isize;
    let mut _24: bool;
    let _25: &structures::paging::page_table::PageTableEntry;
    let mut _26: &structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _28: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let _29: ();
    let mut _30: &mut structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: addr::PhysAddr;
    let mut _33: structures::paging::page_table::PageTableFlags;
    let mut _34: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _35: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
            let _22: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
            let _23: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _23;
            }
            scope 8 {
                debug residual => _22;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _23;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _35 = deref_copy (*_7);
        _12 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_35, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb6, otherwise: bb25];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb24, unwind unreachable];
    }

    bb7: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _20) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _17 = PageTableWalker::<P>::create_next_table::<A>(move _18, _19, _5, _6) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = discriminant(_16);
        switchInt(move _21) -> [0: bb11, 1: bb12, otherwise: bb25];
    }

    bb11: {
        _23 = move ((_16 as Continue).0: &mut structures::paging::page_table::PageTable);
        _26 = &(*_23);
        _27 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _22 = move ((_16 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _22) -> [return: bb24, unwind unreachable];
    }

    bb13: {
        _25 = <PageTable as Index<PageTableIndex>>::index(move _26, move _27) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = PageTableEntry::is_unused(_25) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _24) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _31 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb17: {
        _28 = mapper::MapToError::<page::Size2MiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Err(move _28);
        goto -> bb24;
    }

    bb18: {
        _30 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _31) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _32 = PhysFrame::<page::Size2MiB>::start_address(_3) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _33 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _29 = PageTableEntry::set_addr(_30, move _32, move _33) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _34 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Ok(move _34);
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:22:1: 22:58>::map_to_4kib(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _9: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _10: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _11: &mut structures::paging::page_table::PageTableEntry;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: isize;
    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _17: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _18: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: isize;
    let mut _24: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>, &mut structures::paging::page_table::PageTable>;
    let mut _25: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let mut _26: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: isize;
    let mut _32: bool;
    let _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: &structures::paging::page_table::PageTable;
    let mut _35: structures::paging::page_table::PageTableIndex;
    let mut _36: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let _37: ();
    let mut _38: &mut structures::paging::page_table::PageTableEntry;
    let mut _39: structures::paging::page_table::PageTableIndex;
    let mut _40: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _41: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _14: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
        let _15: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _15;
            let _22: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
            let _23: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _23;
                let _30: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
                let _31: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _31;
                }
                scope 13 {
                    debug residual => _30;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _31;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _22;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _23;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _10 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _41 = deref_copy (*_7);
        _12 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_41, move _12) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableWalker::<P>::create_next_table::<A>(move _10, _11, _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _9) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb5, 1: bb6, otherwise: bb29];
    }

    bb5: {
        _15 = move ((_8 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _14 = move ((_8 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _14) -> [return: bb28, unwind unreachable];
    }

    bb7: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_15, move _20) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _17 = PageTableWalker::<P>::create_next_table::<A>(move _18, _19, _5, _6) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = discriminant(_16);
        switchInt(move _21) -> [0: bb11, 1: bb12, otherwise: bb29];
    }

    bb11: {
        _23 = move ((_16 as Continue).0: &mut structures::paging::page_table::PageTable);
        _26 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _28 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _22 = move ((_16 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _22) -> [return: bb28, unwind unreachable];
    }

    bb13: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _25 = PageTableWalker::<P>::create_next_table::<A>(move _26, _27, _5, _6) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _24 = <Result<&mut PageTable, PageTableCreateError> as Try>::branch(move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _29 = discriminant(_24);
        switchInt(move _29) -> [0: bb17, 1: bb18, otherwise: bb29];
    }

    bb17: {
        _31 = move ((_24 as Continue).0: &mut structures::paging::page_table::PageTable);
        _34 = &(*_31);
        _35 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _30 = move ((_24 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableCreateError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, PageTableCreateError>>>::from_residual(move _30) -> [return: bb28, unwind unreachable];
    }

    bb19: {
        _33 = <PageTable as Index<PageTableIndex>>::index(move _34, move _35) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _32 = PageTableEntry::is_unused(_33) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _32) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _39 = Page::p1_index(_2) -> [return: bb24, unwind unreachable];
    }

    bb23: {
        _36 = mapper::MapToError::<page::Size4KiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Err(move _36);
        goto -> bb28;
    }

    bb24: {
        _38 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_31, move _39) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _37 = PageTableEntry::set_frame(_38, _3, _4) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _40 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Ok(move _40);
        goto -> bb28;
    }

    bb28: {
        return;
    }

    bb29: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_1gib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: bool;
    let mut _18: &structures::paging::page_table::PageTableFlags;
    let mut _19: structures::paging::mapper::UnmapError;
    let mut _20: bool;
    let mut _21: &structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::UnmapError;
    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>>;
    let mut _24: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::UnmapError>;
    let mut _25: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _26: addr::PhysAddr;
    let mut _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41};
    let mut _29: &&mut structures::paging::page_table::PageTableEntry;
    let mut _30: isize;
    let _33: ();
    let mut _34: &mut structures::paging::page_table::PageTableEntry;
    let mut _35: (structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>);
    let mut _36: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _12: &mut structures::paging::page_table::PageTableEntry;
            scope 7 {
                debug p3_entry => _12;
                let _15: structures::paging::page_table::PageTableFlags;
                scope 8 {
                    debug flags => _15;
                    let _31: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _32: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                    scope 9 {
                        debug frame => _32;
                    }
                    scope 10 {
                        debug residual => _31;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _32;
                        scope 13 {
                        }
                    }
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _37 = deref_copy (*_3);
        _8 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb25];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb24, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = _13;
        _16 = &(*_12);
        _15 = PageTableEntry::flags(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _18 = &_15;
        _17 = page_table::_::<impl PageTableFlags>::contains(move _18, const _) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _17) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _21 = &_15;
        _20 = page_table::_::<impl PageTableFlags>::contains(move _21, const _) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _19);
        goto -> bb24;
    }

    bb13: {
        switchInt(move _20) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _27 = &(*_12);
        _26 = PageTableEntry::addr(move _27) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _22 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _22);
        goto -> bb24;
    }

    bb16: {
        _25 = PhysFrame::<page::Size1GiB>::from_start_address(move _26) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _29 = &_12;
        _28 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41} { p3_entry: move _29 };
        _24 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41}>(move _25, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _23 = <Result<PhysFrame<page::Size1GiB>, mapper::UnmapError> as Try>::branch(move _24) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _30 = discriminant(_23);
        switchInt(move _30) -> [0: bb20, 1: bb21, otherwise: bb25];
    }

    bb20: {
        _32 = ((_23 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _34 = _12;
        _33 = PageTableEntry::set_unused(move _34) -> [return: bb22, unwind unreachable];
    }

    bb21: {
        _31 = move ((_23 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _31) -> [return: bb24, unwind unreachable];
    }

    bb22: {
        _36 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _35 = (_32, move _36);
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Ok(move _35);
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:186:22: 186:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p3_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _23 = deref_copy (*_4);
        _9 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_23, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb18];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &(*_12);
        _16 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb17, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb17;
    }

    bb11: {
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _18 = PageTableEntry::set_flags(_19, move _21) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _22 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Ok(move _22);
        goto -> bb17;
    }

    bb17: {
        return;
    }

    bb18: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableEntry;
    let mut _18: structures::paging::mapper::TranslateError;
    let mut _19: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _20: addr::PhysAddr;
    let mut _21: &structures::paging::page_table::PageTableEntry;
    let mut _22: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41};
    let mut _23: &&structures::paging::page_table::PageTableEntry;
    let mut _24: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _13: &structures::paging::page_table::PageTableEntry;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _24 = deref_copy (*_3);
        _8 = &(*_24);
        _9 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb15];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb14, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(_12, move _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = _14;
        _17 = _13;
        _16 = PageTableEntry::is_unused(move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _18 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _18);
        goto -> bb14;
    }

    bb11: {
        _21 = _13;
        _20 = PageTableEntry::addr(move _21) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = PhysFrame::<page::Size1GiB>::from_start_address(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _23 = &_13;
        _22 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41} { p3_entry: move _23 };
        _0 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41}>(move _19, move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        return;
    }

    bb15: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:150:1: 150:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:254:22: 254:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p3_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_2mib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _13: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _15: &mut structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: bool;
    let mut _26: &structures::paging::page_table::PageTableFlags;
    let mut _27: structures::paging::mapper::UnmapError;
    let mut _28: bool;
    let mut _29: &structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::UnmapError;
    let mut _31: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::UnmapError>;
    let mut _33: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _34: addr::PhysAddr;
    let mut _35: &structures::paging::page_table::PageTableEntry;
    let mut _36: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41};
    let mut _37: &&mut structures::paging::page_table::PageTableEntry;
    let mut _38: isize;
    let _41: ();
    let mut _42: &mut structures::paging::page_table::PageTableEntry;
    let mut _43: (structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>);
    let mut _44: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _45: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _18: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _19: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _19;
                let _20: &mut structures::paging::page_table::PageTableEntry;
                scope 12 {
                    debug p2_entry => _20;
                    let _23: structures::paging::page_table::PageTableFlags;
                    scope 13 {
                        debug flags => _23;
                        let _39: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _40: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                        scope 14 {
                            debug frame => _40;
                        }
                        scope 15 {
                            debug residual => _39;
                            scope 16 {
                            }
                        }
                        scope 17 {
                            debug val => _40;
                            scope 18 {
                            }
                        }
                    }
                }
            }
            scope 8 {
                debug residual => _18;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _19;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _45 = deref_copy (*_3);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_45, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb31];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb30, unwind unreachable];
    }

    bb7: {
        _15 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableWalker::<P>::next_table_mut(move _14, _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _12 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _13) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = discriminant(_12);
        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb31];
    }

    bb11: {
        _19 = move ((_12 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _18 = move ((_12 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _18) -> [return: bb30, unwind unreachable];
    }

    bb13: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_19, move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _20 = _21;
        _24 = &(*_20);
        _23 = PageTableEntry::flags(move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _26 = &_23;
        _25 = page_table::_::<impl PageTableFlags>::contains(move _26, const _) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _25) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _29 = &_23;
        _28 = page_table::_::<impl PageTableFlags>::contains(move _29, const _) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _27 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _27);
        goto -> bb30;
    }

    bb19: {
        switchInt(move _28) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _35 = &(*_20);
        _34 = PageTableEntry::addr(move _35) -> [return: bb22, unwind unreachable];
    }

    bb21: {
        _30 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _30);
        goto -> bb30;
    }

    bb22: {
        _33 = PhysFrame::<page::Size2MiB>::from_start_address(move _34) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _37 = &_20;
        _36 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41} { p2_entry: move _37 };
        _32 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41}>(move _33, move _36) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _31 = <Result<PhysFrame<page::Size2MiB>, mapper::UnmapError> as Try>::branch(move _32) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _38 = discriminant(_31);
        switchInt(move _38) -> [0: bb26, 1: bb27, otherwise: bb31];
    }

    bb26: {
        _40 = ((_31 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _42 = _20;
        _41 = PageTableEntry::set_unused(move _42) -> [return: bb28, unwind unreachable];
    }

    bb27: {
        _39 = move ((_31 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _39) -> [return: bb30, unwind unreachable];
    }

    bb28: {
        _44 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _43 = (_40, move _44);
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Ok(move _43);
        goto -> bb30;
    }

    bb30: {
        return;
    }

    bb31: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:297:22: 297:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p2_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _31: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _31 = deref_copy (*_4);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_31, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb24];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb23, unwind unreachable];
    }

    bb7: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb24];
    }

    bb11: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _23 = &(*_20);
        _24 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb23, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb23;
    }

    bb17: {
        _28 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _26 = PageTableEntry::set_flags(_27, move _29) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _30 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Ok(move _30);
        goto -> bb23;
    }

    bb23: {
        return;
    }

    bb24: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = deref_copy (*_4);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb15];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb14, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }

    bb15: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _24: bool;
    let mut _25: &structures::paging::page_table::PageTableEntry;
    let mut _26: structures::paging::mapper::TranslateError;
    let mut _27: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _28: addr::PhysAddr;
    let mut _29: &structures::paging::page_table::PageTableEntry;
    let mut _30: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41};
    let mut _31: &&structures::paging::page_table::PageTableEntry;
    let mut _32: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _21: &structures::paging::page_table::PageTableEntry;
                scope 12 {
                    debug p2_entry => _21;
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _32 = deref_copy (*_3);
        _8 = &(*_32);
        _9 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb21];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb20, unwind unreachable];
    }

    bb7: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_12, move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableWalker::<P>::next_table(move _15, _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb21];
    }

    bb11: {
        _20 = ((_13 as Continue).0: &structures::paging::page_table::PageTable);
        _23 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb20, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(_20, move _23) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = _22;
        _25 = _21;
        _24 = PageTableEntry::is_unused(move _25) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _24) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _26 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _26);
        goto -> bb20;
    }

    bb17: {
        _29 = _21;
        _28 = PageTableEntry::addr(move _29) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = PhysFrame::<page::Size2MiB>::from_start_address(move _28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _31 = &_21;
        _30 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41} { p2_entry: move _31 };
        _0 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41}>(move _27, move _30) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        return;
    }

    bb21: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:258:1: 258:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:382:22: 382:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p2_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::map_to_with_table_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;

    bb0: {
        _0 = mapped_page_table::MappedPageTable::<'_, P>::map_to_4kib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::unmap(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _7: &mut structures::paging::page_table::PageTableEntry;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _13: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _15: &mut structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _21: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _22: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _23: &mut structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: isize;
    let mut _28: &mut structures::paging::page_table::PageTableEntry;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _31: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: isize;
    let _37: ();
    let mut _38: (structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>);
    let mut _39: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _40: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _10: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _11: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _18: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _19: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _19;
                let _26: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _27: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _27;
                    scope 17 {
                        debug p1_entry => _28;
                        let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _36: structures::paging::frame::PhysFrame;
                        scope 18 {
                            debug frame => _36;
                        }
                        scope 19 {
                            debug residual => _35;
                            scope 20 {
                            }
                        }
                        scope 21 {
                            debug val => _36;
                            scope 22 {
                            }
                        }
                    }
                }
                scope 13 {
                    debug residual => _26;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _27;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _18;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _19;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _40 = deref_copy (*_3);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_40, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table_mut(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb29];
    }

    bb5: {
        _11 = move ((_4 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _10 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _10) -> [return: bb28, unwind unreachable];
    }

    bb7: {
        _15 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_11, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableWalker::<P>::next_table_mut(move _14, _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _12 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _13) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = discriminant(_12);
        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb29];
    }

    bb11: {
        _19 = move ((_12 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _24 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _18 = move ((_12 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _18) -> [return: bb28, unwind unreachable];
    }

    bb13: {
        _23 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_19, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableWalker::<P>::next_table_mut(move _22, _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _20 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _21) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _25 = discriminant(_20);
        switchInt(move _25) -> [0: bb17, 1: bb18, otherwise: bb29];
    }

    bb17: {
        _27 = move ((_20 as Continue).0: &mut structures::paging::page_table::PageTable);
        _29 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _26 = move ((_20 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _26) -> [return: bb28, unwind unreachable];
    }

    bb19: {
        _28 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_27, move _29) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _33 = &(*_28);
        _32 = PageTableEntry::frame(move _33) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _31 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}>(move _32, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _30 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _31) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _34 = discriminant(_30);
        switchInt(move _34) -> [0: bb24, 1: bb25, otherwise: bb29];
    }

    bb24: {
        _36 = ((_30 as Continue).0: structures::paging::frame::PhysFrame);
        _37 = PageTableEntry::set_unused(_28) -> [return: bb26, unwind unreachable];
    }

    bb25: {
        _35 = move ((_30 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb28, unwind unreachable];
    }

    bb26: {
        _39 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _38 = (_36, move _39);
        _0 = Result::<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError>::Ok(move _38);
        goto -> bb28;
    }

    bb28: {
        return;
    }

    bb29: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:419:46: 419:51}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::update_flags(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _22: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _23: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _24: &mut structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let mut _26: isize;
    let mut _29: bool;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: &structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let mut _33: structures::paging::mapper::FlagUpdateError;
    let _34: ();
    let mut _35: &mut structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _37: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _38: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _27: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _28: &mut structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _28;
                }
                scope 13 {
                    debug residual => _27;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _28;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _38 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_38, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb29];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb28, unwind unreachable];
    }

    bb7: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb29];
    }

    bb11: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _23 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _25 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb28, unwind unreachable];
    }

    bb13: {
        _24 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = PageTableWalker::<P>::next_table_mut(move _23, _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _22) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb17, 1: bb18, otherwise: bb29];
    }

    bb17: {
        _28 = move ((_21 as Continue).0: &mut structures::paging::page_table::PageTable);
        _31 = &(*_28);
        _32 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _27 = move ((_21 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _27) -> [return: bb28, unwind unreachable];
    }

    bb19: {
        _30 = <PageTable as Index<PageTableIndex>>::index(move _31, move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _29 = PageTableEntry::is_unused(_30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _29) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _33 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _33);
        goto -> bb28;
    }

    bb23: {
        _36 = Page::p1_index(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _34 = PageTableEntry::set_flags(_35, _3) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _37 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Ok(move _37);
        goto -> bb28;
    }

    bb28: {
        return;
    }

    bb29: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p4_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p3_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            scope 7 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _20 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb15];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _14 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb14, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }

    bb15: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::set_flags_p2_entry(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _6: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _7: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _8: &mut structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &mut structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _16: &mut structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: bool;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: structures::paging::mapper::MapperFlushAll;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &mut structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                scope 12 {
                    debug p2_entry => _21;
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).1: &mut structures::paging::page_table::PageTable);
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _28 = deref_copy (*_4);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = PageTableWalker::<P>::next_table_mut(move _7, _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb21];
    }

    bb5: {
        _12 = move ((_5 as Continue).0: &mut structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb20, unwind unreachable];
    }

    bb7: {
        _16 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableWalker::<P>::next_table_mut(move _15, _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Result<&mut PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb21];
    }

    bb11: {
        _20 = move ((_13 as Continue).0: &mut structures::paging::page_table::PageTable);
        _22 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<mapper::MapperFlushAll, mapper::FlagUpdateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb20, unwind unreachable];
    }

    bb13: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_20, move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = &(*_21);
        _23 = PageTableEntry::is_unused(move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _23) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb20;
    }

    bb17: {
        _26 = PageTableEntry::set_flags(_21, _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = mapper::MapperFlushAll::new() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb20;
    }

    bb20: {
        return;
    }

    bb21: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::translate_page(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _5: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _6: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: &structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: isize;
    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _14: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _15: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: isize;
    let mut _21: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>, &structures::paging::page_table::PageTable>;
    let mut _22: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _23: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let mut _26: isize;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: bool;
    let mut _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: structures::paging::mapper::TranslateError;
    let mut _35: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _36: addr::PhysAddr;
    let mut _37: &structures::paging::page_table::PageTableEntry;
    let mut _38: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41};
    let mut _39: &&structures::paging::page_table::PageTableEntry;
    let mut _40: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
        let _12: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _12;
            let _19: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
            let _20: &structures::paging::page_table::PageTable;
            scope 7 {
                debug p2 => _20;
                let _27: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
                let _28: &structures::paging::page_table::PageTable;
                scope 12 {
                    debug p1 => _28;
                    let _29: &structures::paging::page_table::PageTableEntry;
                    scope 17 {
                        debug p1_entry => _29;
                    }
                }
                scope 13 {
                    debug residual => _27;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _28;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _19;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _20;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _6 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _40 = deref_copy (*_3);
        _8 = &(*_40);
        _9 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTable as Index<PageTableIndex>>::index(move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableWalker::<P>::next_table(move _6, _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb6, otherwise: bb27];
    }

    bb5: {
        _12 = ((_4 as Continue).0: &structures::paging::page_table::PageTable);
        _15 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _17 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _11 = move ((_4 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _11) -> [return: bb26, unwind unreachable];
    }

    bb7: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_12, move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableWalker::<P>::next_table(move _15, _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb27];
    }

    bb11: {
        _20 = ((_13 as Continue).0: &structures::paging::page_table::PageTable);
        _23 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _25 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _19 = move ((_13 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _19) -> [return: bb26, unwind unreachable];
    }

    bb13: {
        _24 = <PageTable as Index<PageTableIndex>>::index(_20, move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = PageTableWalker::<P>::next_table(move _23, _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = <Result<&PageTable, PageTableWalkError> as Try>::branch(move _22) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb17, 1: bb18, otherwise: bb27];
    }

    bb17: {
        _28 = ((_21 as Continue).0: &structures::paging::page_table::PageTable);
        _31 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb18: {
        _27 = move ((_21 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::mapped_page_table::PageTableWalkError>);
        _0 = <Result<PhysFrame, mapper::TranslateError> as FromResidual<Result<Infallible, PageTableWalkError>>>::from_residual(move _27) -> [return: bb26, unwind unreachable];
    }

    bb19: {
        _30 = <PageTable as Index<PageTableIndex>>::index(_28, move _31) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _29 = _30;
        _33 = _29;
        _32 = PageTableEntry::is_unused(move _33) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _32) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _34 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _34);
        goto -> bb26;
    }

    bb23: {
        _37 = _29;
        _36 = PageTableEntry::addr(move _37) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = PhysFrame::from_start_address(move _36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _39 = &_29;
        _38 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41} { p1_entry: move _39 };
        _0 = Result::<PhysFrame, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41}>(move _35, move _38) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        return;
    }

    bb27: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:386:1: 386:79>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:526:22: 526:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p1_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:530:1: 530:72>::translate(_1: &mapped_page_table::MappedPageTable<'_, P>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _5: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: isize;
    let mut _10: isize;
    let mut _12: !;
    let mut _13: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _14: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _15: &structures::paging::page_table::PageTableEntry;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: isize;
    let mut _18: isize;
    let _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: structures::paging::page_table::PageTableIndex;
    let mut _23: addr::PhysAddr;
    let mut _25: u64;
    let mut _27: structures::paging::mapper::MappedFrame;
    let mut _28: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _29: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: isize;
    let mut _33: isize;
    let _35: &structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _38: addr::PhysAddr;
    let mut _40: u64;
    let mut _42: structures::paging::mapper::MappedFrame;
    let _43: &structures::paging::page_table::PageTableEntry;
    let mut _44: structures::paging::page_table::PageTableIndex;
    let mut _45: bool;
    let mut _46: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _47: addr::PhysAddr;
    let mut _48: isize;
    let mut _50: addr::PhysAddr;
    let mut _52: structures::paging::page_table::PageOffset;
    let mut _54: structures::paging::mapper::MappedFrame;
    let mut _55: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _11: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _11;
            let _19: &structures::paging::page_table::PageTable;
            scope 4 {
                debug p2 => _19;
                let _34: &structures::paging::page_table::PageTable;
                scope 10 {
                    debug p1 => _34;
                    scope 16 {
                        debug p1_entry => _43;
                        let _49: structures::paging::frame::PhysFrame;
                        scope 17 {
                            debug frame => _49;
                            let _51: u64;
                            scope 19 {
                                debug offset => _51;
                                let _53: structures::paging::page_table::PageTableFlags;
                                scope 20 {
                                    debug flags => _53;
                                }
                            }
                        }
                        scope 18 {
                            debug frame => _49;
                        }
                    }
                }
                scope 11 {
                    debug page_table => _34;
                }
                scope 12 {
                    debug entry => _35;
                    let _37: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                    scope 13 {
                        debug frame => _37;
                        let _39: u64;
                        scope 14 {
                            debug offset => _39;
                            let _41: structures::paging::page_table::PageTableFlags;
                            scope 15 {
                                debug flags => _41;
                            }
                        }
                    }
                }
            }
            scope 5 {
                debug page_table => _19;
            }
            scope 6 {
                debug entry => _20;
                let _22: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                scope 7 {
                    debug frame => _22;
                    let _24: u64;
                    scope 8 {
                        debug offset => _24;
                        let _26: structures::paging::page_table::PageTableFlags;
                        scope 9 {
                            debug flags => _26;
                        }
                    }
                }
            }
        }
        scope 3 {
            debug page_table => _11;
        }
    }

    bb0: {
        _3 = &((*_1).1: &mut structures::paging::page_table::PageTable);
        _5 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _55 = deref_copy (*_3);
        _7 = &(*_55);
        _8 = addr::VirtAddr::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableWalker::<P>::next_table(move _5, _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb48];
    }

    bb4: {
        _9 = discriminant(((_4 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb48];
    }

    bb5: {
        _12 = panic(const "level 4 entry has huge page bit set") -> unwind unreachable;
    }

    bb6: {
        _11 = ((_4 as Ok).0: &structures::paging::page_table::PageTable);
        _14 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _16 = addr::VirtAddr::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb47;
    }

    bb8: {
        _15 = <PageTable as Index<PageTableIndex>>::index(_11, move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = PageTableWalker::<P>::next_table(move _14, _15) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb13, 1: bb11, otherwise: bb48];
    }

    bb11: {
        _17 = discriminant(((_13 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _17) -> [0: bb14, 1: bb12, otherwise: bb48];
    }

    bb12: {
        _21 = addr::VirtAddr::p3_index(_2) -> [return: bb15, unwind unreachable];
    }

    bb13: {
        _19 = ((_13 as Ok).0: &structures::paging::page_table::PageTable);
        _29 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _31 = addr::VirtAddr::p2_index(_2) -> [return: bb21, unwind unreachable];
    }

    bb14: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb47;
    }

    bb15: {
        _20 = <PageTable as Index<PageTableIndex>>::index(_11, move _21) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _23 = PageTableEntry::addr(_20) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _22 = PhysFrame::<page::Size1GiB>::containing_address(move _23) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _25 = addr::VirtAddr::as_u64(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _24 = BitAnd(move _25, const 1073741823_u64);
        _26 = PageTableEntry::flags(_20) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _27 = mapper::MappedFrame::Size1GiB(_22);
        _0 = mapper::TranslateResult::Mapped { frame: move _27, offset: _24, flags: _26 };
        goto -> bb47;
    }

    bb21: {
        _30 = <PageTable as Index<PageTableIndex>>::index(_19, move _31) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _28 = PageTableWalker::<P>::next_table(move _29, _30) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _33 = discriminant(_28);
        switchInt(move _33) -> [0: bb26, 1: bb24, otherwise: bb48];
    }

    bb24: {
        _32 = discriminant(((_28 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _32) -> [0: bb27, 1: bb25, otherwise: bb48];
    }

    bb25: {
        _36 = addr::VirtAddr::p2_index(_2) -> [return: bb28, unwind unreachable];
    }

    bb26: {
        _34 = ((_28 as Ok).0: &structures::paging::page_table::PageTable);
        _44 = addr::VirtAddr::p1_index(_2) -> [return: bb34, unwind unreachable];
    }

    bb27: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb47;
    }

    bb28: {
        _35 = <PageTable as Index<PageTableIndex>>::index(_19, move _36) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _38 = PageTableEntry::addr(_35) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _37 = PhysFrame::<page::Size2MiB>::containing_address(move _38) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _40 = addr::VirtAddr::as_u64(_2) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _39 = BitAnd(move _40, const 2097151_u64);
        _41 = PageTableEntry::flags(_35) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _42 = mapper::MappedFrame::Size2MiB(_37);
        _0 = mapper::TranslateResult::Mapped { frame: move _42, offset: _39, flags: _41 };
        goto -> bb47;
    }

    bb34: {
        _43 = <PageTable as Index<PageTableIndex>>::index(_34, move _44) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _45 = PageTableEntry::is_unused(_43) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        switchInt(move _45) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb47;
    }

    bb38: {
        _47 = PageTableEntry::addr(_43) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _46 = PhysFrame::from_start_address(move _47) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _48 = discriminant(_46);
        switchInt(move _48) -> [0: bb42, 1: bb41, otherwise: bb48];
    }

    bb41: {
        _50 = PageTableEntry::addr(_43) -> [return: bb43, unwind unreachable];
    }

    bb42: {
        _49 = ((_46 as Ok).0: structures::paging::frame::PhysFrame);
        _52 = addr::VirtAddr::page_offset(_2) -> [return: bb44, unwind unreachable];
    }

    bb43: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _50);
        goto -> bb47;
    }

    bb44: {
        _51 = <u64 as From<PageOffset>>::from(move _52) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _53 = PageTableEntry::flags(_43) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _54 = mapper::MappedFrame::Size4KiB(_49);
        _0 = mapper::TranslateResult::Mapped { frame: move _54, offset: _51, flags: _53 };
        goto -> bb47;
    }

    bb47: {
        return;
    }

    bb48: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::PageRangeInclusive;
    let mut _4: structures::paging::page::Page;
    let mut _5: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page;
    let mut _8: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _9: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _6 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Page::from_start_address(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Page, AddressNotAligned>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = addr::VirtAddr::new(const 18446744073709547520_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Page::from_start_address(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Result::<Page, AddressNotAligned>::unwrap(move _8) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _3 = PageRangeInclusive { start: move _4, end: move _7 };
        _0 = <mapped_page_table::MappedPageTable<'_, P> as mapper::CleanUp>::clean_up_addr_range::<D>(_1, move _3, _2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up_addr_range(_1: &mut mapped_page_table::MappedPageTable<'_, P>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let _4: bool;
    let _5: &structures::paging::mapper::mapped_page_table::PageTableWalker<P>;
    let mut _6: structures::paging::page_table::PageTableLevel;
    let mut _7: &mut structures::paging::page_table::PageTable;
    scope 1 {
    }

    bb0: {
        _7 = deref_copy ((*_1).1: &mut structures::paging::page_table::PageTable);
        _5 = &((*_1).0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>);
        _6 = PageTableLevel::Four;
        _4 = <mapped_page_table::MappedPageTable<'a, P> as mapper::CleanUp>::clean_up_addr_range::clean_up::<P, D>(_7, _5, move _6, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:592:1: 592:70>::clean_up_addr_range::clean_up(_1: &mut PageTable, _2: &PageTableWalker<P>, _3: PageTableLevel, _4: PageRangeInclusive, _5: &mut impl FrameDeallocator<Size4KiB>) -> bool {
    debug page_table => _1;
    debug page_table_walker => _2;
    debug level => _3;
    debug range => _4;
    debug frame_deallocator => _5;
    let mut _0: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page::PageRangeInclusive;
    let _8: addr::VirtAddr;
    let mut _9: addr::VirtAddr;
    let mut _10: structures::paging::page::Page;
    let mut _11: u64;
    let mut _13: structures::paging::page::Page;
    let mut _15: structures::paging::page::Page;
    let mut _16: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _17: isize;
    let mut _20: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>;
    let mut _21: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>;
    let mut _22: core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>;
    let mut _23: core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>;
    let mut _24: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _25: usize;
    let mut _26: usize;
    let mut _27: (usize, bool);
    let mut _28: usize;
    let mut _30: core::option::Option<(usize, &mut structures::paging::page_table::PageTableEntry)>;
    let mut _31: &mut core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>;
    let mut _32: isize;
    let mut _35: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _36: isize;
    let mut _39: u64;
    let mut _40: u64;
    let mut _41: (u64, bool);
    let mut _43: u64;
    let mut _44: (u64, bool);
    let mut _47: structures::paging::page::Page;
    let mut _50: structures::paging::page::Page;
    let mut _51: bool;
    let mut _52: structures::paging::page::PageRangeInclusive;
    let mut _54: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _55: &structures::paging::page_table::PageTableEntry;
    let _56: ();
    let _57: ();
    let mut _58: &mut core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _59: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _60: &structures::paging::page_table::PageTable;
    scope 1 {
        debug table_addr => _8;
        let _12: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug start => _12;
            let _14: structures::paging::page_table::PageTableIndex;
            scope 3 {
                debug end => _14;
                scope 4 {
                    debug next_level => _18;
                    let _18: structures::paging::page_table::PageTableLevel;
                    let _19: u64;
                    scope 5 {
                        debug offset_per_entry => _19;
                        let mut _29: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>;
                        scope 6 {
                            debug iter => _29;
                            let _33: usize;
                            let _34: &mut structures::paging::page_table::PageTableEntry;
                            scope 7 {
                                debug i => _33;
                                debug entry => _34;
                                scope 8 {
                                    debug page_table => _37;
                                    let _37: &mut structures::paging::page_table::PageTable;
                                    let _38: addr::VirtAddr;
                                    scope 9 {
                                        debug start => _38;
                                        let _42: addr::VirtAddr;
                                        scope 10 {
                                            debug end => _42;
                                            let _45: structures::paging::page::Page;
                                            scope 11 {
                                                debug start => _45;
                                                let _46: structures::paging::page::Page;
                                                scope 12 {
                                                    debug start => _46;
                                                    let _48: structures::paging::page::Page;
                                                    scope 13 {
                                                        debug end => _48;
                                                        let _49: structures::paging::page::Page;
                                                        scope 14 {
                                                            debug end => _49;
                                                            scope 15 {
                                                                let _53: structures::paging::frame::PhysFrame;
                                                                scope 16 {
                                                                    debug frame => _53;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_4;
        _6 = PageRangeInclusive::is_empty(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb41;
    }

    bb3: {
        _10 = (_4.0: structures::paging::page::Page);
        _9 = Page::start_address(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = PageTableLevel::table_address_space_alignment(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = addr::VirtAddr::align_down::<u64>(move _9, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _13 = (_4.0: structures::paging::page::Page);
        _12 = Page::page_table_index(move _13, _3) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = (_4.1: structures::paging::page::Page);
        _14 = Page::page_table_index(move _15, _3) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = PageTableLevel::next_lower_level(_3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = discriminant(_16);
        switchInt(move _17) -> [1: bb10, otherwise: bb39];
    }

    bb10: {
        _18 = ((_16 as Some).0: structures::paging::page_table::PageTableLevel);
        _19 = PageTableLevel::entry_address_space_alignment(_3) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _24 = PageTable::iter_mut(_1) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}> as Iterator>::enumerate(move _24) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _26 = <usize as From<PageTableIndex>>::from(_14) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _27 = CheckedAdd(_26, const 1_usize);
        assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", move _26, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _25 = move (_27.0: usize);
        _22 = <Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>> as Iterator>::take(move _23, move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _28 = <usize as From<PageTableIndex>>::from(_12) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _21 = <Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>> as Iterator>::skip(move _22, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _20 = <Skip<Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>> as IntoIterator>::into_iter(move _21) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = move _20;
        goto -> bb20;
    }

    bb20: {
        _31 = &mut _29;
        _30 = <Skip<Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>> as Iterator>::next(_31) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb39, 1: bb22, otherwise: bb42];
    }

    bb22: {
        _33 = (((_30 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).0: usize);
        _34 = move (((_30 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).1: &mut structures::paging::page_table::PageTableEntry);
        _35 = PageTableWalker::<P>::next_table_mut(_2, _34) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _36 = discriminant(_35);
        switchInt(move _36) -> [0: bb24, otherwise: bb20];
    }

    bb24: {
        _37 = move ((_35 as Ok).0: &mut structures::paging::page_table::PageTable);
        _40 = _33 as u64 (IntToInt);
        _41 = CheckedMul(_19, _40);
        assert(!move (_41.1: bool), "attempt to compute `{} * {}`, which would overflow", _19, move _40) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _39 = move (_41.0: u64);
        _38 = <addr::VirtAddr as Add<u64>>::add(_8, move _39) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _44 = CheckedSub(_19, const 1_u64);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", _19, const 1_u64) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _43 = move (_44.0: u64);
        _42 = <addr::VirtAddr as Add<u64>>::add(_38, move _43) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _45 = Page::containing_address(_38) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _47 = (_4.0: structures::paging::page::Page);
        _46 = <Page as Ord>::max(_45, move _47) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _48 = Page::containing_address(_42) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _50 = (_4.1: structures::paging::page::Page);
        _49 = <Page as Ord>::min(_48, move _50) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _52 = Page::range_inclusive(_46, _49) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _51 = <mapped_page_table::MappedPageTable<'a, P> as mapper::CleanUp>::clean_up_addr_range::clean_up::<P, impl FrameDeallocator<Size4KiB>>(_37, _2, _18, move _52, _5) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _51) -> [0: bb20, otherwise: bb35];
    }

    bb35: {
        _55 = &(*_34);
        _54 = PageTableEntry::frame(move _55) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _53 = Result::<PhysFrame, FrameError>::unwrap(move _54) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _56 = PageTableEntry::set_unused(_34) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _57 = <impl FrameDeallocator<Size4KiB> as FrameDeallocator<page::Size4KiB>>::deallocate_frame(_5, _53) -> [return: bb20, unwind unreachable];
    }

    bb39: {
        _60 = &(*_1);
        _59 = PageTable::iter(move _60) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _58 = &mut _59;
        _0 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}> as Iterator>::all::<for<'a> fn(&'a PageTableEntry) -> bool {PageTableEntry::is_unused}>(move _58, PageTableEntry::is_unused) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        return;
    }

    bb42: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:682:10: 682:15>::fmt(_1: &PageTableWalker<P>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&P;
    let _7: &P;

    bb0: {
        _3 = const "PageTableWalker";
        _4 = const "page_table_frame_mapping";
        _7 = &((*_1).0: P);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::new(_1: P) -> PageTableWalker<P> {
    debug page_table_frame_mapping => _1;
    let mut _0: structures::paging::mapper::mapped_page_table::PageTableWalker<P>;

    bb0: {
        _0 = PageTableWalker::<P> { page_table_frame_mapping: move _1 };
        return;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::next_table(_1: &PageTableWalker<P>, _2: &PageTableEntry) -> Result<&PageTable, PageTableWalkError> {
    debug self => _1;
    debug entry => _2;
    let mut _0: core::result::Result<&structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let _3: *mut structures::paging::page_table::PageTable;
    let mut _4: &P;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>, structures::paging::frame::PhysFrame>;
    let mut _6: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _7: isize;
    let _8: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>;
    let _9: structures::paging::frame::PhysFrame;
    let _10: &structures::paging::page_table::PageTable;
    scope 1 {
        debug page_table_ptr => _3;
        scope 6 {
            debug page_table => _10;
        }
        scope 7 {
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _4 = &((*_1).0: P);
        _6 = PageTableEntry::frame(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Result<PhysFrame, FrameError> as Try>::branch(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb4, otherwise: bb7];
    }

    bb3: {
        _9 = ((_5 as Continue).0: structures::paging::frame::PhysFrame);
        _3 = <P as mapped_page_table::PageTableFrameMapping>::frame_to_pointer(move _4, _9) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _8 = ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>);
        _0 = <Result<&PageTable, PageTableWalkError> as FromResidual<Result<Infallible, FrameError>>>::from_residual(_8) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _10 = &(*_3);
        _0 = Result::<&PageTable, PageTableWalkError>::Ok(_10);
        goto -> bb6;
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::next_table_mut(_1: &PageTableWalker<P>, _2: &mut PageTableEntry) -> Result<&mut PageTable, PageTableWalkError> {
    debug self => _1;
    debug entry => _2;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let _3: *mut structures::paging::page_table::PageTable;
    let mut _4: &P;
    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>, structures::paging::frame::PhysFrame>;
    let mut _6: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: isize;
    let _9: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>;
    let _10: structures::paging::frame::PhysFrame;
    let mut _11: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug page_table_ptr => _3;
        scope 6 {
            debug page_table => _11;
        }
        scope 7 {
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _4 = &((*_1).0: P);
        _7 = &(*_2);
        _6 = PageTableEntry::frame(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Result<PhysFrame, FrameError> as Try>::branch(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = discriminant(_5);
        switchInt(move _8) -> [0: bb3, 1: bb4, otherwise: bb7];
    }

    bb3: {
        _10 = ((_5 as Continue).0: structures::paging::frame::PhysFrame);
        _3 = <P as mapped_page_table::PageTableFrameMapping>::frame_to_pointer(move _4, _10) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _9 = ((_5 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::page_table::FrameError>);
        _0 = <Result<&mut PageTable, PageTableWalkError> as FromResidual<Result<Infallible, FrameError>>>::from_residual(_9) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _11 = &mut (*_3);
        _0 = Result::<&mut PageTable, PageTableWalkError>::Ok(_11);
        goto -> bb6;
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:687:1: 687:50>::create_next_table(_1: &PageTableWalker<P>, _2: &mut PageTableEntry, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, PageTableCreateError> {
    debug self => _1;
    debug entry => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableCreateError>;
    let _5: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: core::option::Option<structures::paging::frame::PhysFrame>;
    let mut _9: isize;
    let _11: ();
    let mut _12: structures::paging::page_table::PageTableFlags;
    let mut _13: structures::paging::mapper::mapped_page_table::PageTableCreateError;
    let mut _14: bool;
    let mut _15: &structures::paging::page_table::PageTableFlags;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableFlags;
    let _18: structures::paging::page_table::PageTableFlags;
    let mut _19: &structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableFlags;
    let _21: ();
    let mut _22: structures::paging::page_table::PageTableFlags;
    let mut _23: structures::paging::page_table::PageTableFlags;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::mapped_page_table::PageTableWalkError>;
    let mut _27: isize;
    let mut _28: isize;
    let mut _29: structures::paging::mapper::mapped_page_table::PageTableCreateError;
    let mut _30: !;
    let mut _32: bool;
    let _33: ();
    scope 1 {
        debug created => _5;
        let _31: &mut structures::paging::page_table::PageTable;
        scope 2 {
            debug frame => _10;
            let _10: structures::paging::frame::PhysFrame;
        }
        scope 3 {
            debug page_table => _31;
        }
        scope 4 {
            debug page_table => _31;
        }
    }

    bb0: {
        _7 = &(*_2);
        _6 = PageTableEntry::is_unused(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _8 = <A as frame_alloc::FrameAllocator<page::Size4KiB>>::allocate_frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb4, otherwise: bb6];
    }

    bb4: {
        _10 = ((_8 as Some).0: structures::paging::frame::PhysFrame);
        _12 = _3;
        _11 = PageTableEntry::set_frame(_2, _10, move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _5 = const true;
        goto -> bb16;
    }

    bb6: {
        _13 = PageTableCreateError::FrameAllocationFailed;
        _0 = Result::<&mut PageTable, PageTableCreateError>::Err(move _13);
        goto -> bb24;
    }

    bb7: {
        _15 = &_3;
        _14 = page_table::_::<impl PageTableFlags>::is_empty(move _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _14) -> [0: bb9, otherwise: bb15];
    }

    bb9: {
        _19 = &(*_2);
        _18 = PageTableEntry::flags(move _19) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = &_18;
        _20 = _3;
        _16 = page_table::_::<impl PageTableFlags>::contains(move _17, move _20) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _16) -> [0: bb12, otherwise: bb15];
    }

    bb12: {
        _24 = &(*_2);
        _23 = PageTableEntry::flags(move _24) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = _3;
        _22 = <PageTableFlags as BitOr>::bitor(move _23, move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::set_flags(_2, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _5 = const false;
        goto -> bb16;
    }

    bb16: {
        _26 = PageTableWalker::<P>::next_table_mut(_1, _2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb18, 1: bb19, otherwise: bb25];
    }

    bb18: {
        _31 = move ((_26 as Ok).0: &mut structures::paging::page_table::PageTable);
        _32 = _5;
        switchInt(move _32) -> [0: bb23, otherwise: bb22];
    }

    bb19: {
        _27 = discriminant(((_26 as Err).0: structures::paging::mapper::mapped_page_table::PageTableWalkError));
        switchInt(move _27) -> [0: bb21, 1: bb20, otherwise: bb25];
    }

    bb20: {
        _29 = PageTableCreateError::MappedToHugePage;
        _0 = Result::<&mut PageTable, PageTableCreateError>::Err(move _29);
        goto -> bb24;
    }

    bb21: {
        _30 = panic(const "entry should be mapped at this point") -> unwind unreachable;
    }

    bb22: {
        _33 = PageTable::zero(_31) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = Result::<&mut PageTable, PageTableCreateError>::Ok(_31);
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:780:10: 780:15>::fmt(_1: &PageTableWalkError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = const "MappedToHugePage";
        _3 = _6;
        goto -> bb3;
    }

    bb2: {
        _5 = const "NotMapped";
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:786:10: 786:15>::fmt(_1: &PageTableCreateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = const "FrameAllocationFailed";
        _3 = _6;
        goto -> bb3;
    }

    bb2: {
        _5 = const "MappedToHugePage";
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:792:1: 792:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size4KiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size4KiB>::FrameAllocationFailed;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::MapToError::<page::Size4KiB>::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:802:1: 802:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size2MiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size2MiB>::FrameAllocationFailed;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::MapToError::<page::Size2MiB>::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:812:1: 812:57>::from(_1: PageTableCreateError) -> mapper::MapToError<page::Size1GiB> {
    debug err => _1;
    let mut _0: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::MapToError::<page::Size1GiB>::FrameAllocationFailed;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::MapToError::<page::Size1GiB>::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:822:1: 822:45>::from(_1: FrameError) -> PageTableWalkError {
    debug err => _1;
    let mut _0: structures::paging::mapper::mapped_page_table::PageTableWalkError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4];
    }

    bb1: {
        _0 = PageTableWalkError::NotMapped;
        goto -> bb3;
    }

    bb2: {
        _0 = PageTableWalkError::MappedToHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:832:1: 832:45>::from(_1: PageTableWalkError) -> mapper::UnmapError {
    debug err => _1;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:842:1: 842:50>::from(_1: PageTableWalkError) -> mapper::FlagUpdateError {
    debug err => _1;
    let mut _0: structures::paging::mapper::FlagUpdateError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::FlagUpdateError::PageNotMapped;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::FlagUpdateError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn mapped_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mapped_page_table.rs:852:1: 852:49>::from(_1: PageTableWalkError) -> mapper::TranslateError {
    debug err => _1;
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::TranslateError::PageNotMapped;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::TranslateError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:10:10: 10:15>::fmt(_1: &OffsetPageTable<'_>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    let _7: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = const "OffsetPageTable";
        _4 = const "inner";
        _7 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::new(_1: &mut PageTable, _2: addr::VirtAddr) -> OffsetPageTable<'_> {
    debug level_4_table => _1;
    debug phys_offset => _2;
    let mut _0: structures::paging::mapper::offset_page_table::OffsetPageTable<'_>;
    let _3: structures::paging::mapper::offset_page_table::PhysOffset;
    let mut _4: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
        debug phys_offset => _3;
        scope 2 {
        }
    }

    bb0: {
        _3 = PhysOffset { offset: _2 };
        _4 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::new(_1, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = OffsetPageTable::<'_> { inner: move _4 };
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::level_4_table(_1: &mut OffsetPageTable<'_>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _2 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::level_4_table(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:15:1: 15:29>::phys_offset(_1: &OffsetPageTable<'_>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;
    let mut _2: &structures::paging::mapper::offset_page_table::PhysOffset;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _2 = mapped_page_table::MappedPageTable::<'_, PhysOffset>::page_table_frame_mapping(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = ((*_2).0: addr::VirtAddr);
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:52:10: 52:15>::fmt(_1: &PhysOffset, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&addr::VirtAddr;
    let _7: &addr::VirtAddr;

    bb0: {
        _3 = const "PhysOffset";
        _4 = const "offset";
        _7 = &((*_1).0: addr::VirtAddr);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:57:1: 57:49>::frame_to_pointer(_1: &PhysOffset, _2: PhysFrame) -> *mut PageTable {
    debug self => _1;
    debug frame => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: addr::PhysAddr;
    scope 1 {
        debug virt => _3;
    }

    bb0: {
        _4 = ((*_1).0: addr::VirtAddr);
        _6 = PhysFrame::start_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = PhysAddr::as_u64(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:66:1: 66:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size1GiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:135:1: 135:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size2MiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::map_to_with_table_flags(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _7: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _7 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::map_to_with_table_flags::<A>(move _7, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::unmap(_1: &mut OffsetPageTable<'_>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::unmap(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::update_flags(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::update_flags(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p4_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p4_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p3_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p3_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::set_flags_p2_entry(_1: &mut OffsetPageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::set_flags_p2_entry(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:204:1: 204:50>::translate_page(_1: &OffsetPageTable<'_>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Mapper<page::Size4KiB>>::translate_page(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:273:1: 273:43>::translate(_1: &OffsetPageTable<'_>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let mut _3: &structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;

    bb0: {
        _3 = &((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::Translate>::translate(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:280:1: 280:41>::clean_up(_1: &mut OffsetPageTable<'_>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::CleanUp>::clean_up::<D>(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn offset_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/offset_page_table.rs:280:1: 280:41>::clean_up_addr_range(_1: &mut OffsetPageTable<'_>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let mut _4: &mut structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::mapper::mapped_page_table::MappedPageTable<'_, structures::paging::mapper::offset_page_table::PhysOffset>);
        _0 = <mapped_page_table::MappedPageTable<'_, PhysOffset> as mapper::CleanUp>::clean_up_addr_range::<D>(move _4, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:32:10: 32:15>::fmt(_1: &RecursivePageTable<'_>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&mut structures::paging::page_table::PageTable;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&structures::paging::page_table::PageTableIndex;
    let _10: &structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = const "RecursivePageTable";
        _4 = const "p4";
        _6 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "recursive_index";
        _10 = &((*_1).1: structures::paging::page_table::PageTableIndex);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::new(_1: &mut PageTable) -> Result<RecursivePageTable<'_>, InvalidPageTable> {
    debug table => _1;
    let mut _0: core::result::Result<structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>, structures::paging::mapper::recursive_page_table::InvalidPageTable>;
    let _2: structures::paging::page::Page;
    let mut _3: addr::VirtAddr;
    let mut _4: u64;
    let mut _5: *const structures::paging::page_table::PageTable;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableIndex;
    let _9: structures::paging::page_table::PageTableIndex;
    let mut _10: &structures::paging::page_table::PageTableIndex;
    let mut _11: bool;
    let mut _12: &structures::paging::page_table::PageTableIndex;
    let _13: structures::paging::page_table::PageTableIndex;
    let mut _14: &structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableIndex;
    let _17: structures::paging::page_table::PageTableIndex;
    let mut _18: &structures::paging::page_table::PageTableIndex;
    let mut _19: structures::paging::mapper::recursive_page_table::InvalidPageTable;
    let mut _20: bool;
    let mut _21: &core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _22: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _23: structures::paging::frame::PhysFrame;
    let mut _24: (structures::paging::frame::PhysFrame, registers::control::Cr3Flags);
    let mut _25: &core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _26: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: &structures::paging::page_table::PageTable;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: structures::paging::mapper::recursive_page_table::InvalidPageTable;
    let mut _31: structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>;
    let mut _32: structures::paging::page_table::PageTableIndex;
    scope 1 {
        debug page => _2;
        let _6: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug recursive_index => _6;
        }
    }

    bb0: {
        _5 = &raw const (*_1);
        _4 = _5 as u64 (PointerExposeAddress);
        _3 = addr::VirtAddr::new(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Page::containing_address(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Page::p4_index(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Page::p3_index(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = &_9;
        _10 = &_6;
        _7 = <PageTableIndex as PartialEq>::ne(move _8, move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb6, otherwise: bb12];
    }

    bb6: {
        _13 = Page::p2_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = &_13;
        _14 = &_6;
        _11 = <PageTableIndex as PartialEq>::ne(move _12, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _11) -> [0: bb9, otherwise: bb12];
    }

    bb9: {
        _17 = Page::p1_index(_2) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = &_17;
        _18 = &_6;
        _15 = <PageTableIndex as PartialEq>::ne(move _16, move _18) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _15) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _19 = InvalidPageTable::NotRecursive;
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Err(move _19);
        goto -> bb20;
    }

    bb13: {
        _24 = control::x86_64::<impl control::Cr3>::read() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _23 = (_24.0: structures::paging::frame::PhysFrame);
        _22 = Result::<PhysFrame, FrameError>::Ok(move _23);
        _21 = &_22;
        _28 = &(*_1);
        _29 = _6;
        _27 = <PageTable as Index<PageTableIndex>>::index(move _28, move _29) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _26 = PageTableEntry::frame(_27) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _25 = &_26;
        _20 = <Result<PhysFrame, FrameError> as PartialEq>::ne(move _21, move _25) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _20) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _30 = InvalidPageTable::NotActive;
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Err(move _30);
        goto -> bb20;
    }

    bb19: {
        _32 = _6;
        _31 = RecursivePageTable::<'_> { p4: _1, recursive_index: move _32 };
        _0 = Result::<RecursivePageTable<'_>, InvalidPageTable>::Ok(move _31);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::new_unchecked(_1: &mut PageTable, _2: PageTableIndex) -> RecursivePageTable<'_> {
    debug table => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::mapper::recursive_page_table::RecursivePageTable<'_>;

    bb0: {
        _0 = RecursivePageTable::<'_> { p4: _1, recursive_index: _2 };
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::level_4_table(_1: &mut RecursivePageTable<'_>) -> &mut PageTable {
    debug self => _1;
    let mut _0: &mut structures::paging::page_table::PageTable;
    let mut _2: &mut &mut structures::paging::page_table::PageTable;

    bb0: {
        _2 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _0 = deref_copy (*_2);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::create_next_table(_1: &mut PageTableEntry, _2: Page, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, mapper::MapToError<S>> {
    debug entry => _1;
    debug next_table_page => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<S>>;

    bb0: {
        _0 = inner::<A, S>(_1, _2, _3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn inner(_1: &mut PageTableEntry, _2: Page, _3: PageTableFlags, _4: &mut A) -> Result<&mut PageTable, mapper::MapToError<S>> {
    debug entry => _1;
    debug next_table_page => _2;
    debug insert_flags => _3;
    debug allocator => _4;
    let mut _0: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<S>>;
    let _5: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableEntry;
    let mut _8: core::option::Option<structures::paging::frame::PhysFrame>;
    let mut _9: isize;
    let _11: ();
    let mut _12: structures::paging::page_table::PageTableFlags;
    let mut _13: structures::paging::page_table::PageTableFlags;
    let mut _14: structures::paging::page_table::PageTableFlags;
    let mut _15: structures::paging::mapper::MapToError<S>;
    let mut _16: bool;
    let mut _17: &structures::paging::page_table::PageTableFlags;
    let mut _18: bool;
    let mut _19: &structures::paging::page_table::PageTableFlags;
    let _20: structures::paging::page_table::PageTableFlags;
    let mut _21: &structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableFlags;
    let _23: ();
    let mut _24: structures::paging::page_table::PageTableFlags;
    let mut _25: structures::paging::page_table::PageTableFlags;
    let mut _26: &structures::paging::page_table::PageTableEntry;
    let mut _27: structures::paging::page_table::PageTableFlags;
    let mut _28: bool;
    let mut _29: &structures::paging::page_table::PageTableFlags;
    let _30: structures::paging::page_table::PageTableFlags;
    let mut _31: &structures::paging::page_table::PageTableEntry;
    let mut _32: structures::paging::mapper::MapToError<S>;
    let mut _34: addr::VirtAddr;
    let mut _35: &mut structures::paging::page_table::PageTable;
    let mut _36: bool;
    let _37: ();
    scope 1 {
        debug created => _5;
        let _33: *mut structures::paging::page_table::PageTable;
        scope 2 {
            debug frame => _10;
            let _10: structures::paging::frame::PhysFrame;
        }
        scope 3 {
            debug page_table_ptr => _33;
            scope 4 {
                debug page_table => _35;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = PageTableEntry::is_unused(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb9, otherwise: bb2];
    }

    bb2: {
        _8 = <A as frame_alloc::FrameAllocator<page::Size4KiB>>::allocate_frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb4, otherwise: bb8];
    }

    bb4: {
        _10 = ((_8 as Some).0: structures::paging::frame::PhysFrame);
        _13 = <PageTableFlags as BitOr>::bitor(const _, const _) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = _3;
        _12 = <PageTableFlags as BitOr>::bitor(move _13, move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = PageTableEntry::set_frame(_1, _10, move _12) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _5 = const true;
        goto -> bb18;
    }

    bb8: {
        _15 = mapper::MapToError::<S>::FrameAllocationFailed;
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Err(move _15);
        goto -> bb27;
    }

    bb9: {
        _17 = &_3;
        _16 = page_table::_::<impl PageTableFlags>::is_empty(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _16) -> [0: bb11, otherwise: bb17];
    }

    bb11: {
        _21 = &(*_1);
        _20 = PageTableEntry::flags(move _21) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = &_20;
        _22 = _3;
        _18 = page_table::_::<impl PageTableFlags>::contains(move _19, move _22) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _18) -> [0: bb14, otherwise: bb17];
    }

    bb14: {
        _26 = &(*_1);
        _25 = PageTableEntry::flags(move _26) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _27 = _3;
        _24 = <PageTableFlags as BitOr>::bitor(move _25, move _27) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _23 = PageTableEntry::set_flags(_1, move _24) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _5 = const false;
        goto -> bb18;
    }

    bb18: {
        _31 = &(*_1);
        _30 = PageTableEntry::flags(move _31) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = &_30;
        _28 = page_table::_::<impl PageTableFlags>::contains(move _29, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _28) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _32 = mapper::MapToError::<S>::ParentEntryHugePage;
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Err(move _32);
        goto -> bb27;
    }

    bb22: {
        _34 = Page::start_address(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _33 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _34) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = &mut (*_33);
        _36 = _5;
        switchInt(move _36) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _37 = PageTable::zero(_35) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _0 = Result::<&mut PageTable, mapper::MapToError<S>>::Ok(_35);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_1gib(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _17: bool;
    let _18: &structures::paging::page_table::PageTableEntry;
    let mut _19: &structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>;
    let _22: ();
    let mut _23: &mut structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: addr::PhysAddr;
    let mut _26: structures::paging::page_table::PageTableFlags;
    let mut _27: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size1GiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _28 = deref_copy (*_7);
        _13 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_28, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size1GiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size1GiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb7, otherwise: bb20];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _19 = &(*_16);
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size1GiB>>>>::from_residual(move _15) -> [return: bb19, unwind unreachable];
    }

    bb8: {
        _18 = <PageTable as Index<PageTableIndex>>::index(move _19, move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = PageTableEntry::is_unused(_18) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        switchInt(move _17) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _24 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _21 = mapper::MapToError::<page::Size1GiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Err(move _21);
        goto -> bb19;
    }

    bb13: {
        _23 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _25 = PhysFrame::<page::Size1GiB>::start_address(_3) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _26 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _22 = PageTableEntry::set_addr(_23, move _25, move _26) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _27 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>>::Ok(move _27);
        goto -> bb19;
    }

    bb19: {
        return;
    }

    bb20: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_2mib(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _20: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: isize;
    let mut _26: bool;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: &structures::paging::page_table::PageTable;
    let mut _29: structures::paging::page_table::PageTableIndex;
    let mut _30: structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>;
    let _31: ();
    let mut _32: &mut structures::paging::page_table::PageTableEntry;
    let mut _33: structures::paging::page_table::PageTableIndex;
    let mut _34: addr::PhysAddr;
    let mut _35: structures::paging::page_table::PageTableFlags;
    let mut _36: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
                let _17: structures::paging::page::Page;
                scope 9 {
                    debug p2_page => _17;
                    scope 10 {
                        debug p2 => _25;
                    }
                    scope 11 {
                        let _24: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
                        let _25: &mut structures::paging::page_table::PageTable;
                        scope 12 {
                            debug residual => _24;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _25;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size2MiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _37 = deref_copy (*_7);
        _13 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size2MiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size2MiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb7, otherwise: bb27];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_page::<page::Size2MiB>(_2, move _18) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size2MiB>>>>::from_residual(move _15) -> [return: bb26, unwind unreachable];
    }

    bb8: {
        _22 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _22) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _20 = RecursivePageTable::<'_>::create_next_table::<A, page::Size2MiB>(_21, _17, _5, _6) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _19 = <Result<&mut PageTable, mapper::MapToError<page::Size2MiB>> as Try>::branch(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = discriminant(_19);
        switchInt(move _23) -> [0: bb13, 1: bb14, otherwise: bb27];
    }

    bb13: {
        _25 = move ((_19 as Continue).0: &mut structures::paging::page_table::PageTable);
        _28 = &(*_25);
        _29 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _24 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size2MiB>>>>::from_residual(move _24) -> [return: bb26, unwind unreachable];
    }

    bb15: {
        _27 = <PageTable as Index<PageTableIndex>>::index(move _28, move _29) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = PageTableEntry::is_unused(_27) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _26) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _33 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _30 = mapper::MapToError::<page::Size2MiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Err(move _30);
        goto -> bb26;
    }

    bb20: {
        _32 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _33) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _34 = PhysFrame::<page::Size2MiB>::start_address(_3) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _35 = <PageTableFlags as BitOr>::bitor(_4, const _) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _31 = PageTableEntry::set_addr(_32, move _34, move _35) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _36 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>>::Ok(move _36);
        goto -> bb26;
    }

    bb26: {
        return;
    }

    bb27: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:38:1: 38:32>::map_to_4kib(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let _7: &mut &mut structures::paging::page_table::PageTable;
    let mut _9: structures::paging::page_table::PageTableIndex;
    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _11: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _12: &mut structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: isize;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _20: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: isize;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _28: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>, &mut structures::paging::page_table::PageTable>;
    let mut _29: core::result::Result<&mut structures::paging::page_table::PageTable, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
    let mut _30: &mut structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::page_table::PageTableIndex;
    let mut _32: isize;
    let mut _35: bool;
    let _36: &structures::paging::page_table::PageTableEntry;
    let mut _37: &structures::paging::page_table::PageTable;
    let mut _38: structures::paging::page_table::PageTableIndex;
    let mut _39: structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>;
    let _40: ();
    let mut _41: &mut structures::paging::page_table::PageTableEntry;
    let mut _42: structures::paging::page_table::PageTableIndex;
    let mut _43: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _44: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _7;
        let _8: structures::paging::page::Page;
        scope 2 {
            debug p3_page => _8;
            scope 3 {
                debug p3 => _16;
                let _17: structures::paging::page::Page;
                scope 9 {
                    debug p2_page => _17;
                    scope 10 {
                        debug p2 => _25;
                        let _26: structures::paging::page::Page;
                        scope 16 {
                            debug p1_page => _26;
                            scope 17 {
                                debug p1 => _34;
                            }
                            scope 18 {
                                let _33: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                                let _34: &mut structures::paging::page_table::PageTable;
                                scope 19 {
                                    debug residual => _33;
                                    scope 20 {
                                    }
                                }
                                scope 21 {
                                    debug val => _34;
                                    scope 22 {
                                    }
                                }
                            }
                        }
                    }
                    scope 11 {
                        let _24: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                        let _25: &mut structures::paging::page_table::PageTable;
                        scope 12 {
                            debug residual => _24;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _25;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 4 {
                let _15: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;
                let _16: &mut structures::paging::page_table::PageTable;
                scope 5 {
                    debug residual => _15;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _16;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _9 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _8 = p3_page::<page::Size4KiB>(_2, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _44 = deref_copy (*_7);
        _13 = Page::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _12 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_44, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_12, _8, _5, _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = discriminant(_10);
        switchInt(move _14) -> [0: bb6, 1: bb7, otherwise: bb32];
    }

    bb6: {
        _16 = move ((_10 as Continue).0: &mut structures::paging::page_table::PageTable);
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_page::<page::Size4KiB>(_2, move _18) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _15 = move ((_10 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _15) -> [return: bb31, unwind unreachable];
    }

    bb8: {
        _22 = Page::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_16, move _22) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _20 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_21, _17, _5, _6) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _19 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = discriminant(_19);
        switchInt(move _23) -> [0: bb13, 1: bb14, otherwise: bb32];
    }

    bb13: {
        _25 = move ((_19 as Continue).0: &mut structures::paging::page_table::PageTable);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p1_page(_2, move _27) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _24 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _24) -> [return: bb31, unwind unreachable];
    }

    bb15: {
        _31 = Page::p2_index(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _30 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _31) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _29 = RecursivePageTable::<'_>::create_next_table::<A, page::Size4KiB>(_30, _26, _5, _6) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _28 = <Result<&mut PageTable, mapper::MapToError<page::Size4KiB>> as Try>::branch(move _29) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _32 = discriminant(_28);
        switchInt(move _32) -> [0: bb20, 1: bb21, otherwise: bb32];
    }

    bb20: {
        _34 = move ((_28 as Continue).0: &mut structures::paging::page_table::PageTable);
        _37 = &(*_34);
        _38 = Page::p1_index(_2) -> [return: bb22, unwind unreachable];
    }

    bb21: {
        _33 = move ((_28 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>);
        _0 = <Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> as FromResidual<Result<Infallible, mapper::MapToError<page::Size4KiB>>>>::from_residual(move _33) -> [return: bb31, unwind unreachable];
    }

    bb22: {
        _36 = <PageTable as Index<PageTableIndex>>::index(move _37, move _38) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _35 = PageTableEntry::is_unused(_36) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _35) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _42 = Page::p1_index(_2) -> [return: bb27, unwind unreachable];
    }

    bb26: {
        _39 = mapper::MapToError::<page::Size4KiB>::PageAlreadyMapped(_3);
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Err(move _39);
        goto -> bb31;
    }

    bb27: {
        _41 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_34, move _42) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _40 = PageTableEntry::set_frame(_41, _3, _4) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _43 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>>::Ok(move _43);
        goto -> bb31;
    }

    bb31: {
        return;
    }

    bb32: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PhysFrame<page::Size1GiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::MapToError<page::Size1GiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::MapToError<structures::paging::page::Size1GiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_1gib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>) -> Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let mut _17: &mut structures::paging::page_table::PageTableEntry;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: bool;
    let mut _22: &structures::paging::page_table::PageTableFlags;
    let mut _23: structures::paging::mapper::UnmapError;
    let mut _24: bool;
    let mut _25: &structures::paging::page_table::PageTableFlags;
    let mut _26: structures::paging::mapper::UnmapError;
    let mut _27: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>>;
    let mut _28: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::UnmapError>;
    let mut _29: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _30: addr::PhysAddr;
    let mut _31: &structures::paging::page_table::PageTableEntry;
    let mut _32: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:339:22: 339:41};
    let mut _33: &&mut structures::paging::page_table::PageTableEntry;
    let mut _34: isize;
    let _37: ();
    let mut _38: &mut structures::paging::page_table::PageTableEntry;
    let mut _39: (structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>);
    let mut _40: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _41: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                let _16: &mut structures::paging::page_table::PageTableEntry;
                scope 9 {
                    debug p3_entry => _16;
                    let _19: structures::paging::page_table::PageTableFlags;
                    scope 10 {
                        debug flags => _19;
                        let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                        let _36: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                        scope 11 {
                            debug frame => _36;
                        }
                        scope 12 {
                            debug residual => _35;
                            scope 13 {
                            }
                        }
                        scope 14 {
                            debug val => _36;
                            scope 15 {
                            }
                        }
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _41 = deref_copy (*_3);
        _5 = &(*_41);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:322:34: 322:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:322:34: 322:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb7, otherwise: bb27];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size1GiB>(_2, move _15) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb26, unwind unreachable];
    }

    bb8: {
        _13 = &mut (*_14);
        _18 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_13, move _18) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = _17;
        _20 = &(*_16);
        _19 = PageTableEntry::flags(move _20) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _22 = &_19;
        _21 = page_table::_::<impl PageTableFlags>::contains(move _22, const _) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        switchInt(move _21) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _25 = &_19;
        _24 = page_table::_::<impl PageTableFlags>::contains(move _25, const _) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _23 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _23);
        goto -> bb26;
    }

    bb15: {
        switchInt(move _24) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _31 = &(*_16);
        _30 = PageTableEntry::addr(move _31) -> [return: bb18, unwind unreachable];
    }

    bb17: {
        _26 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Err(move _26);
        goto -> bb26;
    }

    bb18: {
        _29 = PhysFrame::<page::Size1GiB>::from_start_address(move _30) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _33 = &_16;
        _32 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:339:22: 339:41} { p3_entry: move _33 };
        _28 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:339:22: 339:41}>(move _29, move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _27 = <Result<PhysFrame<page::Size1GiB>, mapper::UnmapError> as Try>::branch(move _28) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _34 = discriminant(_27);
        switchInt(move _34) -> [0: bb22, 1: bb23, otherwise: bb27];
    }

    bb22: {
        _36 = ((_27 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _38 = _16;
        _37 = PageTableEntry::set_unused(move _38) -> [return: bb24, unwind unreachable];
    }

    bb23: {
        _35 = move ((_27 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb26, unwind unreachable];
    }

    bb24: {
        _40 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _39 = (_36, move _40);
        _0 = Result::<(PhysFrame<page::Size1GiB>, mapper::MapperFlush<page::Size1GiB>), mapper::UnmapError>::Ok(move _39);
        goto -> bb26;
    }

    bb26: {
        return;
    }

    bb27: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:322:34: 322:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:339:22: 339:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p3_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: &mut structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: structures::paging::page_table::PageTableFlags;
    let mut _22: structures::paging::mapper::MapperFlush<structures::paging::page::Size1GiB>;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _23 = deref_copy (*_4);
        _7 = &(*_23);
        _8 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb17;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size1GiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb17;
    }

    bb11: {
        _20 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _18 = PageTableEntry::set_flags(_19, move _21) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _22 = mapper::MapperFlush::<page::Size1GiB>::new(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Result::<mapper::MapperFlush<page::Size1GiB>, mapper::FlagUpdateError>::Ok(move _22);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size1GiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page<page::Size1GiB>) -> Result<PhysFrame<page::Size1GiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _13: &structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::TranslateError;
    let mut _18: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>, structures::paging::page::AddressNotAligned>;
    let mut _19: addr::PhysAddr;
    let mut _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:415:22: 415:41};
    let mut _22: &&structures::paging::page_table::PageTableEntry;
    let mut _23: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            let _12: &structures::paging::page_table::PageTableEntry;
            scope 4 {
                debug p3_entry => _12;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _23 = deref_copy (*_3);
        _6 = &(*_23);
        _7 = Page::<page::Size1GiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _8);
        goto -> bb14;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size1GiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _14 = Page::<page::Size1GiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as Index<PageTableIndex>>::index(_9, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = _13;
        _16 = _12;
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size1GiB>, mapper::TranslateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _20 = _12;
        _19 = PageTableEntry::addr(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = PhysFrame::<page::Size1GiB>::from_start_address(move _19) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = &_12;
        _21 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:415:22: 415:41} { p3_entry: move _22 };
        _0 = Result::<PhysFrame<page::Size1GiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:415:22: 415:41}>(move _18, move _21) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:299:1: 299:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:415:22: 415:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p3_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PhysFrame<page::Size2MiB>, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::MapToError<page::Size2MiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::MapToError<structures::paging::page::Size2MiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_2mib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>) -> Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: &structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _20: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _21: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _22: isize;
    let mut _25: &mut structures::paging::page_table::PageTable;
    let mut _26: *mut structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let mut _29: &mut structures::paging::page_table::PageTableEntry;
    let mut _30: structures::paging::page_table::PageTableIndex;
    let mut _32: &structures::paging::page_table::PageTableEntry;
    let mut _33: bool;
    let mut _34: &structures::paging::page_table::PageTableFlags;
    let mut _35: structures::paging::mapper::UnmapError;
    let mut _36: bool;
    let mut _37: &structures::paging::page_table::PageTableFlags;
    let mut _38: structures::paging::mapper::UnmapError;
    let mut _39: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>>;
    let mut _40: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::UnmapError>;
    let mut _41: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _42: addr::PhysAddr;
    let mut _43: &structures::paging::page_table::PageTableEntry;
    let mut _44: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:465:22: 465:41};
    let mut _45: &&mut structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let _49: ();
    let mut _50: &mut structures::paging::page_table::PageTableEntry;
    let mut _51: (structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>);
    let mut _52: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _53: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                scope 9 {
                    debug p3_entry => _16;
                    let _23: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _24: structures::paging::frame::PhysFrame;
                    scope 10 {
                        debug residual => _23;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _24;
                        scope 13 {
                        }
                    }
                    scope 14 {
                        debug p2 => _25;
                        let _28: &mut structures::paging::page_table::PageTableEntry;
                        scope 16 {
                            debug p2_entry => _28;
                            let _31: structures::paging::page_table::PageTableFlags;
                            scope 17 {
                                debug flags => _31;
                                let _47: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                                let _48: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                                scope 18 {
                                    debug frame => _48;
                                }
                                scope 19 {
                                    debug residual => _47;
                                    scope 20 {
                                    }
                                }
                                scope 21 {
                                    debug val => _48;
                                    scope 22 {
                                    }
                                }
                            }
                        }
                    }
                    scope 15 {
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _53 = deref_copy (*_3);
        _5 = &(*_53);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:441:34: 441:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:441:34: 441:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb7, otherwise: bb35];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size2MiB>(_2, move _15) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb34, unwind unreachable];
    }

    bb8: {
        _13 = &mut (*_14);
        _17 = &(*_13);
        _18 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = <PageTable as Index<PageTableIndex>>::index(move _17, move _18) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = PageTableEntry::frame(_16) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _20 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:448:34: 448:39}>(move _21, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:448:34: 448:39}) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb14, 1: bb15, otherwise: bb35];
    }

    bb14: {
        _24 = ((_19 as Continue).0: structures::paging::frame::PhysFrame);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p2_ptr::<page::Size2MiB>(_2, move _27) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _23 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _23) -> [return: bb34, unwind unreachable];
    }

    bb16: {
        _25 = &mut (*_26);
        _30 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _29 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_25, move _30) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _28 = _29;
        _32 = &(*_28);
        _31 = PageTableEntry::flags(move _32) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _34 = &_31;
        _33 = page_table::_::<impl PageTableFlags>::contains(move _34, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _33) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _37 = &_31;
        _36 = page_table::_::<impl PageTableFlags>::contains(move _37, const _) -> [return: bb23, unwind unreachable];
    }

    bb22: {
        _35 = mapper::UnmapError::PageNotMapped;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _35);
        goto -> bb34;
    }

    bb23: {
        switchInt(move _36) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _43 = &(*_28);
        _42 = PageTableEntry::addr(move _43) -> [return: bb26, unwind unreachable];
    }

    bb25: {
        _38 = mapper::UnmapError::ParentEntryHugePage;
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Err(move _38);
        goto -> bb34;
    }

    bb26: {
        _41 = PhysFrame::<page::Size2MiB>::from_start_address(move _42) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _45 = &_28;
        _44 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:465:22: 465:41} { p2_entry: move _45 };
        _40 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:465:22: 465:41}>(move _41, move _44) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _39 = <Result<PhysFrame<page::Size2MiB>, mapper::UnmapError> as Try>::branch(move _40) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _46 = discriminant(_39);
        switchInt(move _46) -> [0: bb30, 1: bb31, otherwise: bb35];
    }

    bb30: {
        _48 = ((_39 as Continue).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _50 = _28;
        _49 = PageTableEntry::set_unused(move _50) -> [return: bb32, unwind unreachable];
    }

    bb31: {
        _47 = move ((_39 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _47) -> [return: bb34, unwind unreachable];
    }

    bb32: {
        _52 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _51 = (_48, move _52);
        _0 = Result::<(PhysFrame<page::Size2MiB>, mapper::MapperFlush<page::Size2MiB>), mapper::UnmapError>::Ok(move _51);
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:441:34: 441:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:448:34: 448:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::unmap::{closure#2}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:465:22: 465:41}, _2: AddressNotAligned) -> mapper::UnmapError {
    debug p2_entry => (*(_1.0: &&mut structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: addr::PhysAddr;
    let mut _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &&mut structures::paging::page_table::PageTableEntry;
    let mut _6: &mut structures::paging::page_table::PageTableEntry;

    bb0: {
        _5 = deref_copy (_1.0: &&mut structures::paging::page_table::PageTableEntry);
        _6 = deref_copy (*_5);
        _4 = &(*_6);
        _3 = PageTableEntry::addr(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: &mut structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: structures::paging::page_table::PageTableFlags;
    let mut _30: structures::paging::mapper::MapperFlush<structures::paging::page::Size2MiB>;
    let mut _31: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _31 = deref_copy (*_4);
        _7 = &(*_31);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb23;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size2MiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb23;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size2MiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _23 = &(*_18);
        _24 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb23;
    }

    bb17: {
        _28 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_18, move _28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = <PageTableFlags as BitOr>::bitor(_3, const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _26 = PageTableEntry::set_flags(_27, move _29) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _30 = mapper::MapperFlush::<page::Size2MiB>::new(_2) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _0 = Result::<mapper::MapperFlush<page::Size2MiB>, mapper::FlagUpdateError>::Ok(move _30);
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _20 = deref_copy (*_4);
        _7 = &(*_20);
        _8 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb14;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size2MiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _14 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page<page::Size2MiB>, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug _page => _2;
    debug _flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let mut _4: structures::paging::mapper::FlagUpdateError;

    bb0: {
        _4 = mapper::FlagUpdateError::ParentEntryHugePage;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _4);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page<page::Size2MiB>) -> Result<PhysFrame<page::Size2MiB>, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _12: &structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: bool;
    let mut _15: structures::paging::mapper::TranslateError;
    let _17: *mut structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let _20: &structures::paging::page_table::PageTableEntry;
    let mut _21: structures::paging::page_table::PageTableIndex;
    let mut _22: bool;
    let mut _23: &structures::paging::page_table::PageTableEntry;
    let mut _24: structures::paging::mapper::TranslateError;
    let mut _25: core::result::Result<structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>, structures::paging::page::AddressNotAligned>;
    let mut _26: addr::PhysAddr;
    let mut _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:570:22: 570:41};
    let mut _29: &&structures::paging::page_table::PageTableEntry;
    let mut _30: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            scope 4 {
                debug p3_entry => _12;
                let _16: &structures::paging::page_table::PageTable;
                scope 5 {
                    debug p2 => _16;
                    let _19: &structures::paging::page_table::PageTableEntry;
                    scope 7 {
                        debug p2_entry => _19;
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _30 = deref_copy (*_3);
        _6 = &(*_30);
        _7 = Page::<page::Size2MiB>::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _8);
        goto -> bb20;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size2MiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _13 = Page::<page::Size2MiB>::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = <PageTable as Index<PageTableIndex>>::index(_9, move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableEntry::is_unused(_12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _14) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _15 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _15);
        goto -> bb20;
    }

    bb11: {
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_ptr::<page::Size2MiB>(_2, move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = &(*_17);
        _21 = Page::<page::Size2MiB>::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _20 = <PageTable as Index<PageTableIndex>>::index(_16, move _21) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _19 = _20;
        _23 = _19;
        _22 = PageTableEntry::is_unused(move _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _22) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _24 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame<page::Size2MiB>, mapper::TranslateError>::Err(move _24);
        goto -> bb20;
    }

    bb17: {
        _27 = _19;
        _26 = PageTableEntry::addr(move _27) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _25 = PhysFrame::<page::Size2MiB>::from_start_address(move _26) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _29 = &_19;
        _28 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:570:22: 570:41} { p2_entry: move _29 };
        _0 = Result::<PhysFrame<page::Size2MiB>, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:570:22: 570:41}>(move _25, move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:419:1: 419:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:570:22: 570:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p2_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::map_to_with_table_flags(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PhysFrame, _4: PageTableFlags, _5: PageTableFlags, _6: &mut A) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::MapToError<page::Size4KiB>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug parent_table_flags => _5;
    debug allocator => _6;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::MapToError<structures::paging::page::Size4KiB>>;

    bb0: {
        _0 = RecursivePageTable::<'_>::map_to_4kib::<A>(_1, _2, _3, _4, _5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::unmap(_1: &mut RecursivePageTable<'_>, _2: Page) -> Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<(structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>), structures::paging::mapper::UnmapError>;
    let _3: &mut &mut structures::paging::page_table::PageTable;
    let _4: &structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTable;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _8: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _9: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _10: isize;
    let mut _13: &mut structures::paging::page_table::PageTable;
    let mut _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: &structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _20: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _21: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _22: isize;
    let mut _25: &mut structures::paging::page_table::PageTable;
    let mut _26: *mut structures::paging::page_table::PageTable;
    let mut _27: structures::paging::page_table::PageTableIndex;
    let _28: &structures::paging::page_table::PageTableEntry;
    let mut _29: &structures::paging::page_table::PageTable;
    let mut _30: structures::paging::page_table::PageTableIndex;
    let mut _31: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _33: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _34: isize;
    let mut _37: &mut structures::paging::page_table::PageTable;
    let mut _38: *mut structures::paging::page_table::PageTable;
    let mut _39: structures::paging::page_table::PageTableIndex;
    let mut _40: &mut structures::paging::page_table::PageTableEntry;
    let mut _41: structures::paging::page_table::PageTableIndex;
    let mut _42: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>, structures::paging::frame::PhysFrame>;
    let mut _43: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::UnmapError>;
    let mut _44: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _45: &structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let _49: ();
    let mut _50: (structures::paging::frame::PhysFrame, structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>);
    let mut _51: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _52: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        scope 2 {
            debug p4_entry => _4;
            let _11: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
            let _12: structures::paging::frame::PhysFrame;
            scope 3 {
                debug residual => _11;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _12;
                scope 6 {
                }
            }
            scope 7 {
                debug p3 => _13;
                scope 9 {
                    debug p3_entry => _16;
                    let _23: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                    let _24: structures::paging::frame::PhysFrame;
                    scope 10 {
                        debug residual => _23;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _24;
                        scope 13 {
                        }
                    }
                    scope 14 {
                        debug p2 => _25;
                        scope 16 {
                            debug p2_entry => _28;
                            let _35: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                            let _36: structures::paging::frame::PhysFrame;
                            scope 17 {
                                debug residual => _35;
                                scope 18 {
                                }
                            }
                            scope 19 {
                                debug val => _36;
                                scope 20 {
                                }
                            }
                            scope 21 {
                                debug p1 => _37;
                                scope 23 {
                                    debug p1_entry => _40;
                                    let _47: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>;
                                    let _48: structures::paging::frame::PhysFrame;
                                    scope 24 {
                                        debug frame => _48;
                                    }
                                    scope 25 {
                                        debug residual => _47;
                                        scope 26 {
                                        }
                                    }
                                    scope 27 {
                                        debug val => _48;
                                        scope 28 {
                                        }
                                    }
                                }
                            }
                            scope 22 {
                            }
                        }
                    }
                    scope 15 {
                    }
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _52 = deref_copy (*_3);
        _5 = &(*_52);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <PageTable as Index<PageTableIndex>>::index(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = PageTableEntry::frame(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:596:34: 596:39}>(move _9, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:596:34: 596:39}) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb7, otherwise: bb35];
    }

    bb6: {
        _12 = ((_7 as Continue).0: structures::paging::frame::PhysFrame);
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size4KiB>(_2, move _15) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _11 = move ((_7 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _11) -> [return: bb34, unwind unreachable];
    }

    bb8: {
        _13 = &mut (*_14);
        _17 = &(*_13);
        _18 = Page::p3_index(_2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = <PageTable as Index<PageTableIndex>>::index(move _17, move _18) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = PageTableEntry::frame(_16) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _20 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:603:34: 603:39}>(move _21, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:603:34: 603:39}) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb14, 1: bb15, otherwise: bb35];
    }

    bb14: {
        _24 = ((_19 as Continue).0: structures::paging::frame::PhysFrame);
        _27 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _26 = p2_ptr::<page::Size4KiB>(_2, move _27) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _23 = move ((_19 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _23) -> [return: bb34, unwind unreachable];
    }

    bb16: {
        _25 = &mut (*_26);
        _29 = &(*_25);
        _30 = Page::p2_index(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = <PageTable as Index<PageTableIndex>>::index(move _29, move _30) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _33 = PageTableEntry::frame(_28) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _32 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:610:34: 610:39}>(move _33, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:610:34: 610:39}) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _31 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _32) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _34 = discriminant(_31);
        switchInt(move _34) -> [0: bb22, 1: bb23, otherwise: bb35];
    }

    bb22: {
        _36 = ((_31 as Continue).0: structures::paging::frame::PhysFrame);
        _39 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _38 = p1_ptr(_2, move _39) -> [return: bb24, unwind unreachable];
    }

    bb23: {
        _35 = move ((_31 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _35) -> [return: bb34, unwind unreachable];
    }

    bb24: {
        _37 = &mut (*_38);
        _41 = Page::p1_index(_2) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _40 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_37, move _41) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _45 = &(*_40);
        _44 = PageTableEntry::frame(move _45) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _43 = Result::<PhysFrame, FrameError>::map_err::<mapper::UnmapError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:618:46: 618:51}>(move _44, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:618:46: 618:51}) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _42 = <Result<PhysFrame, mapper::UnmapError> as Try>::branch(move _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _46 = discriminant(_42);
        switchInt(move _46) -> [0: bb30, 1: bb31, otherwise: bb35];
    }

    bb30: {
        _48 = ((_42 as Continue).0: structures::paging::frame::PhysFrame);
        _49 = PageTableEntry::set_unused(_40) -> [return: bb32, unwind unreachable];
    }

    bb31: {
        _47 = move ((_42 as Break).0: core::result::Result<core::convert::Infallible, structures::paging::mapper::UnmapError>);
        _0 = <Result<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError> as FromResidual<Result<Infallible, mapper::UnmapError>>>::from_residual(move _47) -> [return: bb34, unwind unreachable];
    }

    bb32: {
        _51 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _50 = (_48, move _51);
        _0 = Result::<(PhysFrame, mapper::MapperFlush<page::Size4KiB>), mapper::UnmapError>::Ok(move _50);
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::unmap::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:596:34: 596:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::unmap::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:603:34: 603:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::unmap::{closure#2}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:610:34: 610:39}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::unmap::{closure#3}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:618:46: 618:51}, _2: FrameError) -> mapper::UnmapError {
    debug err => _2;
    let mut _0: structures::paging::mapper::UnmapError;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4];
    }

    bb1: {
        _0 = mapper::UnmapError::ParentEntryHugePage;
        goto -> bb3;
    }

    bb2: {
        _0 = mapper::UnmapError::PageNotMapped;
        goto -> bb3;
    }

    bb3: {
        return;
    }

    bb4: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::update_flags(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: &structures::paging::page_table::PageTable;
    let mut _24: structures::paging::page_table::PageTableIndex;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let mut _26: &mut structures::paging::page_table::PageTable;
    let mut _27: *mut structures::paging::page_table::PageTable;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: bool;
    let _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: &structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let mut _33: structures::paging::mapper::FlagUpdateError;
    let _34: ();
    let mut _35: &mut structures::paging::page_table::PageTableEntry;
    let mut _36: structures::paging::page_table::PageTableIndex;
    let mut _37: structures::paging::mapper::MapperFlush<structures::paging::page::Size4KiB>;
    let mut _38: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
                scope 6 {
                    debug p1 => _26;
                }
                scope 7 {
                }
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _38 = deref_copy (*_4);
        _7 = &(*_38);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb28;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb28;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size4KiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _23 = &(*_18);
        _24 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _22 = <PageTable as Index<PageTableIndex>>::index(move _23, move _24) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb28;
    }

    bb17: {
        _28 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _27 = p1_ptr(_2, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _26 = &mut (*_27);
        _31 = &(*_26);
        _32 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _30 = <PageTable as Index<PageTableIndex>>::index(move _31, move _32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _29 = PageTableEntry::is_unused(_30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _29) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _33 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Err(move _33);
        goto -> bb28;
    }

    bb23: {
        _36 = Page::p1_index(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _35 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_26, move _36) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _34 = PageTableEntry::set_flags(_35, _3) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _37 = mapper::MapperFlush::<page::Size4KiB>::new(_2) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _0 = Result::<mapper::MapperFlush<page::Size4KiB>, mapper::FlagUpdateError>::Ok(move _37);
        goto -> bb28;
    }

    bb28: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::set_flags_p4_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: &mut structures::paging::page_table::PageTableEntry;
    let mut _6: structures::paging::page_table::PageTableIndex;
    let mut _7: bool;
    let mut _8: &structures::paging::page_table::PageTableEntry;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let _10: ();
    let mut _11: structures::paging::mapper::MapperFlushAll;
    let mut _12: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p4_entry => _5;
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _12 = deref_copy (*_4);
        _6 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = &(*_5);
        _7 = PageTableEntry::is_unused(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb8;
    }

    bb5: {
        _10 = PageTableEntry::set_flags(_5, _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = mapper::MapperFlushAll::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::set_flags_p3_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: &mut structures::paging::page_table::PageTableEntry;
    let mut _14: structures::paging::page_table::PageTableIndex;
    let mut _15: bool;
    let mut _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let _18: ();
    let mut _19: structures::paging::mapper::MapperFlushAll;
    let mut _20: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p3_entry => _13;
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _20 = deref_copy (*_4);
        _7 = &(*_20);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb14;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _14 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _13 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_10, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &(*_13);
        _15 = PageTableEntry::is_unused(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb14;
    }

    bb11: {
        _18 = PageTableEntry::set_flags(_13, _3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = mapper::MapperFlushAll::new() -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::set_flags_p2_entry(_1: &mut RecursivePageTable<'_>, _2: Page, _3: PageTableFlags) -> Result<mapper::MapperFlushAll, mapper::FlagUpdateError> {
    debug self => _1;
    debug page => _2;
    debug flags => _3;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlushAll, structures::paging::mapper::FlagUpdateError>;
    let _4: &mut &mut structures::paging::page_table::PageTable;
    let mut _5: bool;
    let _6: &structures::paging::page_table::PageTableEntry;
    let mut _7: &structures::paging::page_table::PageTable;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _9: structures::paging::mapper::FlagUpdateError;
    let mut _10: &mut structures::paging::page_table::PageTable;
    let mut _11: *mut structures::paging::page_table::PageTable;
    let mut _12: structures::paging::page_table::PageTableIndex;
    let mut _13: bool;
    let _14: &structures::paging::page_table::PageTableEntry;
    let mut _15: &structures::paging::page_table::PageTable;
    let mut _16: structures::paging::page_table::PageTableIndex;
    let mut _17: structures::paging::mapper::FlagUpdateError;
    let mut _18: &mut structures::paging::page_table::PageTable;
    let mut _19: *mut structures::paging::page_table::PageTable;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: &mut structures::paging::page_table::PageTableEntry;
    let mut _22: structures::paging::page_table::PageTableIndex;
    let mut _23: bool;
    let mut _24: &structures::paging::page_table::PageTableEntry;
    let mut _25: structures::paging::mapper::FlagUpdateError;
    let _26: ();
    let mut _27: structures::paging::mapper::MapperFlushAll;
    let mut _28: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _4;
        scope 2 {
            debug p3 => _10;
            scope 4 {
                debug p2 => _18;
                scope 6 {
                    debug p2_entry => _21;
                }
            }
            scope 5 {
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: &mut structures::paging::page_table::PageTable);
        _28 = deref_copy (*_4);
        _7 = &(*_28);
        _8 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <PageTable as Index<PageTableIndex>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = PageTableEntry::is_unused(_6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _9);
        goto -> bb20;
    }

    bb5: {
        _12 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _11 = p3_ptr::<page::Size4KiB>(_2, move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = &mut (*_11);
        _15 = &(*_10);
        _16 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <PageTable as Index<PageTableIndex>>::index(move _15, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _13 = PageTableEntry::is_unused(_14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _17);
        goto -> bb20;
    }

    bb11: {
        _20 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _19 = p2_ptr::<page::Size4KiB>(_2, move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = &mut (*_19);
        _22 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = <PageTable as IndexMut<PageTableIndex>>::index_mut(_18, move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = &(*_21);
        _23 = PageTableEntry::is_unused(move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _23) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _25 = mapper::FlagUpdateError::PageNotMapped;
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Err(move _25);
        goto -> bb20;
    }

    bb17: {
        _26 = PageTableEntry::set_flags(_21, _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _27 = mapper::MapperFlushAll::new() -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _0 = Result::<mapper::MapperFlushAll, mapper::FlagUpdateError>::Ok(const mapper::MapperFlushAll(()));
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::translate_page(_1: &RecursivePageTable<'_>, _2: Page) -> Result<PhysFrame, mapper::TranslateError> {
    debug self => _1;
    debug page => _2;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::mapper::TranslateError>;
    let _3: &&mut structures::paging::page_table::PageTable;
    let mut _4: bool;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: structures::paging::mapper::TranslateError;
    let _10: *mut structures::paging::page_table::PageTable;
    let mut _11: structures::paging::page_table::PageTableIndex;
    let _12: &structures::paging::page_table::PageTableEntry;
    let mut _13: structures::paging::page_table::PageTableIndex;
    let mut _14: bool;
    let mut _15: structures::paging::mapper::TranslateError;
    let _17: *mut structures::paging::page_table::PageTable;
    let mut _18: structures::paging::page_table::PageTableIndex;
    let _19: &structures::paging::page_table::PageTableEntry;
    let mut _20: structures::paging::page_table::PageTableIndex;
    let mut _21: bool;
    let mut _22: structures::paging::mapper::TranslateError;
    let _24: *mut structures::paging::page_table::PageTable;
    let mut _25: structures::paging::page_table::PageTableIndex;
    let _27: &structures::paging::page_table::PageTableEntry;
    let mut _28: structures::paging::page_table::PageTableIndex;
    let mut _29: bool;
    let mut _30: &structures::paging::page_table::PageTableEntry;
    let mut _31: structures::paging::mapper::TranslateError;
    let mut _32: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _33: addr::PhysAddr;
    let mut _34: &structures::paging::page_table::PageTableEntry;
    let mut _35: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:759:22: 759:41};
    let mut _36: &&structures::paging::page_table::PageTableEntry;
    let mut _37: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug p4 => _3;
        let _9: &structures::paging::page_table::PageTable;
        scope 2 {
            debug p3 => _9;
            scope 4 {
                debug p3_entry => _12;
                let _16: &structures::paging::page_table::PageTable;
                scope 5 {
                    debug p2 => _16;
                    scope 7 {
                        debug p2_entry => _19;
                        let _23: &structures::paging::page_table::PageTable;
                        scope 8 {
                            debug p1 => _23;
                            let _26: &structures::paging::page_table::PageTableEntry;
                            scope 10 {
                                debug p1_entry => _26;
                            }
                        }
                        scope 9 {
                        }
                    }
                }
                scope 6 {
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _37 = deref_copy (*_3);
        _6 = &(*_37);
        _7 = Page::p4_index(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = PageTableEntry::is_unused(_5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _8 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _8);
        goto -> bb26;
    }

    bb5: {
        _11 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _10 = p3_ptr::<page::Size4KiB>(_2, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = &(*_10);
        _13 = Page::p3_index(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = <PageTable as Index<PageTableIndex>>::index(_9, move _13) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = PageTableEntry::is_unused(_12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _14) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _15 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _15);
        goto -> bb26;
    }

    bb11: {
        _18 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _17 = p2_ptr::<page::Size4KiB>(_2, move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = &(*_17);
        _20 = Page::p2_index(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _19 = <PageTable as Index<PageTableIndex>>::index(_16, move _20) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _21 = PageTableEntry::is_unused(_19) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _21) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _22 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _22);
        goto -> bb26;
    }

    bb17: {
        _25 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _24 = p1_ptr(_2, move _25) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _23 = &(*_24);
        _28 = Page::p1_index(_2) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _27 = <PageTable as Index<PageTableIndex>>::index(_23, move _28) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _26 = _27;
        _30 = _26;
        _29 = PageTableEntry::is_unused(move _30) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _29) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _31 = mapper::TranslateError::PageNotMapped;
        _0 = Result::<PhysFrame, mapper::TranslateError>::Err(move _31);
        goto -> bb26;
    }

    bb23: {
        _34 = _26;
        _33 = PageTableEntry::addr(move _34) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _32 = PhysFrame::from_start_address(move _33) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _36 = &_26;
        _35 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:759:22: 759:41} { p1_entry: move _36 };
        _0 = Result::<PhysFrame, AddressNotAligned>::map_err::<mapper::TranslateError, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:759:22: 759:41}>(move _32, move _35) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:574:1: 574:53>::translate_page::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:759:22: 759:41}, _2: AddressNotAligned) -> mapper::TranslateError {
    debug p1_entry => (*(_1.0: &&structures::paging::page_table::PageTableEntry));
    let mut _0: structures::paging::mapper::TranslateError;
    let mut _3: addr::PhysAddr;
    let mut _4: &&structures::paging::page_table::PageTableEntry;
    let mut _5: &structures::paging::page_table::PageTableEntry;

    bb0: {
        _4 = deref_copy (_1.0: &&structures::paging::page_table::PageTableEntry);
        _5 = deref_copy (*_4);
        _3 = PageTableEntry::addr(_5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _3);
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:763:1: 763:46>::translate(_1: &RecursivePageTable<'_>, _2: addr::VirtAddr) -> mapper::TranslateResult {
    debug self => _1;
    debug addr => _2;
    let mut _0: structures::paging::mapper::TranslateResult;
    let _3: structures::paging::page::Page;
    let _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: &structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableIndex;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: &structures::paging::page_table::PageTableFlags;
    let _11: structures::paging::page_table::PageTableFlags;
    let mut _12: !;
    let _14: *mut structures::paging::page_table::PageTable;
    let mut _15: structures::paging::page_table::PageTableIndex;
    let _16: &structures::paging::page_table::PageTableEntry;
    let mut _17: structures::paging::page_table::PageTableIndex;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: &structures::paging::page_table::PageTableFlags;
    let _21: structures::paging::page_table::PageTableFlags;
    let _22: &structures::paging::page_table::PageTableEntry;
    let mut _23: structures::paging::page_table::PageTableIndex;
    let mut _25: addr::PhysAddr;
    let mut _27: u64;
    let mut _29: structures::paging::mapper::MappedFrame;
    let _31: *mut structures::paging::page_table::PageTable;
    let mut _32: structures::paging::page_table::PageTableIndex;
    let _33: &structures::paging::page_table::PageTableEntry;
    let mut _34: structures::paging::page_table::PageTableIndex;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: &structures::paging::page_table::PageTableFlags;
    let _38: structures::paging::page_table::PageTableFlags;
    let _39: &structures::paging::page_table::PageTableEntry;
    let mut _40: structures::paging::page_table::PageTableIndex;
    let mut _42: addr::PhysAddr;
    let mut _44: u64;
    let mut _46: structures::paging::mapper::MappedFrame;
    let _48: *mut structures::paging::page_table::PageTable;
    let mut _49: structures::paging::page_table::PageTableIndex;
    let _50: &structures::paging::page_table::PageTableEntry;
    let mut _51: structures::paging::page_table::PageTableIndex;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: &structures::paging::page_table::PageTableFlags;
    let _55: structures::paging::page_table::PageTableFlags;
    let mut _56: !;
    let mut _57: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page::AddressNotAligned>;
    let mut _58: addr::PhysAddr;
    let mut _59: isize;
    let mut _61: addr::PhysAddr;
    let mut _63: structures::paging::page_table::PageOffset;
    let mut _65: structures::paging::mapper::MappedFrame;
    let mut _66: &mut structures::paging::page_table::PageTable;
    scope 1 {
        debug page => _3;
        let _4: &&mut structures::paging::page_table::PageTable;
        scope 2 {
            debug p4 => _4;
            scope 3 {
                debug p4_entry => _5;
                let _13: &structures::paging::page_table::PageTable;
                scope 4 {
                    debug p3 => _13;
                    scope 6 {
                        debug p3_entry => _16;
                        let _30: &structures::paging::page_table::PageTable;
                        scope 7 {
                            debug entry => _22;
                            let _24: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
                            scope 8 {
                                debug frame => _24;
                                let _26: u64;
                                scope 9 {
                                    debug offset => _26;
                                    let _28: structures::paging::page_table::PageTableFlags;
                                    scope 10 {
                                        debug flags => _28;
                                    }
                                }
                            }
                        }
                        scope 11 {
                            debug p2 => _30;
                            scope 13 {
                                debug p2_entry => _33;
                                let _47: &structures::paging::page_table::PageTable;
                                scope 14 {
                                    debug entry => _39;
                                    let _41: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
                                    scope 15 {
                                        debug frame => _41;
                                        let _43: u64;
                                        scope 16 {
                                            debug offset => _43;
                                            let _45: structures::paging::page_table::PageTableFlags;
                                            scope 17 {
                                                debug flags => _45;
                                            }
                                        }
                                    }
                                }
                                scope 18 {
                                    debug p1 => _47;
                                    scope 20 {
                                        debug p1_entry => _50;
                                        let _60: structures::paging::frame::PhysFrame;
                                        scope 21 {
                                            debug frame => _60;
                                            let _62: u64;
                                            scope 23 {
                                                debug offset => _62;
                                                let _64: structures::paging::page_table::PageTableFlags;
                                                scope 24 {
                                                    debug flags => _64;
                                                }
                                            }
                                        }
                                        scope 22 {
                                            debug frame => _60;
                                        }
                                    }
                                }
                                scope 19 {
                                }
                            }
                        }
                        scope 12 {
                        }
                    }
                }
                scope 5 {
                }
            }
        }
    }

    bb0: {
        _3 = Page::containing_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &((*_1).0: &mut structures::paging::page_table::PageTable);
        _66 = deref_copy (*_4);
        _6 = &(*_66);
        _7 = addr::VirtAddr::p4_index(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = <PageTable as Index<PageTableIndex>>::index(move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = PageTableEntry::is_unused(_5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb61;
    }

    bb6: {
        _11 = PageTableEntry::flags(_5) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _10 = &_11;
        _9 = page_table::_::<impl PageTableFlags>::contains(move _10, const _) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _12 = panic(const "level 4 entry has huge page bit set") -> unwind unreachable;
    }

    bb10: {
        _15 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _14 = p3_ptr::<page::Size4KiB>(_3, move _15) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = &(*_14);
        _17 = addr::VirtAddr::p3_index(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = <PageTable as Index<PageTableIndex>>::index(_13, move _17) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _18 = PageTableEntry::is_unused(_16) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        switchInt(move _18) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb61;
    }

    bb16: {
        _21 = PageTableEntry::flags(_16) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _20 = &_21;
        _19 = page_table::_::<impl PageTableFlags>::contains(move _20, const _) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        switchInt(move _19) -> [0: bb26, otherwise: bb19];
    }

    bb19: {
        _23 = addr::VirtAddr::p3_index(_2) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _22 = <PageTable as Index<PageTableIndex>>::index(_13, move _23) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _25 = PageTableEntry::addr(_22) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _24 = PhysFrame::<page::Size1GiB>::containing_address(move _25) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _27 = addr::VirtAddr::as_u64(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _26 = BitAnd(move _27, const 1073741823_u64);
        _28 = PageTableEntry::flags(_22) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _29 = mapper::MappedFrame::Size1GiB(_24);
        _0 = mapper::TranslateResult::Mapped { frame: move _29, offset: _26, flags: _28 };
        goto -> bb61;
    }

    bb26: {
        _32 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _31 = p2_ptr::<page::Size4KiB>(_3, move _32) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _30 = &(*_31);
        _34 = addr::VirtAddr::p2_index(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _33 = <PageTable as Index<PageTableIndex>>::index(_30, move _34) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _35 = PageTableEntry::is_unused(_33) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _35) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb61;
    }

    bb32: {
        _38 = PageTableEntry::flags(_33) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _37 = &_38;
        _36 = page_table::_::<impl PageTableFlags>::contains(move _37, const _) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _36) -> [0: bb42, otherwise: bb35];
    }

    bb35: {
        _40 = addr::VirtAddr::p2_index(_2) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _39 = <PageTable as Index<PageTableIndex>>::index(_30, move _40) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _42 = PageTableEntry::addr(_39) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _41 = PhysFrame::<page::Size2MiB>::containing_address(move _42) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _44 = addr::VirtAddr::as_u64(_2) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _43 = BitAnd(move _44, const 2097151_u64);
        _45 = PageTableEntry::flags(_39) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _46 = mapper::MappedFrame::Size2MiB(_41);
        _0 = mapper::TranslateResult::Mapped { frame: move _46, offset: _43, flags: _45 };
        goto -> bb61;
    }

    bb42: {
        _49 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _48 = p1_ptr(_3, move _49) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _47 = &(*_48);
        _51 = addr::VirtAddr::p1_index(_2) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _50 = <PageTable as Index<PageTableIndex>>::index(_47, move _51) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _52 = PageTableEntry::is_unused(_50) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _52) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _0 = mapper::TranslateResult::NotMapped;
        goto -> bb61;
    }

    bb48: {
        _55 = PageTableEntry::flags(_50) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _54 = &_55;
        _53 = page_table::_::<impl PageTableFlags>::contains(move _54, const _) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        switchInt(move _53) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _56 = panic(const "level 1 entry has huge page bit set") -> unwind unreachable;
    }

    bb52: {
        _58 = PageTableEntry::addr(_50) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _57 = PhysFrame::from_start_address(move _58) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _59 = discriminant(_57);
        switchInt(move _59) -> [0: bb56, 1: bb55, otherwise: bb62];
    }

    bb55: {
        _61 = PageTableEntry::addr(_50) -> [return: bb57, unwind unreachable];
    }

    bb56: {
        _60 = ((_57 as Ok).0: structures::paging::frame::PhysFrame);
        _63 = addr::VirtAddr::page_offset(_2) -> [return: bb58, unwind unreachable];
    }

    bb57: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _61);
        goto -> bb61;
    }

    bb58: {
        _62 = <u64 as From<PageOffset>>::from(move _63) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _64 = PageTableEntry::flags(_50) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _65 = mapper::MappedFrame::Size4KiB(_60);
        _0 = mapper::TranslateResult::Mapped { frame: move _65, offset: _62, flags: _64 };
        goto -> bb61;
    }

    bb61: {
        return;
    }

    bb62: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:834:1: 834:44>::clean_up(_1: &mut RecursivePageTable<'_>, _2: &mut D) -> () {
    debug self => _1;
    debug frame_deallocator => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::PageRangeInclusive;
    let mut _4: structures::paging::page::Page;
    let mut _5: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page;
    let mut _8: core::result::Result<structures::paging::page::Page, structures::paging::page::AddressNotAligned>;
    let mut _9: addr::VirtAddr;
    scope 1 {
    }

    bb0: {
        _6 = addr::VirtAddr::new(const 0_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Page::from_start_address(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Result::<Page, AddressNotAligned>::unwrap(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = addr::VirtAddr::new(const 18446744073709547520_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Page::from_start_address(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Result::<Page, AddressNotAligned>::unwrap(move _8) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _3 = PageRangeInclusive { start: move _4, end: move _7 };
        _0 = <RecursivePageTable<'_> as mapper::CleanUp>::clean_up_addr_range::<D>(_1, move _3, _2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:834:1: 834:44>::clean_up_addr_range(_1: &mut RecursivePageTable<'_>, _2: PageRangeInclusive, _3: &mut D) -> () {
    debug self => _1;
    debug range => _2;
    debug frame_deallocator => _3;
    let mut _0: ();
    let _4: bool;
    let mut _5: structures::paging::page_table::PageTableIndex;
    let mut _6: &mut structures::paging::page_table::PageTable;
    let mut _7: structures::paging::page_table::PageTableLevel;

    bb0: {
        _5 = ((*_1).1: structures::paging::page_table::PageTableIndex);
        _6 = RecursivePageTable::<'_>::level_4_table(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = PageTableLevel::Four;
        _4 = <RecursivePageTable<'a> as mapper::CleanUp>::clean_up_addr_range::clean_up::<D>(move _5, _6, move _7, _2, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:834:1: 834:44>::clean_up_addr_range::clean_up(_1: PageTableIndex, _2: &mut PageTable, _3: PageTableLevel, _4: PageRangeInclusive, _5: &mut impl FrameDeallocator<Size4KiB>) -> bool {
    debug recursive_index => _1;
    debug page_table => _2;
    debug level => _3;
    debug range => _4;
    debug frame_deallocator => _5;
    let mut _0: bool;
    let mut _6: bool;
    let mut _7: &structures::paging::page::PageRangeInclusive;
    let _8: addr::VirtAddr;
    let mut _9: addr::VirtAddr;
    let mut _10: structures::paging::page::Page;
    let mut _11: u64;
    let mut _12: structures::paging::page_table::PageTableLevel;
    let mut _14: structures::paging::page::Page;
    let mut _15: structures::paging::page_table::PageTableLevel;
    let mut _17: structures::paging::page::Page;
    let mut _18: structures::paging::page_table::PageTableLevel;
    let mut _19: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _20: structures::paging::page_table::PageTableLevel;
    let mut _21: isize;
    let mut _24: structures::paging::page_table::PageTableLevel;
    let mut _25: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}>;
    let mut _26: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}>;
    let mut _27: core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>;
    let mut _28: core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>;
    let mut _29: core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>;
    let mut _30: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _31: usize;
    let mut _32: usize;
    let mut _33: (usize, bool);
    let mut _34: usize;
    let mut _35: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37};
    let mut _36: &structures::paging::page_table::PageTableLevel;
    let mut _37: &structures::paging::page_table::PageTableIndex;
    let mut _39: core::option::Option<(usize, &mut structures::paging::page_table::PageTableEntry)>;
    let mut _40: &mut core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}>;
    let mut _41: isize;
    let mut _44: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _45: &structures::paging::page_table::PageTableEntry;
    let mut _46: isize;
    let mut _49: u64;
    let mut _50: u64;
    let mut _51: (u64, bool);
    let mut _53: u64;
    let mut _54: (u64, bool);
    let mut _57: structures::paging::page::Page;
    let mut _60: structures::paging::page::Page;
    let mut _62: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _63: [fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable; 3];
    let mut _64: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _65: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let mut _66: fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable;
    let _67: usize;
    let mut _68: usize;
    let _69: structures::paging::page_table::PageTableLevel;
    let mut _70: isize;
    let mut _71: u8;
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: (usize, bool);
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: structures::paging::page_table::PageTableIndex;
    let mut _79: &mut structures::paging::page_table::PageTable;
    let mut _80: bool;
    let mut _81: structures::paging::page_table::PageTableIndex;
    let mut _82: structures::paging::page::PageRangeInclusive;
    let _83: ();
    let _84: ();
    let mut _85: &mut core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _86: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _87: &structures::paging::page_table::PageTable;
    scope 1 {
        debug table_addr => _8;
        let _13: structures::paging::page_table::PageTableIndex;
        scope 2 {
            debug start => _13;
            let _16: structures::paging::page_table::PageTableIndex;
            scope 3 {
                debug end => _16;
                scope 4 {
                    debug next_level => _22;
                    let _22: structures::paging::page_table::PageTableLevel;
                    let _23: u64;
                    scope 5 {
                        debug offset_per_entry => _23;
                        let mut _38: core::iter::Filter<core::iter::Skip<core::iter::Take<core::iter::Enumerate<core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}>;
                        scope 6 {
                            debug iter => _38;
                            let _42: usize;
                            let _43: &mut structures::paging::page_table::PageTableEntry;
                            scope 7 {
                                debug i => _42;
                                debug entry => _43;
                                scope 8 {
                                    debug frame => _47;
                                    let _47: structures::paging::frame::PhysFrame;
                                    let _48: addr::VirtAddr;
                                    scope 9 {
                                        debug start => _48;
                                        let _52: addr::VirtAddr;
                                        scope 10 {
                                            debug end => _52;
                                            let _55: structures::paging::page::Page;
                                            scope 11 {
                                                debug start => _55;
                                                let _56: structures::paging::page::Page;
                                                scope 12 {
                                                    debug start => _56;
                                                    let _58: structures::paging::page::Page;
                                                    scope 13 {
                                                        debug end => _58;
                                                        let _59: structures::paging::page::Page;
                                                        scope 14 {
                                                            debug end => _59;
                                                            let _61: *mut structures::paging::page_table::PageTable;
                                                            scope 15 {
                                                                debug page_table => _61;
                                                                scope 16 {
                                                                    debug page_table => _79;
                                                                    scope 18 {
                                                                    }
                                                                }
                                                                scope 17 {
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_4;
        _6 = PageRangeInclusive::is_empty(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb43;
    }

    bb3: {
        _10 = (_4.0: structures::paging::page::Page);
        _9 = Page::start_address(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = _3;
        _11 = PageTableLevel::table_address_space_alignment(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = addr::VirtAddr::align_down::<u64>(move _9, move _11) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _14 = (_4.0: structures::paging::page::Page);
        _15 = _3;
        _13 = Page::page_table_index(move _14, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _17 = (_4.1: structures::paging::page::Page);
        _18 = _3;
        _16 = Page::page_table_index(move _17, move _18) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _20 = _3;
        _19 = PageTableLevel::next_lower_level(move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [1: bb10, otherwise: bb41];
    }

    bb10: {
        _22 = ((_19 as Some).0: structures::paging::page_table::PageTableLevel);
        _24 = _3;
        _23 = PageTableLevel::entry_address_space_alignment(move _24) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _30 = PageTable::iter_mut(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _29 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}> as Iterator>::enumerate(move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _32 = <usize as From<PageTableIndex>>::from(_16) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _33 = CheckedAdd(_32, const 1_usize);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _32, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _31 = move (_33.0: usize);
        _28 = <Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>> as Iterator>::take(move _29, move _31) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _34 = <usize as From<PageTableIndex>>::from(_13) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _27 = <Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>> as Iterator>::skip(move _28, move _34) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _36 = &_3;
        _37 = &_1;
        _35 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37} { level: move _36, recursive_index: move _37 };
        _26 = <Skip<Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>> as Iterator>::filter::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}>(move _27, move _35) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = <Filter<Skip<Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}> as IntoIterator>::into_iter(move _26) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _38 = move _25;
        goto -> bb21;
    }

    bb21: {
        _40 = &mut _38;
        _39 = <Filter<Skip<Take<Enumerate<Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>>>>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}> as Iterator>::next(_40) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _41 = discriminant(_39);
        switchInt(move _41) -> [0: bb41, 1: bb23, otherwise: bb44];
    }

    bb23: {
        _42 = (((_39 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).0: usize);
        _43 = move (((_39 as Some).0: (usize, &mut structures::paging::page_table::PageTableEntry)).1: &mut structures::paging::page_table::PageTableEntry);
        _45 = &(*_43);
        _44 = PageTableEntry::frame(move _45) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb25, otherwise: bb21];
    }

    bb25: {
        _47 = ((_44 as Ok).0: structures::paging::frame::PhysFrame);
        _50 = _42 as u64 (IntToInt);
        _51 = CheckedMul(_23, _50);
        assert(!move (_51.1: bool), "attempt to compute `{} * {}`, which would overflow", _23, move _50) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _49 = move (_51.0: u64);
        _48 = <addr::VirtAddr as Add<u64>>::add(_8, move _49) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _54 = CheckedSub(_23, const 1_u64);
        assert(!move (_54.1: bool), "attempt to compute `{} - {}`, which would overflow", _23, const 1_u64) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _53 = move (_54.0: u64);
        _52 = <addr::VirtAddr as Add<u64>>::add(_48, move _53) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _55 = Page::containing_address(_48) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _57 = (_4.0: structures::paging::page::Page);
        _56 = <Page as Ord>::max(_55, move _57) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _58 = Page::containing_address(_52) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _60 = (_4.1: structures::paging::page::Page);
        _59 = <Page as Ord>::min(_58, move _60) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _64 = structures::paging::mapper::recursive_page_table::p1_ptr as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _65 = structures::paging::mapper::recursive_page_table::p2_ptr::<structures::paging::page::Size4KiB> as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _66 = structures::paging::mapper::recursive_page_table::p3_ptr::<structures::paging::page::Size4KiB> as fn(structures::paging::page::Page, structures::paging::page_table::PageTableIndex) -> *mut structures::paging::page_table::PageTable (PointerCoercion(ReifyFnPointer));
        _63 = [move _64, move _65, move _66];
        _69 = _3;
        _70 = discriminant(_69);
        _71 = _70 as u8 (IntToInt);
        _72 = Ge(_71, const 1_u8);
        _73 = Le(_71, const 4_u8);
        _74 = BitAnd(move _72, move _73);
        assume(move _74);
        _68 = move _70 as usize (IntToInt);
        _75 = CheckedSub(_68, const 2_usize);
        assert(!move (_75.1: bool), "attempt to compute `{} - {}`, which would overflow", move _68, const 2_usize) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _67 = move (_75.0: usize);
        _76 = const 3_usize;
        _77 = Lt(_67, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _67) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _62 = _63[_67];
        _78 = _1;
        _61 = move _62(_56, move _78) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _79 = &mut (*_61);
        _81 = _1;
        _82 = Page::range_inclusive(_56, _59) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _80 = <RecursivePageTable<'a> as mapper::CleanUp>::clean_up_addr_range::clean_up::<impl FrameDeallocator<Size4KiB>>(move _81, _79, _22, move _82, _5) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        switchInt(move _80) -> [0: bb21, otherwise: bb39];
    }

    bb39: {
        _83 = PageTableEntry::set_unused(_43) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _84 = <impl FrameDeallocator<Size4KiB> as FrameDeallocator<page::Size4KiB>>::deallocate_frame(_5, _47) -> [return: bb21, unwind unreachable];
    }

    bb41: {
        _87 = &(*_2);
        _86 = PageTable::iter(move _87) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _85 = &mut _86;
        _0 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}> as Iterator>::all::<for<'a> fn(&'a PageTableEntry) -> bool {PageTableEntry::is_unused}>(move _85, PageTableEntry::is_unused) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        return;
    }

    bb44: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:834:1: 834:44>::clean_up_addr_range::clean_up::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:884:29: 884:37}, _2: &(usize, &mut PageTableEntry)) -> bool {
    debug level => (*((*_1).0: &structures::paging::page_table::PageTableLevel));
    debug recursive_index => (*((*_1).1: &structures::paging::page_table::PageTableIndex));
    let mut _0: bool;
    let _3: &usize;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: structures::paging::page_table::PageTableIndex;
    let mut _10: &structures::paging::page_table::PageTableLevel;
    let mut _11: &structures::paging::page_table::PageTableIndex;
    scope 1 {
        debug i => _3;
        let mut _9: &structures::paging::page_table::PageTableLevel;
    }

    bb0: {
        _3 = &((*_2).0: usize);
        _10 = deref_copy ((*_1).0: &structures::paging::page_table::PageTableLevel);
        _9 = const _;
        _5 = <PageTableLevel as PartialEq>::eq(_10, _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _5) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = (*_3);
        _11 = deref_copy ((*_1).1: &structures::paging::page_table::PageTableIndex);
        _8 = (*_11);
        _7 = <PageTableIndex as Into<usize>>::into(move _8) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _4 = const false;
        goto -> bb5;
    }

    bb4: {
        _4 = Eq(move _6, move _7);
        goto -> bb5;
    }

    bb5: {
        _0 = Not(move _4);
        return;
    }
}

promoted[0] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:834:1: 834:44>::clean_up_addr_range::clean_up::{closure#0}: &PageTableLevel = {
    let mut _0: &structures::paging::page_table::PageTableLevel;
    let mut _1: structures::paging::page_table::PageTableLevel;

    bb0: {
        _1 = PageTableLevel::Four;
        _0 = &_1;
        return;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:928:10: 928:15>::fmt(_1: &InvalidPageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = const "NotActive";
        _3 = _6;
        goto -> bb3;
    }

    bb2: {
        _5 = const "NotRecursive";
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:943:1: 943:39>::fmt(_1: &InvalidPageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: core::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[&str; 1];
    let mut _9: &[&str; 1];

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb6];
    }

    bb1: {
        _8 = const _;
        _7 = _8 as &[&str] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_const(move _7) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_const(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

promoted[0] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:943:1: 943:39>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "given page table is not active on the CPU"];
        _0 = &_1;
        return;
    }
}

promoted[1] in recursive_page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/recursive_page_table.rs:943:1: 943:39>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "given page table address is not recursive"];
        _0 = &_1;
        return;
    }
}

fn p3_ptr(_1: Page<S>, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p3_page::<S>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p3_page(_1: Page<S>, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::<S>::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Page::from_page_table_indices(_2, _2, _2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn p2_ptr(_1: Page<S>, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p2_page::<S>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p2_page(_1: Page<S>, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;
    let mut _4: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::<S>::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Page::<S>::p3_index(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Page::from_page_table_indices(_2, _2, move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p1_ptr(_1: Page, _2: PageTableIndex) -> *mut PageTable {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: *mut structures::paging::page_table::PageTable;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page;

    bb0: {
        _4 = p1_page(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Page::start_address(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = addr::VirtAddr::as_mut_ptr::<PageTable>(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn p1_page(_1: Page, _2: PageTableIndex) -> Page {
    debug page => _1;
    debug recursive_index => _2;
    let mut _0: structures::paging::page::Page;
    let mut _3: structures::paging::page_table::PageTableIndex;
    let mut _4: structures::paging::page_table::PageTableIndex;
    let mut _5: structures::paging::page_table::PageTableIndex;

    bb0: {
        _3 = Page::p4_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Page::p3_index(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Page::p2_index(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::from_page_table_indices(_2, move _3, move _4, move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapper::Translate::translate_addr(_1: &Self, _2: addr::VirtAddr) -> Option<PhysAddr> {
    debug self => _1;
    debug addr => _2;
    let mut _0: core::option::Option<addr::PhysAddr>;
    let mut _3: structures::paging::mapper::TranslateResult;
    let mut _4: isize;
    let _5: structures::paging::mapper::MappedFrame;
    let _6: u64;
    let mut _7: addr::PhysAddr;
    let mut _8: addr::PhysAddr;
    let mut _9: &structures::paging::mapper::MappedFrame;
    scope 1 {
        debug frame => _5;
        debug offset => _6;
    }

    bb0: {
        _3 = <Self as mapper::Translate>::translate(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb3, otherwise: bb7];
    }

    bb2: {
        _5 = move ((_3 as Mapped).0: structures::paging::mapper::MappedFrame);
        _6 = ((_3 as Mapped).1: u64);
        _9 = &_5;
        _8 = mapper::MappedFrame::start_address(move _9) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = Option::<PhysAddr>::None;
        goto -> bb6;
    }

    bb4: {
        _7 = <PhysAddr as Add<u64>>::add(move _8, _6) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Option::<PhysAddr>::Some(move _7);
        goto -> bb6;
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:57:10: 57:15>::fmt(_1: &mapper::TranslateResult, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &structures::paging::mapper::MappedFrame;
    let _5: &u64;
    let _6: &structures::paging::page_table::PageTableFlags;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &str;
    let mut _13: &dyn core::fmt::Debug;
    let _14: &&structures::paging::page_table::PageTableFlags;
    let _15: &str;
    let _16: &addr::PhysAddr;
    let _17: &str;
    let mut _18: &dyn core::fmt::Debug;
    let _19: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
        debug __self_2 => _6;
    }
    scope 2 {
        debug __self_0 => _16;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _16 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _17 = const "InvalidFrameAddress";
        _19 = &_16;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _17, move _18) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _4 = &(((*_1) as Mapped).0: structures::paging::mapper::MappedFrame);
        _5 = &(((*_1) as Mapped).1: u64);
        _6 = &(((*_1) as Mapped).2: structures::paging::page_table::PageTableFlags);
        _7 = const "Mapped";
        _8 = const "frame";
        _9 = _4 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "offset";
        _11 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _12 = const "flags";
        _14 = &_6;
        _13 = _14 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _7, _8, move _9, _10, move _11, _12, move _13) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _15 = const "NotMapped";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:79:10: 79:15>::fmt(_1: &mapper::MappedFrame, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &structures::paging::frame::PhysFrame;
    let _5: &str;
    let mut _6: &dyn core::fmt::Debug;
    let _7: &&structures::paging::frame::PhysFrame;
    let _8: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _9: &str;
    let mut _10: &dyn core::fmt::Debug;
    let _11: &&structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _12: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &&structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _12 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _13 = const "Size1GiB";
        _15 = &_12;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _4 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _5 = const "Size4KiB";
        _7 = &_4;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _8 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _9 = const "Size2MiB";
        _11 = &_8;
        _10 = _11 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:89:1: 89:17>::start_address(_1: &mapper::MappedFrame) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: isize;
    let _3: &structures::paging::frame::PhysFrame;
    let _4: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _5: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug frame => _3;
    }
    scope 2 {
        debug frame => _4;
    }
    scope 3 {
        debug frame => _5;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _5 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _0 = ((*_5).0: addr::PhysAddr);
        goto -> bb4;
    }

    bb2: {
        _3 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _0 = ((*_3).0: addr::PhysAddr);
        goto -> bb4;
    }

    bb3: {
        _4 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _0 = ((*_4).0: addr::PhysAddr);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:89:1: 89:17>::start_address(_1: &mapper::MappedFrame) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: isize;
    let _3: &structures::paging::frame::PhysFrame;
    let _4: &structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>;
    let _5: &structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>;
    scope 1 {
        debug frame => _3;
    }
    scope 2 {
        debug frame => _4;
    }
    scope 3 {
        debug frame => _5;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        StorageLive(_5);
        _5 = &(((*_1) as Size1GiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size1GiB>);
        _0 = ((*_5).0: addr::PhysAddr);
        StorageDead(_5);
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_3);
        _3 = &(((*_1) as Size4KiB).0: structures::paging::frame::PhysFrame);
        _0 = ((*_3).0: addr::PhysAddr);
        StorageDead(_3);
        goto -> bb5;
    }

    bb4: {
        StorageLive(_4);
        _4 = &(((*_1) as Size2MiB).0: structures::paging::frame::PhysFrame<structures::paging::page::Size2MiB>);
        _0 = ((*_4).0: addr::PhysAddr);
        StorageDead(_4);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:89:1: 89:17>::size(_1: &mapper::MappedFrame) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _0 = const _;
        goto -> bb4;
    }

    bb2: {
        _0 = const _;
        goto -> bb4;
    }

    bb3: {
        _0 = const _;
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:89:1: 89:17>::size(_1: &mapper::MappedFrame) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const _;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn mapper::Mapper::map_to(_1: &mut Self, _2: Page<S>, _3: PhysFrame<S>, _4: PageTableFlags, _5: &mut A) -> Result<mapper::MapperFlush<S>, mapper::MapToError<S>> {
    debug self => _1;
    debug page => _2;
    debug frame => _3;
    debug flags => _4;
    debug frame_allocator => _5;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<S>, structures::paging::mapper::MapToError<S>>;
    let _6: structures::paging::page_table::PageTableFlags;
    let mut _7: structures::paging::page_table::PageTableFlags;
    let mut _8: structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug parent_table_flags => _6;
        scope 2 {
        }
    }

    bb0: {
        _8 = <PageTableFlags as BitOr>::bitor(const _, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <PageTableFlags as BitOr>::bitor(move _8, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = <PageTableFlags as BitAnd>::bitand(_4, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <Self as mapper::Mapper<S>>::map_to_with_table_flags::<A>(_1, _2, _3, _4, _6, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn mapper::Mapper::identity_map(_1: &mut Self, _2: PhysFrame<S>, _3: PageTableFlags, _4: &mut A) -> Result<mapper::MapperFlush<S>, mapper::MapToError<S>> {
    debug self => _1;
    debug frame => _2;
    debug flags => _3;
    debug frame_allocator => _4;
    let mut _0: core::result::Result<structures::paging::mapper::MapperFlush<S>, structures::paging::mapper::MapToError<S>>;
    let _5: structures::paging::page::Page<S>;
    let mut _6: addr::VirtAddr;
    let mut _7: u64;
    let mut _8: addr::PhysAddr;
    scope 1 {
        debug page => _5;
        scope 2 {
        }
    }

    bb0: {
        _8 = PhysFrame::<S>::start_address(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = PhysAddr::as_u64(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = addr::VirtAddr::new(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Page::<S>::containing_address(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <Self as mapper::Mapper<S>>::map_to::<A>(_1, _5, _2, _3, _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:382:10: 382:15>::fmt(_1: &mapper::MapperFlush<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&structures::paging::page::Page<S>;
    let _6: &structures::paging::page::Page<S>;

    bb0: {
        _3 = const "MapperFlush";
        _6 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:386:1: 386:33>::new(_1: Page<S>) -> mapper::MapperFlush<S> {
    debug page => _1;
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(_1);
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:386:1: 386:33>::flush(_1: mapper::MapperFlush<S>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (_1.0: structures::paging::page::Page<S>);
        _3 = Page::<S>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = flush(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:386:1: 386:33>::ignore(_1: mapper::MapperFlush<S>) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:413:10: 413:15>::fmt(_1: &mapper::MapperFlushAll, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "MapperFlushAll";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:413:17: 413:24>::default() -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;
    let mut _1: ();

    bb0: {
        _1 = <() as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:417:1: 417:20>::new() -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:417:1: 417:20>::flush_all(_1: mapper::MapperFlushAll) -> () {
    debug self => const mapper::MapperFlushAll(());
    let mut _0: ();

    bb0: {
        _0 = flush_all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:417:1: 417:20>::ignore(_1: mapper::MapperFlushAll) -> () {
    debug self => const mapper::MapperFlushAll(());
    let mut _0: ();

    bb0: {
        return;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:440:10: 440:15>::fmt(_1: &mapper::MapToError<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &structures::paging::frame::PhysFrame<S>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&structures::paging::frame::PhysFrame<S>;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = &(((*_1) as PageAlreadyMapped).0: structures::paging::frame::PhysFrame<S>);
        _7 = const "PageAlreadyMapped";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _4 = const "FrameAllocationFailed";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _5 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:453:10: 453:15>::fmt(_1: &mapper::UnmapError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &addr::PhysAddr;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _7 = const "InvalidFrameAddress";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _4 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _5 = const "PageNotMapped";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:465:10: 465:15>::fmt(_1: &mapper::FlagUpdateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = const "ParentEntryHugePage";
        _3 = _6;
        goto -> bb3;
    }

    bb2: {
        _5 = const "PageNotMapped";
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn mapper::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/mapper/mod.rs:475:10: 475:15>::fmt(_1: &mapper::TranslateError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &addr::PhysAddr;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&addr::PhysAddr;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb2, 1: bb3, 2: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = &(((*_1) as InvalidFrameAddress).0: addr::PhysAddr);
        _7 = const "InvalidFrameAddress";
        _9 = &_6;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb4, unwind unreachable];
    }

    bb2: {
        _4 = const "PageNotMapped";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _5 = const "ParentEntryHugePage";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

static _ASSERT_OBJECT_SAFE: Option<&dyn mapper::Translate + Sync> = {
    let mut _0: core::option::Option<&dyn structures::paging::mapper::Translate + core::marker::Sync>;

    bb0: {
        _0 = Option::<&dyn mapper::Translate + Sync>::None;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:10: 25:15>::fmt(_1: &page::Size4KiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:17: 25:22>::clone(_1: &page::Size4KiB) -> page::Size4KiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size4KiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:30: 25:39>::eq(_1: &page::Size4KiB, _2: &page::Size4KiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:41: 25:43>::assert_receiver_is_total_eq(_1: &page::Size4KiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:45: 25:55>::partial_cmp(_1: &page::Size4KiB, _2: &page::Size4KiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:25:57: 25:60>::cmp(_1: &page::Size4KiB, _2: &page::Size4KiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:10: 29:15>::fmt(_1: &page::Size2MiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:17: 29:22>::clone(_1: &page::Size2MiB) -> page::Size2MiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size2MiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:30: 29:39>::eq(_1: &page::Size2MiB, _2: &page::Size2MiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:41: 29:43>::assert_receiver_is_total_eq(_1: &page::Size2MiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:45: 29:55>::partial_cmp(_1: &page::Size2MiB, _2: &page::Size2MiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:29:57: 29:60>::cmp(_1: &page::Size2MiB, _2: &page::Size2MiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:10: 35:15>::fmt(_1: &page::Size1GiB, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:17: 35:22>::clone(_1: &page::Size1GiB) -> page::Size1GiB {
    debug self => _1;
    let mut _0: structures::paging::page::Size1GiB;

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:30: 35:39>::eq(_1: &page::Size1GiB, _2: &page::Size1GiB) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:41: 35:43>::assert_receiver_is_total_eq(_1: &page::Size1GiB) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:45: 35:55>::partial_cmp(_1: &page::Size1GiB, _2: &page::Size1GiB) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;

    bb0: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:35:57: 35:60>::cmp(_1: &page::Size1GiB, _2: &page::Size1GiB) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;

    bb0: {
        unreachable;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:38:1: 38:27>::SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 4096_u64;
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:38:1: 38:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "4KiB";
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:45:1: 45:27>::SIZE: u64 = {
    let mut _0: u64;
    let mut _1: (u64, bool);

    bb0: {
        _1 = CheckedMul(const _, const 512_u64);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 512_u64) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: u64);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:45:1: 45:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "2MiB";
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:52:1: 52:27>::SIZE: u64 = {
    let mut _0: u64;
    let mut _1: (u64, bool);

    bb0: {
        _1 = CheckedMul(const _, const 512_u64);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 512_u64) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: u64);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:52:1: 52:27>::SIZE_AS_DEBUG_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "1GiB";
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:10: 58:15>::clone(_1: &Page<S>) -> Page<S> {
    debug self => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;
    let _3: &addr::VirtAddr;
    let mut _4: core::marker::PhantomData<S>;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _3 = &((*_1).0: addr::VirtAddr);
        _2 = <addr::VirtAddr as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _4 = <PhantomData<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Page::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:23: 58:32>::eq(_1: &Page<S>, _2: &Page<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &addr::VirtAddr;
    let mut _5: &addr::VirtAddr;
    let mut _6: &core::marker::PhantomData<S>;
    let mut _7: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: core::marker::PhantomData<S>);
        _7 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:34: 58:36>::assert_receiver_is_total_eq(_1: &Page<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:38: 58:48>::partial_cmp(_1: &Page<S>, _2: &Page<S>) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let mut _3: core::option::Option<core::cmp::Ordering>;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &core::marker::PhantomData<S>;
    let _9: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: core::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: core::marker::PhantomData<S>);
        _9 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:50: 58:53>::cmp(_1: &Page<S>, _2: &Page<S>) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let mut _3: core::cmp::Ordering;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;
    let mut _6: i8;
    let _7: &core::marker::PhantomData<S>;
    let _8: &core::marker::PhantomData<S>;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Ord>::cmp(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb4;
    }

    bb3: {
        _7 = &((*_1).1: core::marker::PhantomData<S>);
        _8 = &((*_2).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Ord>::cmp(_7, _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:58:55: 58:59>::hash(_1: &Page<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &addr::VirtAddr;
    let _5: &core::marker::PhantomData<S>;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: core::marker::PhantomData<S>);
        _0 = <PhantomData<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

const page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::from_start_address(_1: addr::VirtAddr) -> Result<Page<S>, AddressNotAligned> {
    debug address => _1;
    let mut _0: core::result::Result<structures::paging::page::Page<S>, structures::paging::page::AddressNotAligned>;
    let mut _2: bool;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        _2 = addr::VirtAddr::is_aligned::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = Page::<S>::containing_address(_1) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = Result::<Page<S>, AddressNotAligned>::Err(const AddressNotAligned);
        goto -> bb5;
    }

    bb4: {
        _0 = Result::<Page<S>, AddressNotAligned>::Ok(move _3);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::from_start_address_unchecked(_1: addr::VirtAddr) -> Page<S> {
    debug start_address => _1;
    let mut _0: structures::paging::page::Page<S>;

    bb0: {
        _0 = Page::<S> { start_address: _1, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::from_start_address_unchecked(_1: addr::VirtAddr) -> Page<S> {
    debug start_address => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;
    let mut _3: core::marker::PhantomData<S>;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = PhantomData::<S>;
        _0 = Page::<S> { start_address: move _2, size: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::containing_address(_1: addr::VirtAddr) -> Page<S> {
    debug address => _1;
    let mut _0: structures::paging::page::Page<S>;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = addr::VirtAddr::align_down::<u64>(_1, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Page::<S> { start_address: move _2, size: const ZeroSized: PhantomData<S> };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::start_address(_1: Page<S>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = (_1.0: addr::VirtAddr);
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::start_address(_1: Page<S>) -> addr::VirtAddr {
    debug self => _1;
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = (_1.0: addr::VirtAddr);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::size(_1: Page<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::size(_1: Page<S>) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::p4_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p4_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::p4_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p4_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::p3_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p3_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::p3_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p3_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::page_table_index(_1: Page<S>, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: addr::VirtAddr;

    bb0: {
        _3 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::page_table_index(move _3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::page_table_index(_1: Page<S>, _2: PageTableLevel) -> PageTableIndex {
    debug self => _1;
    debug level => _2;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<S>;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        ConstEvalCounter;
        _3 = Page::<S>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _0 = addr::VirtAddr::page_table_index(move _3, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::range(_1: Page<S>, _2: Page<S>) -> PageRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRange<S>;

    bb0: {
        _0 = PageRange::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::range(_1: Page<S>, _2: Page<S>) -> PageRange<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRange<S>;
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PageRange::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::range_inclusive(_1: Page<S>, _2: Page<S>) -> PageRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;

    bb0: {
        _0 = PageRangeInclusive::<S> { start: _1, end: _2 };
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::range_inclusive(_1: Page<S>, _2: Page<S>) -> PageRangeInclusive<S> {
    debug start => _1;
    debug end => _2;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        _0 = PageRangeInclusive::<S> { start: move _3, end: move _4 };
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::steps_between_impl(_1: &Page<S>, _2: &Page<S>) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;
    let mut _3: core::option::Option<usize>;
    let _4: &addr::VirtAddr;
    let _5: &addr::VirtAddr;

    bb0: {
        _4 = &((*_1).0: addr::VirtAddr);
        _5 = &((*_2).0: addr::VirtAddr);
        _3 = addr::VirtAddr::steps_between_impl(_4, _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Option::<usize>::map::<usize, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:155:18: 155:25}>(move _3, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:155:18: 155:25}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::steps_between_impl::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:155:18: 155:25}, _2: usize) -> usize {
    debug steps => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const _ as usize (IntToInt);
        _4 = Eq(_3, const 0_usize);
        assert(!move _4, "attempt to divide `{}` by zero", _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Div(_2, move _3);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:65:1: 65:26>::forward_checked_impl(_1: Page<S>, _2: usize) -> Option<Page<S>> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;
    let mut _4: core::option::Option<usize>;
    let mut _5: usize;
    let mut _6: isize;
    let _7: usize;
    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, addr::VirtAddr>;
    let mut _9: core::option::Option<addr::VirtAddr>;
    let mut _10: addr::VirtAddr;
    let mut _11: isize;
    let mut _13: structures::paging::page::Page<S>;
    scope 1 {
        debug count => _7;
        let _12: addr::VirtAddr;
        scope 6 {
            debug start_address => _12;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = const _ as usize (IntToInt);
        _4 = core::num::<impl usize>::checked_mul(_2, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <Option<usize> as Try>::branch(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb4, otherwise: bb10];
    }

    bb3: {
        _7 = ((_3 as Continue).0: usize);
        _10 = (_1.0: addr::VirtAddr);
        _9 = addr::VirtAddr::forward_checked_impl(move _10, _7) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb9, unwind unreachable];
    }

    bb5: {
        _8 = <Option<addr::VirtAddr> as Try>::branch(move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb7, 1: bb8, otherwise: bb10];
    }

    bb7: {
        _12 = ((_8 as Continue).0: addr::VirtAddr);
        _13 = Page::<S> { start_address: _12, size: const ZeroSized: PhantomData<S> };
        _0 = Option::<Page<S>>::Some(move _13);
        goto -> bb9;
    }

    bb8: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }

    bb10: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:169:1: 169:34>::p2_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = addr::VirtAddr::p2_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:169:1: 169:34>::p2_index(_1: Page<S>) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;
    let mut _3: structures::paging::page::Page<S>;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        ConstEvalCounter;
        _2 = Page::<S>::start_address(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p2_index(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:178:1: 178:20>::from_page_table_indices_1gib(_1: PageTableIndex, _2: PageTableIndex) -> Page<page::Size1GiB> {
    debug p4_index => _1;
    debug p3_index => _2;
    let mut _0: structures::paging::page::Page<structures::paging::page::Size1GiB>;
    let mut _3: u64;
    let _4: &mut u64;
    let mut _5: &mut u64;
    let mut _6: core::ops::Range<usize>;
    let mut _7: u64;
    let _8: &mut u64;
    let mut _9: &mut u64;
    let mut _10: core::ops::Range<usize>;
    let mut _11: u64;
    let mut _12: addr::VirtAddr;
    let mut _13: u64;
    scope 1 {
        debug addr => _3;
    }

    bb0: {
        _3 = const 0_u64;
        _5 = &mut _3;
        _6 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _7 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as BitField>::set_bits::<Range<usize>>(move _5, move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &mut _3;
        _10 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _11 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = <u64 as BitField>::set_bits::<Range<usize>>(move _9, move _10, move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = _3;
        _12 = addr::VirtAddr::new(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _0 = Page::<page::Size1GiB>::containing_address(move _12) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:194:1: 194:20>::from_page_table_indices_2mib(_1: PageTableIndex, _2: PageTableIndex, _3: PageTableIndex) -> Page<page::Size2MiB> {
    debug p4_index => _1;
    debug p3_index => _2;
    debug p2_index => _3;
    let mut _0: structures::paging::page::Page<structures::paging::page::Size2MiB>;
    let mut _4: u64;
    let _5: &mut u64;
    let mut _6: &mut u64;
    let mut _7: core::ops::Range<usize>;
    let mut _8: u64;
    let _9: &mut u64;
    let mut _10: &mut u64;
    let mut _11: core::ops::Range<usize>;
    let mut _12: u64;
    let _13: &mut u64;
    let mut _14: &mut u64;
    let mut _15: core::ops::Range<usize>;
    let mut _16: u64;
    let mut _17: addr::VirtAddr;
    let mut _18: u64;
    scope 1 {
        debug addr => _4;
    }

    bb0: {
        _4 = const 0_u64;
        _6 = &mut _4;
        _7 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _8 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <u64 as BitField>::set_bits::<Range<usize>>(move _6, move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = &mut _4;
        _11 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _12 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = <u64 as BitField>::set_bits::<Range<usize>>(move _10, move _11, move _12) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _14 = &mut _4;
        _15 = Range::<usize> { start: const 21_usize, end: const 30_usize };
        _16 = <u64 as From<PageTableIndex>>::from(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = <u64 as BitField>::set_bits::<Range<usize>>(move _14, move _15, move _16) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _18 = _4;
        _17 = addr::VirtAddr::new(move _18) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Page::<page::Size2MiB>::containing_address(move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:212:1: 212:20>::from_page_table_indices(_1: PageTableIndex, _2: PageTableIndex, _3: PageTableIndex, _4: PageTableIndex) -> Page {
    debug p4_index => _1;
    debug p3_index => _2;
    debug p2_index => _3;
    debug p1_index => _4;
    let mut _0: structures::paging::page::Page;
    let mut _5: u64;
    let _6: &mut u64;
    let mut _7: &mut u64;
    let mut _8: core::ops::Range<usize>;
    let mut _9: u64;
    let _10: &mut u64;
    let mut _11: &mut u64;
    let mut _12: core::ops::Range<usize>;
    let mut _13: u64;
    let _14: &mut u64;
    let mut _15: &mut u64;
    let mut _16: core::ops::Range<usize>;
    let mut _17: u64;
    let _18: &mut u64;
    let mut _19: &mut u64;
    let mut _20: core::ops::Range<usize>;
    let mut _21: u64;
    let mut _22: addr::VirtAddr;
    let mut _23: u64;
    scope 1 {
        debug addr => _5;
    }

    bb0: {
        _5 = const 0_u64;
        _7 = &mut _5;
        _8 = Range::<usize> { start: const 39_usize, end: const 48_usize };
        _9 = <u64 as From<PageTableIndex>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = <u64 as BitField>::set_bits::<Range<usize>>(move _7, move _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = &mut _5;
        _12 = Range::<usize> { start: const 30_usize, end: const 39_usize };
        _13 = <u64 as From<PageTableIndex>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = <u64 as BitField>::set_bits::<Range<usize>>(move _11, move _12, move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &mut _5;
        _16 = Range::<usize> { start: const 21_usize, end: const 30_usize };
        _17 = <u64 as From<PageTableIndex>>::from(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = <u64 as BitField>::set_bits::<Range<usize>>(move _15, move _16, move _17) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _19 = &mut _5;
        _20 = Range::<usize> { start: const 12_usize, end: const 21_usize };
        _21 = <u64 as From<PageTableIndex>>::from(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _18 = <u64 as BitField>::set_bits::<Range<usize>>(move _19, move _20, move _21) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _23 = _5;
        _22 = addr::VirtAddr::new(move _23) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = Page::containing_address(move _22) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:212:1: 212:20>::p1_index(_1: Page) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        _2 = (_1.0: addr::VirtAddr);
        _0 = addr::VirtAddr::p1_index(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:212:1: 212:20>::p1_index(_1: Page) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: addr::VirtAddr;

    bb0: {
        StorageLive(_2);
        _2 = (_1.0: addr::VirtAddr);
        ConstEvalCounter;
        _0 = addr::VirtAddr::p1_index(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:238:1: 238:41>::fmt(_1: &Page<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &u64;
    let _11: u64;
    let mut _12: addr::VirtAddr;
    let mut _13: structures::paging::page::Page<S>;
    let mut _14: &[core::fmt::rt::Placeholder];
    let _15: &[core::fmt::rt::Placeholder; 2];
    let _16: [core::fmt::rt::Placeholder; 2];
    let mut _17: core::fmt::rt::Placeholder;
    let mut _18: core::fmt::rt::Alignment;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::Count;
    let mut _21: core::fmt::rt::Placeholder;
    let mut _22: core::fmt::rt::Alignment;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::Count;
    let mut _25: core::fmt::rt::UnsafeArg;
    let mut _26: &&str;
    let mut _27: &[&str; 3];
    scope 1 {
    }

    bb0: {
        _27 = const _;
        _4 = _27 as &[&str] (PointerCoercion(Unsize));
        _26 = const _;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_26) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _13 = (*_1);
        _12 = Page::<S>::start_address(move _13) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = addr::VirtAddr::as_u64(move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = [move _8, move _9];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = core::fmt::rt::Alignment::Unknown;
        _19 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Count::Implied;
        _17 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _18, const 0_u32, move _19, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = core::fmt::rt::Alignment::Unknown;
        _23 = core::fmt::rt::Count::Implied;
        _24 = core::fmt::rt::Count::Implied;
        _21 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _22, const 4_u32, move _23, move _24) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _16 = [move _17, move _21];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::UnsafeArg::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _14, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:238:1: 238:41>::fmt: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:238:1: 238:41>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Page[", const "](", const ")"];
        _0 = &_1;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:248:1: 248:39>::add(_1: Page<S>, _2: u64) -> Page<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::page::Page<S>;
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <addr::VirtAddr as Add<u64>>::add(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:256:1: 256:45>::add_assign(_1: &mut Page<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (*_1);
        _3 = <Page<S> as Add<u64>>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:263:1: 263:39>::sub(_1: Page<S>, _2: u64) -> Page<S> {
    debug self => _1;
    debug rhs => _2;
    let mut _0: structures::paging::page::Page<S>;
    let mut _3: addr::VirtAddr;
    let mut _4: addr::VirtAddr;
    let mut _5: u64;
    let mut _6: (u64, bool);

    bb0: {
        _4 = Page::<S>::start_address(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = CheckedMul(_2, const _);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", _2, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move (_6.0: u64);
        _3 = <addr::VirtAddr as Sub<u64>>::sub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Page::<S>::containing_address(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:271:1: 271:45>::sub_assign(_1: &mut Page<S>, _2: u64) -> () {
    debug self => _1;
    debug rhs => _2;
    let mut _0: ();
    let mut _3: structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;

    bb0: {
        _4 = (*_1);
        _3 = <Page<S> as Sub<u64>>::sub(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        (*_1) = move _3;
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:278:1: 278:40>::sub(_1: Page<S>, _2: Page<S>) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: addr::VirtAddr;
    let mut _5: addr::VirtAddr;
    let mut _6: bool;

    bb0: {
        _4 = (_1.0: addr::VirtAddr);
        _5 = (_2.0: addr::VirtAddr);
        _3 = <addr::VirtAddr as Sub>::sub(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Eq(const _, const 0_u64);
        assert(!move _6, "attempt to divide `{}` by zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Div(move _3, const _);
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:287:1: 287:35>::steps_between(_1: &Page<S>, _2: &Page<S>) -> Option<usize> {
    debug start => _1;
    debug end => _2;
    let mut _0: core::option::Option<usize>;

    bb0: {
        _0 = Page::<S>::steps_between_impl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:287:1: 287:35>::forward_checked(_1: Page<S>, _2: usize) -> Option<Page<S>> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;

    bb0: {
        _0 = Page::<S>::forward_checked_impl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:287:1: 287:35>::backward_checked(_1: Page<S>, _2: usize) -> Option<Page<S>> {
    debug start => _1;
    debug count => _2;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;
    let mut _4: core::option::Option<usize>;
    let mut _5: usize;
    let mut _6: isize;
    let _7: usize;
    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, addr::VirtAddr>;
    let mut _9: core::option::Option<addr::VirtAddr>;
    let mut _10: addr::VirtAddr;
    let mut _11: isize;
    let mut _13: structures::paging::page::Page<S>;
    scope 1 {
        debug count => _7;
        let _12: addr::VirtAddr;
        scope 6 {
            debug start_address => _12;
        }
        scope 7 {
            debug residual => const Option::<Infallible>::None;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = const _ as usize (IntToInt);
        _4 = core::num::<impl usize>::checked_mul(_2, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <Option<usize> as Try>::branch(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb4, otherwise: bb10];
    }

    bb3: {
        _7 = ((_3 as Continue).0: usize);
        _10 = (_1.0: addr::VirtAddr);
        _9 = <addr::VirtAddr as Step>::backward_checked(move _10, _7) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb9, unwind unreachable];
    }

    bb5: {
        _8 = <Option<addr::VirtAddr> as Try>::branch(move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb7, 1: bb8, otherwise: bb10];
    }

    bb7: {
        _12 = ((_8 as Continue).0: addr::VirtAddr);
        _13 = Page::<S> { start_address: _12, size: const ZeroSized: PhantomData<S> };
        _0 = Option::<Page<S>>::Some(move _13);
        goto -> bb9;
    }

    bb8: {
        _0 = <Option<Page<S>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }

    bb10: {
        unreachable;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:307:10: 307:15>::clone(_1: &PageRange<S>) -> PageRange<S> {
    debug self => _1;
    let mut _0: structures::paging::page::PageRange<S>;
    let mut _2: structures::paging::page::Page<S>;
    let _3: &structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _2 = <Page<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _4 = <Page<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PageRange::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:307:23: 307:32>::eq(_1: &PageRange<S>, _2: &PageRange<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page::Page<S>;
    let mut _5: &structures::paging::page::Page<S>;
    let mut _6: &structures::paging::page::Page<S>;
    let mut _7: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &((*_2).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::page::Page<S>);
        _7 = &((*_2).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:307:34: 307:36>::assert_receiver_is_total_eq(_1: &PageRange<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:307:38: 307:42>::hash(_1: &PageRange<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:316:1: 316:31>::is_empty(_1: &PageRange<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page::Page<S>;
    let mut _3: &structures::paging::page::Page<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialOrd>::ge(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:324:1: 324:44>::next(_1: &mut PageRange<S>) -> Option<Page<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::page::Page<S>;
    let mut _4: &structures::paging::page::Page<S>;
    let _5: structures::paging::page::Page<S>;
    let _6: ();
    let mut _7: &mut structures::paging::page::Page<S>;
    scope 1 {
        debug page => _5;
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _4 = &((*_1).1: structures::paging::page::Page<S>);
        _2 = <Page<S> as PartialOrd>::lt(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::page::Page<S>);
        _7 = &mut ((*_1).0: structures::paging::page::Page<S>);
        _6 = <Page<S> as AddAssign<u64>>::add_assign(move _7, const 1_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<Page<S>>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<Page<S>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:339:1: 339:25>::as_4kib_page_range(_1: PageRange<page::Size2MiB>) -> PageRange {
    debug self => _1;
    let mut _0: structures::paging::page::PageRange;
    let mut _2: structures::paging::page::Page;
    let mut _3: addr::VirtAddr;
    let mut _4: structures::paging::page::Page<structures::paging::page::Size2MiB>;
    let mut _5: structures::paging::page::Page;
    let mut _6: addr::VirtAddr;
    let mut _7: structures::paging::page::Page<structures::paging::page::Size2MiB>;

    bb0: {
        _4 = (_1.0: structures::paging::page::Page<structures::paging::page::Size2MiB>);
        _3 = Page::<page::Size2MiB>::start_address(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Page::containing_address(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = (_1.1: structures::paging::page::Page<structures::paging::page::Size2MiB>);
        _6 = Page::<page::Size2MiB>::start_address(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Page::containing_address(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = PageRange { start: move _2, end: move _5 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:350:1: 350:46>::fmt(_1: &PageRange<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::page::Page<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::page::Page<S>;

    bb0: {
        _7 = const "PageRange";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::page::Page<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::page::Page<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:360:10: 360:15>::clone(_1: &PageRangeInclusive<S>) -> PageRangeInclusive<S> {
    debug self => _1;
    let mut _0: structures::paging::page::PageRangeInclusive<S>;
    let mut _2: structures::paging::page::Page<S>;
    let _3: &structures::paging::page::Page<S>;
    let mut _4: structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _2 = <Page<S> as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _4 = <Page<S> as Clone>::clone(_5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = PageRangeInclusive::<S> { start: move _2, end: move _4 };
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:360:23: 360:32>::eq(_1: &PageRangeInclusive<S>, _2: &PageRangeInclusive<S>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &structures::paging::page::Page<S>;
    let mut _5: &structures::paging::page::Page<S>;
    let mut _6: &structures::paging::page::Page<S>;
    let mut _7: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _5 = &((*_2).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: structures::paging::page::Page<S>);
        _7 = &((*_2).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:360:34: 360:36>::assert_receiver_is_total_eq(_1: &PageRangeInclusive<S>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:360:38: 360:42>::hash(_1: &PageRangeInclusive<S>, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: ();
    let _4: &structures::paging::page::Page<S>;
    let _5: &structures::paging::page::Page<S>;

    bb0: {
        _4 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = <Page<S> as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as Hash>::hash::<__H>(_5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:369:1: 369:40>::is_empty(_1: &PageRangeInclusive<S>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page::Page<S>;
    let mut _3: &structures::paging::page::Page<S>;

    bb0: {
        _2 = &((*_1).0: structures::paging::page::Page<S>);
        _3 = &((*_1).1: structures::paging::page::Page<S>);
        _0 = <Page<S> as PartialOrd>::gt(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:377:1: 377:53>::next(_1: &mut PageRangeInclusive<S>) -> Option<Page<S>> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page::Page<S>>;
    let mut _2: bool;
    let mut _3: &structures::paging::page::Page<S>;
    let mut _4: &structures::paging::page::Page<S>;
    let _5: structures::paging::page::Page<S>;
    let mut _7: addr::VirtAddr;
    let mut _8: u64;
    let mut _9: (u64, bool);
    let mut _10: bool;
    let mut _11: &addr::VirtAddr;
    let _12: addr::VirtAddr;
    let mut _13: structures::paging::page::Page<S>;
    let mut _14: &addr::VirtAddr;
    let _15: ();
    let mut _16: &mut structures::paging::page::Page<S>;
    let _17: ();
    let mut _18: &mut structures::paging::page::Page<S>;
    scope 1 {
        debug page => _5;
        let _6: addr::VirtAddr;
        scope 2 {
            debug max_page_addr => _6;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page::Page<S>);
        _4 = &((*_1).1: structures::paging::page::Page<S>);
        _2 = <Page<S> as PartialOrd>::le(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _2) -> [0: bb11, otherwise: bb2];
    }

    bb2: {
        _5 = ((*_1).0: structures::paging::page::Page<S>);
        _7 = addr::VirtAddr::new(const _) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = CheckedSub(const _, const 1_u64);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_9.0: u64);
        _6 = <addr::VirtAddr as Sub<u64>>::sub(move _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = ((*_1).0: structures::paging::page::Page<S>);
        _12 = Page::<S>::start_address(move _13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = &_12;
        _14 = &_6;
        _10 = <addr::VirtAddr as PartialOrd>::lt(move _11, move _14) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _10) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _16 = &mut ((*_1).0: structures::paging::page::Page<S>);
        _15 = <Page<S> as AddAssign<u64>>::add_assign(move _16, const 1_u64) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _18 = &mut ((*_1).1: structures::paging::page::Page<S>);
        _17 = <Page<S> as SubAssign<u64>>::sub_assign(move _18, const 1_u64) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = Option::<Page<S>>::Some(_5);
        goto -> bb12;
    }

    bb11: {
        _0 = Option::<Page<S>>::None;
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:401:1: 401:55>::fmt(_1: &PageRangeInclusive<S>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &structures::paging::page::Page<S>;
    let _11: &str;
    let mut _12: &dyn core::fmt::Debug;
    let _13: &structures::paging::page::Page<S>;

    bb0: {
        _7 = const "PageRangeInclusive";
        _6 = Formatter::<'_>::debug_struct(_2, _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut _6;
        _8 = const "start";
        _10 = &((*_1).0: structures::paging::page::Page<S>);
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(move _5, _8, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const "end";
        _13 = &((*_1).1: structures::paging::page::Page<S>);
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _11, move _12) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:411:10: 411:15>::fmt(_1: &AddressNotAligned, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "AddressNotAligned";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:414:1: 414:40>::fmt(_1: &AddressNotAligned, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];

    bb0: {
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in page::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page.rs:414:1: 414:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "the given address was not sufficiently aligned"];
        _0 = &_1;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:12:10: 12:15>::fmt(_1: &FrameError, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb1, otherwise: bb5];
    }

    bb1: {
        _6 = const "HugeFrame";
        _3 = _6;
        goto -> bb3;
    }

    bb2: {
        _5 = const "FrameNotPresent";
        _3 = _5;
        goto -> bb3;
    }

    bb3: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:12:17: 12:22>::clone(_1: &FrameError) -> FrameError {
    debug self => _1;
    let mut _0: structures::paging::page_table::FrameError;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:12:30: 12:39>::eq(_1: &FrameError, _2: &FrameError) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:22:10: 22:15>::clone(_1: &PageTableEntry) -> PageTableEntry {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableEntry;
    let mut _2: u64;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _2 = (*_3);
        _0 = PageTableEntry { entry: move _2 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::new() -> PageTableEntry {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        _0 = PageTableEntry { entry: const 0_u64 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::new() -> PageTableEntry {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        _0 = PageTableEntry { entry: const 0_u64 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::is_unused(_1: &PageTableEntry) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::is_unused(_1: &PageTableEntry) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = ((*_1).0: u64);
        _0 = Eq(move _2, const 0_u64);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::set_unused(_1: &mut PageTableEntry) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        ((*_1).0: u64) = const 0_u64;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::flags(_1: &PageTableEntry) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _0 = page_table::_::<impl PageTableFlags>::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::flags(_1: &PageTableEntry) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = ((*_1).0: u64);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_truncate(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::addr(_1: &PageTableEntry) -> PhysAddr {
    debug self => _1;
    let mut _0: addr::PhysAddr;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _2 = BitAnd(move _3, const 4503599627366400_u64);
        _0 = PhysAddr::new(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::frame(_1: &PageTableEntry) -> Result<PhysFrame, FrameError> {
    debug self => _1;
    let mut _0: core::result::Result<structures::paging::frame::PhysFrame, structures::paging::page_table::FrameError>;
    let mut _2: bool;
    let mut _3: &structures::paging::page_table::PageTableFlags;
    let _4: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::FrameError;
    let mut _6: bool;
    let mut _7: &structures::paging::page_table::PageTableFlags;
    let _8: structures::paging::page_table::PageTableFlags;
    let mut _9: structures::paging::page_table::FrameError;
    let mut _10: structures::paging::frame::PhysFrame;
    let mut _11: addr::PhysAddr;

    bb0: {
        _4 = PageTableEntry::flags(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &_4;
        _2 = page_table::_::<impl PageTableFlags>::contains(move _3, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _8 = PageTableEntry::flags(_1) -> [return: bb5, unwind unreachable];
    }

    bb4: {
        _5 = FrameError::FrameNotPresent;
        _0 = Result::<PhysFrame, FrameError>::Err(move _5);
        goto -> bb11;
    }

    bb5: {
        _7 = &_8;
        _6 = page_table::_::<impl PageTableFlags>::contains(move _7, const _) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(move _6) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _9 = FrameError::HugeFrame;
        _0 = Result::<PhysFrame, FrameError>::Err(move _9);
        goto -> bb11;
    }

    bb8: {
        _11 = PageTableEntry::addr(_1) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _10 = PhysFrame::containing_address(move _11) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = Result::<PhysFrame, FrameError>::Ok(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::set_addr(_1: &mut PageTableEntry, _2: PhysAddr, _3: PageTableFlags) -> () {
    debug self => _1;
    debug addr => _2;
    debug flags => _3;
    let mut _0: ();
    let mut _4: bool;
    let mut _5: !;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _4 = PhysAddr::is_aligned::<u64>(_2, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = PhysAddr::as_u64(_2) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _5 = panic(const "assertion failed: addr.is_aligned(Size4KiB::SIZE)") -> unwind unreachable;
    }

    bb4: {
        _8 = &_3;
        _7 = page_table::_::<impl PageTableFlags>::bits(move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        ((*_1).0: u64) = BitOr(move _6, move _7);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::set_frame(_1: &mut PageTableEntry, _2: PhysFrame, _3: PageTableFlags) -> () {
    debug self => _1;
    debug frame => _2;
    debug flags => _3;
    let mut _0: ();
    let mut _4: bool;
    let mut _5: &structures::paging::page_table::PageTableFlags;
    let mut _6: !;
    let mut _7: addr::PhysAddr;
    let mut _8: structures::paging::page_table::PageTableFlags;

    bb0: {
        _5 = &_3;
        _4 = page_table::_::<impl PageTableFlags>::contains(move _5, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = panic(const "assertion failed: !flags.contains(PageTableFlags::HUGE_PAGE)") -> unwind unreachable;
    }

    bb3: {
        _7 = PhysFrame::start_address(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = _3;
        _0 = PageTableEntry::set_addr(_1, move _7, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:28:1: 28:20>::set_flags(_1: &mut PageTableEntry, _2: PageTableFlags) -> () {
    debug self => _1;
    debug flags => _2;
    let mut _0: ();
    let mut _3: u64;
    let mut _4: addr::PhysAddr;
    let mut _5: &structures::paging::page_table::PageTableEntry;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _5 = &(*_1);
        _4 = PageTableEntry::addr(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = PhysAddr::as_u64(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = &_2;
        _6 = page_table::_::<impl PageTableFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        ((*_1).0: u64) = BitOr(move _3, move _6);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:98:1: 98:35>::fmt(_1: &PageTableEntry, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::DebugStruct<'_, '_>;
    let _4: &str;
    let _5: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &addr::PhysAddr;
    let _10: addr::PhysAddr;
    let _11: &mut core::fmt::DebugStruct<'_, '_>;
    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &structures::paging::page_table::PageTableFlags;
    let _16: structures::paging::page_table::PageTableFlags;
    let mut _17: &mut core::fmt::DebugStruct<'_, '_>;
    scope 1 {
        debug f => _3;
    }

    bb0: {
        _4 = const "PageTableEntry";
        _3 = Formatter::<'_>::debug_struct(_2, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &mut _3;
        _7 = const "addr";
        _10 = PageTableEntry::addr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _7, move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &mut _3;
        _13 = const "flags";
        _16 = PageTableEntry::flags(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = DebugStruct::<'_, '_>::field(move _12, _13, move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _17 = &mut _3;
        _0 = DebugStruct::<'_, '_>::finish(move _17) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:14: 109:23>::eq(_1: &PageTableFlags, _2: &PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:25: 109:27>::assert_receiver_is_total_eq(_1: &PageTableFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:29: 109:39>::partial_cmp(_1: &PageTableFlags, _2: &PageTableFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &structures::paging::page_table::_::InternalBitFlags;
    let _4: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:41: 109:44>::cmp(_1: &PageTableFlags, _2: &PageTableFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &structures::paging::page_table::_::InternalBitFlags;
    let _4: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:46: 109:50>::hash(_1: &PageTableFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:52: 109:57>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&structures::paging::page_table::_::InternalBitFlags;
    let _6: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = const "PageTableFlags";
        _6 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:109:59: 109:64>::clone(_1: &PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::PRESENT: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(const 1_u64) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::WRITABLE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 1_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 1_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::USER_ACCESSIBLE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 2_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 2_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::WRITE_THROUGH: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 3_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 3_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NO_CACHE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 4_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 4_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::ACCESSED: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 5_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 5_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::DIRTY: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 6_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 6_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 6_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::HUGE_PAGE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 7_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 7_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 7_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::GLOBAL: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 8_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 8_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_9: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 9_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 9_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_10: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 10_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 10_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 10_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_11: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 11_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 11_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_52: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 52_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 52_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_53: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 53_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 53_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_54: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 54_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 54_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 54_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_55: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 55_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 55_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 55_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_56: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 56_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 56_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 56_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_57: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 57_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 57_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 57_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_58: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 58_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 58_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 58_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_59: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 59_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 59_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 59_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_60: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 60_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 60_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 60_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_61: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 61_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 61_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 61_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::BIT_62: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 62_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 62_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 62_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:482:9: 482:29>::NO_EXECUTE: PageTableFlags = {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: u64;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = const 63_i32 as u32 (IntToInt);
        _3 = Lt(move _2, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const 63_i32);
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<PageTableFlags>] = {
    let mut _0: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let mut _1: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    let _2: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    let _3: [bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    let mut _4: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _5: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _6: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _7: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _8: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _9: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _10: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _11: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _12: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _13: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _14: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _15: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _16: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _17: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _18: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _19: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _20: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _21: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _22: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _23: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _24: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _25: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _26: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _27: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _28: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
    }
    scope 4 {
    }
    scope 5 {
    }
    scope 6 {
    }
    scope 7 {
    }
    scope 8 {
    }
    scope 9 {
    }
    scope 10 {
    }
    scope 11 {
    }
    scope 12 {
    }
    scope 13 {
    }
    scope 14 {
    }
    scope 15 {
    }
    scope 16 {
    }
    scope 17 {
    }
    scope 18 {
    }
    scope 19 {
    }
    scope 20 {
    }
    scope 21 {
    }
    scope 22 {
    }
    scope 23 {
    }
    scope 24 {
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _28 = const _;
        _2 = &(*_28);
        _1 = &(*_2);
        _0 = move _1 as &[bitflags::Flag<structures::paging::page_table::PageTableFlags>] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::FLAGS: &[Flag<PageTableFlags>; 24] = {
    let mut _0: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    let mut _1: [bitflags::Flag<structures::paging::page_table::PageTableFlags>; 24];
    let mut _2: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _3: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _4: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _5: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _6: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _7: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _8: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _9: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _10: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _11: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _12: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _13: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _14: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _15: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _16: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _17: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _18: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _19: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _20: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _21: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _22: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _23: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _24: bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let mut _25: bitflags::Flag<structures::paging::page_table::PageTableFlags>;

    bb0: {
        _2 = Flag::<PageTableFlags>::new(const "PRESENT", const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Flag::<PageTableFlags>::new(const "WRITABLE", const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Flag::<PageTableFlags>::new(const "USER_ACCESSIBLE", const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Flag::<PageTableFlags>::new(const "WRITE_THROUGH", const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Flag::<PageTableFlags>::new(const "NO_CACHE", const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Flag::<PageTableFlags>::new(const "ACCESSED", const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Flag::<PageTableFlags>::new(const "DIRTY", const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Flag::<PageTableFlags>::new(const "HUGE_PAGE", const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Flag::<PageTableFlags>::new(const "GLOBAL", const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Flag::<PageTableFlags>::new(const "BIT_9", const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Flag::<PageTableFlags>::new(const "BIT_10", const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Flag::<PageTableFlags>::new(const "BIT_11", const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Flag::<PageTableFlags>::new(const "BIT_52", const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Flag::<PageTableFlags>::new(const "BIT_53", const _) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Flag::<PageTableFlags>::new(const "BIT_54", const _) -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = Flag::<PageTableFlags>::new(const "BIT_55", const _) -> [return: bb16, unwind continue];
    }

    bb16: {
        _18 = Flag::<PageTableFlags>::new(const "BIT_56", const _) -> [return: bb17, unwind continue];
    }

    bb17: {
        _19 = Flag::<PageTableFlags>::new(const "BIT_57", const _) -> [return: bb18, unwind continue];
    }

    bb18: {
        _20 = Flag::<PageTableFlags>::new(const "BIT_58", const _) -> [return: bb19, unwind continue];
    }

    bb19: {
        _21 = Flag::<PageTableFlags>::new(const "BIT_59", const _) -> [return: bb20, unwind continue];
    }

    bb20: {
        _22 = Flag::<PageTableFlags>::new(const "BIT_60", const _) -> [return: bb21, unwind continue];
    }

    bb21: {
        _23 = Flag::<PageTableFlags>::new(const "BIT_61", const _) -> [return: bb22, unwind continue];
    }

    bb22: {
        _24 = Flag::<PageTableFlags>::new(const "BIT_62", const _) -> [return: bb23, unwind continue];
    }

    bb23: {
        _25 = Flag::<PageTableFlags>::new(const "NO_EXECUTE", const _) -> [return: bb24, unwind continue];
    }

    bb24: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _15, move _16, move _17, move _18, move _19, move _20, move _21, move _22, move _23, move _24, move _25];
        _0 = &_1;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::bits(_1: &PageTableFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:499:9: 499:47>::from_bits_retain(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const page_table::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:18: 18:23>::clone(_1: &page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:31: 18:40>::eq(_1: &page_table::_::InternalBitFlags, _2: &page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = ((*_1).0: u64);
        _4 = ((*_2).0: u64);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:42: 18:44>::assert_receiver_is_total_eq(_1: &page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:46: 18:56>::partial_cmp(_1: &page_table::_::InternalBitFlags, _2: &page_table::_::InternalBitFlags) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:58: 18:61>::cmp(_1: &page_table::_::InternalBitFlags, _2: &page_table::_::InternalBitFlags) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u64;
    let _4: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _4 = &((*_2).0: u64);
        _0 = <u64 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:18:63: 18:67>::hash(_1: &page_table::_::InternalBitFlags, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:47:9: 47:77>::default() -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: bool;
    let mut _4: core::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: &u64;
    let mut _19: &[&str; 1];
    scope 1 {
    }

    bb0: {
        _3 = page_table::_::InternalBitFlags::is_empty(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _19 = const _;
        _5 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = const _;
        _9 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_18) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Unknown;
        _15 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Count::Implied;
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 4_u32, move _15, move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _0 = <page_table::_::InternalBitFlags as Display>::fmt(_1, _2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

promoted[0] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &u64 = {
    let mut _0: &u64;
    let mut _1: u64;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:54:9: 54:71>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:72:9: 72:73>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::paging::page_table::PageTableFlags;
    let _4: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _5 = (*_1);
        _4 = PageTableFlags(move _5);
        _3 = &_4;
        _0 = to_writer::<PageTableFlags, &mut Formatter<'_>>(_3, move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str(_1: &str) -> Result<page_table::_::InternalBitFlags, ParseError> {
    debug s => _1;
    let mut _0: core::result::Result<structures::paging::page_table::_::InternalBitFlags, bitflags::parser::ParseError>;
    let mut _2: core::result::Result<structures::paging::page_table::PageTableFlags, bitflags::parser::ParseError>;

    bb0: {
        _2 = bitflags::parser::from_str::<PageTableFlags>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Result::<PageTableFlags, ParseError>::map::<page_table::_::InternalBitFlags, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:78:9: 78:73>::from_str::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:82:68: 82:75}, _2: PageTableFlags) -> page_table::_::InternalBitFlags {
    debug flags => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:86:9: 86:79>::as_ref(_1: &page_table::_::InternalBitFlags) -> &u64 {
    debug self => _1;
    let mut _0: &u64;

    bb0: {
        _0 = &((*_1).0: u64);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:92:9: 92:78>::from(_1: u64) -> page_table::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags(const _);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags(const _);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let mut _1: u64;
    let _4: &structures::paging::page_table::PageTableFlags;
    let mut _5: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _6: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: u64;
    let mut _11: (usize, bool);
    let _13: &structures::paging::page_table::PageTableFlags;
    let mut _14: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _15: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: (usize, bool);
    let _22: &structures::paging::page_table::PageTableFlags;
    let mut _23: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _24: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: u64;
    let mut _29: (usize, bool);
    let _31: &structures::paging::page_table::PageTableFlags;
    let mut _32: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _33: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _40: &structures::paging::page_table::PageTableFlags;
    let mut _41: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _42: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: u64;
    let mut _47: (usize, bool);
    let _49: &structures::paging::page_table::PageTableFlags;
    let mut _50: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _51: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: u64;
    let mut _56: (usize, bool);
    let _58: &structures::paging::page_table::PageTableFlags;
    let mut _59: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _60: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: (usize, bool);
    let _67: &structures::paging::page_table::PageTableFlags;
    let mut _68: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _69: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _76: &structures::paging::page_table::PageTableFlags;
    let mut _77: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _78: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _79: usize;
    let mut _80: usize;
    let mut _81: bool;
    let mut _82: u64;
    let mut _83: (usize, bool);
    let _85: &structures::paging::page_table::PageTableFlags;
    let mut _86: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _87: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: (usize, bool);
    let _94: &structures::paging::page_table::PageTableFlags;
    let mut _95: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _96: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: u64;
    let mut _101: (usize, bool);
    let _103: &structures::paging::page_table::PageTableFlags;
    let mut _104: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _105: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _106: usize;
    let mut _107: usize;
    let mut _108: bool;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _112: &structures::paging::page_table::PageTableFlags;
    let mut _113: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _114: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: u64;
    let mut _119: (usize, bool);
    let _121: &structures::paging::page_table::PageTableFlags;
    let mut _122: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _123: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _124: usize;
    let mut _125: usize;
    let mut _126: bool;
    let mut _127: u64;
    let mut _128: (usize, bool);
    let _130: &structures::paging::page_table::PageTableFlags;
    let mut _131: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _132: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _133: usize;
    let mut _134: usize;
    let mut _135: bool;
    let mut _136: u64;
    let mut _137: (usize, bool);
    let _139: &structures::paging::page_table::PageTableFlags;
    let mut _140: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _141: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _142: usize;
    let mut _143: usize;
    let mut _144: bool;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _148: &structures::paging::page_table::PageTableFlags;
    let mut _149: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _150: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _151: usize;
    let mut _152: usize;
    let mut _153: bool;
    let mut _154: u64;
    let mut _155: (usize, bool);
    let _157: &structures::paging::page_table::PageTableFlags;
    let mut _158: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _159: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _160: usize;
    let mut _161: usize;
    let mut _162: bool;
    let mut _163: u64;
    let mut _164: (usize, bool);
    let _166: &structures::paging::page_table::PageTableFlags;
    let mut _167: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _168: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _169: usize;
    let mut _170: usize;
    let mut _171: bool;
    let mut _172: u64;
    let mut _173: (usize, bool);
    let _175: &structures::paging::page_table::PageTableFlags;
    let mut _176: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _177: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _178: usize;
    let mut _179: usize;
    let mut _180: bool;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let _184: &structures::paging::page_table::PageTableFlags;
    let mut _185: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _186: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _187: usize;
    let mut _188: usize;
    let mut _189: bool;
    let mut _190: u64;
    let mut _191: (usize, bool);
    let _193: &structures::paging::page_table::PageTableFlags;
    let mut _194: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _195: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _196: usize;
    let mut _197: usize;
    let mut _198: bool;
    let mut _199: u64;
    let mut _200: (usize, bool);
    let _202: &structures::paging::page_table::PageTableFlags;
    let mut _203: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _204: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _205: usize;
    let mut _206: usize;
    let mut _207: bool;
    let mut _208: u64;
    let mut _209: (usize, bool);
    let _211: &structures::paging::page_table::PageTableFlags;
    let mut _212: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _213: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _214: usize;
    let mut _215: usize;
    let mut _216: bool;
    let mut _217: u64;
    let mut _218: (usize, bool);
    let mut _219: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _3: u64;
            let _12: u64;
            let _21: u64;
            let _30: u64;
            let _39: u64;
            let _48: u64;
            let _57: u64;
            let _66: u64;
            let _75: u64;
            let _84: u64;
            let _93: u64;
            let _102: u64;
            let _111: u64;
            let _120: u64;
            let _129: u64;
            let _138: u64;
            let _147: u64;
            let _156: u64;
            let _165: u64;
            let _174: u64;
            let _183: u64;
            let _192: u64;
            let _201: u64;
            let _210: u64;
            scope 3 {
                debug flag => _3;
            }
            scope 4 {
                debug flag => _12;
            }
            scope 5 {
                debug flag => _21;
            }
            scope 6 {
                debug flag => _30;
            }
            scope 7 {
                debug flag => _39;
            }
            scope 8 {
                debug flag => _48;
            }
            scope 9 {
                debug flag => _57;
            }
            scope 10 {
                debug flag => _66;
            }
            scope 11 {
                debug flag => _75;
            }
            scope 12 {
                debug flag => _84;
            }
            scope 13 {
                debug flag => _93;
            }
            scope 14 {
                debug flag => _102;
            }
            scope 15 {
                debug flag => _111;
            }
            scope 16 {
                debug flag => _120;
            }
            scope 17 {
                debug flag => _129;
            }
            scope 18 {
                debug flag => _138;
            }
            scope 19 {
                debug flag => _147;
            }
            scope 20 {
                debug flag => _156;
            }
            scope 21 {
                debug flag => _165;
            }
            scope 22 {
                debug flag => _174;
            }
            scope 23 {
                debug flag => _183;
            }
            scope 24 {
                debug flag => _192;
            }
            scope 25 {
                debug flag => _201;
            }
            scope 26 {
                debug flag => _210;
            }
            scope 27 {
            }
        }
    }

    bb0: {
        _1 = const _;
        _2 = const 0_usize;
        _6 = const _;
        _7 = _2;
        _8 = Len((*_6));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &(*_6)[_7];
        _4 = Flag::<PageTableFlags>::value(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::<impl PageTableFlags>::bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = _1;
        _1 = BitOr(move _10, _3);
        _11 = CheckedAdd(_2, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_11.0: usize);
        _15 = const _;
        _16 = _2;
        _17 = Len((*_15));
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _14 = &(*_15)[_16];
        _13 = Flag::<PageTableFlags>::value(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = page_table::_::<impl PageTableFlags>::bits(_13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = _1;
        _1 = BitOr(move _19, _12);
        _20 = CheckedAdd(_2, const 1_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_20.0: usize);
        _24 = const _;
        _25 = _2;
        _26 = Len((*_24));
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _23 = &(*_24)[_25];
        _22 = Flag::<PageTableFlags>::value(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = page_table::_::<impl PageTableFlags>::bits(_22) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = _1;
        _1 = BitOr(move _28, _21);
        _29 = CheckedAdd(_2, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_29.0: usize);
        _33 = const _;
        _34 = _2;
        _35 = Len((*_33));
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &(*_33)[_34];
        _31 = Flag::<PageTableFlags>::value(move _32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _30 = page_table::_::<impl PageTableFlags>::bits(_31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _37 = _1;
        _1 = BitOr(move _37, _30);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_38.0: usize);
        _42 = const _;
        _43 = _2;
        _44 = Len((*_42));
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = &(*_42)[_43];
        _40 = Flag::<PageTableFlags>::value(move _41) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = page_table::_::<impl PageTableFlags>::bits(_40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _46 = _1;
        _1 = BitOr(move _46, _39);
        _47 = CheckedAdd(_2, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_47.0: usize);
        _51 = const _;
        _52 = _2;
        _53 = Len((*_51));
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = &(*_51)[_52];
        _49 = Flag::<PageTableFlags>::value(move _50) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = page_table::_::<impl PageTableFlags>::bits(_49) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _1;
        _1 = BitOr(move _55, _48);
        _56 = CheckedAdd(_2, const 1_usize);
        assert(!move (_56.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_56.0: usize);
        _60 = const _;
        _61 = _2;
        _62 = Len((*_60));
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _59 = &(*_60)[_61];
        _58 = Flag::<PageTableFlags>::value(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _57 = page_table::_::<impl PageTableFlags>::bits(_58) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _64 = _1;
        _1 = BitOr(move _64, _57);
        _65 = CheckedAdd(_2, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_65.0: usize);
        _69 = const _;
        _70 = _2;
        _71 = Len((*_69));
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _68 = &(*_69)[_70];
        _67 = Flag::<PageTableFlags>::value(move _68) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _66 = page_table::_::<impl PageTableFlags>::bits(_67) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _73 = _1;
        _1 = BitOr(move _73, _66);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_74.0: usize);
        _78 = const _;
        _79 = _2;
        _80 = Len((*_78));
        _81 = Lt(_79, _80);
        assert(move _81, "index out of bounds: the length is {} but the index is {}", move _80, _79) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _77 = &(*_78)[_79];
        _76 = Flag::<PageTableFlags>::value(move _77) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _75 = page_table::_::<impl PageTableFlags>::bits(_76) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _82 = _1;
        _1 = BitOr(move _82, _75);
        _83 = CheckedAdd(_2, const 1_usize);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_83.0: usize);
        _87 = const _;
        _88 = _2;
        _89 = Len((*_87));
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _86 = &(*_87)[_88];
        _85 = Flag::<PageTableFlags>::value(move _86) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _84 = page_table::_::<impl PageTableFlags>::bits(_85) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _91 = _1;
        _1 = BitOr(move _91, _84);
        _92 = CheckedAdd(_2, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_92.0: usize);
        _96 = const _;
        _97 = _2;
        _98 = Len((*_96));
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _95 = &(*_96)[_97];
        _94 = Flag::<PageTableFlags>::value(move _95) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _93 = page_table::_::<impl PageTableFlags>::bits(_94) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _100 = _1;
        _1 = BitOr(move _100, _93);
        _101 = CheckedAdd(_2, const 1_usize);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_101.0: usize);
        _105 = const _;
        _106 = _2;
        _107 = Len((*_105));
        _108 = Lt(_106, _107);
        assert(move _108, "index out of bounds: the length is {} but the index is {}", move _107, _106) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _104 = &(*_105)[_106];
        _103 = Flag::<PageTableFlags>::value(move _104) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _102 = page_table::_::<impl PageTableFlags>::bits(_103) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _109 = _1;
        _1 = BitOr(move _109, _102);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_110.0: usize);
        _114 = const _;
        _115 = _2;
        _116 = Len((*_114));
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _113 = &(*_114)[_115];
        _112 = Flag::<PageTableFlags>::value(move _113) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _111 = page_table::_::<impl PageTableFlags>::bits(_112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _118 = _1;
        _1 = BitOr(move _118, _111);
        _119 = CheckedAdd(_2, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_119.0: usize);
        _123 = const _;
        _124 = _2;
        _125 = Len((*_123));
        _126 = Lt(_124, _125);
        assert(move _126, "index out of bounds: the length is {} but the index is {}", move _125, _124) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _122 = &(*_123)[_124];
        _121 = Flag::<PageTableFlags>::value(move _122) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _120 = page_table::_::<impl PageTableFlags>::bits(_121) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = _1;
        _1 = BitOr(move _127, _120);
        _128 = CheckedAdd(_2, const 1_usize);
        assert(!move (_128.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_128.0: usize);
        _132 = const _;
        _133 = _2;
        _134 = Len((*_132));
        _135 = Lt(_133, _134);
        assert(move _135, "index out of bounds: the length is {} but the index is {}", move _134, _133) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _131 = &(*_132)[_133];
        _130 = Flag::<PageTableFlags>::value(move _131) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _129 = page_table::_::<impl PageTableFlags>::bits(_130) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _136 = _1;
        _1 = BitOr(move _136, _129);
        _137 = CheckedAdd(_2, const 1_usize);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_137.0: usize);
        _141 = const _;
        _142 = _2;
        _143 = Len((*_141));
        _144 = Lt(_142, _143);
        assert(move _144, "index out of bounds: the length is {} but the index is {}", move _143, _142) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _140 = &(*_141)[_142];
        _139 = Flag::<PageTableFlags>::value(move _140) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _138 = page_table::_::<impl PageTableFlags>::bits(_139) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _145 = _1;
        _1 = BitOr(move _145, _138);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_146.0: usize);
        _150 = const _;
        _151 = _2;
        _152 = Len((*_150));
        _153 = Lt(_151, _152);
        assert(move _153, "index out of bounds: the length is {} but the index is {}", move _152, _151) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _149 = &(*_150)[_151];
        _148 = Flag::<PageTableFlags>::value(move _149) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _147 = page_table::_::<impl PageTableFlags>::bits(_148) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _154 = _1;
        _1 = BitOr(move _154, _147);
        _155 = CheckedAdd(_2, const 1_usize);
        assert(!move (_155.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_155.0: usize);
        _159 = const _;
        _160 = _2;
        _161 = Len((*_159));
        _162 = Lt(_160, _161);
        assert(move _162, "index out of bounds: the length is {} but the index is {}", move _161, _160) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _158 = &(*_159)[_160];
        _157 = Flag::<PageTableFlags>::value(move _158) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _156 = page_table::_::<impl PageTableFlags>::bits(_157) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _163 = _1;
        _1 = BitOr(move _163, _156);
        _164 = CheckedAdd(_2, const 1_usize);
        assert(!move (_164.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_164.0: usize);
        _168 = const _;
        _169 = _2;
        _170 = Len((*_168));
        _171 = Lt(_169, _170);
        assert(move _171, "index out of bounds: the length is {} but the index is {}", move _170, _169) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _167 = &(*_168)[_169];
        _166 = Flag::<PageTableFlags>::value(move _167) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _165 = page_table::_::<impl PageTableFlags>::bits(_166) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _172 = _1;
        _1 = BitOr(move _172, _165);
        _173 = CheckedAdd(_2, const 1_usize);
        assert(!move (_173.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _2 = move (_173.0: usize);
        _177 = const _;
        _178 = _2;
        _179 = Len((*_177));
        _180 = Lt(_178, _179);
        assert(move _180, "index out of bounds: the length is {} but the index is {}", move _179, _178) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _176 = &(*_177)[_178];
        _175 = Flag::<PageTableFlags>::value(move _176) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _174 = page_table::_::<impl PageTableFlags>::bits(_175) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _181 = _1;
        _1 = BitOr(move _181, _174);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _2 = move (_182.0: usize);
        _186 = const _;
        _187 = _2;
        _188 = Len((*_186));
        _189 = Lt(_187, _188);
        assert(move _189, "index out of bounds: the length is {} but the index is {}", move _188, _187) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _185 = &(*_186)[_187];
        _184 = Flag::<PageTableFlags>::value(move _185) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _183 = page_table::_::<impl PageTableFlags>::bits(_184) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _190 = _1;
        _1 = BitOr(move _190, _183);
        _191 = CheckedAdd(_2, const 1_usize);
        assert(!move (_191.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _2 = move (_191.0: usize);
        _195 = const _;
        _196 = _2;
        _197 = Len((*_195));
        _198 = Lt(_196, _197);
        assert(move _198, "index out of bounds: the length is {} but the index is {}", move _197, _196) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _194 = &(*_195)[_196];
        _193 = Flag::<PageTableFlags>::value(move _194) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _192 = page_table::_::<impl PageTableFlags>::bits(_193) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _199 = _1;
        _1 = BitOr(move _199, _192);
        _200 = CheckedAdd(_2, const 1_usize);
        assert(!move (_200.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _2 = move (_200.0: usize);
        _204 = const _;
        _205 = _2;
        _206 = Len((*_204));
        _207 = Lt(_205, _206);
        assert(move _207, "index out of bounds: the length is {} but the index is {}", move _206, _205) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _203 = &(*_204)[_205];
        _202 = Flag::<PageTableFlags>::value(move _203) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _201 = page_table::_::<impl PageTableFlags>::bits(_202) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _208 = _1;
        _1 = BitOr(move _208, _201);
        _209 = CheckedAdd(_2, const 1_usize);
        assert(!move (_209.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb92, unwind unreachable];
    }

    bb92: {
        _2 = move (_209.0: usize);
        _213 = const _;
        _214 = _2;
        _215 = Len((*_213));
        _216 = Lt(_214, _215);
        assert(move _216, "index out of bounds: the length is {} but the index is {}", move _215, _214) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _212 = &(*_213)[_214];
        _211 = Flag::<PageTableFlags>::value(move _212) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _210 = page_table::_::<impl PageTableFlags>::bits(_211) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _217 = _1;
        _1 = BitOr(move _217, _210);
        _218 = CheckedAdd(_2, const 1_usize);
        assert(!move (_218.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _2 = move (_218.0: usize);
        _219 = _1;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _219) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let mut _1: u64;
    let _3: ();
    let mut _5: &structures::paging::page_table::PageTableFlags;
    let _6: &structures::paging::page_table::PageTableFlags;
    let mut _7: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _8: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: (usize, bool);
    let _15: ();
    let mut _17: &structures::paging::page_table::PageTableFlags;
    let _18: &structures::paging::page_table::PageTableFlags;
    let mut _19: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _20: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: (usize, bool);
    let _27: ();
    let mut _29: &structures::paging::page_table::PageTableFlags;
    let _30: &structures::paging::page_table::PageTableFlags;
    let mut _31: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _32: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: (usize, bool);
    let _39: ();
    let mut _41: &structures::paging::page_table::PageTableFlags;
    let _42: &structures::paging::page_table::PageTableFlags;
    let mut _43: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _44: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _45: usize;
    let mut _46: usize;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: (usize, bool);
    let _51: ();
    let mut _53: &structures::paging::page_table::PageTableFlags;
    let _54: &structures::paging::page_table::PageTableFlags;
    let mut _55: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _56: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: (usize, bool);
    let _63: ();
    let mut _65: &structures::paging::page_table::PageTableFlags;
    let _66: &structures::paging::page_table::PageTableFlags;
    let mut _67: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _68: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: u64;
    let mut _73: u64;
    let mut _74: (usize, bool);
    let _75: ();
    let mut _77: &structures::paging::page_table::PageTableFlags;
    let _78: &structures::paging::page_table::PageTableFlags;
    let mut _79: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _80: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: u64;
    let mut _85: u64;
    let mut _86: (usize, bool);
    let _87: ();
    let mut _89: &structures::paging::page_table::PageTableFlags;
    let _90: &structures::paging::page_table::PageTableFlags;
    let mut _91: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _92: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _93: usize;
    let mut _94: usize;
    let mut _95: bool;
    let mut _96: u64;
    let mut _97: u64;
    let mut _98: (usize, bool);
    let _99: ();
    let mut _101: &structures::paging::page_table::PageTableFlags;
    let _102: &structures::paging::page_table::PageTableFlags;
    let mut _103: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _104: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _105: usize;
    let mut _106: usize;
    let mut _107: bool;
    let mut _108: u64;
    let mut _109: u64;
    let mut _110: (usize, bool);
    let _111: ();
    let mut _113: &structures::paging::page_table::PageTableFlags;
    let _114: &structures::paging::page_table::PageTableFlags;
    let mut _115: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _116: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _117: usize;
    let mut _118: usize;
    let mut _119: bool;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: (usize, bool);
    let _123: ();
    let mut _125: &structures::paging::page_table::PageTableFlags;
    let _126: &structures::paging::page_table::PageTableFlags;
    let mut _127: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _128: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: u64;
    let mut _133: u64;
    let mut _134: (usize, bool);
    let _135: ();
    let mut _137: &structures::paging::page_table::PageTableFlags;
    let _138: &structures::paging::page_table::PageTableFlags;
    let mut _139: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _140: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _141: usize;
    let mut _142: usize;
    let mut _143: bool;
    let mut _144: u64;
    let mut _145: u64;
    let mut _146: (usize, bool);
    let _147: ();
    let mut _149: &structures::paging::page_table::PageTableFlags;
    let _150: &structures::paging::page_table::PageTableFlags;
    let mut _151: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _152: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _153: usize;
    let mut _154: usize;
    let mut _155: bool;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: (usize, bool);
    let _159: ();
    let mut _161: &structures::paging::page_table::PageTableFlags;
    let _162: &structures::paging::page_table::PageTableFlags;
    let mut _163: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _164: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _165: usize;
    let mut _166: usize;
    let mut _167: bool;
    let mut _168: u64;
    let mut _169: u64;
    let mut _170: (usize, bool);
    let _171: ();
    let mut _173: &structures::paging::page_table::PageTableFlags;
    let _174: &structures::paging::page_table::PageTableFlags;
    let mut _175: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _176: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _177: usize;
    let mut _178: usize;
    let mut _179: bool;
    let mut _180: u64;
    let mut _181: u64;
    let mut _182: (usize, bool);
    let _183: ();
    let mut _185: &structures::paging::page_table::PageTableFlags;
    let _186: &structures::paging::page_table::PageTableFlags;
    let mut _187: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _188: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _189: usize;
    let mut _190: usize;
    let mut _191: bool;
    let mut _192: u64;
    let mut _193: u64;
    let mut _194: (usize, bool);
    let _195: ();
    let mut _197: &structures::paging::page_table::PageTableFlags;
    let _198: &structures::paging::page_table::PageTableFlags;
    let mut _199: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _200: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _201: usize;
    let mut _202: usize;
    let mut _203: bool;
    let mut _204: u64;
    let mut _205: u64;
    let mut _206: (usize, bool);
    let _207: ();
    let mut _209: &structures::paging::page_table::PageTableFlags;
    let _210: &structures::paging::page_table::PageTableFlags;
    let mut _211: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _212: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _213: usize;
    let mut _214: usize;
    let mut _215: bool;
    let mut _216: u64;
    let mut _217: u64;
    let mut _218: (usize, bool);
    let _219: ();
    let mut _221: &structures::paging::page_table::PageTableFlags;
    let _222: &structures::paging::page_table::PageTableFlags;
    let mut _223: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _224: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _225: usize;
    let mut _226: usize;
    let mut _227: bool;
    let mut _228: u64;
    let mut _229: u64;
    let mut _230: (usize, bool);
    let _231: ();
    let mut _233: &structures::paging::page_table::PageTableFlags;
    let _234: &structures::paging::page_table::PageTableFlags;
    let mut _235: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _236: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _237: usize;
    let mut _238: usize;
    let mut _239: bool;
    let mut _240: u64;
    let mut _241: u64;
    let mut _242: (usize, bool);
    let _243: ();
    let mut _245: &structures::paging::page_table::PageTableFlags;
    let _246: &structures::paging::page_table::PageTableFlags;
    let mut _247: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _248: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _249: usize;
    let mut _250: usize;
    let mut _251: bool;
    let mut _252: u64;
    let mut _253: u64;
    let mut _254: (usize, bool);
    let _255: ();
    let mut _257: &structures::paging::page_table::PageTableFlags;
    let _258: &structures::paging::page_table::PageTableFlags;
    let mut _259: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _260: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _261: usize;
    let mut _262: usize;
    let mut _263: bool;
    let mut _264: u64;
    let mut _265: u64;
    let mut _266: (usize, bool);
    let _267: ();
    let mut _269: &structures::paging::page_table::PageTableFlags;
    let _270: &structures::paging::page_table::PageTableFlags;
    let mut _271: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _272: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _273: usize;
    let mut _274: usize;
    let mut _275: bool;
    let mut _276: u64;
    let mut _277: u64;
    let mut _278: (usize, bool);
    let _279: ();
    let mut _281: &structures::paging::page_table::PageTableFlags;
    let _282: &structures::paging::page_table::PageTableFlags;
    let mut _283: &bitflags::Flag<structures::paging::page_table::PageTableFlags>;
    let _284: &[bitflags::Flag<structures::paging::page_table::PageTableFlags>];
    let _285: usize;
    let mut _286: usize;
    let mut _287: bool;
    let mut _288: u64;
    let mut _289: u64;
    let mut _290: (usize, bool);
    let mut _291: u64;
    scope 1 {
        debug truncated => _1;
        let mut _2: usize;
        scope 2 {
            debug i => _2;
            let _4: u64;
            let _16: u64;
            let _28: u64;
            let _40: u64;
            let _52: u64;
            let _64: u64;
            let _76: u64;
            let _88: u64;
            let _100: u64;
            let _112: u64;
            let _124: u64;
            let _136: u64;
            let _148: u64;
            let _160: u64;
            let _172: u64;
            let _184: u64;
            let _196: u64;
            let _208: u64;
            let _220: u64;
            let _232: u64;
            let _244: u64;
            let _256: u64;
            let _268: u64;
            let _280: u64;
            scope 3 {
                debug flag => _4;
            }
            scope 4 {
                debug flag => _16;
            }
            scope 5 {
                debug flag => _28;
            }
            scope 6 {
                debug flag => _40;
            }
            scope 7 {
                debug flag => _52;
            }
            scope 8 {
                debug flag => _64;
            }
            scope 9 {
                debug flag => _76;
            }
            scope 10 {
                debug flag => _88;
            }
            scope 11 {
                debug flag => _100;
            }
            scope 12 {
                debug flag => _112;
            }
            scope 13 {
                debug flag => _124;
            }
            scope 14 {
                debug flag => _136;
            }
            scope 15 {
                debug flag => _148;
            }
            scope 16 {
                debug flag => _160;
            }
            scope 17 {
                debug flag => _172;
            }
            scope 18 {
                debug flag => _184;
            }
            scope 19 {
                debug flag => _196;
            }
            scope 20 {
                debug flag => _208;
            }
            scope 21 {
                debug flag => _220;
            }
            scope 22 {
                debug flag => _232;
            }
            scope 23 {
                debug flag => _244;
            }
            scope 24 {
                debug flag => _256;
            }
            scope 25 {
                debug flag => _268;
            }
            scope 26 {
                debug flag => _280;
            }
            scope 27 {
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = const 0_usize;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        StorageLive(_8);
        _8 = const _;
        StorageLive(_9);
        _9 = _2;
        _10 = Len((*_8));
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &(*_8)[_9];
        ConstEvalCounter;
        _6 = Flag::<PageTableFlags>::value(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = &(*_6);
        StorageDead(_7);
        ConstEvalCounter;
        _4 = page_table::_::<impl PageTableFlags>::bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_9);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_12);
        _12 = _1;
        StorageLive(_13);
        _13 = _4;
        _1 = BitOr(move _12, move _13);
        StorageDead(_13);
        StorageDead(_12);
        _14 = CheckedAdd(_2, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move (_14.0: usize);
        _3 = const ();
        StorageDead(_4);
        StorageDead(_3);
        StorageLive(_15);
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        StorageLive(_19);
        StorageLive(_20);
        _20 = const _;
        StorageLive(_21);
        _21 = _2;
        _22 = Len((*_20));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = &(*_20)[_21];
        ConstEvalCounter;
        _18 = Flag::<PageTableFlags>::value(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = &(*_18);
        StorageDead(_19);
        ConstEvalCounter;
        _16 = page_table::_::<impl PageTableFlags>::bits(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        StorageDead(_17);
        StorageDead(_21);
        StorageDead(_20);
        StorageDead(_18);
        StorageLive(_24);
        _24 = _1;
        StorageLive(_25);
        _25 = _16;
        _1 = BitOr(move _24, move _25);
        StorageDead(_25);
        StorageDead(_24);
        _26 = CheckedAdd(_2, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = move (_26.0: usize);
        _15 = const ();
        StorageDead(_16);
        StorageDead(_15);
        StorageLive(_27);
        StorageLive(_28);
        StorageLive(_29);
        StorageLive(_30);
        StorageLive(_31);
        StorageLive(_32);
        _32 = const _;
        StorageLive(_33);
        _33 = _2;
        _34 = Len((*_32));
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _31 = &(*_32)[_33];
        ConstEvalCounter;
        _30 = Flag::<PageTableFlags>::value(move _31) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = &(*_30);
        StorageDead(_31);
        ConstEvalCounter;
        _28 = page_table::_::<impl PageTableFlags>::bits(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        StorageDead(_29);
        StorageDead(_33);
        StorageDead(_32);
        StorageDead(_30);
        StorageLive(_36);
        _36 = _1;
        StorageLive(_37);
        _37 = _28;
        _1 = BitOr(move _36, move _37);
        StorageDead(_37);
        StorageDead(_36);
        _38 = CheckedAdd(_2, const 1_usize);
        assert(!move (_38.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_38.0: usize);
        _27 = const ();
        StorageDead(_28);
        StorageDead(_27);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        StorageLive(_42);
        StorageLive(_43);
        StorageLive(_44);
        _44 = const _;
        StorageLive(_45);
        _45 = _2;
        _46 = Len((*_44));
        _47 = Lt(_45, _46);
        assert(move _47, "index out of bounds: the length is {} but the index is {}", move _46, _45) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _43 = &(*_44)[_45];
        ConstEvalCounter;
        _42 = Flag::<PageTableFlags>::value(move _43) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _41 = &(*_42);
        StorageDead(_43);
        ConstEvalCounter;
        _40 = page_table::_::<impl PageTableFlags>::bits(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        StorageDead(_41);
        StorageDead(_45);
        StorageDead(_44);
        StorageDead(_42);
        StorageLive(_48);
        _48 = _1;
        StorageLive(_49);
        _49 = _40;
        _1 = BitOr(move _48, move _49);
        StorageDead(_49);
        StorageDead(_48);
        _50 = CheckedAdd(_2, const 1_usize);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = move (_50.0: usize);
        _39 = const ();
        StorageDead(_40);
        StorageDead(_39);
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = const _;
        StorageLive(_57);
        _57 = _2;
        _58 = Len((*_56));
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _55 = &(*_56)[_57];
        ConstEvalCounter;
        _54 = Flag::<PageTableFlags>::value(move _55) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _53 = &(*_54);
        StorageDead(_55);
        ConstEvalCounter;
        _52 = page_table::_::<impl PageTableFlags>::bits(move _53) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        StorageDead(_53);
        StorageDead(_57);
        StorageDead(_56);
        StorageDead(_54);
        StorageLive(_60);
        _60 = _1;
        StorageLive(_61);
        _61 = _52;
        _1 = BitOr(move _60, move _61);
        StorageDead(_61);
        StorageDead(_60);
        _62 = CheckedAdd(_2, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move (_62.0: usize);
        _51 = const ();
        StorageDead(_52);
        StorageDead(_51);
        StorageLive(_63);
        StorageLive(_64);
        StorageLive(_65);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = const _;
        StorageLive(_69);
        _69 = _2;
        _70 = Len((*_68));
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _67 = &(*_68)[_69];
        ConstEvalCounter;
        _66 = Flag::<PageTableFlags>::value(move _67) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _65 = &(*_66);
        StorageDead(_67);
        ConstEvalCounter;
        _64 = page_table::_::<impl PageTableFlags>::bits(move _65) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        StorageDead(_65);
        StorageDead(_69);
        StorageDead(_68);
        StorageDead(_66);
        StorageLive(_72);
        _72 = _1;
        StorageLive(_73);
        _73 = _64;
        _1 = BitOr(move _72, move _73);
        StorageDead(_73);
        StorageDead(_72);
        _74 = CheckedAdd(_2, const 1_usize);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _2 = move (_74.0: usize);
        _63 = const ();
        StorageDead(_64);
        StorageDead(_63);
        StorageLive(_75);
        StorageLive(_76);
        StorageLive(_77);
        StorageLive(_78);
        StorageLive(_79);
        StorageLive(_80);
        _80 = const _;
        StorageLive(_81);
        _81 = _2;
        _82 = Len((*_80));
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _79 = &(*_80)[_81];
        ConstEvalCounter;
        _78 = Flag::<PageTableFlags>::value(move _79) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _77 = &(*_78);
        StorageDead(_79);
        ConstEvalCounter;
        _76 = page_table::_::<impl PageTableFlags>::bits(move _77) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        StorageDead(_77);
        StorageDead(_81);
        StorageDead(_80);
        StorageDead(_78);
        StorageLive(_84);
        _84 = _1;
        StorageLive(_85);
        _85 = _76;
        _1 = BitOr(move _84, move _85);
        StorageDead(_85);
        StorageDead(_84);
        _86 = CheckedAdd(_2, const 1_usize);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _2 = move (_86.0: usize);
        _75 = const ();
        StorageDead(_76);
        StorageDead(_75);
        StorageLive(_87);
        StorageLive(_88);
        StorageLive(_89);
        StorageLive(_90);
        StorageLive(_91);
        StorageLive(_92);
        _92 = const _;
        StorageLive(_93);
        _93 = _2;
        _94 = Len((*_92));
        _95 = Lt(_93, _94);
        assert(move _95, "index out of bounds: the length is {} but the index is {}", move _94, _93) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _91 = &(*_92)[_93];
        ConstEvalCounter;
        _90 = Flag::<PageTableFlags>::value(move _91) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _89 = &(*_90);
        StorageDead(_91);
        ConstEvalCounter;
        _88 = page_table::_::<impl PageTableFlags>::bits(move _89) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        StorageDead(_89);
        StorageDead(_93);
        StorageDead(_92);
        StorageDead(_90);
        StorageLive(_96);
        _96 = _1;
        StorageLive(_97);
        _97 = _88;
        _1 = BitOr(move _96, move _97);
        StorageDead(_97);
        StorageDead(_96);
        _98 = CheckedAdd(_2, const 1_usize);
        assert(!move (_98.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _2 = move (_98.0: usize);
        _87 = const ();
        StorageDead(_88);
        StorageDead(_87);
        StorageLive(_99);
        StorageLive(_100);
        StorageLive(_101);
        StorageLive(_102);
        StorageLive(_103);
        StorageLive(_104);
        _104 = const _;
        StorageLive(_105);
        _105 = _2;
        _106 = Len((*_104));
        _107 = Lt(_105, _106);
        assert(move _107, "index out of bounds: the length is {} but the index is {}", move _106, _105) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _103 = &(*_104)[_105];
        ConstEvalCounter;
        _102 = Flag::<PageTableFlags>::value(move _103) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _101 = &(*_102);
        StorageDead(_103);
        ConstEvalCounter;
        _100 = page_table::_::<impl PageTableFlags>::bits(move _101) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        StorageDead(_101);
        StorageDead(_105);
        StorageDead(_104);
        StorageDead(_102);
        StorageLive(_108);
        _108 = _1;
        StorageLive(_109);
        _109 = _100;
        _1 = BitOr(move _108, move _109);
        StorageDead(_109);
        StorageDead(_108);
        _110 = CheckedAdd(_2, const 1_usize);
        assert(!move (_110.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _2 = move (_110.0: usize);
        _99 = const ();
        StorageDead(_100);
        StorageDead(_99);
        StorageLive(_111);
        StorageLive(_112);
        StorageLive(_113);
        StorageLive(_114);
        StorageLive(_115);
        StorageLive(_116);
        _116 = const _;
        StorageLive(_117);
        _117 = _2;
        _118 = Len((*_116));
        _119 = Lt(_117, _118);
        assert(move _119, "index out of bounds: the length is {} but the index is {}", move _118, _117) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _115 = &(*_116)[_117];
        ConstEvalCounter;
        _114 = Flag::<PageTableFlags>::value(move _115) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _113 = &(*_114);
        StorageDead(_115);
        ConstEvalCounter;
        _112 = page_table::_::<impl PageTableFlags>::bits(move _113) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        StorageDead(_113);
        StorageDead(_117);
        StorageDead(_116);
        StorageDead(_114);
        StorageLive(_120);
        _120 = _1;
        StorageLive(_121);
        _121 = _112;
        _1 = BitOr(move _120, move _121);
        StorageDead(_121);
        StorageDead(_120);
        _122 = CheckedAdd(_2, const 1_usize);
        assert(!move (_122.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _2 = move (_122.0: usize);
        _111 = const ();
        StorageDead(_112);
        StorageDead(_111);
        StorageLive(_123);
        StorageLive(_124);
        StorageLive(_125);
        StorageLive(_126);
        StorageLive(_127);
        StorageLive(_128);
        _128 = const _;
        StorageLive(_129);
        _129 = _2;
        _130 = Len((*_128));
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _127 = &(*_128)[_129];
        ConstEvalCounter;
        _126 = Flag::<PageTableFlags>::value(move _127) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _125 = &(*_126);
        StorageDead(_127);
        ConstEvalCounter;
        _124 = page_table::_::<impl PageTableFlags>::bits(move _125) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        StorageDead(_125);
        StorageDead(_129);
        StorageDead(_128);
        StorageDead(_126);
        StorageLive(_132);
        _132 = _1;
        StorageLive(_133);
        _133 = _124;
        _1 = BitOr(move _132, move _133);
        StorageDead(_133);
        StorageDead(_132);
        _134 = CheckedAdd(_2, const 1_usize);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move (_134.0: usize);
        _123 = const ();
        StorageDead(_124);
        StorageDead(_123);
        StorageLive(_135);
        StorageLive(_136);
        StorageLive(_137);
        StorageLive(_138);
        StorageLive(_139);
        StorageLive(_140);
        _140 = const _;
        StorageLive(_141);
        _141 = _2;
        _142 = Len((*_140));
        _143 = Lt(_141, _142);
        assert(move _143, "index out of bounds: the length is {} but the index is {}", move _142, _141) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _139 = &(*_140)[_141];
        ConstEvalCounter;
        _138 = Flag::<PageTableFlags>::value(move _139) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _137 = &(*_138);
        StorageDead(_139);
        ConstEvalCounter;
        _136 = page_table::_::<impl PageTableFlags>::bits(move _137) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        StorageDead(_137);
        StorageDead(_141);
        StorageDead(_140);
        StorageDead(_138);
        StorageLive(_144);
        _144 = _1;
        StorageLive(_145);
        _145 = _136;
        _1 = BitOr(move _144, move _145);
        StorageDead(_145);
        StorageDead(_144);
        _146 = CheckedAdd(_2, const 1_usize);
        assert(!move (_146.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _2 = move (_146.0: usize);
        _135 = const ();
        StorageDead(_136);
        StorageDead(_135);
        StorageLive(_147);
        StorageLive(_148);
        StorageLive(_149);
        StorageLive(_150);
        StorageLive(_151);
        StorageLive(_152);
        _152 = const _;
        StorageLive(_153);
        _153 = _2;
        _154 = Len((*_152));
        _155 = Lt(_153, _154);
        assert(move _155, "index out of bounds: the length is {} but the index is {}", move _154, _153) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _151 = &(*_152)[_153];
        ConstEvalCounter;
        _150 = Flag::<PageTableFlags>::value(move _151) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _149 = &(*_150);
        StorageDead(_151);
        ConstEvalCounter;
        _148 = page_table::_::<impl PageTableFlags>::bits(move _149) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        StorageDead(_149);
        StorageDead(_153);
        StorageDead(_152);
        StorageDead(_150);
        StorageLive(_156);
        _156 = _1;
        StorageLive(_157);
        _157 = _148;
        _1 = BitOr(move _156, move _157);
        StorageDead(_157);
        StorageDead(_156);
        _158 = CheckedAdd(_2, const 1_usize);
        assert(!move (_158.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _2 = move (_158.0: usize);
        _147 = const ();
        StorageDead(_148);
        StorageDead(_147);
        StorageLive(_159);
        StorageLive(_160);
        StorageLive(_161);
        StorageLive(_162);
        StorageLive(_163);
        StorageLive(_164);
        _164 = const _;
        StorageLive(_165);
        _165 = _2;
        _166 = Len((*_164));
        _167 = Lt(_165, _166);
        assert(move _167, "index out of bounds: the length is {} but the index is {}", move _166, _165) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _163 = &(*_164)[_165];
        ConstEvalCounter;
        _162 = Flag::<PageTableFlags>::value(move _163) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _161 = &(*_162);
        StorageDead(_163);
        ConstEvalCounter;
        _160 = page_table::_::<impl PageTableFlags>::bits(move _161) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        StorageDead(_161);
        StorageDead(_165);
        StorageDead(_164);
        StorageDead(_162);
        StorageLive(_168);
        _168 = _1;
        StorageLive(_169);
        _169 = _160;
        _1 = BitOr(move _168, move _169);
        StorageDead(_169);
        StorageDead(_168);
        _170 = CheckedAdd(_2, const 1_usize);
        assert(!move (_170.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _2 = move (_170.0: usize);
        _159 = const ();
        StorageDead(_160);
        StorageDead(_159);
        StorageLive(_171);
        StorageLive(_172);
        StorageLive(_173);
        StorageLive(_174);
        StorageLive(_175);
        StorageLive(_176);
        _176 = const _;
        StorageLive(_177);
        _177 = _2;
        _178 = Len((*_176));
        _179 = Lt(_177, _178);
        assert(move _179, "index out of bounds: the length is {} but the index is {}", move _178, _177) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _175 = &(*_176)[_177];
        ConstEvalCounter;
        _174 = Flag::<PageTableFlags>::value(move _175) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _173 = &(*_174);
        StorageDead(_175);
        ConstEvalCounter;
        _172 = page_table::_::<impl PageTableFlags>::bits(move _173) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        StorageDead(_173);
        StorageDead(_177);
        StorageDead(_176);
        StorageDead(_174);
        StorageLive(_180);
        _180 = _1;
        StorageLive(_181);
        _181 = _172;
        _1 = BitOr(move _180, move _181);
        StorageDead(_181);
        StorageDead(_180);
        _182 = CheckedAdd(_2, const 1_usize);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _2 = move (_182.0: usize);
        _171 = const ();
        StorageDead(_172);
        StorageDead(_171);
        StorageLive(_183);
        StorageLive(_184);
        StorageLive(_185);
        StorageLive(_186);
        StorageLive(_187);
        StorageLive(_188);
        _188 = const _;
        StorageLive(_189);
        _189 = _2;
        _190 = Len((*_188));
        _191 = Lt(_189, _190);
        assert(move _191, "index out of bounds: the length is {} but the index is {}", move _190, _189) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _187 = &(*_188)[_189];
        ConstEvalCounter;
        _186 = Flag::<PageTableFlags>::value(move _187) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _185 = &(*_186);
        StorageDead(_187);
        ConstEvalCounter;
        _184 = page_table::_::<impl PageTableFlags>::bits(move _185) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        StorageDead(_185);
        StorageDead(_189);
        StorageDead(_188);
        StorageDead(_186);
        StorageLive(_192);
        _192 = _1;
        StorageLive(_193);
        _193 = _184;
        _1 = BitOr(move _192, move _193);
        StorageDead(_193);
        StorageDead(_192);
        _194 = CheckedAdd(_2, const 1_usize);
        assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _2 = move (_194.0: usize);
        _183 = const ();
        StorageDead(_184);
        StorageDead(_183);
        StorageLive(_195);
        StorageLive(_196);
        StorageLive(_197);
        StorageLive(_198);
        StorageLive(_199);
        StorageLive(_200);
        _200 = const _;
        StorageLive(_201);
        _201 = _2;
        _202 = Len((*_200));
        _203 = Lt(_201, _202);
        assert(move _203, "index out of bounds: the length is {} but the index is {}", move _202, _201) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _199 = &(*_200)[_201];
        ConstEvalCounter;
        _198 = Flag::<PageTableFlags>::value(move _199) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _197 = &(*_198);
        StorageDead(_199);
        ConstEvalCounter;
        _196 = page_table::_::<impl PageTableFlags>::bits(move _197) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        StorageDead(_197);
        StorageDead(_201);
        StorageDead(_200);
        StorageDead(_198);
        StorageLive(_204);
        _204 = _1;
        StorageLive(_205);
        _205 = _196;
        _1 = BitOr(move _204, move _205);
        StorageDead(_205);
        StorageDead(_204);
        _206 = CheckedAdd(_2, const 1_usize);
        assert(!move (_206.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _2 = move (_206.0: usize);
        _195 = const ();
        StorageDead(_196);
        StorageDead(_195);
        StorageLive(_207);
        StorageLive(_208);
        StorageLive(_209);
        StorageLive(_210);
        StorageLive(_211);
        StorageLive(_212);
        _212 = const _;
        StorageLive(_213);
        _213 = _2;
        _214 = Len((*_212));
        _215 = Lt(_213, _214);
        assert(move _215, "index out of bounds: the length is {} but the index is {}", move _214, _213) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _211 = &(*_212)[_213];
        ConstEvalCounter;
        _210 = Flag::<PageTableFlags>::value(move _211) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _209 = &(*_210);
        StorageDead(_211);
        ConstEvalCounter;
        _208 = page_table::_::<impl PageTableFlags>::bits(move _209) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        StorageDead(_209);
        StorageDead(_213);
        StorageDead(_212);
        StorageDead(_210);
        StorageLive(_216);
        _216 = _1;
        StorageLive(_217);
        _217 = _208;
        _1 = BitOr(move _216, move _217);
        StorageDead(_217);
        StorageDead(_216);
        _218 = CheckedAdd(_2, const 1_usize);
        assert(!move (_218.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _2 = move (_218.0: usize);
        _207 = const ();
        StorageDead(_208);
        StorageDead(_207);
        StorageLive(_219);
        StorageLive(_220);
        StorageLive(_221);
        StorageLive(_222);
        StorageLive(_223);
        StorageLive(_224);
        _224 = const _;
        StorageLive(_225);
        _225 = _2;
        _226 = Len((*_224));
        _227 = Lt(_225, _226);
        assert(move _227, "index out of bounds: the length is {} but the index is {}", move _226, _225) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _223 = &(*_224)[_225];
        ConstEvalCounter;
        _222 = Flag::<PageTableFlags>::value(move _223) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _221 = &(*_222);
        StorageDead(_223);
        ConstEvalCounter;
        _220 = page_table::_::<impl PageTableFlags>::bits(move _221) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        StorageDead(_221);
        StorageDead(_225);
        StorageDead(_224);
        StorageDead(_222);
        StorageLive(_228);
        _228 = _1;
        StorageLive(_229);
        _229 = _220;
        _1 = BitOr(move _228, move _229);
        StorageDead(_229);
        StorageDead(_228);
        _230 = CheckedAdd(_2, const 1_usize);
        assert(!move (_230.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _2 = move (_230.0: usize);
        _219 = const ();
        StorageDead(_220);
        StorageDead(_219);
        StorageLive(_231);
        StorageLive(_232);
        StorageLive(_233);
        StorageLive(_234);
        StorageLive(_235);
        StorageLive(_236);
        _236 = const _;
        StorageLive(_237);
        _237 = _2;
        _238 = Len((*_236));
        _239 = Lt(_237, _238);
        assert(move _239, "index out of bounds: the length is {} but the index is {}", move _238, _237) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _235 = &(*_236)[_237];
        ConstEvalCounter;
        _234 = Flag::<PageTableFlags>::value(move _235) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _233 = &(*_234);
        StorageDead(_235);
        ConstEvalCounter;
        _232 = page_table::_::<impl PageTableFlags>::bits(move _233) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        StorageDead(_233);
        StorageDead(_237);
        StorageDead(_236);
        StorageDead(_234);
        StorageLive(_240);
        _240 = _1;
        StorageLive(_241);
        _241 = _232;
        _1 = BitOr(move _240, move _241);
        StorageDead(_241);
        StorageDead(_240);
        _242 = CheckedAdd(_2, const 1_usize);
        assert(!move (_242.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _2 = move (_242.0: usize);
        _231 = const ();
        StorageDead(_232);
        StorageDead(_231);
        StorageLive(_243);
        StorageLive(_244);
        StorageLive(_245);
        StorageLive(_246);
        StorageLive(_247);
        StorageLive(_248);
        _248 = const _;
        StorageLive(_249);
        _249 = _2;
        _250 = Len((*_248));
        _251 = Lt(_249, _250);
        assert(move _251, "index out of bounds: the length is {} but the index is {}", move _250, _249) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _247 = &(*_248)[_249];
        ConstEvalCounter;
        _246 = Flag::<PageTableFlags>::value(move _247) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _245 = &(*_246);
        StorageDead(_247);
        ConstEvalCounter;
        _244 = page_table::_::<impl PageTableFlags>::bits(move _245) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        StorageDead(_245);
        StorageDead(_249);
        StorageDead(_248);
        StorageDead(_246);
        StorageLive(_252);
        _252 = _1;
        StorageLive(_253);
        _253 = _244;
        _1 = BitOr(move _252, move _253);
        StorageDead(_253);
        StorageDead(_252);
        _254 = CheckedAdd(_2, const 1_usize);
        assert(!move (_254.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _2 = move (_254.0: usize);
        _243 = const ();
        StorageDead(_244);
        StorageDead(_243);
        StorageLive(_255);
        StorageLive(_256);
        StorageLive(_257);
        StorageLive(_258);
        StorageLive(_259);
        StorageLive(_260);
        _260 = const _;
        StorageLive(_261);
        _261 = _2;
        _262 = Len((*_260));
        _263 = Lt(_261, _262);
        assert(move _263, "index out of bounds: the length is {} but the index is {}", move _262, _261) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _259 = &(*_260)[_261];
        ConstEvalCounter;
        _258 = Flag::<PageTableFlags>::value(move _259) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _257 = &(*_258);
        StorageDead(_259);
        ConstEvalCounter;
        _256 = page_table::_::<impl PageTableFlags>::bits(move _257) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        StorageDead(_257);
        StorageDead(_261);
        StorageDead(_260);
        StorageDead(_258);
        StorageLive(_264);
        _264 = _1;
        StorageLive(_265);
        _265 = _256;
        _1 = BitOr(move _264, move _265);
        StorageDead(_265);
        StorageDead(_264);
        _266 = CheckedAdd(_2, const 1_usize);
        assert(!move (_266.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _2 = move (_266.0: usize);
        _255 = const ();
        StorageDead(_256);
        StorageDead(_255);
        StorageLive(_267);
        StorageLive(_268);
        StorageLive(_269);
        StorageLive(_270);
        StorageLive(_271);
        StorageLive(_272);
        _272 = const _;
        StorageLive(_273);
        _273 = _2;
        _274 = Len((*_272));
        _275 = Lt(_273, _274);
        assert(move _275, "index out of bounds: the length is {} but the index is {}", move _274, _273) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _271 = &(*_272)[_273];
        ConstEvalCounter;
        _270 = Flag::<PageTableFlags>::value(move _271) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _269 = &(*_270);
        StorageDead(_271);
        ConstEvalCounter;
        _268 = page_table::_::<impl PageTableFlags>::bits(move _269) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        StorageDead(_269);
        StorageDead(_273);
        StorageDead(_272);
        StorageDead(_270);
        StorageLive(_276);
        _276 = _1;
        StorageLive(_277);
        _277 = _268;
        _1 = BitOr(move _276, move _277);
        StorageDead(_277);
        StorageDead(_276);
        _278 = CheckedAdd(_2, const 1_usize);
        assert(!move (_278.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb92, unwind unreachable];
    }

    bb92: {
        _2 = move (_278.0: usize);
        _267 = const ();
        StorageDead(_268);
        StorageDead(_267);
        StorageLive(_279);
        StorageLive(_280);
        StorageLive(_281);
        StorageLive(_282);
        StorageLive(_283);
        StorageLive(_284);
        _284 = const _;
        StorageLive(_285);
        _285 = _2;
        _286 = Len((*_284));
        _287 = Lt(_285, _286);
        assert(move _287, "index out of bounds: the length is {} but the index is {}", move _286, _285) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _283 = &(*_284)[_285];
        ConstEvalCounter;
        _282 = Flag::<PageTableFlags>::value(move _283) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _281 = &(*_282);
        StorageDead(_283);
        ConstEvalCounter;
        _280 = page_table::_::<impl PageTableFlags>::bits(move _281) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        StorageDead(_281);
        StorageDead(_285);
        StorageDead(_284);
        StorageDead(_282);
        StorageLive(_288);
        _288 = _1;
        StorageLive(_289);
        _289 = _280;
        _1 = BitOr(move _288, move _289);
        StorageDead(_289);
        StorageDead(_288);
        _290 = CheckedAdd(_2, const 1_usize);
        assert(!move (_290.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _2 = move (_290.0: usize);
        _279 = const ();
        StorageDead(_280);
        StorageDead(_279);
        StorageLive(_291);
        _291 = _1;
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _291) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        StorageDead(_291);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &page_table::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _0 = ((*_1).0: u64);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &page_table::_::InternalBitFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        _0 = ((*_2).0: u64);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<page_table::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: bool;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
        let _2: u64;
        scope 2 {
            debug truncated => _2;
        }
    }

    bb0: {
        _3 = page_table::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_3.0: u64);
        _4 = Eq(_2, _1);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = page_table::_::InternalBitFlags(_1);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _5);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<page_table::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<page_table::_::InternalBitFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let _2: u64;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: structures::paging::page_table::_::InternalBitFlags;
    let mut _10: u64;
    scope 1 {
        debug bits => _2;
        let _3: u64;
        scope 2 {
            debug truncated => _3;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _2;
        ConstEvalCounter;
        _4 = page_table::_::InternalBitFlags::from_bits_truncate(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = (_4.0: u64);
        StorageDead(_4);
        StorageLive(_6);
        StorageLive(_7);
        _7 = _3;
        StorageLive(_8);
        _8 = _2;
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_8);
        StorageDead(_7);
        StorageLive(_9);
        StorageLive(_10);
        _10 = _2;
        _9 = page_table::_::InternalBitFlags(move _10);
        StorageDead(_10);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _9);
        StorageDead(_9);
        goto -> bb4;
    }

    bb3: {
        StorageDead(_8);
        StorageDead(_7);
        _0 = Option::<page_table::_::InternalBitFlags>::None;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_6);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> page_table::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;
    let _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _5 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = page_table::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = BitAnd(_1, move _3);
        _0 = page_table::_::InternalBitFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> page_table::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::_::InternalBitFlags;
    let _7: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        ConstEvalCounter;
        _7 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = &_7;
        ConstEvalCounter;
        _5 = page_table::_::InternalBitFlags::bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_6);
        _3 = BitAnd(move _4, move _5);
        StorageDead(_5);
        StorageDead(_4);
        _0 = page_table::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_7);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> page_table::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _0 = page_table::_::InternalBitFlags(_1);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> page_table::_::InternalBitFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _2: u64;
    let mut _3: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = _2;
        _0 = page_table::_::InternalBitFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<page_table::_::InternalBitFlags> {
    debug name => _1;
    let mut _0: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let _2: &str;
    let mut _3: bool;
    let mut _4: &&str;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: bool;
    let mut _8: &&str;
    let mut _9: structures::paging::page_table::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: bool;
    let mut _12: &&str;
    let mut _13: structures::paging::page_table::_::InternalBitFlags;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: &&str;
    let mut _17: structures::paging::page_table::_::InternalBitFlags;
    let mut _18: u64;
    let mut _19: bool;
    let mut _20: &&str;
    let mut _21: structures::paging::page_table::_::InternalBitFlags;
    let mut _22: u64;
    let mut _23: bool;
    let mut _24: &&str;
    let mut _25: structures::paging::page_table::_::InternalBitFlags;
    let mut _26: u64;
    let mut _27: bool;
    let mut _28: &&str;
    let mut _29: structures::paging::page_table::_::InternalBitFlags;
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: &&str;
    let mut _33: structures::paging::page_table::_::InternalBitFlags;
    let mut _34: u64;
    let mut _35: bool;
    let mut _36: &&str;
    let mut _37: structures::paging::page_table::_::InternalBitFlags;
    let mut _38: u64;
    let mut _39: bool;
    let mut _40: &&str;
    let mut _41: structures::paging::page_table::_::InternalBitFlags;
    let mut _42: u64;
    let mut _43: bool;
    let mut _44: &&str;
    let mut _45: structures::paging::page_table::_::InternalBitFlags;
    let mut _46: u64;
    let mut _47: bool;
    let mut _48: &&str;
    let mut _49: structures::paging::page_table::_::InternalBitFlags;
    let mut _50: u64;
    let mut _51: bool;
    let mut _52: &&str;
    let mut _53: structures::paging::page_table::_::InternalBitFlags;
    let mut _54: u64;
    let mut _55: bool;
    let mut _56: &&str;
    let mut _57: structures::paging::page_table::_::InternalBitFlags;
    let mut _58: u64;
    let mut _59: bool;
    let mut _60: &&str;
    let mut _61: structures::paging::page_table::_::InternalBitFlags;
    let mut _62: u64;
    let mut _63: bool;
    let mut _64: &&str;
    let mut _65: structures::paging::page_table::_::InternalBitFlags;
    let mut _66: u64;
    let mut _67: bool;
    let mut _68: &&str;
    let mut _69: structures::paging::page_table::_::InternalBitFlags;
    let mut _70: u64;
    let mut _71: bool;
    let mut _72: &&str;
    let mut _73: structures::paging::page_table::_::InternalBitFlags;
    let mut _74: u64;
    let mut _75: bool;
    let mut _76: &&str;
    let mut _77: structures::paging::page_table::_::InternalBitFlags;
    let mut _78: u64;
    let mut _79: bool;
    let mut _80: &&str;
    let mut _81: structures::paging::page_table::_::InternalBitFlags;
    let mut _82: u64;
    let mut _83: bool;
    let mut _84: &&str;
    let mut _85: structures::paging::page_table::_::InternalBitFlags;
    let mut _86: u64;
    let mut _87: bool;
    let mut _88: &&str;
    let mut _89: structures::paging::page_table::_::InternalBitFlags;
    let mut _90: u64;
    let mut _91: bool;
    let mut _92: &&str;
    let mut _93: structures::paging::page_table::_::InternalBitFlags;
    let mut _94: u64;
    let mut _95: bool;
    let mut _96: &&str;
    let mut _97: structures::paging::page_table::_::InternalBitFlags;
    let mut _98: u64;
    scope 1 {
        debug name => _2;
        let mut _99: &structures::paging::page_table::PageTableFlags;
        let mut _100: &structures::paging::page_table::PageTableFlags;
        let mut _101: &structures::paging::page_table::PageTableFlags;
        let mut _102: &structures::paging::page_table::PageTableFlags;
        let mut _103: &structures::paging::page_table::PageTableFlags;
        let mut _104: &structures::paging::page_table::PageTableFlags;
        let mut _105: &structures::paging::page_table::PageTableFlags;
        let mut _106: &structures::paging::page_table::PageTableFlags;
        let mut _107: &structures::paging::page_table::PageTableFlags;
        let mut _108: &structures::paging::page_table::PageTableFlags;
        let mut _109: &structures::paging::page_table::PageTableFlags;
        let mut _110: &structures::paging::page_table::PageTableFlags;
        let mut _111: &structures::paging::page_table::PageTableFlags;
        let mut _112: &structures::paging::page_table::PageTableFlags;
        let mut _113: &structures::paging::page_table::PageTableFlags;
        let mut _114: &structures::paging::page_table::PageTableFlags;
        let mut _115: &structures::paging::page_table::PageTableFlags;
        let mut _116: &structures::paging::page_table::PageTableFlags;
        let mut _117: &structures::paging::page_table::PageTableFlags;
        let mut _118: &structures::paging::page_table::PageTableFlags;
        let mut _119: &structures::paging::page_table::PageTableFlags;
        let mut _120: &structures::paging::page_table::PageTableFlags;
        let mut _121: &structures::paging::page_table::PageTableFlags;
        let mut _122: &structures::paging::page_table::PageTableFlags;
        let mut _123: &&str;
        let mut _124: &&str;
        let mut _125: &&str;
        let mut _126: &&str;
        let mut _127: &&str;
        let mut _128: &&str;
        let mut _129: &&str;
        let mut _130: &&str;
        let mut _131: &&str;
        let mut _132: &&str;
        let mut _133: &&str;
        let mut _134: &&str;
        let mut _135: &&str;
        let mut _136: &&str;
        let mut _137: &&str;
        let mut _138: &&str;
        let mut _139: &&str;
        let mut _140: &&str;
        let mut _141: &&str;
        let mut _142: &&str;
        let mut _143: &&str;
        let mut _144: &&str;
        let mut _145: &&str;
        let mut _146: &&str;
        scope 2 {
        }
    }

    bb0: {
        _2 = _1;
        _4 = &_2;
        _146 = const _;
        _3 = <&str as PartialEq>::eq(move _4, _146) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _99 = const _;
        _6 = page_table::_::<impl PageTableFlags>::bits(_99) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = page_table::_::InternalBitFlags(move _6);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _5);
        goto -> bb97;
    }

    bb4: {
        _8 = &_2;
        _145 = const _;
        _7 = <&str as PartialEq>::eq(move _8, _145) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _7) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _100 = const _;
        _10 = page_table::_::<impl PageTableFlags>::bits(_100) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = page_table::_::InternalBitFlags(move _10);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _9);
        goto -> bb97;
    }

    bb8: {
        _12 = &_2;
        _144 = const _;
        _11 = <&str as PartialEq>::eq(move _12, _144) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _11) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _101 = const _;
        _14 = page_table::_::<impl PageTableFlags>::bits(_101) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _13 = page_table::_::InternalBitFlags(move _14);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _13);
        goto -> bb97;
    }

    bb12: {
        _16 = &_2;
        _143 = const _;
        _15 = <&str as PartialEq>::eq(move _16, _143) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _15) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _102 = const _;
        _18 = page_table::_::<impl PageTableFlags>::bits(_102) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _17 = page_table::_::InternalBitFlags(move _18);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _17);
        goto -> bb97;
    }

    bb16: {
        _20 = &_2;
        _142 = const _;
        _19 = <&str as PartialEq>::eq(move _20, _142) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _19) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _103 = const _;
        _22 = page_table::_::<impl PageTableFlags>::bits(_103) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _21 = page_table::_::InternalBitFlags(move _22);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _21);
        goto -> bb97;
    }

    bb20: {
        _24 = &_2;
        _141 = const _;
        _23 = <&str as PartialEq>::eq(move _24, _141) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _23) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _104 = const _;
        _26 = page_table::_::<impl PageTableFlags>::bits(_104) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _25 = page_table::_::InternalBitFlags(move _26);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _25);
        goto -> bb97;
    }

    bb24: {
        _28 = &_2;
        _140 = const _;
        _27 = <&str as PartialEq>::eq(move _28, _140) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _27) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _105 = const _;
        _30 = page_table::_::<impl PageTableFlags>::bits(_105) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _29 = page_table::_::InternalBitFlags(move _30);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _29);
        goto -> bb97;
    }

    bb28: {
        _32 = &_2;
        _139 = const _;
        _31 = <&str as PartialEq>::eq(move _32, _139) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _31) -> [0: bb32, otherwise: bb30];
    }

    bb30: {
        _106 = const _;
        _34 = page_table::_::<impl PageTableFlags>::bits(_106) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = page_table::_::InternalBitFlags(move _34);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _33);
        goto -> bb97;
    }

    bb32: {
        _36 = &_2;
        _138 = const _;
        _35 = <&str as PartialEq>::eq(move _36, _138) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        switchInt(move _35) -> [0: bb36, otherwise: bb34];
    }

    bb34: {
        _107 = const _;
        _38 = page_table::_::<impl PageTableFlags>::bits(_107) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _37 = page_table::_::InternalBitFlags(move _38);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _37);
        goto -> bb97;
    }

    bb36: {
        _40 = &_2;
        _137 = const _;
        _39 = <&str as PartialEq>::eq(move _40, _137) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _39) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _108 = const _;
        _42 = page_table::_::<impl PageTableFlags>::bits(_108) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = page_table::_::InternalBitFlags(move _42);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _41);
        goto -> bb97;
    }

    bb40: {
        _44 = &_2;
        _136 = const _;
        _43 = <&str as PartialEq>::eq(move _44, _136) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _43) -> [0: bb44, otherwise: bb42];
    }

    bb42: {
        _109 = const _;
        _46 = page_table::_::<impl PageTableFlags>::bits(_109) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _45 = page_table::_::InternalBitFlags(move _46);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _45);
        goto -> bb97;
    }

    bb44: {
        _48 = &_2;
        _135 = const _;
        _47 = <&str as PartialEq>::eq(move _48, _135) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _47) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _110 = const _;
        _50 = page_table::_::<impl PageTableFlags>::bits(_110) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _49 = page_table::_::InternalBitFlags(move _50);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _49);
        goto -> bb97;
    }

    bb48: {
        _52 = &_2;
        _134 = const _;
        _51 = <&str as PartialEq>::eq(move _52, _134) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _51) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _111 = const _;
        _54 = page_table::_::<impl PageTableFlags>::bits(_111) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _53 = page_table::_::InternalBitFlags(move _54);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _53);
        goto -> bb97;
    }

    bb52: {
        _56 = &_2;
        _133 = const _;
        _55 = <&str as PartialEq>::eq(move _56, _133) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _55) -> [0: bb56, otherwise: bb54];
    }

    bb54: {
        _112 = const _;
        _58 = page_table::_::<impl PageTableFlags>::bits(_112) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _57 = page_table::_::InternalBitFlags(move _58);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _57);
        goto -> bb97;
    }

    bb56: {
        _60 = &_2;
        _132 = const _;
        _59 = <&str as PartialEq>::eq(move _60, _132) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _59) -> [0: bb60, otherwise: bb58];
    }

    bb58: {
        _113 = const _;
        _62 = page_table::_::<impl PageTableFlags>::bits(_113) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _61 = page_table::_::InternalBitFlags(move _62);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _61);
        goto -> bb97;
    }

    bb60: {
        _64 = &_2;
        _131 = const _;
        _63 = <&str as PartialEq>::eq(move _64, _131) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        switchInt(move _63) -> [0: bb64, otherwise: bb62];
    }

    bb62: {
        _114 = const _;
        _66 = page_table::_::<impl PageTableFlags>::bits(_114) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _65 = page_table::_::InternalBitFlags(move _66);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _65);
        goto -> bb97;
    }

    bb64: {
        _68 = &_2;
        _130 = const _;
        _67 = <&str as PartialEq>::eq(move _68, _130) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        switchInt(move _67) -> [0: bb68, otherwise: bb66];
    }

    bb66: {
        _115 = const _;
        _70 = page_table::_::<impl PageTableFlags>::bits(_115) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _69 = page_table::_::InternalBitFlags(move _70);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _69);
        goto -> bb97;
    }

    bb68: {
        _72 = &_2;
        _129 = const _;
        _71 = <&str as PartialEq>::eq(move _72, _129) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        switchInt(move _71) -> [0: bb72, otherwise: bb70];
    }

    bb70: {
        _116 = const _;
        _74 = page_table::_::<impl PageTableFlags>::bits(_116) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _73 = page_table::_::InternalBitFlags(move _74);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _73);
        goto -> bb97;
    }

    bb72: {
        _76 = &_2;
        _128 = const _;
        _75 = <&str as PartialEq>::eq(move _76, _128) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        switchInt(move _75) -> [0: bb76, otherwise: bb74];
    }

    bb74: {
        _117 = const _;
        _78 = page_table::_::<impl PageTableFlags>::bits(_117) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _77 = page_table::_::InternalBitFlags(move _78);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _77);
        goto -> bb97;
    }

    bb76: {
        _80 = &_2;
        _127 = const _;
        _79 = <&str as PartialEq>::eq(move _80, _127) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        switchInt(move _79) -> [0: bb80, otherwise: bb78];
    }

    bb78: {
        _118 = const _;
        _82 = page_table::_::<impl PageTableFlags>::bits(_118) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _81 = page_table::_::InternalBitFlags(move _82);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _81);
        goto -> bb97;
    }

    bb80: {
        _84 = &_2;
        _126 = const _;
        _83 = <&str as PartialEq>::eq(move _84, _126) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        switchInt(move _83) -> [0: bb84, otherwise: bb82];
    }

    bb82: {
        _119 = const _;
        _86 = page_table::_::<impl PageTableFlags>::bits(_119) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _85 = page_table::_::InternalBitFlags(move _86);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _85);
        goto -> bb97;
    }

    bb84: {
        _88 = &_2;
        _125 = const _;
        _87 = <&str as PartialEq>::eq(move _88, _125) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        switchInt(move _87) -> [0: bb88, otherwise: bb86];
    }

    bb86: {
        _120 = const _;
        _90 = page_table::_::<impl PageTableFlags>::bits(_120) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _89 = page_table::_::InternalBitFlags(move _90);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _89);
        goto -> bb97;
    }

    bb88: {
        _92 = &_2;
        _124 = const _;
        _91 = <&str as PartialEq>::eq(move _92, _124) -> [return: bb89, unwind unreachable];
    }

    bb89: {
        switchInt(move _91) -> [0: bb92, otherwise: bb90];
    }

    bb90: {
        _121 = const _;
        _94 = page_table::_::<impl PageTableFlags>::bits(_121) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _93 = page_table::_::InternalBitFlags(move _94);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _93);
        goto -> bb97;
    }

    bb92: {
        _96 = &_2;
        _123 = const _;
        _95 = <&str as PartialEq>::eq(move _96, _123) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        switchInt(move _95) -> [0: bb96, otherwise: bb94];
    }

    bb94: {
        _122 = const _;
        _98 = page_table::_::<impl PageTableFlags>::bits(_122) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _97 = page_table::_::InternalBitFlags(move _98);
        _0 = Option::<page_table::_::InternalBitFlags>::Some(move _97);
        goto -> bb97;
    }

    bb96: {
        _0 = Option::<page_table::_::InternalBitFlags>::None;
        goto -> bb97;
    }

    bb97: {
        return;
    }
}

promoted[0] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[14] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[15] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[16] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[17] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[18] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[19] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[20] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[21] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[22] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[23] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &PageTableFlags = {
    let mut _0: &structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::PageTableFlags;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[24] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NO_EXECUTE";
        _0 = &_1;
        return;
    }
}

promoted[25] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_62";
        _0 = &_1;
        return;
    }
}

promoted[26] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_61";
        _0 = &_1;
        return;
    }
}

promoted[27] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_60";
        _0 = &_1;
        return;
    }
}

promoted[28] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_59";
        _0 = &_1;
        return;
    }
}

promoted[29] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_58";
        _0 = &_1;
        return;
    }
}

promoted[30] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_57";
        _0 = &_1;
        return;
    }
}

promoted[31] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_56";
        _0 = &_1;
        return;
    }
}

promoted[32] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_55";
        _0 = &_1;
        return;
    }
}

promoted[33] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_54";
        _0 = &_1;
        return;
    }
}

promoted[34] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_53";
        _0 = &_1;
        return;
    }
}

promoted[35] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_52";
        _0 = &_1;
        return;
    }
}

promoted[36] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_11";
        _0 = &_1;
        return;
    }
}

promoted[37] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_10";
        _0 = &_1;
        return;
    }
}

promoted[38] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "BIT_9";
        _0 = &_1;
        return;
    }
}

promoted[39] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "GLOBAL";
        _0 = &_1;
        return;
    }
}

promoted[40] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "HUGE_PAGE";
        _0 = &_1;
        return;
    }
}

promoted[41] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "DIRTY";
        _0 = &_1;
        return;
    }
}

promoted[42] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ACCESSED";
        _0 = &_1;
        return;
    }
}

promoted[43] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "NO_CACHE";
        _0 = &_1;
        return;
    }
}

promoted[44] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "WRITE_THROUGH";
        _0 = &_1;
        return;
    }
}

promoted[45] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "USER_ACCESSIBLE";
        _0 = &_1;
        return;
    }
}

promoted[46] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "WRITABLE";
        _0 = &_1;
        return;
    }
}

promoted[47] in page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "PRESENT";
        _0 = &_1;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Eq(move _2, const _);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::paging::page_table::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_2);
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = Eq(move _3, const _);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;
    let _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: u64;
    let mut _7: u64;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _5 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = page_table::_::InternalBitFlags::bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = BitOr(move _3, move _6);
        _7 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Eq(move _2, move _7);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::paging::page_table::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::paging::page_table::_::InternalBitFlags;
    let _6: structures::paging::page_table::_::InternalBitFlags;
    let mut _7: u64;
    let mut _8: &structures::paging::page_table::_::InternalBitFlags;
    let mut _9: u64;
    let mut _10: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &_6;
        ConstEvalCounter;
        _4 = page_table::_::InternalBitFlags::bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_5);
        StorageLive(_7);
        StorageLive(_8);
        _8 = &(*_2);
        ConstEvalCounter;
        _7 = page_table::_::InternalBitFlags::bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_8);
        _3 = BitOr(move _4, move _7);
        StorageDead(_7);
        StorageDead(_4);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &(*_2);
        ConstEvalCounter;
        _9 = page_table::_::InternalBitFlags::bits(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_10);
        _0 = Eq(move _3, move _9);
        StorageDead(_9);
        StorageDead(_3);
        StorageDead(_2);
        StorageDead(_6);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _0 = Ne(move _4, const _);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        _0 = Ne(move _5, const _);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        let _3: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _3;
        }
    }

    bb0: {
        _3 = _2;
        _5 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = BitAnd(move _5, move _6);
        _9 = &_3;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Eq(move _4, move _8);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    let mut _10: u64;
    let mut _11: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_3);
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        StorageLive(_10);
        StorageLive(_11);
        _11 = &_4;
        ConstEvalCounter;
        _10 = page_table::_::InternalBitFlags::bits(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_11);
        _0 = Eq(move _5, move _10);
        StorageDead(_10);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = page_table::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::InternalBitFlags::union(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = page_table::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::InternalBitFlags::difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = page_table::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::InternalBitFlags::symmetric_difference(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let _4: ();
    let _5: ();
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = page_table::_::InternalBitFlags::insert(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _5 = page_table::_::InternalBitFlags::remove(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, move _8);
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitOr(move _6, move _8);
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitOr(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = &_4;
        _9 = page_table::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(move _9);
        _5 = BitAnd(move _6, move _8);
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        StorageLive(_10);
        _10 = &_4;
        ConstEvalCounter;
        _9 = page_table::_::InternalBitFlags::bits(move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_10);
        _8 = Not(move _9);
        StorageDead(_9);
        _5 = BitAnd(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _7 = &_3;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_4;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitXor(move _6, move _8);
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;
    let mut _8: u64;
    let mut _9: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &_3;
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = &_4;
        ConstEvalCounter;
        _8 = page_table::_::InternalBitFlags::bits(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_9);
        _5 = BitXor(move _6, move _8);
        StorageDead(_8);
        StorageDead(_6);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _2: structures::paging::page_table::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        _2 = _1;
        _5 = &_2;
        _4 = page_table::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = page_table::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let _2: structures::paging::page_table::_::InternalBitFlags;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = &_2;
        ConstEvalCounter;
        _4 = page_table::_::InternalBitFlags::bits(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_5);
        _3 = Not(move _4);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::from_bits_truncate(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &page_table::_::InternalBitFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &u64;

    bb0: {
        _3 = &((*_1).0: u64);
        _0 = <u64 as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::InternalBitFlags::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::InternalBitFlags::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _6 = &(*_1);
        _5 = page_table::_::InternalBitFlags::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = page_table::_::InternalBitFlags::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::InternalBitFlags::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut page_table::_::InternalBitFlags, _2: page_table::_::InternalBitFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::InternalBitFlags::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: page_table::_::InternalBitFlags) -> page_table::_::InternalBitFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut page_table::_::InternalBitFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::paging::page_table::_::InternalBitFlags);
        _5 = page_table::_::InternalBitFlags::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> page_table::_::InternalBitFlags {
    debug iterator => _1;
    let mut _0: structures::paging::page_table::_::InternalBitFlags;
    let mut _2: structures::paging::page_table::_::InternalBitFlags;
    let _3: ();
    let mut _4: &mut structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <page_table::_::InternalBitFlags as Extend<page_table::_::InternalBitFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &page_table::_::InternalBitFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;

    bb0: {
        _3 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<PageTableFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &page_table::_::InternalBitFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<PageTableFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &page_table::_::InternalBitFlags) -> IterNames<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;

    bb0: {
        _3 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = page_table::_::InternalBitFlags::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<PageTableFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &page_table::_::InternalBitFlags) -> IterNames<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = page_table::_::InternalBitFlags::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<PageTableFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: page_table::_::InternalBitFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _2 = &_1;
        _0 = page_table::_::InternalBitFlags::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/internal.rs:117:9: 117:31>::bits_mut(_1: &mut page_table::_::InternalBitFlags) -> &mut u64 {
    debug self => _1;
    let mut _0: &mut u64;

    bb0: {
        _0 = &mut ((*_1).0: u64);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _1 = page_table::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::empty() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = page_table::_::InternalBitFlags::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _1 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::all() -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _1: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = page_table::_::InternalBitFlags::all() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _1);
        StorageDead(_1);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &PageTableFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::bits(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::bits(_1: &PageTableFlags) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &structures::paging::page_table::PageTableFlags;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<PageTableFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _2: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug bits => _1;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<PageTableFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::paging::page_table::_::InternalBitFlags);
        _5 = PageTableFlags(_4);
        _0 = Option::<PageTableFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits(_1: u64) -> Option<PageTableFlags> {
    debug bits => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let _2: u64;
    let mut _3: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let mut _4: u64;
    let mut _5: isize;
    let mut _7: structures::paging::page_table::PageTableFlags;
    let mut _8: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _2;
        let _6: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug bits => _6;
        }
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::from_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Option::<PageTableFlags>::None;
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        StorageLive(_6);
        _6 = ((_3 as Some).0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_7);
        StorageLive(_8);
        _8 = _6;
        _7 = PageTableFlags(move _8);
        StorageDead(_8);
        _0 = Option::<PageTableFlags>::Some(move _7);
        StorageDead(_7);
        StorageDead(_6);
        goto -> bb5;
    }

    bb5: {
        StorageDead(_2);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::from_bits_truncate(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_truncate(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _2: u64;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::from_bits_truncate(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageTableFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug bits => _1;
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_bits_retain(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _2: u64;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: u64;
    scope 1 {
        debug bits => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::from_bits_retain(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageTableFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::from_name(_1: &str) -> Option<PageTableFlags> {
    debug name => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _2: core::option::Option<structures::paging::page_table::_::InternalBitFlags>;
    let mut _3: isize;
    let mut _5: structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug name => _1;
        let _4: structures::paging::page_table::_::InternalBitFlags;
        scope 2 {
            debug bits => _4;
        }
    }

    bb0: {
        _2 = page_table::_::InternalBitFlags::from_name(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb3, otherwise: bb5];
    }

    bb2: {
        _0 = Option::<PageTableFlags>::None;
        goto -> bb4;
    }

    bb3: {
        _4 = ((_2 as Some).0: structures::paging::page_table::_::InternalBitFlags);
        _5 = PageTableFlags(_4);
        _0 = Option::<PageTableFlags>::Some(move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }

    bb5: {
        unreachable;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::is_empty(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_empty(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::paging::page_table::PageTableFlags;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _2 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::is_all(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::is_all(_1: &PageTableFlags) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &structures::paging::page_table::PageTableFlags;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        _3 = &((*_2).0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::is_all(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::intersects(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersects(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::paging::page_table::PageTableFlags;
    let mut _5: &structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::intersects(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::contains(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::contains(_1: &PageTableFlags, _2: PageTableFlags) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: &structures::paging::page_table::PageTableFlags;
    let mut _5: &structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        _5 = &((*_3).0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_6);
        _6 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _0 = page_table::_::InternalBitFlags::contains(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_6);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::insert(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::insert(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::remove(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::remove(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::toggle(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: &mut structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _3 = &mut ((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::toggle(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::set(_1: &mut PageTableFlags, _2: PageTableFlags, _3: bool) -> () {
    debug self => _1;
    debug other => _2;
    debug value => _3;
    let mut _0: ();
    let mut _4: &mut structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
            scope 3 {
                debug value => _3;
            }
        }
    }

    bb0: {
        _4 = &mut ((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _5 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _0 = page_table::_::InternalBitFlags::set(move _4, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::paging::page_table::_::InternalBitFlags);
        _5 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _3 = page_table::_::InternalBitFlags::intersection(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::intersection(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _3: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    let mut _7: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = page_table::_::InternalBitFlags::intersection(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageTableFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::paging::page_table::_::InternalBitFlags);
        _5 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _3 = page_table::_::InternalBitFlags::union(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::union(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _3: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    let mut _7: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = page_table::_::InternalBitFlags::union(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageTableFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::paging::page_table::_::InternalBitFlags);
        _5 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _3 = page_table::_::InternalBitFlags::difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _3: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    let mut _7: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = page_table::_::InternalBitFlags::difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageTableFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
        scope 2 {
            debug other => _2;
        }
    }

    bb0: {
        _4 = (_1.0: structures::paging::page_table::_::InternalBitFlags);
        _5 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        _3 = page_table::_::InternalBitFlags::symmetric_difference(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _3);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::symmetric_difference(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _3: structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::_::InternalBitFlags;
    let mut _6: structures::paging::page_table::_::InternalBitFlags;
    let mut _7: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _3;
        let _4: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug other => _4;
        }
    }

    bb0: {
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = _2;
        StorageLive(_5);
        StorageLive(_6);
        _6 = (_3.0: structures::paging::page_table::_::InternalBitFlags);
        StorageLive(_7);
        _7 = (_4.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _5 = page_table::_::InternalBitFlags::symmetric_difference(move _6, move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_7);
        StorageDead(_6);
        _0 = PageTableFlags(move _5);
        StorageDead(_5);
        StorageDead(_4);
        StorageDead(_3);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::_::InternalBitFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _1;
    }

    bb0: {
        _3 = (_1.0: structures::paging::page_table::_::InternalBitFlags);
        _2 = page_table::_::InternalBitFlags::complement(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTableFlags(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/lib.rs:618:9: 618:29>::complement(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let _2: structures::paging::page_table::PageTableFlags;
    let mut _3: structures::paging::page_table::_::InternalBitFlags;
    let mut _4: structures::paging::page_table::_::InternalBitFlags;
    scope 1 {
        debug f => _2;
    }

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = (_2.0: structures::paging::page_table::_::InternalBitFlags);
        ConstEvalCounter;
        _3 = page_table::_::InternalBitFlags::complement(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        _0 = PageTableFlags(move _3);
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:319:9: 319:70>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as Binary>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:328:9: 328:69>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as Octal>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:337:9: 337:72>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as LowerHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:346:9: 346:72>::fmt(_1: &PageTableFlags, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _3 = &((*_1).0: structures::paging::page_table::_::InternalBitFlags);
        _0 = <page_table::_::InternalBitFlags as UpperHex>::fmt(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:355:9: 355:69>::bitor(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::union(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:365:9: 365:75>::bitor_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::<impl PageTableFlags>::insert(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:373:9: 373:70>::bitxor(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::symmetric_difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:383:9: 383:76>::bitxor_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::<impl PageTableFlags>::toggle(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:391:9: 391:70>::bitand(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::intersection(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:401:9: 401:76>::bitand_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: structures::paging::page_table::PageTableFlags;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;
    let mut _6: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _6 = &(*_1);
        _5 = page_table::_::<impl PageTableFlags>::bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = page_table::_::<impl PageTableFlags>::intersection(move _4, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        (*_1) = move _3;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:409:9: 409:67>::sub(_1: PageTableFlags, _2: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    debug other => _2;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::difference(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:422:9: 422:73>::sub_assign(_1: &mut PageTableFlags, _2: PageTableFlags) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = page_table::_::<impl PageTableFlags>::remove(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:433:9: 433:67>::not(_1: PageTableFlags) -> PageTableFlags {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::complement(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:443:9: 443:88>::extend(_1: &mut PageTableFlags, _2: T) -> () {
    debug self => _1;
    debug iterator => _2;
    let mut _0: ();
    let mut _3: <T as core::iter::IntoIterator>::IntoIter;
    let mut _4: <T as core::iter::IntoIterator>::IntoIter;
    let _5: ();
    let mut _6: core::option::Option<structures::paging::page_table::PageTableFlags>;
    let mut _7: &mut <T as core::iter::IntoIterator>::IntoIter;
    let mut _8: isize;
    scope 1 {
        debug iter => _4;
        let _9: structures::paging::page_table::PageTableFlags;
        scope 2 {
            debug item => _9;
        }
    }

    bb0: {
        _3 = <T as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _3;
        goto -> bb2;
    }

    bb2: {
        _7 = &mut _4;
        _6 = <<T as IntoIterator>::IntoIter as Iterator>::next(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb7];
    }

    bb4: {
        _9 = ((_6 as Some).0: structures::paging::page_table::PageTableFlags);
        _5 = page_table::_::<impl PageTableFlags>::insert(_1, _9) -> [return: bb2, unwind unreachable];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:455:9: 455:94>::from_iter(_1: T) -> PageTableFlags {
    debug iterator => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let _3: ();
    let mut _4: &mut structures::paging::page_table::PageTableFlags;
    scope 1 {
        debug result => _2;
    }

    bb0: {
        _2 = page_table::_::<impl PageTableFlags>::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <PageTableFlags as Extend<PageTableFlags>>::extend::<T>(move _4, move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = _2;
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &PageTableFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;

    bb0: {
        _3 = page_table::_::<impl PageTableFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = page_table::_::<impl PageTableFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = bitflags::iter::Iter::<PageTableFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter(_1: &PageTableFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = page_table::_::<impl PageTableFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = page_table::_::<impl PageTableFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = bitflags::iter::Iter::<PageTableFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &PageTableFlags) -> IterNames<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: structures::paging::page_table::PageTableFlags;
    let mut _5: u64;

    bb0: {
        _3 = page_table::_::<impl PageTableFlags>::bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = page_table::_::<impl PageTableFlags>::bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = IterNames::<PageTableFlags>::__private_const_new(const _, move _2, move _4) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:275:9: 275:23>::iter_names(_1: &PageTableFlags) -> IterNames<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::IterNames<structures::paging::page_table::PageTableFlags>;
    let mut _2: structures::paging::page_table::PageTableFlags;
    let mut _3: u64;
    let mut _4: &structures::paging::page_table::PageTableFlags;
    let mut _5: structures::paging::page_table::PageTableFlags;
    let mut _6: u64;
    let mut _7: &structures::paging::page_table::PageTableFlags;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &(*_1);
        ConstEvalCounter;
        _3 = page_table::_::<impl PageTableFlags>::bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_4);
        ConstEvalCounter;
        _2 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageLive(_5);
        StorageLive(_6);
        StorageLive(_7);
        _7 = &(*_1);
        ConstEvalCounter;
        _6 = page_table::_::<impl PageTableFlags>::bits(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageDead(_7);
        ConstEvalCounter;
        _5 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        StorageDead(_6);
        ConstEvalCounter;
        _0 = IterNames::<PageTableFlags>::__private_const_new(const _, move _2, move _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        StorageDead(_5);
        StorageDead(_2);
        return;
    }
}

fn page_table::_::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-2.4.1/src/public.rs:303:9: 303:71>::into_iter(_1: PageTableFlags) -> bitflags::iter::Iter<PageTableFlags> {
    debug self => _1;
    let mut _0: bitflags::iter::Iter<structures::paging::page_table::PageTableFlags>;
    let mut _2: &structures::paging::page_table::PageTableFlags;

    bb0: {
        _2 = &_1;
        _0 = page_table::_::<impl PageTableFlags>::iter(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:172:1: 172:20>::from_bits_unchecked(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:172:1: 172:20>::from_bits_unchecked(_1: u64) -> PageTableFlags {
    debug bits => _1;
    let mut _0: structures::paging::page_table::PageTableFlags;
    let mut _2: u64;

    bb0: {
        StorageLive(_2);
        _2 = _1;
        ConstEvalCounter;
        _0 = page_table::_::<impl PageTableFlags>::from_bits_retain(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageDead(_2);
        return;
    }
}

const ENTRY_COUNT: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 512_usize;
        return;
    }
}

PageTable::entries::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:194:10: 194:15>::clone(_1: &PageTable) -> PageTable {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTable;
    let mut _2: [structures::paging::page_table::PageTableEntry; 512];
    let _3: &[structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _3 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _2 = <[PageTableEntry; 512] as Clone>::clone(_3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = PageTable { entries: move _2 };
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::new() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;
    let mut _1: [structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _1 = [const _; 512];
        _0 = PageTable { entries: move _1 };
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::new() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;
    let mut _1: [structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        StorageLive(_1);
        _1 = [const _; 512];
        _0 = PageTable { entries: move _1 };
        StorageDead(_1);
        return;
    }
}

const page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::new::EMPTY: PageTableEntry = {
    let mut _0: structures::paging::page_table::PageTableEntry;

    bb0: {
        ConstEvalCounter;
        _0 = PageTableEntry::new() -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::zero(_1: &mut PageTable) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _3: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _4: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _5: core::option::Option<&mut structures::paging::page_table::PageTableEntry>;
    let mut _6: &mut core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let mut _7: isize;
    let _9: ();
    scope 1 {
        debug iter => _4;
        let _8: &mut structures::paging::page_table::PageTableEntry;
        scope 2 {
            debug entry => _8;
        }
    }

    bb0: {
        _3 = PageTable::iter_mut(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}> as IntoIterator>::into_iter(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move _2;
        goto -> bb3;
    }

    bb3: {
        _6 = &mut _4;
        _5 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}> as Iterator>::next(_6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb6, 1: bb5, otherwise: bb7];
    }

    bb5: {
        _8 = move ((_5 as Some).0: &mut structures::paging::page_table::PageTableEntry);
        _9 = PageTableEntry::set_unused(_8) -> [return: bb3, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::iter(_1: &PageTable) -> Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}> {
    debug self => _1;
    let mut _0: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _2: core::ops::Range<usize>;
    let mut _3: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30};

    bb0: {
        _2 = Range::<usize> { start: const 0_usize, end: const 512_usize };
        _3 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30} { self: _1 };
        _0 = <Range<usize> as Iterator>::map::<&PageTableEntry, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>(move _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::iter::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}, _2: usize) -> &PageTableEntry {
    debug i => _2;
    debug self => ((*_1).0: &structures::paging::page_table::PageTable);
    let mut _0: &structures::paging::page_table::PageTableEntry;
    let mut _3: usize;
    let mut _4: bool;
    let mut _5: &structures::paging::page_table::PageTable;

    bb0: {
        _3 = const 512_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = deref_copy ((*_1).0: &structures::paging::page_table::PageTable);
        _0 = &((*_5).0: [structures::paging::page_table::PageTableEntry; 512])[_2];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::iter_mut(_1: &mut PageTable) -> Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}> {
    debug self => _1;
    let mut _0: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>;
    let _2: *mut structures::paging::page_table::PageTableEntry;
    let mut _3: &mut [structures::paging::page_table::PageTableEntry];
    let mut _4: &mut [structures::paging::page_table::PageTableEntry; 512];
    let mut _5: core::ops::Range<usize>;
    let mut _6: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30};
    scope 1 {
        debug ptr => _2;
    }

    bb0: {
        _4 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _3 = move _4 as &mut [structures::paging::page_table::PageTableEntry] (PointerCoercion(Unsize));
        _2 = slice::<impl [PageTableEntry]>::as_mut_ptr(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Range::<usize> { start: const 0_usize, end: const 512_usize };
        _6 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30} { ptr: _2 };
        _0 = <Range<usize> as Iterator>::map::<&mut PageTableEntry, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}>(move _5, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::iter_mut::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:241:22: 241:30}, _2: usize) -> &mut PageTableEntry {
    debug i => _2;
    debug ptr => ((*_1).0: *mut structures::paging::page_table::PageTableEntry);
    let mut _0: &mut structures::paging::page_table::PageTableEntry;
    let mut _3: *mut structures::paging::page_table::PageTableEntry;
    let mut _4: *mut structures::paging::page_table::PageTableEntry;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut structures::paging::page_table::PageTableEntry);
        _3 = core::ptr::mut_ptr::<impl *mut PageTableEntry>::add(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &mut (*_3);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::is_empty(_1: &PageTable) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &mut core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;
    let mut _3: core::iter::Map<core::ops::Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}>;

    bb0: {
        _3 = PageTable::iter(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = &mut _3;
        _0 = <Map<Range<usize>, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:220:22: 220:30}> as Iterator>::all::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:247:25: 247:32}>(move _2, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:247:25: 247:32}) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:199:1: 199:15>::is_empty::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:247:25: 247:32}, _2: &PageTableEntry) -> bool {
    debug entry => _2;
    let mut _0: bool;

    bb0: {
        _0 = PageTableEntry::is_unused(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:251:1: 251:32>::index(_1: &PageTable, _2: usize) -> &PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::paging::page_table::PageTableEntry;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const 512_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_2];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:260:1: 260:35>::index_mut(_1: &mut PageTable, _2: usize) -> &mut PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::paging::page_table::PageTableEntry;
    let mut _3: usize;
    let mut _4: bool;

    bb0: {
        _3 = const 512_usize;
        _4 = Lt(_2, _3);
        assert(move _4, "index out of bounds: the length is {} but the index is {}", move _3, _2) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_2];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:267:1: 267:41>::index(_1: &PageTable, _2: PageTableIndex) -> &PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &structures::paging::page_table::PageTableEntry;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;

    bb0: {
        _3 = <usize as From<PageTableIndex>>::from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 512_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_3];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:276:1: 276:44>::index_mut(_1: &mut PageTable, _2: PageTableIndex) -> &mut PageTableEntry {
    debug self => _1;
    debug index => _2;
    let mut _0: &mut structures::paging::page_table::PageTableEntry;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;

    bb0: {
        _3 = <usize as From<PageTableIndex>>::from(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 512_usize;
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _0 = &mut ((*_1).0: [structures::paging::page_table::PageTableEntry; 512])[_3];
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:283:1: 283:27>::default() -> PageTable {
    let mut _0: structures::paging::page_table::PageTable;

    bb0: {
        _0 = PageTable::new() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:289:1: 289:30>::fmt(_1: &PageTable, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &[structures::paging::page_table::PageTableEntry];
    let mut _4: &[structures::paging::page_table::PageTableEntry; 512];

    bb0: {
        _4 = &((*_1).0: [structures::paging::page_table::PageTableEntry; 512]);
        _3 = <[PageTableEntry; 512] as Index<RangeFull>>::index(move _4, const RangeFull) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = <[PageTableEntry] as Debug>::fmt(_3, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:10: 301:15>::fmt(_1: &PageTableIndex, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "PageTableIndex";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:17: 301:22>::clone(_1: &PageTableIndex) -> PageTableIndex {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:30: 301:39>::eq(_1: &PageTableIndex, _2: &PageTableIndex) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:41: 301:43>::assert_receiver_is_total_eq(_1: &PageTableIndex) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:45: 301:55>::partial_cmp(_1: &PageTableIndex, _2: &PageTableIndex) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:57: 301:60>::cmp(_1: &PageTableIndex, _2: &PageTableIndex) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:301:62: 301:66>::hash(_1: &PageTableIndex, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:304:1: 304:20>::new(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: !;

    bb0: {
        _3 = <usize as From<u16>>::from(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Lt(move _3, const _);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = PageTableIndex(_1);
        return;
    }

    bb3: {
        _4 = panic(const "assertion failed: usize::from(index) < ENTRY_COUNT") -> unwind unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:304:1: 304:20>::new_truncate(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: bool;

    bb0: {
        _3 = const _ as u16 (IntToInt);
        _4 = Eq(_3, const 0_u16);
        assert(!move _4, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Rem(_1, move _3);
        _0 = PageTableIndex(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:304:1: 304:20>::new_truncate(_1: u16) -> PageTableIndex {
    debug index => _1;
    let mut _0: structures::paging::page_table::PageTableIndex;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _4 = const _ as u16 (IntToInt);
        _5 = Eq(_4, const 0_u16);
        assert(!move _5, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageTableIndex(move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:319:1: 319:34>::from(_1: PageTableIndex) -> u16 {
    debug index => _1;
    let mut _0: u16;

    bb0: {
        _0 = (_1.0: u16);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:326:1: 326:34>::from(_1: PageTableIndex) -> u32 {
    debug index => _1;
    let mut _0: u32;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u32 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:333:1: 333:34>::from(_1: PageTableIndex) -> u64 {
    debug index => _1;
    let mut _0: u64;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u64 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:340:1: 340:36>::from(_1: PageTableIndex) -> usize {
    debug index => _1;
    let mut _0: usize;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <usize as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:10: 352:15>::fmt(_1: &PageOffset, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn core::fmt::Debug;
    let _5: &&u16;
    let _6: &u16;

    bb0: {
        _3 = const "PageOffset";
        _6 = &((*_1).0: u16);
        _5 = &_6;
        _4 = _5 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:17: 352:22>::clone(_1: &PageOffset) -> PageOffset {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:30: 352:39>::eq(_1: &PageOffset, _2: &PageOffset) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = ((*_1).0: u16);
        _4 = ((*_2).0: u16);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:41: 352:43>::assert_receiver_is_total_eq(_1: &PageOffset) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:45: 352:55>::partial_cmp(_1: &PageOffset, _2: &PageOffset) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:57: 352:60>::cmp(_1: &PageOffset, _2: &PageOffset) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: &u16;
    let _4: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _4 = &((*_2).0: u16);
        _0 = <u16 as Ord>::cmp(_3, _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:352:62: 352:66>::hash(_1: &PageOffset, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: &u16;

    bb0: {
        _3 = &((*_1).0: u16);
        _0 = <u16 as Hash>::hash::<__H>(_3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:355:1: 355:16>::new(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: bool;
    let mut _3: u16;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: !;

    bb0: {
        _4 = const 12_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 16_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u16, const 12_i32);
        _2 = Lt(_1, move _3);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = PageOffset(_1);
        return;
    }

    bb3: {
        _6 = panic(const "assertion failed: offset < (1 << 12)") -> unwind unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:355:1: 355:16>::new_truncate(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: bool;

    bb0: {
        _4 = const 12_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 16_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Shl(const 1_u16, const 12_i32);
        _6 = Eq(_3, const 0_u16);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(_1, move _3);
        _0 = PageOffset(move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:355:1: 355:16>::new_truncate(_1: u16) -> PageOffset {
    debug offset => _1;
    let mut _0: structures::paging::page_table::PageOffset;
    let mut _2: u16;
    let mut _3: u16;
    let mut _4: u16;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = _1;
        StorageLive(_4);
        _5 = const 12_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 16_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(const 1_u16, const 12_i32);
        _7 = Eq(_4, const 0_u16);
        assert(!move _7, "attempt to calculate the remainder of `{}` with a divisor of zero", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Rem(move _3, move _4);
        StorageDead(_4);
        StorageDead(_3);
        _0 = PageOffset(move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:370:1: 370:30>::from(_1: PageOffset) -> u16 {
    debug offset => _1;
    let mut _0: u16;

    bb0: {
        _0 = (_1.0: u16);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:377:1: 377:30>::from(_1: PageOffset) -> u32 {
    debug offset => _1;
    let mut _0: u32;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u32 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:384:1: 384:30>::from(_1: PageOffset) -> u64 {
    debug offset => _1;
    let mut _0: u64;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <u64 as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:391:1: 391:32>::from(_1: PageOffset) -> usize {
    debug offset => _1;
    let mut _0: usize;
    let mut _2: u16;

    bb0: {
        _2 = (_1.0: u16);
        _0 = <usize as From<u16>>::from(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

PageTableLevel::One::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 1_isize;
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:10: 398:15>::fmt(_1: &PageTableLevel, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [1: bb2, 2: bb3, 3: bb4, 4: bb1, otherwise: bb7];
    }

    bb1: {
        _8 = const "Four";
        _3 = _8;
        goto -> bb5;
    }

    bb2: {
        _5 = const "One";
        _3 = _5;
        goto -> bb5;
    }

    bb3: {
        _6 = const "Two";
        _3 = _6;
        goto -> bb5;
    }

    bb4: {
        _7 = const "Three";
        _3 = _7;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:17: 398:22>::clone(_1: &PageTableLevel) -> PageTableLevel {
    debug self => _1;
    let mut _0: structures::paging::page_table::PageTableLevel;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:30: 398:39>::eq(_1: &PageTableLevel, _2: &PageTableLevel) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:41: 398:43>::assert_receiver_is_total_eq(_1: &PageTableLevel) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:45: 398:55>::partial_cmp(_1: &PageTableLevel, _2: &PageTableLevel) -> Option<core::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: core::option::Option<core::cmp::Ordering>;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as PartialOrd>::partial_cmp(_5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:57: 398:60>::cmp(_1: &PageTableLevel, _2: &PageTableLevel) -> core::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: core::cmp::Ordering;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as Ord>::cmp(_5, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:398:62: 398:66>::hash(_1: &PageTableLevel, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: isize;
    let _4: &isize;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <isize as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::next_lower_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb4, 3: bb3, 4: bb2, otherwise: bb6];
    }

    bb1: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb5;
    }

    bb2: {
        _3 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _3);
        goto -> bb5;
    }

    bb3: {
        _4 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _4);
        goto -> bb5;
    }

    bb4: {
        _5 = PageTableLevel::One;
        _0 = Option::<PageTableLevel>::Some(move _5);
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::next_lower_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb5, 3: bb4, 4: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        StorageLive(_3);
        _3 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb4: {
        StorageLive(_4);
        _4 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_5);
        _5 = PageTableLevel::One;
        _0 = Option::<PageTableLevel>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::next_higher_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb4, 3: bb3, 4: bb2, otherwise: bb6];
    }

    bb1: {
        _5 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _5);
        goto -> bb5;
    }

    bb2: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb5;
    }

    bb3: {
        _3 = PageTableLevel::Four;
        _0 = Option::<PageTableLevel>::Some(move _3);
        goto -> bb5;
    }

    bb4: {
        _4 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _4);
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::next_higher_level(_1: PageTableLevel) -> Option<PageTableLevel> {
    debug self => _1;
    let mut _0: core::option::Option<structures::paging::page_table::PageTableLevel>;
    let mut _2: isize;
    let mut _3: structures::paging::page_table::PageTableLevel;
    let mut _4: structures::paging::page_table::PageTableLevel;
    let mut _5: structures::paging::page_table::PageTableLevel;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb1, 2: bb5, 3: bb4, 4: bb3, otherwise: bb2];
    }

    bb1: {
        StorageLive(_5);
        _5 = PageTableLevel::Two;
        _0 = Option::<PageTableLevel>::Some(move _5);
        StorageDead(_5);
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = Option::<PageTableLevel>::None;
        goto -> bb6;
    }

    bb4: {
        StorageLive(_3);
        _3 = PageTableLevel::Four;
        _0 = Option::<PageTableLevel>::Some(move _3);
        StorageDead(_3);
        goto -> bb6;
    }

    bb5: {
        StorageLive(_4);
        _4 = PageTableLevel::Three;
        _0 = Option::<PageTableLevel>::Some(move _4);
        StorageDead(_4);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::table_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: isize;
    let mut _6: u8;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: (u8, bool);
    let mut _11: (u8, bool);
    let mut _12: bool;

    bb0: {
        _5 = discriminant(_1);
        _6 = _5 as u8 (IntToInt);
        _7 = Ge(_6, const 1_u8);
        _8 = Le(_6, const 4_u8);
        _9 = BitAnd(move _7, move _8);
        assume(move _9);
        _4 = move _5 as u8 (IntToInt);
        _10 = CheckedMul(_4, const 9_u8);
        assert(!move (_10.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_10.0: u8);
        _11 = CheckedAdd(_3, const 12_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = move (_11.0: u8);
        _12 = Lt(_2, const 64_u8);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Shl(const 1_u64, move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::table_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let _5: structures::paging::page_table::PageTableLevel;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: (u8, bool);
    let mut _12: (u8, bool);
    let mut _13: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        _6 = discriminant(_5);
        _7 = _6 as u8 (IntToInt);
        _8 = Ge(_7, const 1_u8);
        _9 = Le(_7, const 4_u8);
        _10 = BitAnd(move _8, move _9);
        assume(move _10);
        _4 = move _6 as u8 (IntToInt);
        StorageDead(_5);
        _11 = CheckedMul(_4, const 9_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_11.0: u8);
        StorageDead(_4);
        _12 = CheckedAdd(_3, const 12_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = move (_12.0: u8);
        StorageDead(_3);
        _13 = Lt(_2, const 64_u8);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Shl(const 1_u64, move _2);
        StorageDead(_2);
        return;
    }
}

fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::entry_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: (u8, bool);
    let mut _12: (u8, bool);
    let mut _13: (u8, bool);
    let mut _14: bool;

    bb0: {
        _6 = discriminant(_1);
        _7 = _6 as u8 (IntToInt);
        _8 = Ge(_7, const 1_u8);
        _9 = Le(_7, const 4_u8);
        _10 = BitAnd(move _8, move _9);
        assume(move _10);
        _5 = move _6 as u8 (IntToInt);
        _11 = CheckedSub(_5, const 1_u8);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, const 1_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move (_11.0: u8);
        _12 = CheckedMul(_4, const 9_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_12.0: u8);
        _13 = CheckedAdd(_3, const 12_u8);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move (_13.0: u8);
        _14 = Lt(_2, const 64_u8);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Shl(const 1_u64, move _2);
        return;
    }
}

// MIR FOR CTFE
fn page_table::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/paging/page_table.rs:411:1: 411:20>::entry_address_space_alignment(_1: PageTableLevel) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: u8;
    let _6: structures::paging::page_table::PageTableLevel;
    let mut _7: isize;
    let mut _8: u8;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: (u8, bool);
    let mut _13: (u8, bool);
    let mut _14: (u8, bool);
    let mut _15: bool;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _7 = discriminant(_6);
        _8 = _7 as u8 (IntToInt);
        _9 = Ge(_8, const 1_u8);
        _10 = Le(_8, const 4_u8);
        _11 = BitAnd(move _9, move _10);
        assume(move _11);
        _5 = move _7 as u8 (IntToInt);
        StorageDead(_6);
        _12 = CheckedSub(_5, const 1_u8);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, const 1_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move (_12.0: u8);
        StorageDead(_5);
        _13 = CheckedMul(_4, const 9_u8);
        assert(!move (_13.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 9_u8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _3 = move (_13.0: u8);
        StorageDead(_4);
        _14 = CheckedAdd(_3, const 12_u8);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 12_u8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move (_14.0: u8);
        StorageDead(_3);
        _15 = Lt(_2, const 64_u8);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Shl(const 1_u64, move _2);
        StorageDead(_2);
        return;
    }
}

TaskStateSegment::privilege_stack_table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

TaskStateSegment::interrupt_stack_table::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:10:10: 10:15>::fmt(_1: &TaskStateSegment, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _4: &[&dyn core::fmt::Debug; 7];
    let _5: [&dyn core::fmt::Debug; 7];
    let mut _6: &dyn core::fmt::Debug;
    let _7: &u32;
    let _8: u32;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &[addr::VirtAddr; 3];
    let _11: [addr::VirtAddr; 3];
    let mut _12: &dyn core::fmt::Debug;
    let _13: &u64;
    let _14: u64;
    let mut _15: &dyn core::fmt::Debug;
    let _16: &[addr::VirtAddr; 7];
    let _17: [addr::VirtAddr; 7];
    let mut _18: &dyn core::fmt::Debug;
    let _19: &u64;
    let _20: u64;
    let mut _21: &dyn core::fmt::Debug;
    let _22: &u16;
    let _23: u16;
    let mut _24: &dyn core::fmt::Debug;
    let _25: &&u16;
    let _26: &u16;
    let _27: u16;
    let _28: &str;
    let mut _29: &[&str];
    let mut _30: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn core::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _30 = const _;
        _8 = ((*_1).0: u32);
        _7 = &_8;
        _6 = _7 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _11 = ((*_1).1: [addr::VirtAddr; 3]);
        _10 = &_11;
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _14 = ((*_1).2: u64);
        _13 = &_14;
        _12 = _13 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _17 = ((*_1).3: [addr::VirtAddr; 7]);
        _16 = &_17;
        _15 = _16 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _20 = ((*_1).4: u64);
        _19 = &_20;
        _18 = _19 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _23 = ((*_1).5: u16);
        _22 = &_23;
        _21 = _22 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _27 = ((*_1).6: u16);
        _26 = &_27;
        _25 = &_26;
        _24 = _25 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _9, move _12, move _15, move _18, move _21, move _24];
        _4 = &_5;
        _3 = _4 as &[&dyn core::fmt::Debug] (PointerCoercion(Unsize));
        _28 = const "TaskStateSegment";
        _29 = _30 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _28, move _29, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

promoted[0] in tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:10:10: 10:15>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "privilege_stack_table";
        _2 = &(*_3);
        _5 = const "reserved_2";
        _4 = &(*_5);
        _7 = const "interrupt_stack_table";
        _6 = &(*_7);
        _9 = const "reserved_3";
        _8 = &(*_9);
        _11 = const "reserved_4";
        _10 = &(*_11);
        _13 = const "iomap_base";
        _12 = &(*_13);
        _1 = [const "reserved_1", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:10:17: 10:22>::clone(_1: &TaskStateSegment) -> TaskStateSegment {
    debug self => _1;
    let mut _0: structures::tss::TaskStateSegment;
    scope 1 {
        scope 2 {
            scope 3 {
                scope 4 {
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:10:17: 10:22>::clone::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:10:17: 10:22>::clone::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:25:1: 25:22>::new() -> TaskStateSegment {
    let mut _0: structures::tss::TaskStateSegment;
    let mut _1: [addr::VirtAddr; 3];
    let mut _2: addr::VirtAddr;
    let mut _3: [addr::VirtAddr; 7];
    let mut _4: addr::VirtAddr;
    let mut _5: u16;
    let mut _6: usize;

    bb0: {
        _2 = addr::VirtAddr::zero() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = [move _2; 3];
        _4 = addr::VirtAddr::zero() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = [move _4; 7];
        _6 = core::mem::size_of::<TaskStateSegment>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move _6 as u16 (IntToInt);
        _0 = TaskStateSegment { reserved_1: const 0_u32, privilege_stack_table: move _1, reserved_2: const 0_u64, interrupt_stack_table: move _3, reserved_3: const 0_u64, reserved_4: const 0_u16, iomap_base: move _5 };
        return;
    }
}

// MIR FOR CTFE
fn tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:25:1: 25:22>::new() -> TaskStateSegment {
    let mut _0: structures::tss::TaskStateSegment;
    let mut _1: [addr::VirtAddr; 3];
    let mut _2: addr::VirtAddr;
    let mut _3: [addr::VirtAddr; 7];
    let mut _4: addr::VirtAddr;
    let mut _5: u16;
    let mut _6: usize;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        ConstEvalCounter;
        _2 = addr::VirtAddr::zero() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = [move _2; 3];
        StorageDead(_2);
        StorageLive(_3);
        StorageLive(_4);
        ConstEvalCounter;
        _4 = addr::VirtAddr::zero() -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = [move _4; 7];
        StorageDead(_4);
        StorageLive(_5);
        StorageLive(_6);
        ConstEvalCounter;
        _6 = core::mem::size_of::<TaskStateSegment>() -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move _6 as u16 (IntToInt);
        StorageDead(_6);
        _0 = TaskStateSegment { reserved_1: const 0_u32, privilege_stack_table: move _1, reserved_2: const 0_u64, interrupt_stack_table: move _3, reserved_3: const 0_u64, reserved_4: const 0_u16, iomap_base: move _5 };
        StorageDead(_5);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:25:1: 25:22>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

tss::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/tss.rs:25:1: 25:22>::new::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 7_usize;
        return;
    }
}

fn structures::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/mod.rs:15:10: 15:15>::fmt(_1: &DescriptorTablePointer, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u16;
    let _7: u16;
    let _8: &str;
    let mut _9: &dyn core::fmt::Debug;
    let _10: &&addr::VirtAddr;
    let _11: &addr::VirtAddr;
    let _12: addr::VirtAddr;

    bb0: {
        _3 = const "DescriptorTablePointer";
        _4 = const "limit";
        _7 = ((*_1).0: u16);
        _6 = &_7;
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _8 = const "base";
        _12 = ((*_1).1: addr::VirtAddr);
        _11 = &_12;
        _10 = &_11;
        _9 = _10 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _8, move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn structures::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/structures/mod.rs:15:17: 15:22>::clone(_1: &DescriptorTablePointer) -> DescriptorTablePointer {
    debug self => _1;
    let mut _0: structures::DescriptorTablePointer;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

PrivilegeLevel::Ring0::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

PrivilegeLevel::Ring1::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

PrivilegeLevel::Ring2::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 2_u8;
        return;
    }
}

PrivilegeLevel::Ring3::{constant#0}: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 3_u8;
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:21:10: 21:15>::fmt(_1: &PrivilegeLevel, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb7];
    }

    bb1: {
        _8 = const "Ring3";
        _3 = _8;
        goto -> bb5;
    }

    bb2: {
        _5 = const "Ring0";
        _3 = _5;
        goto -> bb5;
    }

    bb3: {
        _6 = const "Ring1";
        _3 = _6;
        goto -> bb5;
    }

    bb4: {
        _7 = const "Ring2";
        _3 = _7;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }

    bb7: {
        unreachable;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:21:23: 21:28>::clone(_1: &PrivilegeLevel) -> PrivilegeLevel {
    debug self => _1;
    let mut _0: PrivilegeLevel;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:21:30: 21:39>::eq(_1: &PrivilegeLevel, _2: &PrivilegeLevel) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:21:41: 21:43>::assert_receiver_is_total_eq(_1: &PrivilegeLevel) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:21:45: 21:49>::hash(_1: &PrivilegeLevel, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: u8;
    let _4: &u8;
    scope 1 {
        debug __self_tag => _3;
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = &_3;
        _0 = <u8 as Hash>::hash::<__H>(_4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:50:1: 50:20>::from_u16(_1: u16) -> PrivilegeLevel {
    debug value => _1;
    let mut _0: PrivilegeLevel;
    let mut _2: !;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        _2 = panic(const "invalid privilege level") -> unwind unreachable;
    }

    bb2: {
        _0 = PrivilegeLevel::Ring0;
        goto -> bb6;
    }

    bb3: {
        _0 = PrivilegeLevel::Ring1;
        goto -> bb6;
    }

    bb4: {
        _0 = PrivilegeLevel::Ring2;
        goto -> bb6;
    }

    bb5: {
        _0 = PrivilegeLevel::Ring3;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

// MIR FOR CTFE
fn <impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/x86_64-0.14.11/src/lib.rs:50:1: 50:20>::from_u16(_1: u16) -> PrivilegeLevel {
    debug value => _1;
    let mut _0: PrivilegeLevel;
    let mut _2: !;

    bb0: {
        switchInt(_1) -> [0: bb2, 1: bb3, 2: bb4, 3: bb5, otherwise: bb1];
    }

    bb1: {
        StorageLive(_2);
        ConstEvalCounter;
        _2 = panic(const "invalid privilege level") -> unwind unreachable;
    }

    bb2: {
        _0 = PrivilegeLevel::Ring0;
        goto -> bb6;
    }

    bb3: {
        _0 = PrivilegeLevel::Ring1;
        goto -> bb6;
    }

    bb4: {
        _0 = PrivilegeLevel::Ring2;
        goto -> bb6;
    }

    bb5: {
        _0 = PrivilegeLevel::Ring3;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn addr::VirtAddr(_1: u64) -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn addr::VirtAddr(_1: u64) -> addr::VirtAddr {
    let mut _0: addr::VirtAddr;

    bb0: {
        _0 = addr::VirtAddr(move _1);
        return;
    }
}

fn PhysAddr(_1: u64) -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PhysAddr(_1: u64) -> PhysAddr {
    let mut _0: addr::PhysAddr;

    bb0: {
        _0 = PhysAddr(move _1);
        return;
    }
}

fn VirtAddrNotValid(_1: u64) -> VirtAddrNotValid {
    let mut _0: addr::VirtAddrNotValid;

    bb0: {
        _0 = VirtAddrNotValid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn VirtAddrNotValid(_1: u64) -> VirtAddrNotValid {
    let mut _0: addr::VirtAddrNotValid;

    bb0: {
        _0 = VirtAddrNotValid(move _1);
        return;
    }
}

fn PhysAddrNotValid(_1: u64) -> PhysAddrNotValid {
    let mut _0: addr::PhysAddrNotValid;

    bb0: {
        _0 = PhysAddrNotValid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PhysAddrNotValid(_1: u64) -> PhysAddrNotValid {
    let mut _0: addr::PhysAddrNotValid;

    bb0: {
        _0 = PhysAddrNotValid(move _1);
        return;
    }
}

fn ReadOnlyAccess(_1: ()) -> ReadOnlyAccess {
    let mut _0: instructions::port::ReadOnlyAccess;

    bb0: {
        _0 = ReadOnlyAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ReadOnlyAccess(_1: ()) -> ReadOnlyAccess {
    let mut _0: instructions::port::ReadOnlyAccess;

    bb0: {
        _0 = ReadOnlyAccess(move _1);
        return;
    }
}

fn WriteOnlyAccess(_1: ()) -> WriteOnlyAccess {
    let mut _0: instructions::port::WriteOnlyAccess;

    bb0: {
        _0 = WriteOnlyAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn WriteOnlyAccess(_1: ()) -> WriteOnlyAccess {
    let mut _0: instructions::port::WriteOnlyAccess;

    bb0: {
        _0 = WriteOnlyAccess(move _1);
        return;
    }
}

fn ReadWriteAccess(_1: ()) -> ReadWriteAccess {
    let mut _0: instructions::port::ReadWriteAccess;

    bb0: {
        _0 = ReadWriteAccess(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ReadWriteAccess(_1: ()) -> ReadWriteAccess {
    let mut _0: instructions::port::ReadWriteAccess;

    bb0: {
        _0 = ReadWriteAccess(move _1);
        return;
    }
}

fn RdRand(_1: ()) -> RdRand {
    let mut _0: instructions::random::RdRand;

    bb0: {
        _0 = RdRand(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RdRand(_1: ()) -> RdRand {
    let mut _0: instructions::random::RdRand;

    bb0: {
        _0 = RdRand(move _1);
        return;
    }
}

fn InvPicdCommand::Address(_1: addr::VirtAddr, _2: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Address(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn InvPicdCommand::Address(_1: addr::VirtAddr, _2: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Address(move _1, move _2);
        return;
    }
}

fn InvPicdCommand::Single(_1: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Single(move _1);
        return;
    }
}

// MIR FOR CTFE
fn InvPicdCommand::Single(_1: Pcid) -> InvPicdCommand {
    let mut _0: instructions::tlb::InvPicdCommand;

    bb0: {
        _0 = InvPicdCommand::Single(move _1);
        return;
    }
}

fn Pcid(_1: u16) -> Pcid {
    let mut _0: instructions::tlb::Pcid;

    bb0: {
        _0 = Pcid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Pcid(_1: u16) -> Pcid {
    let mut _0: instructions::tlb::Pcid;

    bb0: {
        _0 = Pcid(move _1);
        return;
    }
}

fn control::Cr0Flags(_1: control::_::InternalBitFlags) -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::Cr0Flags(_1: control::_::InternalBitFlags) -> control::Cr0Flags {
    let mut _0: registers::control::Cr0Flags;

    bb0: {
        _0 = control::Cr0Flags(move _1);
        return;
    }
}

fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

fn control::Cr3Flags(_1: control::_::InternalBitFlags) -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::Cr3Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::Cr3Flags(_1: control::_::InternalBitFlags) -> control::Cr3Flags {
    let mut _0: registers::control::Cr3Flags;

    bb0: {
        _0 = control::Cr3Flags(move _1);
        return;
    }
}

fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

fn control::Cr4Flags(_1: control::_::InternalBitFlags) -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::Cr4Flags(_1: control::_::InternalBitFlags) -> control::Cr4Flags {
    let mut _0: registers::control::Cr4Flags;

    bb0: {
        _0 = control::Cr4Flags(move _1);
        return;
    }
}

fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn control::_::InternalBitFlags(_1: u64) -> control::_::InternalBitFlags {
    let mut _0: registers::control::_::InternalBitFlags;

    bb0: {
        _0 = control::_::InternalBitFlags(move _1);
        return;
    }
}

fn debug::Dr6Flags(_1: debug::_::InternalBitFlags) -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::Dr6Flags(_1: debug::_::InternalBitFlags) -> debug::Dr6Flags {
    let mut _0: registers::debug::Dr6Flags;

    bb0: {
        _0 = debug::Dr6Flags(move _1);
        return;
    }
}

fn debug::_::InternalBitFlags(_1: u64) -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::InternalBitFlags(_1: u64) -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(move _1);
        return;
    }
}

fn Dr7Flags(_1: debug::_::InternalBitFlags) -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Dr7Flags(_1: debug::_::InternalBitFlags) -> Dr7Flags {
    let mut _0: registers::debug::Dr7Flags;

    bb0: {
        _0 = Dr7Flags(move _1);
        return;
    }
}

fn debug::_::InternalBitFlags(_1: u64) -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn debug::_::InternalBitFlags(_1: u64) -> debug::_::InternalBitFlags {
    let mut _0: registers::debug::_::InternalBitFlags;

    bb0: {
        _0 = debug::_::InternalBitFlags(move _1);
        return;
    }
}

fn model_specific::Msr(_1: u32) -> model_specific::Msr {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::Msr(_1: u32) -> model_specific::Msr {
    let mut _0: registers::model_specific::Msr;

    bb0: {
        _0 = model_specific::Msr(move _1);
        return;
    }
}

fn model_specific::EferFlags(_1: model_specific::_::InternalBitFlags) -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::EferFlags(_1: model_specific::_::InternalBitFlags) -> model_specific::EferFlags {
    let mut _0: registers::model_specific::EferFlags;

    bb0: {
        _0 = model_specific::EferFlags(move _1);
        return;
    }
}

fn model_specific::_::InternalBitFlags(_1: u64) -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::InternalBitFlags(_1: u64) -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(move _1);
        return;
    }
}

fn model_specific::CetFlags(_1: model_specific::_::InternalBitFlags) -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::CetFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::CetFlags(_1: model_specific::_::InternalBitFlags) -> model_specific::CetFlags {
    let mut _0: registers::model_specific::CetFlags;

    bb0: {
        _0 = model_specific::CetFlags(move _1);
        return;
    }
}

fn model_specific::_::InternalBitFlags(_1: u64) -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn model_specific::_::InternalBitFlags(_1: u64) -> model_specific::_::InternalBitFlags {
    let mut _0: registers::model_specific::_::InternalBitFlags;

    bb0: {
        _0 = model_specific::_::InternalBitFlags(move _1);
        return;
    }
}

fn mxcsr::MxCsr(_1: mxcsr::_::InternalBitFlags) -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::MxCsr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::MxCsr(_1: mxcsr::_::InternalBitFlags) -> mxcsr::MxCsr {
    let mut _0: registers::mxcsr::MxCsr;

    bb0: {
        _0 = mxcsr::MxCsr(move _1);
        return;
    }
}

fn mxcsr::_::InternalBitFlags(_1: u32) -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mxcsr::_::InternalBitFlags(_1: u32) -> mxcsr::_::InternalBitFlags {
    let mut _0: registers::mxcsr::_::InternalBitFlags;

    bb0: {
        _0 = mxcsr::_::InternalBitFlags(move _1);
        return;
    }
}

fn rflags::RFlags(_1: rflags::_::InternalBitFlags) -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn rflags::RFlags(_1: rflags::_::InternalBitFlags) -> rflags::RFlags {
    let mut _0: registers::rflags::RFlags;

    bb0: {
        _0 = rflags::RFlags(move _1);
        return;
    }
}

fn rflags::_::InternalBitFlags(_1: u64) -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn rflags::_::InternalBitFlags(_1: u64) -> rflags::_::InternalBitFlags {
    let mut _0: registers::rflags::_::InternalBitFlags;

    bb0: {
        _0 = rflags::_::InternalBitFlags(move _1);
        return;
    }
}

fn SegmentSelector(_1: u16) -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = SegmentSelector(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SegmentSelector(_1: u16) -> SegmentSelector {
    let mut _0: registers::segmentation::SegmentSelector;

    bb0: {
        _0 = SegmentSelector(move _1);
        return;
    }
}

fn xcontrol::XCr0Flags(_1: xcontrol::_::InternalBitFlags) -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::XCr0Flags(_1: xcontrol::_::InternalBitFlags) -> xcontrol::XCr0Flags {
    let mut _0: registers::xcontrol::XCr0Flags;

    bb0: {
        _0 = xcontrol::XCr0Flags(move _1);
        return;
    }
}

fn xcontrol::_::InternalBitFlags(_1: u64) -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn xcontrol::_::InternalBitFlags(_1: u64) -> xcontrol::_::InternalBitFlags {
    let mut _0: registers::xcontrol::_::InternalBitFlags;

    bb0: {
        _0 = xcontrol::_::InternalBitFlags(move _1);
        return;
    }
}

fn Descriptor::UserSegment(_1: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Descriptor::UserSegment(_1: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::UserSegment(move _1);
        return;
    }
}

fn Descriptor::SystemSegment(_1: u64, _2: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::SystemSegment(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn Descriptor::SystemSegment(_1: u64, _2: u64) -> Descriptor {
    let mut _0: structures::gdt::Descriptor;

    bb0: {
        _0 = Descriptor::SystemSegment(move _1, move _2);
        return;
    }
}

fn DescriptorFlags(_1: gdt::_::InternalBitFlags) -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn DescriptorFlags(_1: gdt::_::InternalBitFlags) -> DescriptorFlags {
    let mut _0: structures::gdt::DescriptorFlags;

    bb0: {
        _0 = DescriptorFlags(move _1);
        return;
    }
}

fn gdt::_::InternalBitFlags(_1: u64) -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn gdt::_::InternalBitFlags(_1: u64) -> gdt::_::InternalBitFlags {
    let mut _0: structures::gdt::_::InternalBitFlags;

    bb0: {
        _0 = gdt::_::InternalBitFlags(move _1);
        return;
    }
}

fn EntryOptions(_1: u16) -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EntryOptions(_1: u16) -> EntryOptions {
    let mut _0: structures::idt::EntryOptions;

    bb0: {
        _0 = EntryOptions(move _1);
        return;
    }
}

fn Hex(_1: u64) -> Hex {
    let mut _0: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;

    bb0: {
        _0 = Hex(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Hex(_1: u64) -> Hex {
    let mut _0: <structures::idt::InterruptStackFrameValue as core::fmt::Debug>::fmt::Hex;

    bb0: {
        _0 = Hex(move _1);
        return;
    }
}

fn PageFaultErrorCode(_1: idt::_::InternalBitFlags) -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageFaultErrorCode(_1: idt::_::InternalBitFlags) -> PageFaultErrorCode {
    let mut _0: structures::idt::PageFaultErrorCode;

    bb0: {
        _0 = PageFaultErrorCode(move _1);
        return;
    }
}

fn idt::_::InternalBitFlags(_1: u64) -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn idt::_::InternalBitFlags(_1: u64) -> idt::_::InternalBitFlags {
    let mut _0: structures::idt::_::InternalBitFlags;

    bb0: {
        _0 = idt::_::InternalBitFlags(move _1);
        return;
    }
}

fn mapper::TranslateResult::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateResult {
    let mut _0: structures::paging::mapper::TranslateResult;

    bb0: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::TranslateResult::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateResult {
    let mut _0: structures::paging::mapper::TranslateResult;

    bb0: {
        _0 = mapper::TranslateResult::InvalidFrameAddress(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size4KiB(_1: PhysFrame) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size4KiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size4KiB(_1: PhysFrame) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size4KiB(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size2MiB(_1: PhysFrame<page::Size2MiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size2MiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size2MiB(_1: PhysFrame<page::Size2MiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size2MiB(move _1);
        return;
    }
}

fn mapper::MappedFrame::Size1GiB(_1: PhysFrame<page::Size1GiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size1GiB(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MappedFrame::Size1GiB(_1: PhysFrame<page::Size1GiB>) -> mapper::MappedFrame {
    let mut _0: structures::paging::mapper::MappedFrame;

    bb0: {
        _0 = mapper::MappedFrame::Size1GiB(move _1);
        return;
    }
}

fn mapper::MapperFlush(_1: Page<S>) -> mapper::MapperFlush<S> {
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapperFlush(_1: Page<S>) -> mapper::MapperFlush<S> {
    let mut _0: structures::paging::mapper::MapperFlush<S>;

    bb0: {
        _0 = mapper::MapperFlush::<S>(move _1);
        return;
    }
}

fn mapper::MapperFlushAll(_1: ()) -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        _0 = mapper::MapperFlushAll(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapperFlushAll(_1: ()) -> mapper::MapperFlushAll {
    let mut _0: structures::paging::mapper::MapperFlushAll;

    bb0: {
        _0 = mapper::MapperFlushAll(move _1);
        return;
    }
}

fn mapper::MapToError::PageAlreadyMapped(_1: PhysFrame<S>) -> mapper::MapToError<S> {
    let mut _0: structures::paging::mapper::MapToError<S>;

    bb0: {
        _0 = mapper::MapToError::<S>::PageAlreadyMapped(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::MapToError::PageAlreadyMapped(_1: PhysFrame<S>) -> mapper::MapToError<S> {
    let mut _0: structures::paging::mapper::MapToError<S>;

    bb0: {
        _0 = mapper::MapToError::<S>::PageAlreadyMapped(move _1);
        return;
    }
}

fn mapper::UnmapError::InvalidFrameAddress(_1: PhysAddr) -> mapper::UnmapError {
    let mut _0: structures::paging::mapper::UnmapError;

    bb0: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::UnmapError::InvalidFrameAddress(_1: PhysAddr) -> mapper::UnmapError {
    let mut _0: structures::paging::mapper::UnmapError;

    bb0: {
        _0 = mapper::UnmapError::InvalidFrameAddress(move _1);
        return;
    }
}

fn mapper::TranslateError::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateError {
    let mut _0: structures::paging::mapper::TranslateError;

    bb0: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _1);
        return;
    }
}

// MIR FOR CTFE
fn mapper::TranslateError::InvalidFrameAddress(_1: PhysAddr) -> mapper::TranslateError {
    let mut _0: structures::paging::mapper::TranslateError;

    bb0: {
        _0 = mapper::TranslateError::InvalidFrameAddress(move _1);
        return;
    }
}

fn PageTableFlags(_1: page_table::_::InternalBitFlags) -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageTableFlags(_1: page_table::_::InternalBitFlags) -> PageTableFlags {
    let mut _0: structures::paging::page_table::PageTableFlags;

    bb0: {
        _0 = PageTableFlags(move _1);
        return;
    }
}

fn page_table::_::InternalBitFlags(_1: u64) -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags(move _1);
        return;
    }
}

// MIR FOR CTFE
fn page_table::_::InternalBitFlags(_1: u64) -> page_table::_::InternalBitFlags {
    let mut _0: structures::paging::page_table::_::InternalBitFlags;

    bb0: {
        _0 = page_table::_::InternalBitFlags(move _1);
        return;
    }
}

fn PageTableIndex(_1: u16) -> PageTableIndex {
    let mut _0: structures::paging::page_table::PageTableIndex;

    bb0: {
        _0 = PageTableIndex(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageTableIndex(_1: u16) -> PageTableIndex {
    let mut _0: structures::paging::page_table::PageTableIndex;

    bb0: {
        _0 = PageTableIndex(move _1);
        return;
    }
}

fn PageOffset(_1: u16) -> PageOffset {
    let mut _0: structures::paging::page_table::PageOffset;

    bb0: {
        _0 = PageOffset(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PageOffset(_1: u16) -> PageOffset {
    let mut _0: structures::paging::page_table::PageOffset;

    bb0: {
        _0 = PageOffset(move _1);
        return;
    }
}
