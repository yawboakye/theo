// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const CMD_INIT: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 17_u8;
        return;
    }
}

const CMD_END_OF_INTERRUPT: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 32_u8;
        return;
    }
}

const MODE_8086: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:48:1: 48:9>::handles_interrupt(_1: &Pic, _2: u8) -> bool {
    debug self => _1;
    debug interrupt_id => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: u8;
    let mut _7: (u8, bool);

    bb0: {
        _4 = ((*_1).0: u8);
        _3 = Le(move _4, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = ((*_1).0: u8);
        _7 = CheckedAdd(_6, const 8_u8);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, const 8_u8) -> [success: bb3, unwind unreachable];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _5 = move (_7.0: u8);
        _0 = Lt(_2, move _5);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:48:1: 48:9>::end_of_interrupt(_1: &mut Pic) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        _3 = &mut ((*_1).1: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _2 = PortGeneric::<u8, ReadWriteAccess>::write(move _3, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:48:1: 48:9>::read_mask(_1: &mut Pic) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        _2 = &mut ((*_1).2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _0 = PortGeneric::<u8, ReadWriteAccess>::read(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:48:1: 48:9>::write_mask(_1: &mut Pic, _2: u8) -> () {
    debug self => _1;
    debug mask => _2;
    let mut _0: ();
    let mut _3: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        _3 = &mut ((*_1).2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _0 = PortGeneric::<u8, ReadWriteAccess>::write(move _3, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

ChainedPics::pics::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::new(_1: u8, _2: u8) -> ChainedPics {
    debug offset1 => _1;
    debug offset2 => _2;
    let mut _0: ChainedPics;
    let mut _3: [Pic; 2];
    let mut _4: Pic;
    let mut _5: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _6: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _7: Pic;
    let mut _8: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _9: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        _5 = PortGeneric::<u8, ReadWriteAccess>::new(const 32_u16) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = PortGeneric::<u8, ReadWriteAccess>::new(const 33_u16) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Pic { offset: _1, command: move _5, data: move _6 };
        _8 = PortGeneric::<u8, ReadWriteAccess>::new(const 160_u16) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = PortGeneric::<u8, ReadWriteAccess>::new(const 161_u16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = Pic { offset: _2, command: move _8, data: move _9 };
        _3 = [move _4, move _7];
        _0 = ChainedPics { pics: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::new(_1: u8, _2: u8) -> ChainedPics {
    debug offset1 => _1;
    debug offset2 => _2;
    let mut _0: ChainedPics;
    let mut _3: [Pic; 2];
    let mut _4: Pic;
    let mut _5: u8;
    let mut _6: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _7: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _8: Pic;
    let mut _9: u8;
    let mut _10: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _11: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = _1;
        StorageLive(_6);
        ConstEvalCounter;
        _6 = PortGeneric::<u8, ReadWriteAccess>::new(const 32_u16) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_7);
        ConstEvalCounter;
        _7 = PortGeneric::<u8, ReadWriteAccess>::new(const 33_u16) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Pic { offset: move _5, command: move _6, data: move _7 };
        StorageDead(_7);
        StorageDead(_6);
        StorageDead(_5);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _2;
        StorageLive(_10);
        ConstEvalCounter;
        _10 = PortGeneric::<u8, ReadWriteAccess>::new(const 160_u16) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        StorageLive(_11);
        ConstEvalCounter;
        _11 = PortGeneric::<u8, ReadWriteAccess>::new(const 161_u16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Pic { offset: move _9, command: move _10, data: move _11 };
        StorageDead(_11);
        StorageDead(_10);
        StorageDead(_9);
        _3 = [move _4, move _8];
        StorageDead(_8);
        StorageDead(_4);
        _0 = ChainedPics { pics: move _3 };
        StorageDead(_3);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::new_contiguous(_1: u8) -> ChainedPics {
    debug primary_offset => _1;
    let mut _0: ChainedPics;
    let mut _2: u8;
    let mut _3: (u8, bool);

    bb0: {
        _3 = CheckedAdd(_1, const 8_u8);
        assert(!move (_3.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 8_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = move (_3.0: u8);
        _0 = ChainedPics::new(_1, move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

// MIR FOR CTFE
fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::new_contiguous(_1: u8) -> ChainedPics {
    debug primary_offset => _1;
    let mut _0: ChainedPics;
    let mut _2: u8;
    let mut _3: u8;
    let mut _4: u8;
    let mut _5: (u8, bool);

    bb0: {
        StorageLive(_2);
        _2 = _1;
        StorageLive(_3);
        StorageLive(_4);
        _4 = _1;
        _5 = CheckedAdd(_4, const 8_u8);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 8_u8) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_5.0: u8);
        StorageDead(_4);
        ConstEvalCounter;
        _0 = ChainedPics::new(move _2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::initialize(_1: &mut ChainedPics) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let mut _4: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _6: ();
    let mut _7: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _8: usize;
    let mut _9: usize;
    let mut _10: bool;
    let _11: ();
    let mut _12: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _13: ();
    let mut _14: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _15: usize;
    let mut _16: usize;
    let mut _17: bool;
    let _18: ();
    let mut _19: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _20: ();
    let mut _21: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    let mut _25: u8;
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let _29: ();
    let mut _30: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _31: ();
    let mut _32: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: u8;
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let _40: ();
    let mut _41: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _42: ();
    let mut _43: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let _47: ();
    let mut _48: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _49: ();
    let mut _50: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let _54: ();
    let mut _55: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _56: ();
    let mut _57: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let _61: ();
    let mut _62: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let _63: ();
    let mut _64: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;
    let _65: usize;
    let mut _66: usize;
    let mut _67: bool;
    let _68: ();
    let mut _69: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
    let mut _70: u8;
    let _71: usize;
    let mut _72: usize;
    let mut _73: bool;
    let mut _74: u8;
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    scope 1 {
        debug wait_port => _2;
        let mut _3: {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26};
        scope 2 {
            debug wait => _3;
            let _5: [u8; 2];
            scope 3 {
                debug saved_masks => _5;
            }
        }
    }

    bb0: {
        _2 = PortGeneric::<u8, ReadWriteAccess>::new(const 128_u16) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _2;
        _3 = {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} { wait_port: move _4 };
        _5 = ChainedPics::read_masks(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = const 0_usize;
        _9 = const 2_usize;
        _10 = Lt(_8, _9);
        assert(move _10, "index out of bounds: the length is {} but the index is {}", move _9, _8) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = &mut (((*_1).0: [Pic; 2])[_8].1: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _6 = PortGeneric::<u8, ReadWriteAccess>::write(move _7, const _) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = &mut _3;
        _11 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _12, const ()) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _15 = const 1_usize;
        _16 = const 2_usize;
        _17 = Lt(_15, _16);
        assert(move _17, "index out of bounds: the length is {} but the index is {}", move _16, _15) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _14 = &mut (((*_1).0: [Pic; 2])[_15].1: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _13 = PortGeneric::<u8, ReadWriteAccess>::write(move _14, const _) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _19 = &mut _3;
        _18 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _19, const ()) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _22 = const 0_usize;
        _23 = const 2_usize;
        _24 = Lt(_22, _23);
        assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _22) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _21 = &mut (((*_1).0: [Pic; 2])[_22].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _26 = const 0_usize;
        _27 = const 2_usize;
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _25 = (((*_1).0: [Pic; 2])[_26].0: u8);
        _20 = PortGeneric::<u8, ReadWriteAccess>::write(move _21, move _25) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _30 = &mut _3;
        _29 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _30, const ()) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _33 = const 1_usize;
        _34 = const 2_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &mut (((*_1).0: [Pic; 2])[_33].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _37 = const 1_usize;
        _38 = const 2_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _36 = (((*_1).0: [Pic; 2])[_37].0: u8);
        _31 = PortGeneric::<u8, ReadWriteAccess>::write(move _32, move _36) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _41 = &mut _3;
        _40 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _41, const ()) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _44 = const 0_usize;
        _45 = const 2_usize;
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _43 = &mut (((*_1).0: [Pic; 2])[_44].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _42 = PortGeneric::<u8, ReadWriteAccess>::write(move _43, const 4_u8) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _48 = &mut _3;
        _47 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _48, const ()) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _51 = const 1_usize;
        _52 = const 2_usize;
        _53 = Lt(_51, _52);
        assert(move _53, "index out of bounds: the length is {} but the index is {}", move _52, _51) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _50 = &mut (((*_1).0: [Pic; 2])[_51].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _49 = PortGeneric::<u8, ReadWriteAccess>::write(move _50, const 2_u8) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _55 = &mut _3;
        _54 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _55, const ()) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _58 = const 0_usize;
        _59 = const 2_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _57 = &mut (((*_1).0: [Pic; 2])[_58].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _56 = PortGeneric::<u8, ReadWriteAccess>::write(move _57, const _) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _62 = &mut _3;
        _61 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _62, const ()) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _65 = const 1_usize;
        _66 = const 2_usize;
        _67 = Lt(_65, _66);
        assert(move _67, "index out of bounds: the length is {} but the index is {}", move _66, _65) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _64 = &mut (((*_1).0: [Pic; 2])[_65].2: x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _63 = PortGeneric::<u8, ReadWriteAccess>::write(move _64, const _) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _69 = &mut _3;
        _68 = <{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26} as FnMut<()>>::call_mut(move _69, const ()) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _71 = const 0_usize;
        _72 = const 2_usize;
        _73 = Lt(_71, _72);
        assert(move _73, "index out of bounds: the length is {} but the index is {}", move _72, _71) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _70 = _5[_71];
        _75 = const 1_usize;
        _76 = const 2_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _74 = _5[_75];
        _0 = ChainedPics::write_masks(_1, move _70, move _74) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::initialize::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:118:24: 118:26}) -> () {
    debug wait_port => (*((*_1).0: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>));
    let mut _0: ();
    let mut _2: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>;

    bb0: {
        _2 = deref_copy ((*_1).0: &mut x86_64::instructions::port::PortGeneric<u8, x86_64::instructions::port::ReadWriteAccess>);
        _0 = PortGeneric::<u8, ReadWriteAccess>::write(_2, const 0_u8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::read_masks(_1: &mut ChainedPics) -> [u8; 2] {
    debug self => _1;
    let mut _0: [u8; 2];
    let mut _2: u8;
    let mut _3: &mut Pic;
    let _4: usize;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: u8;
    let mut _8: &mut Pic;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;

    bb0: {
        _4 = const 0_usize;
        _5 = const 2_usize;
        _6 = Lt(_4, _5);
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _4) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &mut ((*_1).0: [Pic; 2])[_4];
        _2 = Pic::read_mask(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = const 1_usize;
        _10 = const 2_usize;
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = &mut ((*_1).0: [Pic; 2])[_9];
        _7 = Pic::read_mask(move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = [move _2, move _7];
        return;
    }
}

<impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::read_masks::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::write_masks(_1: &mut ChainedPics, _2: u8, _3: u8) -> () {
    debug self => _1;
    debug mask1 => _2;
    debug mask2 => _3;
    let mut _0: ();
    let _4: ();
    let mut _5: &mut Pic;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: ();
    let mut _10: &mut Pic;
    let _11: usize;
    let mut _12: usize;
    let mut _13: bool;

    bb0: {
        _6 = const 0_usize;
        _7 = const 2_usize;
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = &mut ((*_1).0: [Pic; 2])[_6];
        _4 = Pic::write_mask(move _5, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const 1_usize;
        _12 = const 2_usize;
        _13 = Lt(_11, _12);
        assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _11) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _10 = &mut ((*_1).0: [Pic; 2])[_11];
        _9 = Pic::write_mask(move _10, _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::disable(_1: &mut ChainedPics) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        _0 = ChainedPics::write_masks(_1, const _, const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::handles_interrupt(_1: &ChainedPics, _2: u8) -> bool {
    debug self => _1;
    debug interrupt_id => _2;
    let mut _0: bool;
    let mut _3: &mut core::slice::Iter<'_, Pic>;
    let mut _4: core::slice::Iter<'_, Pic>;
    let mut _5: &[Pic];
    let mut _6: &[Pic; 2];
    let mut _7: {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:172:30: 172:33};
    let mut _8: &u8;

    bb0: {
        _6 = &((*_1).0: [Pic; 2]);
        _5 = move _6 as &[Pic] (PointerCoercion(Unsize));
        _4 = slice::<impl [Pic]>::iter(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &mut _4;
        _8 = &_2;
        _7 = {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:172:30: 172:33} { interrupt_id: move _8 };
        _0 = <core::slice::Iter<'_, Pic> as Iterator>::any::<{closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:172:30: 172:33}>(move _3, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::handles_interrupt::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:172:30: 172:33}, _2: &Pic) -> bool {
    debug p => _2;
    debug interrupt_id => (*((*_1).0: &u8));
    let mut _0: bool;
    let mut _3: u8;
    let mut _4: &u8;

    bb0: {
        _4 = deref_copy ((*_1).0: &u8);
        _3 = (*_4);
        _0 = Pic::handles_interrupt(_2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn <impl at /Users/yaw/.cargo/git/checkouts/pic8259-4bfeaa76e06bf2c9/5e3b49d/src/lib.rs:77:1: 77:17>::notify_end_of_interrupt(_1: &mut ChainedPics, _2: u8) -> () {
    debug self => _1;
    debug interrupt_id => _2;
    let mut _0: ();
    let mut _3: bool;
    let mut _4: &ChainedPics;
    let mut _5: bool;
    let mut _6: &Pic;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let _10: ();
    let mut _11: &mut Pic;
    let _12: usize;
    let mut _13: usize;
    let mut _14: bool;
    let _15: ();
    let mut _16: &mut Pic;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;

    bb0: {
        _4 = &(*_1);
        _3 = ChainedPics::handles_interrupt(move _4, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb9, otherwise: bb2];
    }

    bb2: {
        _7 = const 1_usize;
        _8 = const 2_usize;
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = &((*_1).0: [Pic; 2])[_7];
        _5 = Pic::handles_interrupt(move _6, _2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _5) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        _12 = const 1_usize;
        _13 = const 2_usize;
        _14 = Lt(_12, _13);
        assert(move _14, "index out of bounds: the length is {} but the index is {}", move _13, _12) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = &mut ((*_1).0: [Pic; 2])[_12];
        _10 = Pic::end_of_interrupt(move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _17 = const 0_usize;
        _18 = const 2_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _16 = &mut ((*_1).0: [Pic; 2])[_17];
        _15 = Pic::end_of_interrupt(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}
