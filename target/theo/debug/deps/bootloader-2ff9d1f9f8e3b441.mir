// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const PAGE_SIZE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 4096_u64;
        return;
    }
}

const MAX_MEMORY_MAP_SIZE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 64_usize;
        return;
    }
}

memory_map::MemoryMap::entries::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::new() -> memory_map::MemoryMap {
    let mut _0: bootinfo::memory_map::MemoryMap;
    let mut _1: [bootinfo::memory_map::MemoryRegion; 64];
    let mut _2: bootinfo::memory_map::MemoryRegion;

    bb0: {
        _2 = MemoryRegion::empty() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _1 = [move _2; 64];
        _0 = memory_map::MemoryMap { entries: move _1, next_entry_index: const 0_u64 };
        return;
    }
}

memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::new::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::add_region(_1: &mut memory_map::MemoryMap, _2: MemoryRegion) -> () {
    debug self => _1;
    debug region => _2;
    let mut _0: ();
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: &bootinfo::memory_map::MemoryMap;
    let mut _6: !;
    let _7: usize;
    let mut _8: &bootinfo::memory_map::MemoryMap;
    let mut _9: usize;
    let mut _10: bool;
    let mut _11: (u64, bool);
    let _12: ();

    bb0: {
        _5 = &(*_1);
        _4 = memory_map::MemoryMap::next_entry_index(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Lt(move _4, const _);
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = &(*_1);
        _7 = memory_map::MemoryMap::next_entry_index(move _8) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _6 = panic(const "too many memory regions in memory map") -> unwind unreachable;
    }

    bb4: {
        _9 = const 64_usize;
        _10 = Lt(_7, _9);
        assert(move _10, "index out of bounds: the length is {} but the index is {}", move _9, _7) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        ((*_1).0: [bootinfo::memory_map::MemoryRegion; 64])[_7] = _2;
        _11 = CheckedAdd(((*_1).1: u64), const 1_u64);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).1: u64), const 1_u64) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        ((*_1).1: u64) = move (_11.0: u64);
        _12 = memory_map::MemoryMap::sort(_1) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::sort(_1: &mut memory_map::MemoryMap) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: &mut [bootinfo::memory_map::MemoryRegion];
    let mut _4: &mut [bootinfo::memory_map::MemoryRegion; 64];
    let mut _5: core::option::Option<usize>;
    let mut _6: &mut core::slice::Iter<'_, bootinfo::memory_map::MemoryRegion>;
    let mut _7: core::slice::Iter<'_, bootinfo::memory_map::MemoryRegion>;
    let mut _8: &[bootinfo::memory_map::MemoryRegion];
    let mut _9: &[bootinfo::memory_map::MemoryRegion; 64];
    let mut _10: isize;
    scope 1 {
        debug first_zero_index => _11;
        let _11: usize;
    }

    bb0: {
        _4 = &mut ((*_1).0: [bootinfo::memory_map::MemoryRegion; 64]);
        _3 = move _4 as &mut [bootinfo::memory_map::MemoryRegion] (PointerCoercion(Unsize));
        _2 = slice::<impl [MemoryRegion]>::sort_unstable_by::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:40:39: 40:47}>(move _3, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:40:39: 40:47}) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &((*_1).0: [bootinfo::memory_map::MemoryRegion; 64]);
        _8 = move _9 as &[bootinfo::memory_map::MemoryRegion] (PointerCoercion(Unsize));
        _7 = slice::<impl [MemoryRegion]>::iter(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = &mut _7;
        _5 = <core::slice::Iter<'_, MemoryRegion> as Iterator>::position::<{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:58:70: 58:73}>(move _6, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:58:70: 58:73}) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [1: bb4, otherwise: bb5];
    }

    bb4: {
        _11 = ((_5 as Some).0: usize);
        ((*_1).1: u64) = _11 as u64 (IntToInt);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::sort::{closure#0}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:40:39: 40:47}, _2: &MemoryRegion, _3: &MemoryRegion) -> core::cmp::Ordering {
    debug r1 => _2;
    debug r2 => _3;
    let mut _0: core::cmp::Ordering;
    let mut _4: bool;
    let mut _5: &bootinfo::memory_map::FrameRange;
    let mut _6: bool;
    let mut _7: &bootinfo::memory_map::FrameRange;
    let _8: core::cmp::Ordering;
    let mut _9: &u64;
    let _10: &u64;
    let mut _11: bool;
    let mut _12: &core::cmp::Ordering;
    let mut _13: &u64;
    let _14: &u64;
    scope 1 {
        debug ordering => _8;
        let mut _15: &core::cmp::Ordering;
    }

    bb0: {
        _5 = &((*_2).0: bootinfo::memory_map::FrameRange);
        _4 = FrameRange::is_empty(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Greater;
        goto -> bb11;
    }

    bb3: {
        _7 = &((*_3).0: bootinfo::memory_map::FrameRange);
        _6 = FrameRange::is_empty(move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _6) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = Less;
        goto -> bb11;
    }

    bb6: {
        _9 = &(((*_2).0: bootinfo::memory_map::FrameRange).0: u64);
        _10 = &(((*_3).0: bootinfo::memory_map::FrameRange).0: u64);
        _8 = <u64 as Ord>::cmp(move _9, _10) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = &_8;
        _15 = const _;
        _11 = <core::cmp::Ordering as PartialEq>::eq(move _12, _15) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _13 = &(((*_2).0: bootinfo::memory_map::FrameRange).1: u64);
        _14 = &(((*_3).0: bootinfo::memory_map::FrameRange).1: u64);
        _0 = <u64 as Ord>::cmp(move _13, _14) -> [return: bb11, unwind unreachable];
    }

    bb10: {
        _0 = _8;
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

promoted[0] in memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::sort::{closure#0}: &core::cmp::Ordering = {
    let mut _0: &core::cmp::Ordering;
    let mut _1: core::cmp::Ordering;

    bb0: {
        _1 = Equal;
        _0 = &_1;
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::sort::{closure#1}(_1: &mut {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:58:70: 58:73}, _2: &MemoryRegion) -> bool {
    debug r => _2;
    let mut _0: bool;
    let mut _3: &bootinfo::memory_map::FrameRange;

    bb0: {
        _3 = &((*_2).0: bootinfo::memory_map::FrameRange);
        _0 = FrameRange::is_empty(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:19:1: 19:15>::next_entry_index(_1: &memory_map::MemoryMap) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: u64;

    bb0: {
        _2 = ((*_1).1: u64);
        _0 = move _2 as usize (IntToInt);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:68:1: 68:25>::deref(_1: &memory_map::MemoryMap) -> &[MemoryRegion] {
    debug self => _1;
    let mut _0: &[bootinfo::memory_map::MemoryRegion];
    let mut _2: &[bootinfo::memory_map::MemoryRegion; 64];
    let mut _3: core::ops::Range<usize>;
    let mut _4: usize;

    bb0: {
        _2 = &((*_1).0: [bootinfo::memory_map::MemoryRegion; 64]);
        _4 = memory_map::MemoryMap::next_entry_index(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Range::<usize> { start: const 0_usize, end: move _4 };
        _0 = <[MemoryRegion; 64] as Index<Range<usize>>>::index(move _2, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:76:1: 76:28>::deref_mut(_1: &mut memory_map::MemoryMap) -> &mut [MemoryRegion] {
    debug self => _1;
    let mut _0: &mut [bootinfo::memory_map::MemoryRegion];
    let _2: usize;
    let mut _3: &bootinfo::memory_map::MemoryMap;
    let mut _4: &mut [bootinfo::memory_map::MemoryRegion; 64];
    let mut _5: core::ops::Range<usize>;
    scope 1 {
        debug next_index => _2;
    }

    bb0: {
        _3 = &(*_1);
        _2 = memory_map::MemoryMap::next_entry_index(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut ((*_1).0: [bootinfo::memory_map::MemoryRegion; 64]);
        _5 = Range::<usize> { start: const 0_usize, end: _2 };
        _0 = <[MemoryRegion; 64] as IndexMut<Range<usize>>>::index_mut(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:83:1: 83:30>::fmt(_1: &memory_map::MemoryMap, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &mut core::fmt::DebugList<'_, '_>;
    let mut _4: &mut core::fmt::DebugList<'_, '_>;
    let mut _5: core::fmt::DebugList<'_, '_>;
    let mut _6: core::slice::Iter<'_, bootinfo::memory_map::MemoryRegion>;
    let _7: &[bootinfo::memory_map::MemoryRegion];

    bb0: {
        _5 = Formatter::<'_>::debug_list(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &mut _5;
        _7 = <memory_map::MemoryMap as Deref>::deref(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = slice::<impl [MemoryRegion]>::iter(_7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = DebugList::<'_, '_>::entries::<&MemoryRegion, core::slice::Iter<'_, MemoryRegion>>(move _4, move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = DebugList::<'_, '_>::finish(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:90:10: 90:15>::fmt(_1: &MemoryRegion, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &bootinfo::memory_map::FrameRange;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&bootinfo::memory_map::MemoryRegionType;
    let _10: &bootinfo::memory_map::MemoryRegionType;

    bb0: {
        _3 = const "MemoryRegion";
        _4 = const "range";
        _6 = &((*_1).0: bootinfo::memory_map::FrameRange);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "region_type";
        _10 = &((*_1).1: bootinfo::memory_map::MemoryRegionType);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:90:17: 90:22>::clone(_1: &MemoryRegion) -> MemoryRegion {
    debug self => _1;
    let mut _0: bootinfo::memory_map::MemoryRegion;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:90:30: 90:39>::eq(_1: &MemoryRegion, _2: &MemoryRegion) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &bootinfo::memory_map::FrameRange;
    let mut _5: &bootinfo::memory_map::FrameRange;
    let mut _6: &bootinfo::memory_map::MemoryRegionType;
    let mut _7: &bootinfo::memory_map::MemoryRegionType;

    bb0: {
        _4 = &((*_1).0: bootinfo::memory_map::FrameRange);
        _5 = &((*_2).0: bootinfo::memory_map::FrameRange);
        _3 = <FrameRange as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: bootinfo::memory_map::MemoryRegionType);
        _7 = &((*_2).1: bootinfo::memory_map::MemoryRegionType);
        _0 = <MemoryRegionType as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:90:41: 90:43>::assert_receiver_is_total_eq(_1: &MemoryRegion) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:100:1: 100:18>::empty() -> MemoryRegion {
    let mut _0: bootinfo::memory_map::MemoryRegion;
    let mut _1: bootinfo::memory_map::FrameRange;
    let mut _2: bootinfo::memory_map::MemoryRegionType;

    bb0: {
        _1 = FrameRange { start_frame_number: const 0_u64, end_frame_number: const 0_u64 };
        _2 = MemoryRegionType::Empty;
        _0 = MemoryRegion { range: move _1, region_type: move _2 };
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:113:10: 113:15>::clone(_1: &FrameRange) -> FrameRange {
    debug self => _1;
    let mut _0: bootinfo::memory_map::FrameRange;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:113:23: 113:32>::eq(_1: &FrameRange, _2: &FrameRange) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = ((*_2).0: u64);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = ((*_1).1: u64);
        _7 = ((*_2).1: u64);
        _0 = Eq(move _6, move _7);
        goto -> bb3;
    }

    bb2: {
        _0 = const false;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:113:34: 113:36>::assert_receiver_is_total_eq(_1: &FrameRange) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:128:1: 128:16>::new(_1: u64, _2: u64) -> FrameRange {
    debug start_addr => _1;
    debug end_addr => _2;
    let mut _0: bootinfo::memory_map::FrameRange;
    let _3: u64;
    let mut _4: (u64, bool);
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: bool;
    let mut _10: (u64, bool);
    scope 1 {
        debug last_byte => _3;
    }

    bb0: {
        _4 = CheckedSub(_2, const 1_u64);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1_u64) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_4.0: u64);
        _6 = Eq(const _, const 0_u64);
        assert(!move _6, "attempt to divide `{}` by zero", _1) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Div(_1, const _);
        _9 = Eq(const _, const 0_u64);
        assert(!move _9, "attempt to divide `{}` by zero", _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Div(_3, const _);
        _10 = CheckedAdd(_8, const 1_u64);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 1_u64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _7 = move (_10.0: u64);
        _0 = FrameRange { start_frame_number: move _5, end_frame_number: move _7 };
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:128:1: 128:16>::is_empty(_1: &FrameRange) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _2 = ((*_1).0: u64);
        _3 = ((*_1).1: u64);
        _0 = Eq(move _2, move _3);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:128:1: 128:16>::start_addr(_1: &FrameRange) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u64;
    let mut _3: (u64, bool);

    bb0: {
        _2 = ((*_1).0: u64);
        _3 = CheckedMul(_2, const _);
        assert(!move (_3.1: bool), "attempt to compute `{} * {}`, which would overflow", move _2, const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move (_3.0: u64);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:128:1: 128:16>::end_addr(_1: &FrameRange) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u64;
    let mut _3: (u64, bool);

    bb0: {
        _2 = ((*_1).1: u64);
        _3 = CheckedMul(_2, const _);
        assert(!move (_3.1: bool), "attempt to compute `{} * {}`, which would overflow", move _2, const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move (_3.0: u64);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:156:1: 156:31>::fmt(_1: &FrameRange, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 2];
    let _7: [core::fmt::rt::Argument<'_>; 2];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &u64;
    let _10: u64;
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &u64;
    let _13: u64;
    let mut _14: &[core::fmt::rt::Placeholder];
    let _15: &[core::fmt::rt::Placeholder; 2];
    let _16: [core::fmt::rt::Placeholder; 2];
    let mut _17: core::fmt::rt::Placeholder;
    let mut _18: core::fmt::rt::Alignment;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::Count;
    let mut _21: core::fmt::rt::Placeholder;
    let mut _22: core::fmt::rt::Alignment;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::Count;
    let mut _25: core::fmt::rt::UnsafeArg;
    let mut _26: &[&str; 3];
    scope 1 {
    }

    bb0: {
        _26 = const _;
        _4 = _26 as &[&str] (PointerCoercion(Unsize));
        _10 = FrameRange::start_addr(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = FrameRange::end_addr(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = &_13;
        _11 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_12) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = [move _8, move _11];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = core::fmt::rt::Alignment::Unknown;
        _19 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Count::Implied;
        _17 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _18, const 4_u32, move _19, move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = core::fmt::rt::Alignment::Unknown;
        _23 = core::fmt::rt::Count::Implied;
        _24 = core::fmt::rt::Count::Implied;
        _21 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _22, const 4_u32, move _23, move _24) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _16 = [move _17, move _21];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::UnsafeArg::new() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = Arguments::<'_>::new_v1_formatted(move _4, move _5, move _14, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:156:1: 156:31>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "FrameRange(", const "..", const ")"];
        _0 = &_1;
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:168:10: 168:15>::fmt(_1: &MemoryRegionType, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;
    let _11: &str;
    let _12: &str;
    let _13: &str;
    let _14: &str;
    let _15: &str;
    let _16: &str;
    let _17: &str;
    let _18: &str;
    let _19: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 9: bb12, 10: bb13, 11: bb14, 12: bb15, 13: bb16, 14: bb1, otherwise: bb2];
    }

    bb1: {
        _19 = const "NonExhaustive";
        _3 = _19;
        goto -> bb17;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Usable";
        _3 = _5;
        goto -> bb17;
    }

    bb4: {
        _6 = const "InUse";
        _3 = _6;
        goto -> bb17;
    }

    bb5: {
        _7 = const "Reserved";
        _3 = _7;
        goto -> bb17;
    }

    bb6: {
        _8 = const "AcpiReclaimable";
        _3 = _8;
        goto -> bb17;
    }

    bb7: {
        _9 = const "AcpiNvs";
        _3 = _9;
        goto -> bb17;
    }

    bb8: {
        _10 = const "BadMemory";
        _3 = _10;
        goto -> bb17;
    }

    bb9: {
        _11 = const "Kernel";
        _3 = _11;
        goto -> bb17;
    }

    bb10: {
        _12 = const "KernelStack";
        _3 = _12;
        goto -> bb17;
    }

    bb11: {
        _13 = const "PageTable";
        _3 = _13;
        goto -> bb17;
    }

    bb12: {
        _14 = const "Bootloader";
        _3 = _14;
        goto -> bb17;
    }

    bb13: {
        _15 = const "FrameZero";
        _3 = _15;
        goto -> bb17;
    }

    bb14: {
        _16 = const "Empty";
        _3 = _16;
        goto -> bb17;
    }

    bb15: {
        _17 = const "BootInfo";
        _3 = _17;
        goto -> bb17;
    }

    bb16: {
        _18 = const "Package";
        _3 = _18;
        goto -> bb17;
    }

    bb17: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:168:17: 168:22>::clone(_1: &MemoryRegionType) -> MemoryRegionType {
    debug self => _1;
    let mut _0: bootinfo::memory_map::MemoryRegionType;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:168:30: 168:39>::eq(_1: &MemoryRegionType, _2: &MemoryRegionType) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:168:41: 168:43>::assert_receiver_is_total_eq(_1: &MemoryRegionType) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:208:10: 208:15>::fmt(_1: &E820MemoryRegion, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u64;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &u64;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &u32;
    let _13: &str;
    let mut _14: &dyn core::fmt::Debug;
    let _15: &&u32;
    let _16: &u32;

    bb0: {
        _3 = const "E820MemoryRegion";
        _4 = const "start_addr";
        _6 = &((*_1).0: u64);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "len";
        _9 = &((*_1).1: u64);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "region_type";
        _12 = &((*_1).2: u32);
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "acpi_extended_attributes";
        _16 = &((*_1).3: u32);
        _15 = &_16;
        _14 = _15 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:208:17: 208:22>::clone(_1: &E820MemoryRegion) -> E820MemoryRegion {
    debug self => _1;
    let mut _0: bootinfo::memory_map::E820MemoryRegion;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:208:30: 208:39>::eq(_1: &E820MemoryRegion, _2: &E820MemoryRegion) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = ((*_2).0: u64);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _7 = ((*_1).1: u64);
        _8 = ((*_2).1: u64);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _10 = ((*_1).2: u32);
        _11 = ((*_2).2: u32);
        _9 = Eq(move _10, move _11);
        switchInt(move _9) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _12 = ((*_1).3: u32);
        _13 = ((*_2).3: u32);
        _0 = Eq(move _12, move _13);
        goto -> bb5;
    }

    bb4: {
        _0 = const false;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:208:41: 208:43>::assert_receiver_is_total_eq(_1: &E820MemoryRegion) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:217:1: 217:45>::from(_1: E820MemoryRegion) -> MemoryRegion {
    debug region => _1;
    let mut _0: bootinfo::memory_map::MemoryRegion;
    let _2: bootinfo::memory_map::MemoryRegionType;
    let _3: u32;
    let _4: !;
    let mut _5: core::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &u32;
    let mut _12: bootinfo::memory_map::FrameRange;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: (u64, bool);
    let mut _18: bootinfo::memory_map::MemoryRegionType;
    scope 1 {
        debug region_type => _2;
    }
    scope 2 {
        debug t => _3;
        let mut _19: &[&str; 1];
    }

    bb0: {
        switchInt((_1.2: u32)) -> [1: bb2, 2: bb3, 3: bb4, 4: bb5, 5: bb6, otherwise: bb1];
    }

    bb1: {
        _3 = (_1.2: u32);
        _19 = const _;
        _6 = _19 as &[&str] (PointerCoercion(Unsize));
        _11 = &_3;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_11) -> [return: bb7, unwind unreachable];
    }

    bb2: {
        _2 = MemoryRegionType::Usable;
        goto -> bb9;
    }

    bb3: {
        _2 = MemoryRegionType::Reserved;
        goto -> bb9;
    }

    bb4: {
        _2 = MemoryRegionType::AcpiReclaimable;
        goto -> bb9;
    }

    bb5: {
        _2 = MemoryRegionType::AcpiNvs;
        goto -> bb9;
    }

    bb6: {
        _2 = MemoryRegionType::BadMemory;
        goto -> bb9;
    }

    bb7: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _4 = panic_fmt(move _5) -> unwind unreachable;
    }

    bb9: {
        _13 = (_1.0: u64);
        _15 = (_1.0: u64);
        _16 = (_1.1: u64);
        _17 = CheckedAdd(_15, _16);
        assert(!move (_17.1: bool), "attempt to compute `{} + {}`, which would overflow", move _15, move _16) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _14 = move (_17.0: u64);
        _12 = FrameRange::new(move _13, move _14) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _18 = _2;
        _0 = MemoryRegion { range: move _12, region_type: move _18 };
        return;
    }
}

promoted[0] in memory_map::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/memory_map.rs:217:1: 217:45>::from: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "invalid region type "];
        _0 = &_1;
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:22:10: 22:15>::fmt(_1: &BootInfo, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &bootinfo::memory_map::MemoryMap;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &bootinfo::TlsTemplate;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &&u8;
    let _13: &u8;

    bb0: {
        _3 = const "BootInfo";
        _4 = const "memory_map";
        _6 = &((*_1).0: bootinfo::memory_map::MemoryMap);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "tls_template";
        _9 = &((*_1).1: bootinfo::TlsTemplate);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "_non_exhaustive";
        _13 = &((*_1).2: u8);
        _12 = &_13;
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:49:1: 49:14>::new(_1: memory_map::MemoryMap, _2: Option<TlsTemplate>, _3: u64, _4: u64) -> BootInfo {
    debug memory_map => _1;
    debug tls_template => _2;
    debug recursive_page_table_addr => _3;
    debug physical_memory_offset => _4;
    let mut _0: bootinfo::BootInfo;
    let _5: bootinfo::TlsTemplate;
    let mut _6: bootinfo::TlsTemplate;
    scope 1 {
        debug tls_template => _5;
    }

    bb0: {
        _6 = TlsTemplate { start_addr: const 0_u64, file_size: const 0_u64, mem_size: const 0_u64 };
        _5 = Option::<TlsTemplate>::unwrap_or(_2, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = BootInfo { memory_map: move _1, tls_template: _5, _non_exhaustive: const 0_u8 };
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:49:1: 49:14>::tls_template(_1: &BootInfo) -> Option<TlsTemplate> {
    debug self => _1;
    let mut _0: core::option::Option<bootinfo::TlsTemplate>;
    let mut _2: bool;
    let mut _3: u64;
    let mut _4: bootinfo::TlsTemplate;

    bb0: {
        _3 = (((*_1).1: bootinfo::TlsTemplate).2: u64);
        _2 = Gt(move _3, const 0_u64);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = ((*_1).1: bootinfo::TlsTemplate);
        _0 = Option::<TlsTemplate>::Some(move _4);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<TlsTemplate>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:103:10: 103:15>::fmt(_1: &TlsTemplate, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &u64;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &u64;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &&u64;
    let _13: &u64;

    bb0: {
        _3 = const "TlsTemplate";
        _4 = const "start_addr";
        _6 = &((*_1).0: u64);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "file_size";
        _9 = &((*_1).1: u64);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "mem_size";
        _13 = &((*_1).2: u64);
        _12 = &_13;
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:103:17: 103:22>::clone(_1: &TlsTemplate) -> TlsTemplate {
    debug self => _1;
    let mut _0: bootinfo::TlsTemplate;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:103:30: 103:39>::eq(_1: &TlsTemplate, _2: &TlsTemplate) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u64;

    bb0: {
        _4 = ((*_1).0: u64);
        _5 = ((*_2).0: u64);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _7 = ((*_1).1: u64);
        _8 = ((*_2).1: u64);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _9 = ((*_1).2: u64);
        _10 = ((*_2).2: u64);
        _0 = Eq(move _9, move _10);
        goto -> bb4;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn bootinfo::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bootloader-0.9.23/src/bootinfo/mod.rs:103:41: 103:43>::assert_receiver_is_total_eq(_1: &TlsTemplate) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}
