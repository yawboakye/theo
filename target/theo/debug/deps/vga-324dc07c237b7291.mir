// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
Color::Black::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:11:13: 11:16

    bb0: {
        _0 = const 0_u8;                 // scope 0 at vga/src/lib.rs:11:13: 11:16
        return;                          // scope 0 at vga/src/lib.rs:11:13: 11:16
    }
}

Color::Blue::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:12:12: 12:15

    bb0: {
        _0 = const 1_u8;                 // scope 0 at vga/src/lib.rs:12:12: 12:15
        return;                          // scope 0 at vga/src/lib.rs:12:12: 12:15
    }
}

Color::Green::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:13:13: 13:16

    bb0: {
        _0 = const 2_u8;                 // scope 0 at vga/src/lib.rs:13:13: 13:16
        return;                          // scope 0 at vga/src/lib.rs:13:13: 13:16
    }
}

Color::Cyan::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:14:12: 14:15

    bb0: {
        _0 = const 3_u8;                 // scope 0 at vga/src/lib.rs:14:12: 14:15
        return;                          // scope 0 at vga/src/lib.rs:14:12: 14:15
    }
}

Color::Red::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:15:11: 15:14

    bb0: {
        _0 = const 4_u8;                 // scope 0 at vga/src/lib.rs:15:11: 15:14
        return;                          // scope 0 at vga/src/lib.rs:15:11: 15:14
    }
}

Color::Magenta::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:16:15: 16:18

    bb0: {
        _0 = const 5_u8;                 // scope 0 at vga/src/lib.rs:16:15: 16:18
        return;                          // scope 0 at vga/src/lib.rs:16:15: 16:18
    }
}

Color::Brown::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:17:13: 17:16

    bb0: {
        _0 = const 6_u8;                 // scope 0 at vga/src/lib.rs:17:13: 17:16
        return;                          // scope 0 at vga/src/lib.rs:17:13: 17:16
    }
}

Color::LightGray::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:18:17: 18:20

    bb0: {
        _0 = const 7_u8;                 // scope 0 at vga/src/lib.rs:18:17: 18:20
        return;                          // scope 0 at vga/src/lib.rs:18:17: 18:20
    }
}

Color::DarkGray::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:19:16: 19:19

    bb0: {
        _0 = const 8_u8;                 // scope 0 at vga/src/lib.rs:19:16: 19:19
        return;                          // scope 0 at vga/src/lib.rs:19:16: 19:19
    }
}

Color::LightBlue::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:20:17: 20:20

    bb0: {
        _0 = const 9_u8;                 // scope 0 at vga/src/lib.rs:20:17: 20:20
        return;                          // scope 0 at vga/src/lib.rs:20:17: 20:20
    }
}

Color::LightGreen::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:21:18: 21:21

    bb0: {
        _0 = const 10_u8;                // scope 0 at vga/src/lib.rs:21:18: 21:21
        return;                          // scope 0 at vga/src/lib.rs:21:18: 21:21
    }
}

Color::LightCyan::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:22:17: 22:20

    bb0: {
        _0 = const 11_u8;                // scope 0 at vga/src/lib.rs:22:17: 22:20
        return;                          // scope 0 at vga/src/lib.rs:22:17: 22:20
    }
}

Color::LightRed::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:23:16: 23:19

    bb0: {
        _0 = const 12_u8;                // scope 0 at vga/src/lib.rs:23:16: 23:19
        return;                          // scope 0 at vga/src/lib.rs:23:16: 23:19
    }
}

Color::LightMagenta::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:24:20: 24:23

    bb0: {
        _0 = const 13_u8;                // scope 0 at vga/src/lib.rs:24:20: 24:23
        return;                          // scope 0 at vga/src/lib.rs:24:20: 24:23
    }
}

Color::Yellow::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:25:14: 25:17

    bb0: {
        _0 = const 14_u8;                // scope 0 at vga/src/lib.rs:25:14: 25:17
        return;                          // scope 0 at vga/src/lib.rs:25:14: 25:17
    }
}

Color::White::{constant#0}: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:26:13: 26:16

    bb0: {
        _0 = const 15_u8;                // scope 0 at vga/src/lib.rs:26:13: 26:16
        return;                          // scope 0 at vga/src/lib.rs:26:13: 26:16
    }
}

static PI_CHAR_CODE: u8 = {
    let mut _0: u8;                      // return place in scope 0 at vga/src/lib.rs:30:22: 30:24

    bb0: {
        _0 = const 227_u8;               // scope 0 at vga/src/lib.rs:30:27: 30:31
        return;                          // scope 0 at vga/src/lib.rs:30:1: 30:32
    }
}

fn <impl at vga/src/lib.rs:32:16: 32:21>::clone(_1: &ColorCode) -> ColorCode {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:32:16: 32:21
    let mut _0: ColorCode;               // return place in scope 0 at vga/src/lib.rs:32:16: 32:21
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at vga/src/lib.rs:32:16: 32:21
        return;                          // scope 0 at vga/src/lib.rs:32:21: 32:21
    }
}

fn <impl at vga/src/lib.rs:36:1: 36:15>::new(_1: Color, _2: Color) -> ColorCode {
    debug fg => _1;                      // in scope 0 at vga/src/lib.rs:37:12: 37:14
    debug bg => _2;                      // in scope 0 at vga/src/lib.rs:37:23: 37:25
    let mut _0: ColorCode;               // return place in scope 0 at vga/src/lib.rs:37:37: 37:41
    let mut _3: u8;                      // in scope 0 at vga/src/lib.rs:38:19: 38:47
    let mut _4: u8;                      // in scope 0 at vga/src/lib.rs:38:19: 38:34
    let mut _5: u8;                      // in scope 0 at vga/src/lib.rs:38:20: 38:22
    let mut _6: bool;                    // in scope 0 at vga/src/lib.rs:38:19: 38:29
    let mut _7: u32;                     // in scope 0 at vga/src/lib.rs:38:19: 38:34
    let mut _8: bool;                    // in scope 0 at vga/src/lib.rs:38:19: 38:34
    let mut _9: u8;                      // in scope 0 at vga/src/lib.rs:38:38: 38:40
    let mut _10: bool;                   // in scope 0 at vga/src/lib.rs:38:37: 38:47

    bb0: {
        _5 = discriminant(_2);           // scope 0 at vga/src/lib.rs:38:19: 38:29
        _6 = Le(_5, const 15_u8);        // scope 0 at vga/src/lib.rs:38:19: 38:29
        assume(move _6);                 // scope 0 at vga/src/lib.rs:38:19: 38:29
        _7 = const 4_i32 as u32 (IntToInt); // scope 0 at vga/src/lib.rs:38:19: 38:34
        _8 = Lt(move _7, const 8_u32);   // scope 0 at vga/src/lib.rs:38:19: 38:34
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:38:19: 38:34
    }

    bb1: {
        _4 = Shl(_5, const 4_i32);       // scope 0 at vga/src/lib.rs:38:19: 38:34
        _9 = discriminant(_1);           // scope 0 at vga/src/lib.rs:38:37: 38:47
        _10 = Le(_9, const 15_u8);       // scope 0 at vga/src/lib.rs:38:37: 38:47
        assume(move _10);                // scope 0 at vga/src/lib.rs:38:37: 38:47
        _3 = BitOr(move _4, _9);         // scope 0 at vga/src/lib.rs:38:19: 38:47
        _0 = ColorCode(move _3);         // scope 0 at vga/src/lib.rs:38:9: 38:48
        return;                          // scope 0 at vga/src/lib.rs:39:6: 39:6
    }
}

fn <impl at vga/src/lib.rs:42:16: 42:21>::clone(_1: &ScreenChar) -> ScreenChar {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:42:16: 42:21
    let mut _0: ScreenChar;              // return place in scope 0 at vga/src/lib.rs:42:16: 42:21
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);                      // scope 2 at vga/src/lib.rs:42:16: 42:21
        return;                          // scope 0 at vga/src/lib.rs:42:21: 42:21
    }
}

fn <impl at vga/src/lib.rs:49:1: 49:16>::new(_1: u8) -> ScreenChar {
    debug c => _1;                       // in scope 0 at vga/src/lib.rs:50:12: 50:13
    let mut _0: ScreenChar;              // return place in scope 0 at vga/src/lib.rs:50:22: 50:26
    let mut _2: ColorCode;               // in scope 0 at vga/src/lib.rs:53:25: 53:67
    let mut _3: Color;                   // in scope 0 at vga/src/lib.rs:53:40: 53:53
    let mut _4: Color;                   // in scope 0 at vga/src/lib.rs:53:55: 53:66

    bb0: {
        _3 = Color::Yellow;              // scope 0 at vga/src/lib.rs:53:40: 53:53
        _4 = Color::Blue;                // scope 0 at vga/src/lib.rs:53:55: 53:66
        _2 = ColorCode::new(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:53:25: 53:67
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:53:25: 53:39
                                         // + literal: Const { ty: fn(Color, Color) -> ColorCode {ColorCode::new}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = ScreenChar { char: _1, color_code: move _2 }; // scope 0 at vga/src/lib.rs:51:9: 54:10
        return;                          // scope 0 at vga/src/lib.rs:55:6: 55:6
    }
}

fn <impl at vga/src/lib.rs:49:1: 49:16>::inverse(_1: u8) -> ScreenChar {
    debug c => _1;                       // in scope 0 at vga/src/lib.rs:57:16: 57:17
    let mut _0: ScreenChar;              // return place in scope 0 at vga/src/lib.rs:57:26: 57:30
    let mut _2: ColorCode;               // in scope 0 at vga/src/lib.rs:60:25: 60:67
    let mut _3: Color;                   // in scope 0 at vga/src/lib.rs:60:40: 60:53
    let mut _4: Color;                   // in scope 0 at vga/src/lib.rs:60:55: 60:66

    bb0: {
        _3 = Color::Yellow;              // scope 0 at vga/src/lib.rs:60:40: 60:53
        _4 = Color::Blue;                // scope 0 at vga/src/lib.rs:60:55: 60:66
        _2 = ColorCode::new(move _3, move _4) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:60:25: 60:67
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:60:25: 60:39
                                         // + literal: Const { ty: fn(Color, Color) -> ColorCode {ColorCode::new}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = ScreenChar { char: _1, color_code: move _2 }; // scope 0 at vga/src/lib.rs:58:9: 61:10
        return;                          // scope 0 at vga/src/lib.rs:62:6: 62:6
    }
}

static VGA_COLOR_TEXT_MODE_ADDR: u64 = {
    let mut _0: u64;                     // return place in scope 0 at vga/src/lib.rs:68:34: 68:37

    bb0: {
        _0 = const 753664_u64;           // scope 0 at vga/src/lib.rs:68:40: 68:47
        return;                          // scope 0 at vga/src/lib.rs:68:1: 68:48
    }
}

const VGA_TEXT_BUF_HEIGHT: usize = {
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:69:28: 69:33

    bb0: {
        _0 = const 25_usize;             // scope 0 at vga/src/lib.rs:69:36: 69:38
        return;                          // scope 0 at vga/src/lib.rs:69:1: 69:39
    }
}

const VGA_TEXT_BUF_WIDTH: usize = {
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:70:27: 70:32

    bb0: {
        _0 = const 80_usize;             // scope 0 at vga/src/lib.rs:70:35: 70:37
        return;                          // scope 0 at vga/src/lib.rs:70:1: 70:38
    }
}

ScreenRow::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:72:31: 72:49

    bb0: {
        _0 = const _;                    // scope 0 at vga/src/lib.rs:72:31: 72:49
        return;                          // scope 0 at vga/src/lib.rs:72:31: 72:49
    }
}

Buffer::chars::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:76:24: 76:43

    bb0: {
        _0 = const _;                    // scope 0 at vga/src/lib.rs:76:24: 76:43
        return;                          // scope 0 at vga/src/lib.rs:76:24: 76:43
    }
}

fn <impl at vga/src/lib.rs:79:16: 79:21>::clone(_1: &Dot) -> Dot {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:79:16: 79:21
    let mut _0: Dot;                     // return place in scope 0 at vga/src/lib.rs:79:16: 79:21
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at vga/src/lib.rs:79:16: 79:21
        return;                          // scope 0 at vga/src/lib.rs:79:21: 79:21
    }
}

fn <impl at vga/src/lib.rs:85:16: 85:21>::clone(_1: &Cursor) -> Cursor {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:85:16: 85:21
    let mut _0: Cursor;                  // return place in scope 0 at vga/src/lib.rs:85:16: 85:21
    scope 1 {
    }

    bb0: {
        _0 = (*_1);                      // scope 1 at vga/src/lib.rs:85:16: 85:21
        return;                          // scope 0 at vga/src/lib.rs:85:21: 85:21
    }
}

fn <impl at vga/src/lib.rs:90:1: 90:12>::x(_1: &Cursor) -> usize {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:92:10: 92:15
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:92:20: 92:25

    bb0: {
        _0 = (((*_1).0: Dot).0: usize);  // scope 0 at vga/src/lib.rs:93:9: 93:19
        return;                          // scope 0 at vga/src/lib.rs:94:6: 94:6
    }
}

fn <impl at vga/src/lib.rs:90:1: 90:12>::y(_1: &Cursor) -> usize {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:97:10: 97:15
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:97:20: 97:25

    bb0: {
        _0 = (((*_1).0: Dot).1: usize);  // scope 0 at vga/src/lib.rs:98:9: 98:19
        return;                          // scope 0 at vga/src/lib.rs:99:6: 99:6
    }
}

fn <impl at vga/src/lib.rs:90:1: 90:12>::incr_x(_1: &mut Cursor) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:102:15: 102:24
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:102:26: 102:26
    let mut _2: (usize, bool);           // in scope 0 at vga/src/lib.rs:103:9: 103:24

    bb0: {
        _2 = CheckedAdd((((*_1).0: Dot).0: usize), const 1_usize); // scope 0 at vga/src/lib.rs:103:9: 103:24
        assert(!move (_2.1: bool), "attempt to compute `{} + {}`, which would overflow", (((*_1).0: Dot).0: usize), const 1_usize) -> [success: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:103:9: 103:24
    }

    bb1: {
        (((*_1).0: Dot).0: usize) = move (_2.0: usize); // scope 0 at vga/src/lib.rs:103:9: 103:24
        return;                          // scope 0 at vga/src/lib.rs:104:6: 104:6
    }
}

fn <impl at vga/src/lib.rs:90:1: 90:12>::decr_y(_1: &mut Cursor) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:107:15: 107:24
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:107:26: 107:26
    let mut _2: (usize, bool);           // in scope 0 at vga/src/lib.rs:108:9: 108:24

    bb0: {
        _2 = CheckedSub((((*_1).0: Dot).1: usize), const 1_usize); // scope 0 at vga/src/lib.rs:108:9: 108:24
        assert(!move (_2.1: bool), "attempt to compute `{} - {}`, which would overflow", (((*_1).0: Dot).1: usize), const 1_usize) -> [success: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:108:9: 108:24
    }

    bb1: {
        (((*_1).0: Dot).1: usize) = move (_2.0: usize); // scope 0 at vga/src/lib.rs:108:9: 108:24
        return;                          // scope 0 at vga/src/lib.rs:109:6: 109:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::width(_1: &Screen) -> usize {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:145:14: 145:19
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:145:24: 145:29
    let mut _2: &[ScreenChar];           // in scope 0 at vga/src/lib.rs:146:9: 146:32
    let mut _3: &[ScreenChar; 80];       // in scope 0 at vga/src/lib.rs:146:9: 146:32
    let _4: usize;                       // in scope 0 at vga/src/lib.rs:146:24: 146:25
    let mut _5: usize;                   // in scope 0 at vga/src/lib.rs:146:9: 146:26
    let mut _6: bool;                    // in scope 0 at vga/src/lib.rs:146:9: 146:26
    let mut _7: &mut Buffer;             // in scope 0 at vga/src/lib.rs:145:14: 145:19

    bb0: {
        _4 = const 0_usize;              // scope 0 at vga/src/lib.rs:146:24: 146:25
        _5 = const 25_usize;             // scope 0 at vga/src/lib.rs:146:9: 146:26
        _6 = Lt(_4, _5);                 // scope 0 at vga/src/lib.rs:146:9: 146:26
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _4) -> [success: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:146:9: 146:26
    }

    bb1: {
        _7 = deref_copy ((*_1).3: &mut Buffer); // scope 0 at vga/src/lib.rs:146:9: 146:32
        _3 = &((*_7).0: [[ScreenChar; 80]; 25])[_4]; // scope 0 at vga/src/lib.rs:146:9: 146:32
        _2 = move _3 as &[ScreenChar] (Pointer(Unsize)); // scope 0 at vga/src/lib.rs:146:9: 146:32
        _0 = Len((*_2));                 // scope 0 at vga/src/lib.rs:146:9: 146:32
        return;                          // scope 0 at vga/src/lib.rs:147:6: 147:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::height(_1: &Screen) -> usize {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:150:15: 150:20
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:150:25: 150:30
    let mut _2: &[[ScreenChar; 80]];     // in scope 0 at vga/src/lib.rs:151:9: 151:29
    let mut _3: &[[ScreenChar; 80]; 25]; // in scope 0 at vga/src/lib.rs:151:9: 151:29
    let mut _4: &mut Buffer;             // in scope 0 at vga/src/lib.rs:150:15: 150:20

    bb0: {
        _4 = deref_copy ((*_1).3: &mut Buffer); // scope 0 at vga/src/lib.rs:151:9: 151:29
        _3 = &((*_4).0: [[ScreenChar; 80]; 25]); // scope 0 at vga/src/lib.rs:151:9: 151:29
        _2 = move _3 as &[[ScreenChar; 80]] (Pointer(Unsize)); // scope 0 at vga/src/lib.rs:151:9: 151:29
        _0 = Len((*_2));                 // scope 0 at vga/src/lib.rs:151:9: 151:29
        return;                          // scope 0 at vga/src/lib.rs:152:6: 152:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::top_down_flow_screen(_1: &mut Buffer, _2: [ScreenChar; 80]) -> Screen {
    debug buf => _1;                     // in scope 0 at vga/src/lib.rs:154:29: 154:32
    debug blank_row => _2;               // in scope 0 at vga/src/lib.rs:154:55: 154:64
    let mut _0: Screen;                  // return place in scope 0 at vga/src/lib.rs:154:80: 154:84
    let _3: Dot;                         // in scope 0 at vga/src/lib.rs:155:13: 155:23
    let mut _4: TextFlowDirection;       // in scope 0 at vga/src/lib.rs:157:18: 157:44
    let mut _5: Cursor;                  // in scope 0 at vga/src/lib.rs:158:21: 158:47
    scope 1 {
        debug origin_dot => _3;          // in scope 1 at vga/src/lib.rs:155:13: 155:23
    }

    bb0: {
        _3 = Dot { x: const 0_usize, y: const 0_usize }; // scope 0 at vga/src/lib.rs:155:26: 155:44
        _4 = TextFlowDirection::TopDown; // scope 1 at vga/src/lib.rs:157:18: 157:44
        _5 = Cursor { pos: _3 };         // scope 1 at vga/src/lib.rs:158:21: 158:47
        _0 = Screen { water_level: const 1_usize, cursor: move _5, origin: _3, buf: _1, tfd: move _4, blank_row: _2 }; // scope 1 at vga/src/lib.rs:156:9: 163:10
        return;                          // scope 0 at vga/src/lib.rs:164:6: 164:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::bottom_up_flow_screen(_1: &mut Buffer, _2: [ScreenChar; 80]) -> Screen {
    debug buf => _1;                     // in scope 0 at vga/src/lib.rs:166:30: 166:33
    debug blank_row => _2;               // in scope 0 at vga/src/lib.rs:166:56: 166:65
    let mut _0: Screen;                  // return place in scope 0 at vga/src/lib.rs:166:81: 166:85
    let _3: usize;                       // in scope 0 at vga/src/lib.rs:167:13: 167:24
    let mut _4: (usize, bool);           // in scope 0 at vga/src/lib.rs:167:27: 167:50
    let mut _6: Cursor;                  // in scope 0 at vga/src/lib.rs:173:21: 173:47
    let mut _7: TextFlowDirection;       // in scope 0 at vga/src/lib.rs:174:18: 174:45
    let mut _8: usize;                   // in scope 0 at vga/src/lib.rs:175:26: 175:41
    let mut _9: (usize, bool);           // in scope 0 at vga/src/lib.rs:175:26: 175:41
    scope 1 {
        debug perceived_y => _3;         // in scope 1 at vga/src/lib.rs:167:13: 167:24
        let _5: Dot;                     // in scope 1 at vga/src/lib.rs:168:13: 168:23
        scope 2 {
            debug origin_dot => _5;      // in scope 2 at vga/src/lib.rs:168:13: 168:23
        }
    }

    bb0: {
        _4 = CheckedSub(const _, const 1_usize); // scope 0 at vga/src/lib.rs:167:27: 167:50
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_usize) -> [success: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:167:27: 167:50
    }

    bb1: {
        _3 = move (_4.0: usize);         // scope 0 at vga/src/lib.rs:167:27: 167:50
        _5 = Dot { x: const 0_usize, y: _3 }; // scope 1 at vga/src/lib.rs:168:26: 171:10
        _6 = Cursor { pos: _5 };         // scope 2 at vga/src/lib.rs:173:21: 173:47
        _7 = TextFlowDirection::BottomUp; // scope 2 at vga/src/lib.rs:174:18: 174:45
        _9 = CheckedSub(_3, const 1_usize); // scope 2 at vga/src/lib.rs:175:26: 175:41
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_usize) -> [success: bb2, unwind unreachable]; // scope 2 at vga/src/lib.rs:175:26: 175:41
    }

    bb2: {
        _8 = move (_9.0: usize);         // scope 2 at vga/src/lib.rs:175:26: 175:41
        _0 = Screen { water_level: move _8, cursor: move _6, origin: _5, buf: _1, tfd: move _7, blank_row: _2 }; // scope 2 at vga/src/lib.rs:172:9: 179:10
        return;                          // scope 0 at vga/src/lib.rs:180:6: 180:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::new(_1: TextFlowDirection, _2: u8) -> Screen {
    debug tfd => _1;                     // in scope 0 at vga/src/lib.rs:182:16: 182:19
    debug blank_row_char => _2;          // in scope 0 at vga/src/lib.rs:182:40: 182:54
    let mut _0: Screen;                  // return place in scope 0 at vga/src/lib.rs:182:63: 182:67
    let mut _3: &mut Buffer;             // in scope 0 at vga/src/lib.rs:183:28: 183:75
    let mut _4: *mut Buffer;             // in scope 0 at vga/src/lib.rs:183:34: 183:75
    let mut _5: u64;                     // in scope 0 at vga/src/lib.rs:183:35: 183:59
    let mut _6: &u64;                    // in scope 0 at vga/src/lib.rs:183:35: 183:59
    let mut _8: ScreenChar;              // in scope 0 at vga/src/lib.rs:184:26: 184:61
    let mut _10: isize;                  // in scope 0 at vga/src/lib.rs:186:13: 186:40
    let _11: ();                         // in scope 0 at vga/src/lib.rs:189:9: 189:23
    let mut _12: &mut Screen;            // in scope 0 at vga/src/lib.rs:189:9: 189:23
    scope 1 {
        debug buf => _3;                 // in scope 1 at vga/src/lib.rs:183:13: 183:16
        let _7: [ScreenChar; 80];        // in scope 1 at vga/src/lib.rs:184:13: 184:22
        scope 3 {
            debug blank_row => _7;       // in scope 3 at vga/src/lib.rs:184:13: 184:22
            let mut _9: Screen;          // in scope 3 at vga/src/lib.rs:185:13: 185:23
            scope 4 {
                debug screen => _9;      // in scope 4 at vga/src/lib.rs:185:13: 185:23
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _6 = const {alloc22: &u64};      // scope 2 at vga/src/lib.rs:183:35: 183:59
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:183:35: 183:59
                                         // + literal: Const { ty: &u64, val: Value(Scalar(alloc22)) }
        _5 = (*_6);                      // scope 2 at vga/src/lib.rs:183:35: 183:59
        _4 = move _5 as *mut Buffer (PointerFromExposedAddress); // scope 2 at vga/src/lib.rs:183:34: 183:75
        _3 = &mut (*_4);                 // scope 2 at vga/src/lib.rs:183:28: 183:75
        _8 = ScreenChar::inverse(_2) -> [return: bb1, unwind unreachable]; // scope 1 at vga/src/lib.rs:184:26: 184:61
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:184:26: 184:45
                                         // + literal: Const { ty: fn(u8) -> ScreenChar {ScreenChar::inverse}, val: Value(<ZST>) }
    }

    bb1: {
        _7 = [move _8; 80];              // scope 1 at vga/src/lib.rs:184:25: 184:82
        _10 = discriminant(_1);          // scope 3 at vga/src/lib.rs:185:32: 185:35
        switchInt(move _10) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 3 at vga/src/lib.rs:185:26: 185:35
    }

    bb2: {
        _9 = Screen::top_down_flow_screen(_3, _7) -> [return: bb5, unwind unreachable]; // scope 3 at vga/src/lib.rs:187:43: 187:87
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:187:43: 187:71
                                         // + literal: Const { ty: fn(&'static mut Buffer, [ScreenChar; VGA_TEXT_BUF_WIDTH]) -> Screen {Screen::top_down_flow_screen}, val: Value(<ZST>) }
    }

    bb3: {
        unreachable;                     // scope 3 at vga/src/lib.rs:185:32: 185:35
    }

    bb4: {
        _9 = Screen::bottom_up_flow_screen(_3, _7) -> [return: bb5, unwind unreachable]; // scope 3 at vga/src/lib.rs:186:44: 186:89
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:186:44: 186:73
                                         // + literal: Const { ty: fn(&'static mut Buffer, [ScreenChar; VGA_TEXT_BUF_WIDTH]) -> Screen {Screen::bottom_up_flow_screen}, val: Value(<ZST>) }
    }

    bb5: {
        _12 = &mut _9;                   // scope 4 at vga/src/lib.rs:189:9: 189:23
        _11 = Screen::clear(move _12) -> [return: bb6, unwind unreachable]; // scope 4 at vga/src/lib.rs:189:9: 189:23
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:189:16: 189:21
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen) {Screen::clear}, val: Value(<ZST>) }
    }

    bb6: {
        _0 = move _9;                    // scope 4 at vga/src/lib.rs:190:9: 190:15
        return;                          // scope 0 at vga/src/lib.rs:191:6: 191:6
    }
}

alloc22 (static: VGA_COLOR_TEXT_MODE_ADDR, size: 8, align: 8) {
    00 80 0b 00 00 00 00 00                         │ ........
}

<impl at vga/src/lib.rs:143:1: 143:12>::new::{constant#0}: usize = {
    let mut _0: usize;                   // return place in scope 0 at vga/src/lib.rs:184:63: 184:81

    bb0: {
        _0 = const _;                    // scope 0 at vga/src/lib.rs:184:63: 184:81
        return;                          // scope 0 at vga/src/lib.rs:184:63: 184:81
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::clear(_1: &mut Screen) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:193:14: 193:23
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:193:25: 193:25
    let mut _2: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:196:20: 196:36
    let mut _3: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:196:20: 196:36
    let mut _4: usize;                   // in scope 0 at vga/src/lib.rs:196:23: 196:36
    let mut _5: &Screen;                 // in scope 0 at vga/src/lib.rs:196:23: 196:36
    let mut _6: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:196:20: 196:36
    let mut _7: core::option::Option<usize>; // in scope 0 at vga/src/lib.rs:196:20: 196:36
    let mut _8: &mut core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:196:20: 196:36
    let mut _9: isize;                   // in scope 0 at vga/src/lib.rs:196:9: 198:10
    let mut _11: [ScreenChar; 80];       // in scope 0 at vga/src/lib.rs:197:35: 197:49
    let mut _12: usize;                  // in scope 0 at vga/src/lib.rs:197:13: 197:32
    let mut _13: bool;                   // in scope 0 at vga/src/lib.rs:197:13: 197:32
    let mut _14: &mut Buffer;            // in scope 0 at vga/src/lib.rs:193:14: 193:23
    scope 1 {
        debug iter => _6;                // in scope 1 at vga/src/lib.rs:196:20: 196:36
        let _10: usize;                  // in scope 1 at vga/src/lib.rs:196:13: 196:16
        scope 2 {
            debug row => _10;            // in scope 2 at vga/src/lib.rs:196:13: 196:16
        }
    }

    bb0: {
        _5 = &(*_1);                     // scope 0 at vga/src/lib.rs:196:23: 196:36
        _4 = Screen::height(move _5) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:196:23: 196:36
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:196:28: 196:34
                                         // + literal: Const { ty: for<'a> fn(&'a Screen) -> usize {Screen::height}, val: Value(<ZST>) }
    }

    bb1: {
        _3 = Range::<usize> { start: const 0_usize, end: move _4 }; // scope 0 at vga/src/lib.rs:196:20: 196:36
        _2 = <Range<usize> as IntoIterator>::into_iter(move _3) -> [return: bb2, unwind unreachable]; // scope 0 at vga/src/lib.rs:196:20: 196:36
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:196:20: 196:36
                                         // + literal: Const { ty: fn(Range<usize>) -> <Range<usize> as IntoIterator>::IntoIter {<Range<usize> as IntoIterator>::into_iter}, val: Value(<ZST>) }
    }

    bb2: {
        _6 = move _2;                    // scope 0 at vga/src/lib.rs:196:20: 196:36
        goto -> bb3;                     // scope 1 at vga/src/lib.rs:196:9: 198:10
    }

    bb3: {
        _8 = &mut _6;                    // scope 1 at vga/src/lib.rs:196:20: 196:36
        _7 = <Range<usize> as Iterator>::next(_8) -> [return: bb4, unwind unreachable]; // scope 1 at vga/src/lib.rs:196:20: 196:36
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:196:20: 196:36
                                         // + literal: Const { ty: for<'a> fn(&'a mut Range<usize>) -> Option<<Range<usize> as Iterator>::Item> {<Range<usize> as Iterator>::next}, val: Value(<ZST>) }
    }

    bb4: {
        _9 = discriminant(_7);           // scope 1 at vga/src/lib.rs:196:20: 196:36
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 1 at vga/src/lib.rs:196:20: 196:36
    }

    bb5: {
        _10 = ((_7 as Some).0: usize);   // scope 1 at vga/src/lib.rs:196:13: 196:16
        _11 = ((*_1).5: [ScreenChar; 80]); // scope 2 at vga/src/lib.rs:197:35: 197:49
        _12 = const 25_usize;            // scope 2 at vga/src/lib.rs:197:13: 197:32
        _13 = Lt(_10, _12);              // scope 2 at vga/src/lib.rs:197:13: 197:32
        assert(move _13, "index out of bounds: the length is {} but the index is {}", move _12, _10) -> [success: bb8, unwind unreachable]; // scope 2 at vga/src/lib.rs:197:13: 197:32
    }

    bb6: {
        unreachable;                     // scope 1 at vga/src/lib.rs:196:20: 196:36
    }

    bb7: {
        return;                          // scope 0 at vga/src/lib.rs:199:6: 199:6
    }

    bb8: {
        _14 = deref_copy ((*_1).3: &mut Buffer); // scope 2 at vga/src/lib.rs:197:13: 197:49
        ((*_14).0: [[ScreenChar; 80]; 25])[_10] = move _11; // scope 2 at vga/src/lib.rs:197:13: 197:49
        goto -> bb3;                     // scope 1 at vga/src/lib.rs:196:9: 198:10
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::print_sc(_1: &mut Screen, _2: ScreenChar) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:201:17: 201:26
    debug sc => _2;                      // in scope 0 at vga/src/lib.rs:201:28: 201:30
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:201:44: 201:44
    let _3: &mut ScreenChar;             // in scope 0 at vga/src/lib.rs:202:13: 202:16
    let _4: usize;                       // in scope 0 at vga/src/lib.rs:202:39: 202:54
    let mut _5: &Cursor;                 // in scope 0 at vga/src/lib.rs:202:39: 202:54
    let mut _6: usize;                   // in scope 0 at vga/src/lib.rs:202:24: 202:55
    let mut _7: bool;                    // in scope 0 at vga/src/lib.rs:202:24: 202:55
    let _8: usize;                       // in scope 0 at vga/src/lib.rs:202:56: 202:71
    let mut _9: &Cursor;                 // in scope 0 at vga/src/lib.rs:202:56: 202:71
    let mut _10: usize;                  // in scope 0 at vga/src/lib.rs:202:24: 202:72
    let mut _11: bool;                   // in scope 0 at vga/src/lib.rs:202:24: 202:72
    let _12: ();                         // in scope 0 at vga/src/lib.rs:209:18: 209:41
    let mut _13: *mut ScreenChar;        // in scope 0 at vga/src/lib.rs:209:33: 209:36
    let _14: ();                         // in scope 0 at vga/src/lib.rs:210:9: 210:29
    let mut _15: &mut Cursor;            // in scope 0 at vga/src/lib.rs:210:9: 210:29
    let mut _16: &mut Buffer;            // in scope 0 at vga/src/lib.rs:201:17: 201:26
    scope 1 {
        debug dst => _3;                 // in scope 1 at vga/src/lib.rs:202:13: 202:16
        scope 2 {
        }
    }

    bb0: {
        _5 = &((*_1).1: Cursor);         // scope 0 at vga/src/lib.rs:202:39: 202:54
        _4 = Cursor::y(move _5) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:202:39: 202:54
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:202:51: 202:52
                                         // + literal: Const { ty: for<'a> fn(&'a Cursor) -> usize {Cursor::y}, val: Value(<ZST>) }
    }

    bb1: {
        _6 = const 25_usize;             // scope 0 at vga/src/lib.rs:202:24: 202:55
        _7 = Lt(_4, _6);                 // scope 0 at vga/src/lib.rs:202:24: 202:55
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _4) -> [success: bb2, unwind unreachable]; // scope 0 at vga/src/lib.rs:202:24: 202:55
    }

    bb2: {
        _9 = &((*_1).1: Cursor);         // scope 0 at vga/src/lib.rs:202:56: 202:71
        _8 = Cursor::x(move _9) -> [return: bb3, unwind unreachable]; // scope 0 at vga/src/lib.rs:202:56: 202:71
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:202:68: 202:69
                                         // + literal: Const { ty: for<'a> fn(&'a Cursor) -> usize {Cursor::x}, val: Value(<ZST>) }
    }

    bb3: {
        _10 = const 80_usize;            // scope 0 at vga/src/lib.rs:202:24: 202:72
        _11 = Lt(_8, _10);               // scope 0 at vga/src/lib.rs:202:24: 202:72
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _8) -> [success: bb4, unwind unreachable]; // scope 0 at vga/src/lib.rs:202:24: 202:72
    }

    bb4: {
        _16 = deref_copy ((*_1).3: &mut Buffer); // scope 0 at vga/src/lib.rs:202:19: 202:72
        _3 = &mut ((*_16).0: [[ScreenChar; 80]; 25])[_4][_8]; // scope 0 at vga/src/lib.rs:202:19: 202:72
        _13 = &raw mut (*_3);            // scope 2 at vga/src/lib.rs:209:33: 209:36
        _12 = write_volatile::<ScreenChar>(move _13, _2) -> [return: bb5, unwind unreachable]; // scope 2 at vga/src/lib.rs:209:18: 209:41
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:209:18: 209:32
                                         // + literal: Const { ty: unsafe fn(*mut ScreenChar, ScreenChar) {write_volatile::<ScreenChar>}, val: Value(<ZST>) }
    }

    bb5: {
        _15 = &mut ((*_1).1: Cursor);    // scope 1 at vga/src/lib.rs:210:9: 210:29
        _14 = Cursor::incr_x(move _15) -> [return: bb6, unwind unreachable]; // scope 1 at vga/src/lib.rs:210:9: 210:29
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:210:21: 210:27
                                         // + literal: Const { ty: for<'a> fn(&'a mut Cursor) {Cursor::incr_x}, val: Value(<ZST>) }
    }

    bb6: {
        return;                          // scope 0 at vga/src/lib.rs:211:6: 211:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::should_wrap(_1: &Screen) -> bool {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:214:20: 214:25
    let mut _0: bool;                    // return place in scope 0 at vga/src/lib.rs:214:30: 214:34
    let mut _2: usize;                   // in scope 0 at vga/src/lib.rs:215:9: 215:24
    let mut _3: &Cursor;                 // in scope 0 at vga/src/lib.rs:215:9: 215:24
    let mut _4: usize;                   // in scope 0 at vga/src/lib.rs:215:28: 215:40

    bb0: {
        _3 = &((*_1).1: Cursor);         // scope 0 at vga/src/lib.rs:215:9: 215:24
        _2 = Cursor::x(move _3) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:215:9: 215:24
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:215:21: 215:22
                                         // + literal: Const { ty: for<'a> fn(&'a Cursor) -> usize {Cursor::x}, val: Value(<ZST>) }
    }

    bb1: {
        _4 = Screen::width(_1) -> [return: bb2, unwind unreachable]; // scope 0 at vga/src/lib.rs:215:28: 215:40
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:215:33: 215:38
                                         // + literal: Const { ty: for<'a> fn(&'a Screen) -> usize {Screen::width}, val: Value(<ZST>) }
    }

    bb2: {
        _0 = Eq(move _2, move _4);       // scope 0 at vga/src/lib.rs:215:9: 215:40
        return;                          // scope 0 at vga/src/lib.rs:216:6: 216:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::print(_1: &mut Screen, _2: u8) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:218:14: 218:23
    debug c => _2;                       // in scope 0 at vga/src/lib.rs:218:25: 218:26
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:218:32: 218:32
    let mut _3: bool;                    // in scope 0 at vga/src/lib.rs:221:12: 221:30
    let mut _4: &Screen;                 // in scope 0 at vga/src/lib.rs:221:12: 221:30
    let _5: ();                          // in scope 0 at vga/src/lib.rs:222:13: 222:34
    let mut _6: ScreenChar;              // in scope 0 at vga/src/lib.rs:224:23: 224:41

    bb0: {
        _4 = &(*_1);                     // scope 0 at vga/src/lib.rs:221:12: 221:30
        _3 = Screen::should_wrap(move _4) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:221:12: 221:30
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:221:17: 221:28
                                         // + literal: Const { ty: for<'a> fn(&'a Screen) -> bool {Screen::should_wrap}, val: Value(<ZST>) }
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2]; // scope 0 at vga/src/lib.rs:221:12: 221:30
    }

    bb2: {
        _5 = Screen::print_new_line(_1) -> [return: bb3, unwind unreachable]; // scope 0 at vga/src/lib.rs:222:13: 222:34
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:222:18: 222:32
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen) {Screen::print_new_line}, val: Value(<ZST>) }
    }

    bb3: {
        _6 = ScreenChar::new(_2) -> [return: bb4, unwind unreachable]; // scope 0 at vga/src/lib.rs:224:23: 224:41
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:224:23: 224:38
                                         // + literal: Const { ty: fn(u8) -> ScreenChar {ScreenChar::new}, val: Value(<ZST>) }
    }

    bb4: {
        _0 = Screen::print_sc(_1, move _6) -> [return: bb5, unwind unreachable]; // scope 0 at vga/src/lib.rs:224:9: 224:42
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:224:14: 224:22
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen, ScreenChar) {Screen::print_sc}, val: Value(<ZST>) }
    }

    bb5: {
        return;                          // scope 0 at vga/src/lib.rs:225:6: 225:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::recall_cursor_to_origin(_1: &mut Screen) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:228:32: 228:41
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:228:43: 228:43
    let mut _2: Dot;                     // in scope 0 at vga/src/lib.rs:229:27: 229:38

    bb0: {
        _2 = ((*_1).2: Dot);             // scope 0 at vga/src/lib.rs:229:27: 229:38
        (((*_1).1: Cursor).0: Dot) = move _2; // scope 0 at vga/src/lib.rs:229:9: 229:38
        return;                          // scope 0 at vga/src/lib.rs:230:6: 230:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::print_new_line(_1: &mut Screen) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:232:23: 232:32
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:232:34: 232:34
    let mut _2: isize;                   // in scope 0 at vga/src/lib.rs:234:13: 234:40
    let mut _3: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:235:28: 235:59
    let mut _4: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:235:28: 235:59
    let mut _5: usize;                   // in scope 0 at vga/src/lib.rs:235:28: 235:44
    let mut _6: usize;                   // in scope 0 at vga/src/lib.rs:235:46: 235:59
    let mut _7: &Screen;                 // in scope 0 at vga/src/lib.rs:235:46: 235:59
    let mut _8: core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:235:28: 235:59
    let mut _9: core::option::Option<usize>; // in scope 0 at vga/src/lib.rs:235:28: 235:59
    let mut _10: &mut core::ops::Range<usize>; // in scope 0 at vga/src/lib.rs:235:28: 235:59
    let mut _11: isize;                  // in scope 0 at vga/src/lib.rs:235:17: 242:18
    let mut _13: [ScreenChar; 80];       // in scope 0 at vga/src/lib.rs:240:47: 240:66
    let mut _14: usize;                  // in scope 0 at vga/src/lib.rs:240:47: 240:66
    let mut _15: bool;                   // in scope 0 at vga/src/lib.rs:240:47: 240:66
    let _16: usize;                      // in scope 0 at vga/src/lib.rs:240:36: 240:43
    let mut _17: (usize, bool);          // in scope 0 at vga/src/lib.rs:240:36: 240:43
    let mut _18: usize;                  // in scope 0 at vga/src/lib.rs:240:21: 240:44
    let mut _19: bool;                   // in scope 0 at vga/src/lib.rs:240:21: 240:44
    let mut _20: [ScreenChar; 80];       // in scope 0 at vga/src/lib.rs:241:43: 241:57
    let mut _21: usize;                  // in scope 0 at vga/src/lib.rs:241:21: 241:40
    let mut _22: bool;                   // in scope 0 at vga/src/lib.rs:241:21: 241:40
    let mut _23: bool;                   // in scope 0 at vga/src/lib.rs:245:20: 245:40
    let mut _24: usize;                  // in scope 0 at vga/src/lib.rs:245:20: 245:36
    let mut _25: (usize, bool);          // in scope 0 at vga/src/lib.rs:245:43: 245:64
    let _26: ();                         // in scope 0 at vga/src/lib.rs:246:17: 246:47
    let mut _27: &mut Buffer;            // in scope 0 at vga/src/lib.rs:232:23: 232:32
    let mut _28: &mut Buffer;            // in scope 0 at vga/src/lib.rs:232:23: 232:32
    let mut _29: &mut Buffer;            // in scope 0 at vga/src/lib.rs:232:23: 232:32
    scope 1 {
        debug iter => _8;                // in scope 1 at vga/src/lib.rs:235:28: 235:59
        let _12: usize;                  // in scope 1 at vga/src/lib.rs:235:21: 235:24
        scope 2 {
            debug row => _12;            // in scope 2 at vga/src/lib.rs:235:21: 235:24
        }
    }

    bb0: {
        _2 = discriminant(((*_1).4: TextFlowDirection)); // scope 0 at vga/src/lib.rs:233:15: 233:23
        switchInt(move _2) -> [0: bb17, 1: bb2, otherwise: bb1]; // scope 0 at vga/src/lib.rs:233:9: 233:23
    }

    bb1: {
        unreachable;                     // scope 0 at vga/src/lib.rs:233:15: 233:23
    }

    bb2: {
        _5 = ((*_1).0: usize);           // scope 0 at vga/src/lib.rs:235:28: 235:44
        _7 = &(*_1);                     // scope 0 at vga/src/lib.rs:235:46: 235:59
        _6 = Screen::height(move _7) -> [return: bb3, unwind unreachable]; // scope 0 at vga/src/lib.rs:235:46: 235:59
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:235:51: 235:57
                                         // + literal: Const { ty: for<'a> fn(&'a Screen) -> usize {Screen::height}, val: Value(<ZST>) }
    }

    bb3: {
        _4 = Range::<usize> { start: move _5, end: move _6 }; // scope 0 at vga/src/lib.rs:235:28: 235:59
        _3 = <Range<usize> as IntoIterator>::into_iter(move _4) -> [return: bb4, unwind unreachable]; // scope 0 at vga/src/lib.rs:235:28: 235:59
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:235:28: 235:59
                                         // + literal: Const { ty: fn(Range<usize>) -> <Range<usize> as IntoIterator>::IntoIter {<Range<usize> as IntoIterator>::into_iter}, val: Value(<ZST>) }
    }

    bb4: {
        _8 = move _3;                    // scope 0 at vga/src/lib.rs:235:28: 235:59
        goto -> bb5;                     // scope 1 at vga/src/lib.rs:235:17: 242:18
    }

    bb5: {
        _10 = &mut _8;                   // scope 1 at vga/src/lib.rs:235:28: 235:59
        _9 = <Range<usize> as Iterator>::next(_10) -> [return: bb6, unwind unreachable]; // scope 1 at vga/src/lib.rs:235:28: 235:59
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:235:28: 235:59
                                         // + literal: Const { ty: for<'a> fn(&'a mut Range<usize>) -> Option<<Range<usize> as Iterator>::Item> {<Range<usize> as Iterator>::next}, val: Value(<ZST>) }
    }

    bb6: {
        _11 = discriminant(_9);          // scope 1 at vga/src/lib.rs:235:28: 235:59
        switchInt(move _11) -> [0: bb8, 1: bb7, otherwise: bb1]; // scope 1 at vga/src/lib.rs:235:28: 235:59
    }

    bb7: {
        _12 = ((_9 as Some).0: usize);   // scope 1 at vga/src/lib.rs:235:21: 235:24
        switchInt(move _12) -> [0: bb5, otherwise: bb9]; // scope 2 at vga/src/lib.rs:236:24: 236:32
    }

    bb8: {
        _24 = ((*_1).0: usize);          // scope 0 at vga/src/lib.rs:245:20: 245:36
        _23 = Gt(move _24, const 0_usize); // scope 0 at vga/src/lib.rs:245:20: 245:40
        switchInt(move _23) -> [0: bb16, otherwise: bb14]; // scope 0 at vga/src/lib.rs:245:20: 245:40
    }

    bb9: {
        _14 = const 25_usize;            // scope 2 at vga/src/lib.rs:240:47: 240:66
        _15 = Lt(_12, _14);              // scope 2 at vga/src/lib.rs:240:47: 240:66
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _12) -> [success: bb10, unwind unreachable]; // scope 2 at vga/src/lib.rs:240:47: 240:66
    }

    bb10: {
        _27 = deref_copy ((*_1).3: &mut Buffer); // scope 2 at vga/src/lib.rs:240:47: 240:66
        _13 = ((*_27).0: [[ScreenChar; 80]; 25])[_12]; // scope 2 at vga/src/lib.rs:240:47: 240:66
        _17 = CheckedSub(_12, const 1_usize); // scope 2 at vga/src/lib.rs:240:36: 240:43
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 1_usize) -> [success: bb11, unwind unreachable]; // scope 2 at vga/src/lib.rs:240:36: 240:43
    }

    bb11: {
        _16 = move (_17.0: usize);       // scope 2 at vga/src/lib.rs:240:36: 240:43
        _18 = const 25_usize;            // scope 2 at vga/src/lib.rs:240:21: 240:44
        _19 = Lt(_16, _18);              // scope 2 at vga/src/lib.rs:240:21: 240:44
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _16) -> [success: bb12, unwind unreachable]; // scope 2 at vga/src/lib.rs:240:21: 240:44
    }

    bb12: {
        _28 = deref_copy ((*_1).3: &mut Buffer); // scope 2 at vga/src/lib.rs:240:21: 240:66
        ((*_28).0: [[ScreenChar; 80]; 25])[_16] = move _13; // scope 2 at vga/src/lib.rs:240:21: 240:66
        _20 = ((*_1).5: [ScreenChar; 80]); // scope 2 at vga/src/lib.rs:241:43: 241:57
        _21 = const 25_usize;            // scope 2 at vga/src/lib.rs:241:21: 241:40
        _22 = Lt(_12, _21);              // scope 2 at vga/src/lib.rs:241:21: 241:40
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _12) -> [success: bb13, unwind unreachable]; // scope 2 at vga/src/lib.rs:241:21: 241:40
    }

    bb13: {
        _29 = deref_copy ((*_1).3: &mut Buffer); // scope 2 at vga/src/lib.rs:241:21: 241:57
        ((*_29).0: [[ScreenChar; 80]; 25])[_12] = move _20; // scope 2 at vga/src/lib.rs:241:21: 241:57
        goto -> bb5;                     // scope 1 at vga/src/lib.rs:235:17: 242:18
    }

    bb14: {
        _25 = CheckedSub(((*_1).0: usize), const 1_usize); // scope 0 at vga/src/lib.rs:245:43: 245:64
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", ((*_1).0: usize), const 1_usize) -> [success: bb15, unwind unreachable]; // scope 0 at vga/src/lib.rs:245:43: 245:64
    }

    bb15: {
        ((*_1).0: usize) = move (_25.0: usize); // scope 0 at vga/src/lib.rs:245:43: 245:64
        goto -> bb16;                    // scope 0 at vga/src/lib.rs:245:17: 245:67
    }

    bb16: {
        _26 = Screen::recall_cursor_to_origin(_1) -> [return: bb17, unwind unreachable]; // scope 0 at vga/src/lib.rs:246:17: 246:47
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:246:22: 246:45
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen) {Screen::recall_cursor_to_origin}, val: Value(<ZST>) }
    }

    bb17: {
        return;                          // scope 0 at vga/src/lib.rs:256:6: 256:6
    }
}

fn <impl at vga/src/lib.rs:143:1: 143:12>::print_text(_1: &mut Screen, _2: &str) -> () {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:258:23: 258:32
    debug text => _2;                    // in scope 0 at vga/src/lib.rs:258:34: 258:38
    let mut _0: ();                      // return place in scope 0 at vga/src/lib.rs:258:46: 258:46
    let mut _3: core::str::Bytes<'_>;    // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let mut _4: core::str::Bytes<'_>;    // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let mut _5: core::str::Bytes<'_>;    // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let _6: ();                          // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let mut _7: core::option::Option<u8>; // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let mut _8: &mut core::str::Bytes<'_>; // in scope 0 at vga/src/lib.rs:262:21: 262:33
    let mut _9: isize;                   // in scope 0 at vga/src/lib.rs:262:9: 268:10
    let mut _11: bool;                   // in scope 0 at vga/src/lib.rs:264:17: 264:28
    let mut _12: bool;                   // in scope 0 at vga/src/lib.rs:264:17: 264:28
    let mut _13: u8;                     // in scope 0 at vga/src/lib.rs:266:33: 266:45
    let mut _14: &u8;                    // in scope 0 at vga/src/lib.rs:266:33: 266:45
    scope 1 {
        debug iter => _5;                // in scope 1 at vga/src/lib.rs:262:21: 262:33
        let _10: u8;                     // in scope 1 at vga/src/lib.rs:262:13: 262:17
        scope 2 {
            debug byte => _10;           // in scope 2 at vga/src/lib.rs:262:13: 262:17
        }
    }

    bb0: {
        _4 = str::<impl str>::bytes(_2) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:262:21: 262:33
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:262:26: 262:31
                                         // + literal: Const { ty: for<'a> fn(&'a str) -> Bytes<'a> {str::<impl str>::bytes}, val: Value(<ZST>) }
    }

    bb1: {
        _3 = <Bytes<'_> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind unreachable]; // scope 0 at vga/src/lib.rs:262:21: 262:33
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:262:21: 262:33
                                         // + literal: Const { ty: fn(Bytes<'_>) -> <Bytes<'_> as IntoIterator>::IntoIter {<Bytes<'_> as IntoIterator>::into_iter}, val: Value(<ZST>) }
    }

    bb2: {
        _5 = move _3;                    // scope 0 at vga/src/lib.rs:262:21: 262:33
        goto -> bb3;                     // scope 1 at vga/src/lib.rs:262:9: 268:10
    }

    bb3: {
        _8 = &mut _5;                    // scope 1 at vga/src/lib.rs:262:21: 262:33
        _7 = <Bytes<'_> as Iterator>::next(_8) -> [return: bb4, unwind unreachable]; // scope 1 at vga/src/lib.rs:262:21: 262:33
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:262:21: 262:33
                                         // + literal: Const { ty: for<'a> fn(&'a mut Bytes<'_>) -> Option<<Bytes<'_> as Iterator>::Item> {<Bytes<'_> as Iterator>::next}, val: Value(<ZST>) }
    }

    bb4: {
        _9 = discriminant(_7);           // scope 1 at vga/src/lib.rs:262:21: 262:33
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 1 at vga/src/lib.rs:262:21: 262:33
    }

    bb5: {
        _10 = ((_7 as Some).0: u8);      // scope 1 at vga/src/lib.rs:262:13: 262:17
        _11 = Le(const 32_u8, _10);      // scope 2 at vga/src/lib.rs:264:17: 264:28
        switchInt(move _11) -> [0: bb9, otherwise: bb8]; // scope 2 at vga/src/lib.rs:264:17: 264:28
    }

    bb6: {
        unreachable;                     // scope 1 at vga/src/lib.rs:262:21: 262:33
    }

    bb7: {
        return;                          // scope 0 at vga/src/lib.rs:269:6: 269:6
    }

    bb8: {
        _12 = Le(_10, const 126_u8);     // scope 2 at vga/src/lib.rs:264:17: 264:28
        switchInt(move _12) -> [0: bb9, otherwise: bb11]; // scope 2 at vga/src/lib.rs:264:17: 264:28
    }

    bb9: {
        switchInt(_10) -> [10: bb12, otherwise: bb10]; // scope 2 at vga/src/lib.rs:263:13: 263:23
    }

    bb10: {
        _14 = const {alloc23: &u8};      // scope 2 at vga/src/lib.rs:266:33: 266:45
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:266:33: 266:45
                                         // + literal: Const { ty: &u8, val: Value(Scalar(alloc23)) }
        _13 = (*_14);                    // scope 2 at vga/src/lib.rs:266:33: 266:45
        _6 = Screen::print(_1, move _13) -> [return: bb3, unwind unreachable]; // scope 2 at vga/src/lib.rs:266:22: 266:46
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:266:27: 266:32
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen, u8) {Screen::print}, val: Value(<ZST>) }
    }

    bb11: {
        _6 = Screen::print(_1, _10) -> [return: bb3, unwind unreachable]; // scope 2 at vga/src/lib.rs:264:32: 264:48
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:264:37: 264:42
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen, u8) {Screen::print}, val: Value(<ZST>) }
    }

    bb12: {
        _6 = Screen::print_new_line(_1) -> [return: bb3, unwind unreachable]; // scope 2 at vga/src/lib.rs:265:26: 265:47
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:265:31: 265:45
                                         // + literal: Const { ty: for<'a> fn(&'a mut Screen) {Screen::print_new_line}, val: Value(<ZST>) }
    }
}

alloc23 (static: PI_CHAR_CODE, size: 1, align: 1) {
    e3                                              │ .
}

fn <impl at vga/src/lib.rs:272:1: 272:22>::write_str(_1: &mut Screen, _2: &str) -> Result<(), core::fmt::Error> {
    debug self => _1;                    // in scope 0 at vga/src/lib.rs:273:18: 273:27
    debug text => _2;                    // in scope 0 at vga/src/lib.rs:273:29: 273:33
    let mut _0: core::result::Result<(), core::fmt::Error>; // return place in scope 0 at vga/src/lib.rs:273:44: 273:50
    let mut _3: ();                      // in scope 0 at vga/src/lib.rs:274:12: 274:33

    bb0: {
        _3 = Screen::print_text(_1, _2) -> [return: bb1, unwind unreachable]; // scope 0 at vga/src/lib.rs:274:12: 274:33
                                         // mir::Constant
                                         // + span: vga/src/lib.rs:274:17: 274:27
                                         // + literal: Const { ty: for<'a, 'b> fn(&'a mut Screen, &'b str) {Screen::print_text}, val: Value(<ZST>) }
    }

    bb1: {
        _0 = Result::<(), core::fmt::Error>::Ok(const ()); // scope 0 at vga/src/lib.rs:274:9: 274:34
        return;                          // scope 0 at vga/src/lib.rs:275:6: 275:6
    }
}

fn ColorCode(_1: u8) -> ColorCode {
    let mut _0: ColorCode;               // return place in scope 0 at vga/src/lib.rs:34:1: 34:17

    bb0: {
        _0 = ColorCode(move _1);         // scope 0 at vga/src/lib.rs:34:1: 34:17
        return;                          // scope 0 at vga/src/lib.rs:34:1: 34:17
    }
}

// MIR FOR CTFE
fn ColorCode(_1: u8) -> ColorCode {
    let mut _0: ColorCode;               // return place in scope 0 at vga/src/lib.rs:34:1: 34:17

    bb0: {
        _0 = ColorCode(move _1);         // scope 0 at vga/src/lib.rs:34:1: 34:17
        return;                          // scope 0 at vga/src/lib.rs:34:1: 34:17
    }
}
