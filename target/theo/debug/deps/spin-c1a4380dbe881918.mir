// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:81:10: 81:15>::fmt(_1: &MutexGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&core::sync::atomic::AtomicBool;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&&mut T;
    let _10: &&mut T;

    bb0: {
        _3 = const "MutexGuard";
        _4 = const "lock";
        _6 = &((*_1).0: &core::sync::atomic::AtomicBool);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "data";
        _10 = &((*_1).1: &mut T);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:92:1: 92:17>::new(_1: T) -> Mutex<T> {
    debug user_data => _1;
    let mut _0: mutex::Mutex<T>;
    let mut _2: core::sync::atomic::AtomicBool;
    let mut _3: core::cell::UnsafeCell<T>;

    bb0: {
        _2 = AtomicBool::new(const false) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = UnsafeCell::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = Mutex::<T> { lock: move _2, data: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:92:1: 92:17>::new(_1: T) -> Mutex<T> {
    debug user_data => _1;
    let mut _0: mutex::Mutex<T>;
    let mut _2: core::sync::atomic::AtomicBool;
    let mut _3: core::cell::UnsafeCell<T>;
    let mut _4: T;
    let mut _5: bool;

    bb0: {
        _5 = const false;
        _5 = const true;
        StorageLive(_2);
        ConstEvalCounter;
        _2 = AtomicBool::new(const false) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_3);
        StorageLive(_4);
        _5 = const false;
        _4 = move _1;
        ConstEvalCounter;
        _3 = UnsafeCell::<T>::new(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_4);
        _0 = Mutex::<T> { lock: move _2, data: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:92:1: 92:17>::into_inner(_1: Mutex<T>) -> T {
    debug self => _1;
    let mut _0: T;
    let _2: core::cell::UnsafeCell<T>;
    scope 1 {
        debug data => _2;
    }

    bb0: {
        _2 = move (_1.1: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::into_inner(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:127:1: 127:25>::obtain_lock(_1: &Mutex<T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: &core::sync::atomic::AtomicBool;
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: bool;
    let mut _6: &core::sync::atomic::AtomicBool;
    let mut _7: core::sync::atomic::Ordering;
    let _8: ();

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = &((*_1).0: core::sync::atomic::AtomicBool);
        _4 = Acquire;
        _2 = AtomicBool::compare_and_swap(move _3, const false, const true, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _2) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _6 = &((*_1).0: core::sync::atomic::AtomicBool);
        _7 = Relaxed;
        _5 = AtomicBool::load(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _5) -> [0: bb1, otherwise: bb5];
    }

    bb5: {
        _8 = spin_loop_hint() -> [return: bb3, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:127:1: 127:25>::lock(_1: &Mutex<T>) -> MutexGuard<'_, T> {
    debug self => _1;
    let mut _0: mutex::MutexGuard<'_, T>;
    let _2: ();
    let _3: &core::sync::atomic::AtomicBool;
    let mut _4: &mut T;
    let mut _5: *mut T;
    let mut _6: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _2 = Mutex::<T>::obtain_lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &((*_1).0: core::sync::atomic::AtomicBool);
        _6 = &((*_1).1: core::cell::UnsafeCell<T>);
        _5 = UnsafeCell::<T>::get(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = &mut (*_5);
        _0 = MutexGuard::<'_, T> { lock: _3, data: _4 };
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:127:1: 127:25>::force_unlock(_1: &Mutex<T>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: &core::sync::atomic::AtomicBool;
    let mut _4: core::sync::atomic::Ordering;

    bb0: {
        _3 = &((*_1).0: core::sync::atomic::AtomicBool);
        _4 = Release;
        _2 = AtomicBool::store(move _3, const false, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:127:1: 127:25>::try_lock(_1: &Mutex<T>) -> Option<MutexGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<mutex::MutexGuard<'_, T>>;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: &core::sync::atomic::AtomicBool;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: mutex::MutexGuard<'_, T>;
    let _7: &core::sync::atomic::AtomicBool;
    let mut _8: &mut T;
    let mut _9: *mut T;
    let mut _10: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _4 = &((*_1).0: core::sync::atomic::AtomicBool);
        _5 = Acquire;
        _3 = AtomicBool::compare_and_swap(move _4, const false, const true, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Not(move _3);
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).0: core::sync::atomic::AtomicBool);
        _10 = &((*_1).1: core::cell::UnsafeCell<T>);
        _9 = UnsafeCell::<T>::get(move _10) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = &mut (*_9);
        _6 = MutexGuard::<'_, T> { lock: _7, data: _8 };
        _0 = Option::<MutexGuard<'_, T>>::Some(move _6);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<MutexGuard<'_, T>>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt(_1: &Mutex<T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<mutex::MutexGuard<'_, T>>;
    let mut _4: isize;
    let _5: mutex::MutexGuard<'_, T>;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:204:15: 204:19};
    let mut _12: &mutex::MutexGuard<'_, T>;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:205:15: 205:19};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug guard => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = Mutex::<T>::try_lock(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb9, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Some).0: mutex::MutexGuard<'_, T>);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:204:15: 204:19} { guard: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:204:15: 204:19}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:205:15: 205:19} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:205:15: 205:19}>(move _6, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        drop(_5) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Mutex { <locked> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Mutex { data: "];
        _0 = &_1;
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:204:15: 204:19}, _2: ()) -> Result<(), core::fmt::Error> {
    debug guard => (*(_1.0: &mutex::MutexGuard<'_, T>));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;
    let mut _4: &mutex::MutexGuard<'_, T>;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _4 = deref_copy (_1.0: &mutex::MutexGuard<'_, T>);
        _3 = <MutexGuard<'_, T> as Deref>::deref(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_3, _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:205:15: 205:19}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:197:1: 197:53>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:211:1: 211:47>::default() -> Mutex<T> {
    let mut _0: mutex::Mutex<T>;
    let mut _1: T;

    bb0: {
        _1 = <T as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Mutex::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:217:1: 217:48>::deref(_1: &MutexGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: &mut T;

    bb0: {
        _2 = deref_copy ((*_1).1: &mut T);
        _0 = &(*_2);
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:223:1: 223:51>::deref_mut(_1: &mut MutexGuard<'_, T>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;

    bb0: {
        _0 = deref_copy ((*_1).1: &mut T);
        return;
    }
}

fn mutex::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/mutex.rs:228:1: 228:47>::drop(_1: &mut MutexGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: core::sync::atomic::Ordering;
    let mut _4: &core::sync::atomic::AtomicBool;

    bb0: {
        _4 = deref_copy ((*_1).0: &core::sync::atomic::AtomicBool);
        _3 = Release;
        _2 = AtomicBool::store(_4, const false, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const READER: usize = {
    let mut _0: usize;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 2_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_usize, const 2_i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const UPGRADED: usize = {
    let mut _0: usize;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 1_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_usize, const 1_i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const WRITER: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:72:10: 72:15>::fmt(_1: &RwLockReadGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&core::sync::atomic::AtomicUsize;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &&core::ptr::NonNull<T>;
    let _10: &core::ptr::NonNull<T>;

    bb0: {
        _3 = const "RwLockReadGuard";
        _4 = const "lock";
        _6 = &((*_1).0: &core::sync::atomic::AtomicUsize);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "data";
        _10 = &((*_1).1: core::ptr::NonNull<T>);
        _9 = &_10;
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:81:10: 81:15>::fmt(_1: &RwLockWriteGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&core::sync::atomic::AtomicUsize;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &core::ptr::NonNull<T>;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &&core::marker::PhantomData<&mut T>;
    let _13: &core::marker::PhantomData<&mut T>;

    bb0: {
        _3 = const "RwLockWriteGuard";
        _4 = const "lock";
        _6 = &((*_1).0: &core::sync::atomic::AtomicUsize);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "data";
        _9 = &((*_1).1: core::ptr::NonNull<T>);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "_invariant";
        _13 = &((*_1).2: core::marker::PhantomData<&mut T>);
        _12 = &_13;
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:97:10: 97:15>::fmt(_1: &RwLockUpgradeableGuard<'_, T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn core::fmt::Debug;
    let _6: &&core::sync::atomic::AtomicUsize;
    let _7: &str;
    let mut _8: &dyn core::fmt::Debug;
    let _9: &core::ptr::NonNull<T>;
    let _10: &str;
    let mut _11: &dyn core::fmt::Debug;
    let _12: &&core::marker::PhantomData<&mut T>;
    let _13: &core::marker::PhantomData<&mut T>;

    bb0: {
        _3 = const "RwLockUpgradeableGuard";
        _4 = const "lock";
        _6 = &((*_1).0: &core::sync::atomic::AtomicUsize);
        _5 = _6 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "data";
        _9 = &((*_1).1: core::ptr::NonNull<T>);
        _8 = _9 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "_invariant";
        _13 = &((*_1).2: core::marker::PhantomData<&mut T>);
        _12 = &_13;
        _11 = _12 as &dyn core::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:109:1: 109:18>::new(_1: T) -> RwLock<T> {
    debug user_data => _1;
    let mut _0: rw_lock::RwLock<T>;
    let mut _2: core::sync::atomic::AtomicUsize;
    let mut _3: core::cell::UnsafeCell<T>;

    bb0: {
        _2 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = UnsafeCell::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = RwLock::<T> { lock: move _2, data: move _3 };
        return;
    }
}

// MIR FOR CTFE
fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:109:1: 109:18>::new(_1: T) -> RwLock<T> {
    debug user_data => _1;
    let mut _0: rw_lock::RwLock<T>;
    let mut _2: core::sync::atomic::AtomicUsize;
    let mut _3: core::cell::UnsafeCell<T>;
    let mut _4: T;
    let mut _5: bool;

    bb0: {
        _5 = const false;
        _5 = const true;
        StorageLive(_2);
        ConstEvalCounter;
        _2 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        StorageLive(_3);
        StorageLive(_4);
        _5 = const false;
        _4 = move _1;
        ConstEvalCounter;
        _3 = UnsafeCell::<T>::new(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        StorageDead(_4);
        _0 = RwLock::<T> { lock: move _2, data: move _3 };
        StorageDead(_3);
        StorageDead(_2);
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:109:1: 109:18>::into_inner(_1: RwLock<T>) -> T {
    debug self => _1;
    let mut _0: T;
    let _2: core::cell::UnsafeCell<T>;
    scope 1 {
        debug data => _2;
    }

    bb0: {
        _2 = move (_1.1: core::cell::UnsafeCell<T>);
        _0 = UnsafeCell::<T>::into_inner(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::read(_1: &RwLock<T>) -> RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockReadGuard<'_, T>;
    let mut _2: ();
    let mut _3: core::option::Option<rw_lock::RwLockReadGuard<'_, T>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = RwLock::<T>::try_read(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rw_lock::RwLockReadGuard<'_, T>);
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::try_read(_1: &RwLock<T>) -> Option<RwLockReadGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<rw_lock::RwLockReadGuard<'_, T>>;
    let _2: usize;
    let mut _3: &core::sync::atomic::AtomicUsize;
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: usize;
    let mut _6: usize;
    let _7: usize;
    let mut _8: &core::sync::atomic::AtomicUsize;
    let mut _9: core::sync::atomic::Ordering;
    let mut _10: rw_lock::RwLockReadGuard<'_, T>;
    let _11: &core::sync::atomic::AtomicUsize;
    let mut _12: core::ptr::NonNull<T>;
    let mut _13: *mut T;
    let mut _14: &core::cell::UnsafeCell<T>;
    scope 1 {
        debug value => _2;
        scope 2 {
        }
    }

    bb0: {
        _3 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _4 = Acquire;
        _2 = AtomicUsize::fetch_add(move _3, const _, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = BitOr(const _, const _);
        _5 = BitAnd(_2, move _6);
        switchInt(move _5) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _8 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _9 = Release;
        _7 = AtomicUsize::fetch_sub(move _8, const _, move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = Option::<RwLockReadGuard<'_, T>>::None;
        goto -> bb7;
    }

    bb4: {
        _11 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _14 = &((*_1).1: core::cell::UnsafeCell<T>);
        _13 = UnsafeCell::<T>::get(move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _12 = NonNull::<T>::new_unchecked(move _13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = RwLockReadGuard::<'_, T> { lock: _11, data: move _12 };
        _0 = Option::<RwLockReadGuard<'_, T>>::Some(move _10);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::force_read_decrement(_1: &RwLock<T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: usize;
    let mut _9: !;
    let _10: usize;
    let mut _11: &core::sync::atomic::AtomicUsize;
    let mut _12: core::sync::atomic::Ordering;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _7 = Relaxed;
        _5 = AtomicUsize::load(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Not(const _);
        _4 = BitAnd(move _5, move _8);
        _3 = Gt(move _4, const 0_usize);
        switchInt(move _3) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = panic(const "assertion failed: self.lock.load(Ordering::Relaxed) & !WRITER > 0") -> unwind unreachable;
    }

    bb4: {
        _11 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _12 = Release;
        _10 = AtomicUsize::fetch_sub(move _11, const _, move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::force_write_unlock(_1: &RwLock<T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: &core::sync::atomic::AtomicUsize;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: usize;
    let mut _10: usize;
    let _11: &usize;
    let _12: &usize;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: usize;
    let _17: !;
    let mut _18: core::option::Option<core::fmt::Arguments<'_>>;
    let _19: usize;
    let mut _20: &core::sync::atomic::AtomicUsize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: core::sync::atomic::Ordering;
    let mut _24: &usize;
    scope 1 {
        debug left_val => _11;
        debug right_val => _12;
        let _16: core::panicking::AssertKind;
        scope 2 {
            debug kind => _16;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _7 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _8 = Relaxed;
        _6 = AtomicUsize::load(move _7, move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = BitOr(const _, const _);
        _9 = Not(move _10);
        _5 = BitAnd(move _6, move _9);
        _4 = &_5;
        _24 = const _;
        _3 = (move _4, _24);
        _11 = (_3.0: &usize);
        _12 = (_3.1: &usize);
        _14 = (*_11);
        _15 = (*_12);
        _13 = Eq(move _14, move _15);
        switchInt(move _13) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _16 = core::panicking::AssertKind::Eq;
        _18 = Option::<Arguments<'_>>::None;
        _17 = assert_failed::<usize, usize>(move _16, _11, _12, move _18) -> unwind unreachable;
    }

    bb4: {
        _20 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _22 = BitOr(const _, const _);
        _21 = Not(move _22);
        _23 = Release;
        _19 = AtomicUsize::fetch_and(move _20, move _21, move _23) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::force_write_unlock: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const 0_usize;
        _0 = &_1;
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::try_write_internal(_1: &RwLock<T>, _2: bool) -> Option<RwLockWriteGuard<'_, T>> {
    debug self => _1;
    debug strong => _2;
    let mut _0: core::option::Option<rw_lock::RwLockWriteGuard<'_, T>>;
    let mut _3: bool;
    let mut _4: &core::result::Result<usize, usize>;
    let _5: core::result::Result<usize, usize>;
    let _6: &core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: core::sync::atomic::Ordering;
    let mut _9: rw_lock::RwLockWriteGuard<'_, T>;
    let _10: &core::sync::atomic::AtomicUsize;
    let mut _11: core::ptr::NonNull<T>;
    let mut _12: *mut T;
    let mut _13: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _6 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _7 = Acquire;
        _8 = Relaxed;
        _5 = compare_exchange(_6, const 0_usize, const _, move _7, move _8, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = Result::<usize, usize>::is_ok(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _3) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _10 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _13 = &((*_1).1: core::cell::UnsafeCell<T>);
        _12 = UnsafeCell::<T>::get(move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = NonNull::<T>::new_unchecked(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = RwLockWriteGuard::<'_, T> { lock: _10, data: move _11, _invariant: const ZeroSized: PhantomData<&mut T> };
        _0 = Option::<RwLockWriteGuard<'_, T>>::Some(move _9);
        goto -> bb7;
    }

    bb6: {
        _0 = Option::<RwLockWriteGuard<'_, T>>::None;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::write(_1: &RwLock<T>) -> RwLockWriteGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockWriteGuard<'_, T>;
    let mut _2: ();
    let mut _3: core::option::Option<rw_lock::RwLockWriteGuard<'_, T>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = RwLock::<T>::try_write_internal(_1, const false) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rw_lock::RwLockWriteGuard<'_, T>);
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::try_write(_1: &RwLock<T>) -> Option<RwLockWriteGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<rw_lock::RwLockWriteGuard<'_, T>>;

    bb0: {
        _0 = RwLock::<T>::try_write_internal(_1, const true) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::upgradeable_read(_1: &RwLock<T>) -> RwLockUpgradeableGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let mut _2: ();
    let mut _3: core::option::Option<rw_lock::RwLockUpgradeableGuard<'_, T>>;
    let mut _4: isize;
    scope 1 {
        debug guard => _0;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = RwLock::<T>::try_upgradeable_read(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _2 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_3 as Some).0: rw_lock::RwLockUpgradeableGuard<'_, T>);
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:143:1: 143:26>::try_upgradeable_read(_1: &RwLock<T>) -> Option<RwLockUpgradeableGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::option::Option<rw_lock::RwLockUpgradeableGuard<'_, T>>;
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: &core::sync::atomic::AtomicUsize;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: usize;
    let mut _7: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let _8: &core::sync::atomic::AtomicUsize;
    let mut _9: core::ptr::NonNull<T>;
    let mut _10: *mut T;
    let mut _11: &core::cell::UnsafeCell<T>;
    scope 1 {
    }

    bb0: {
        _4 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _5 = Acquire;
        _3 = AtomicUsize::fetch_or(move _4, const _, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = BitOr(const _, const _);
        _2 = BitAnd(move _3, move _6);
        switchInt(move _2) -> [0: bb2, otherwise: bb5];
    }

    bb2: {
        _8 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _11 = &((*_1).1: core::cell::UnsafeCell<T>);
        _10 = UnsafeCell::<T>::get(move _11) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = NonNull::<T>::new_unchecked(move _10) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = RwLockUpgradeableGuard::<'_, T> { lock: _8, data: move _9, _invariant: const ZeroSized: PhantomData<&mut T> };
        _0 = Option::<RwLockUpgradeableGuard<'_, T>>::Some(move _7);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<RwLockUpgradeableGuard<'_, T>>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt(_1: &RwLock<T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<rw_lock::RwLockReadGuard<'_, T>>;
    let mut _4: isize;
    let _5: rw_lock::RwLockReadGuard<'_, T>;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:346:27: 346:31};
    let mut _12: &rw_lock::RwLockReadGuard<'_, T>;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:347:27: 347:31};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug guard => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = RwLock::<T>::try_read(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb9, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Some).0: rw_lock::RwLockReadGuard<'_, T>);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:346:27: 346:31} { guard: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:346:27: 346:31}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:347:27: 347:31} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:347:27: 347:31}>(move _6, move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        drop(_5) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

promoted[0] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "RwLock { <locked> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "RwLock { data: "];
        _0 = &_1;
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:346:27: 346:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug guard => (*(_1.0: &rw_lock::RwLockReadGuard<'_, T>));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let _3: &T;
    let mut _4: &rw_lock::RwLockReadGuard<'_, T>;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _4 = deref_copy (_1.0: &rw_lock::RwLockReadGuard<'_, T>);
        _3 = <RwLockReadGuard<'_, T> as Deref>::deref(_4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_3, _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:347:27: 347:31}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:342:1: 342:54>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:353:1: 353:48>::default() -> RwLock<T> {
    let mut _0: rw_lock::RwLock<T>;
    let mut _1: T;

    bb0: {
        _1 = <T as Default>::default() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = RwLock::<T>::new(move _1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:359:1: 359:60>::try_upgrade_internal(_1: RwLockUpgradeableGuard<'_, T>, _2: bool) -> Result<RwLockWriteGuard<'_, T>, RwLockUpgradeableGuard<'_, T>> {
    debug self => _1;
    debug strong => _2;
    let mut _0: core::result::Result<rw_lock::RwLockWriteGuard<'_, T>, rw_lock::RwLockUpgradeableGuard<'_, T>>;
    let mut _3: bool;
    let mut _4: &core::result::Result<usize, usize>;
    let _5: core::result::Result<usize, usize>;
    let _6: &&core::sync::atomic::AtomicUsize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: core::sync::atomic::Ordering;
    let _9: core::result::Result<rw_lock::RwLockWriteGuard<'_, T>, rw_lock::RwLockUpgradeableGuard<'_, T>>;
    let mut _10: rw_lock::RwLockWriteGuard<'_, T>;
    let _11: &&core::sync::atomic::AtomicUsize;
    let mut _12: core::ptr::NonNull<T>;
    let _13: ();
    let mut _14: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let mut _15: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let mut _16: &core::sync::atomic::AtomicUsize;
    let mut _17: &core::sync::atomic::AtomicUsize;
    scope 1 {
        debug out => _9;
    }

    bb0: {
        _6 = &(_1.0: &core::sync::atomic::AtomicUsize);
        _16 = deref_copy (*_6);
        _7 = Acquire;
        _8 = Relaxed;
        _5 = compare_exchange(_16, const _, const _, move _7, move _8, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &_5;
        _3 = Result::<usize, usize>::is_ok(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(move _3) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _11 = &(_1.0: &core::sync::atomic::AtomicUsize);
        _17 = deref_copy (*_11);
        _12 = (_1.1: core::ptr::NonNull<T>);
        _10 = RwLockWriteGuard::<'_, T> { lock: _17, data: move _12, _invariant: const ZeroSized: PhantomData<&mut T> };
        _9 = Result::<RwLockWriteGuard<'_, T>, RwLockUpgradeableGuard<'_, T>>::Ok(move _10);
        _14 = move _1;
        _13 = core::mem::forget::<RwLockUpgradeableGuard<'_, T>>(move _14) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = move _9;
        goto -> bb6;
    }

    bb5: {
        _15 = move _1;
        _0 = Result::<RwLockWriteGuard<'_, T>, RwLockUpgradeableGuard<'_, T>>::Err(move _15);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:359:1: 359:60>::upgrade(_1: RwLockUpgradeableGuard<'_, T>) -> RwLockWriteGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockWriteGuard<'_, T>;
    let mut _2: core::result::Result<rw_lock::RwLockWriteGuard<'_, T>, rw_lock::RwLockUpgradeableGuard<'_, T>>;
    let mut _3: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let mut _4: isize;
    let _5: rw_lock::RwLockUpgradeableGuard<'_, T>;
    let _6: ();
    scope 1 {
        debug guard => _0;
    }
    scope 2 {
        debug e => _5;
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _3 = move _1;
        _2 = RwLockUpgradeableGuard::<'_, T>::try_upgrade_internal(move _3, const false) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _5 = move ((_2 as Err).0: rw_lock::RwLockUpgradeableGuard<'_, T>);
        _1 = move _5;
        _6 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = move ((_2 as Ok).0: rw_lock::RwLockWriteGuard<'_, T>);
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:359:1: 359:60>::try_upgrade(_1: RwLockUpgradeableGuard<'_, T>) -> Result<RwLockWriteGuard<'_, T>, RwLockUpgradeableGuard<'_, T>> {
    debug self => _1;
    let mut _0: core::result::Result<rw_lock::RwLockWriteGuard<'_, T>, rw_lock::RwLockUpgradeableGuard<'_, T>>;

    bb0: {
        _0 = RwLockUpgradeableGuard::<'_, T>::try_upgrade_internal(move _1, const true) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:359:1: 359:60>::downgrade(_1: RwLockUpgradeableGuard<'_, T>) -> RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockReadGuard<'_, T>;
    let _2: usize;
    let mut _3: core::sync::atomic::Ordering;
    let _4: &&core::sync::atomic::AtomicUsize;
    let mut _5: core::ptr::NonNull<T>;
    let mut _6: &core::sync::atomic::AtomicUsize;
    let mut _7: &core::sync::atomic::AtomicUsize;

    bb0: {
        _6 = deref_copy (_1.0: &core::sync::atomic::AtomicUsize);
        _3 = Acquire;
        _2 = AtomicUsize::fetch_add(_6, const _, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &(_1.0: &core::sync::atomic::AtomicUsize);
        _7 = deref_copy (*_4);
        _5 = (_1.1: core::ptr::NonNull<T>);
        _0 = RwLockReadGuard::<'_, T> { lock: _7, data: move _5 };
        drop(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:451:1: 451:54>::downgrade(_1: RwLockWriteGuard<'_, T>) -> RwLockReadGuard<'_, T> {
    debug self => _1;
    let mut _0: rw_lock::RwLockReadGuard<'_, T>;
    let _2: usize;
    let mut _3: core::sync::atomic::Ordering;
    let _4: &&core::sync::atomic::AtomicUsize;
    let mut _5: core::ptr::NonNull<T>;
    let mut _6: &core::sync::atomic::AtomicUsize;
    let mut _7: &core::sync::atomic::AtomicUsize;

    bb0: {
        _6 = deref_copy (_1.0: &core::sync::atomic::AtomicUsize);
        _3 = Acquire;
        _2 = AtomicUsize::fetch_add(_6, const _, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = &(_1.0: &core::sync::atomic::AtomicUsize);
        _7 = deref_copy (*_4);
        _5 = (_1.1: core::ptr::NonNull<T>);
        _0 = RwLockReadGuard::<'_, T> { lock: _7, data: move _5 };
        drop(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:478:1: 478:63>::deref(_1: &RwLockReadGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: &core::ptr::NonNull<T>;
    scope 1 {
    }

    bb0: {
        _2 = &((*_1).1: core::ptr::NonNull<T>);
        _0 = NonNull::<T>::as_ref::<'_>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:486:1: 486:70>::deref(_1: &RwLockUpgradeableGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: &core::ptr::NonNull<T>;
    scope 1 {
    }

    bb0: {
        _2 = &((*_1).1: core::ptr::NonNull<T>);
        _0 = NonNull::<T>::as_ref::<'_>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:494:1: 494:64>::deref(_1: &RwLockWriteGuard<'_, T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: &core::ptr::NonNull<T>;
    scope 1 {
    }

    bb0: {
        _2 = &((*_1).1: core::ptr::NonNull<T>);
        _0 = NonNull::<T>::as_ref::<'_>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:502:1: 502:67>::deref_mut(_1: &mut RwLockWriteGuard<'_, T>) -> &mut T {
    debug self => _1;
    let mut _0: &mut T;
    let mut _2: &mut core::ptr::NonNull<T>;
    scope 1 {
    }

    bb0: {
        _2 = &mut ((*_1).1: core::ptr::NonNull<T>);
        _0 = NonNull::<T>::as_mut::<'_>(move _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:508:1: 508:62>::drop(_1: &mut RwLockReadGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: core::sync::atomic::Ordering;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: !;
    let _10: usize;
    let mut _11: core::sync::atomic::Ordering;
    let mut _12: &core::sync::atomic::AtomicUsize;
    let mut _13: &core::sync::atomic::AtomicUsize;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _12 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _6 = Relaxed;
        _5 = AtomicUsize::load(_12, move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = BitOr(const _, const _);
        _7 = Not(move _8);
        _4 = BitAnd(move _5, move _7);
        _3 = Gt(move _4, const 0_usize);
        switchInt(move _3) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = panic(const "assertion failed: self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0") -> unwind unreachable;
    }

    bb4: {
        _13 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _11 = Release;
        _10 = AtomicUsize::fetch_sub(_13, const _, move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:515:1: 515:69>::drop(_1: &mut RwLockUpgradeableGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: core::sync::atomic::Ordering;
    let mut _8: usize;
    let _9: &usize;
    let _10: &usize;
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: usize;
    let _15: !;
    let mut _16: core::option::Option<core::fmt::Arguments<'_>>;
    let _17: usize;
    let mut _18: core::sync::atomic::Ordering;
    let mut _19: &usize;
    let mut _20: &core::sync::atomic::AtomicUsize;
    let mut _21: &core::sync::atomic::AtomicUsize;
    scope 1 {
        debug left_val => _9;
        debug right_val => _10;
        let _14: core::panicking::AssertKind;
        scope 2 {
            debug kind => _14;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _20 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _7 = Relaxed;
        _6 = AtomicUsize::load(_20, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = BitOr(const _, const _);
        _5 = BitAnd(move _6, move _8);
        _4 = &_5;
        _19 = const _;
        _3 = (move _4, _19);
        _9 = (_3.0: &usize);
        _10 = (_3.1: &usize);
        _12 = (*_9);
        _13 = (*_10);
        _11 = Eq(move _12, move _13);
        switchInt(move _11) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _14 = core::panicking::AssertKind::Eq;
        _16 = Option::<Arguments<'_>>::None;
        _15 = assert_failed::<usize, usize>(move _14, _9, _10, move _16) -> unwind unreachable;
    }

    bb4: {
        _21 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _18 = AcqRel;
        _17 = AtomicUsize::fetch_sub(_21, const _, move _18) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:515:1: 515:69>::drop: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:525:1: 525:63>::drop(_1: &mut RwLockWriteGuard<'_, T>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let mut _3: (&usize, &usize);
    let mut _4: &usize;
    let _5: usize;
    let mut _6: usize;
    let mut _7: core::sync::atomic::Ordering;
    let _8: &usize;
    let _9: &usize;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: usize;
    let _14: !;
    let mut _15: core::option::Option<core::fmt::Arguments<'_>>;
    let _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: core::sync::atomic::Ordering;
    let mut _20: &usize;
    let mut _21: &core::sync::atomic::AtomicUsize;
    let mut _22: &core::sync::atomic::AtomicUsize;
    scope 1 {
        debug left_val => _8;
        debug right_val => _9;
        let _13: core::panicking::AssertKind;
        scope 2 {
            debug kind => _13;
        }
    }

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _21 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _7 = Relaxed;
        _6 = AtomicUsize::load(_21, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(move _6, const _);
        _4 = &_5;
        _20 = const _;
        _3 = (move _4, _20);
        _8 = (_3.0: &usize);
        _9 = (_3.1: &usize);
        _11 = (*_8);
        _12 = (*_9);
        _10 = Eq(move _11, move _12);
        switchInt(move _10) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _13 = core::panicking::AssertKind::Eq;
        _15 = Option::<Arguments<'_>>::None;
        _14 = assert_failed::<usize, usize>(move _13, _8, _9, move _15) -> unwind unreachable;
    }

    bb4: {
        _22 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _18 = BitOr(const _, const _);
        _17 = Not(move _18);
        _19 = Release;
        _16 = AtomicUsize::fetch_and(_22, move _17, move _19) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

promoted[0] in rw_lock::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/rw_lock.rs:525:1: 525:63>::drop: &usize = {
    let mut _0: &usize;
    let mut _1: usize;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn compare_exchange(_1: &AtomicUsize, _2: usize, _3: usize, _4: core::sync::atomic::Ordering, _5: core::sync::atomic::Ordering, _6: bool) -> Result<usize, usize> {
    debug atomic => _1;
    debug current => _2;
    debug new => _3;
    debug success => _4;
    debug failure => _5;
    debug strong => _6;
    let mut _0: core::result::Result<usize, usize>;

    bb0: {
        switchInt(_6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = AtomicUsize::compare_exchange(_1, _2, _3, _4, _5) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = AtomicUsize::compare_exchange_weak(_1, _2, _3, _4, _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt(_1: &once::Once<T>, _2: &mut Formatter<'_>) -> Result<(), core::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::option::Option<&T>;
    let mut _4: isize;
    let _5: &T;
    let mut _6: core::result::Result<(), core::fmt::Error>;
    let mut _7: core::result::Result<(), core::fmt::Error>;
    let mut _8: &mut core::fmt::Formatter<'_>;
    let mut _9: core::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:30:15: 30:19};
    let mut _12: &&T;
    let mut _13: &mut &mut core::fmt::Formatter<'_>;
    let mut _14: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:31:15: 31:19};
    let mut _15: &mut &mut core::fmt::Formatter<'_>;
    let mut _16: &mut core::fmt::Formatter<'_>;
    let mut _17: core::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[&str; 1];
    scope 1 {
        debug s => _5;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = once::Once::<T>::try(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _16 = _2;
        _19 = const _;
        _18 = _19 as &[&str] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_const(move _18) -> [return: bb8, unwind unreachable];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: &T);
        _8 = _2;
        _20 = const _;
        _10 = _20 as &[&str] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = Formatter::<'_>::write_fmt(move _8, move _9) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = &_5;
        _13 = &mut _2;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:30:15: 30:19} { s: move _12, f: move _13 };
        _6 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:30:15: 30:19}>(move _7, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = &mut _2;
        _14 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:31:15: 31:19} { f: move _15 };
        _0 = Result::<(), core::fmt::Error>::and_then::<(), {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:31:15: 31:19}>(move _6, move _14) -> [return: bb9, unwind unreachable];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(move _16, move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Once { <uninitialized> }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Once { data: "];
        _0 = &_1;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt::{closure#0}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:30:15: 30:19}, _2: ()) -> Result<(), core::fmt::Error> {
    debug s => (*(_1.0: &&T));
    debug f => (*(_1.1: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: &&T;
    let mut _4: &T;
    let mut _5: &mut &mut core::fmt::Formatter<'_>;
    let mut _6: &mut core::fmt::Formatter<'_>;

    bb0: {
        _3 = deref_copy (_1.0: &&T);
        _4 = deref_copy (*_3);
        _5 = deref_copy (_1.1: &mut &mut core::fmt::Formatter<'_>);
        _6 = deref_copy (*_5);
        _0 = <T as Debug>::fmt(_4, _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt::{closure#1}(_1: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:31:15: 31:19}, _2: ()) -> Result<(), core::fmt::Error> {
    debug f => (*(_1.0: &mut &mut core::fmt::Formatter<'_>));
    let mut _0: core::result::Result<(), core::fmt::Error>;
    let mut _3: core::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[&str; 1];
    let mut _6: &mut &mut core::fmt::Formatter<'_>;
    let mut _7: &mut core::fmt::Formatter<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &mut &mut core::fmt::Formatter<'_>);
        _7 = deref_copy (*_6);
        _5 = const _;
        _4 = _5 as &[&str] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_const(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Formatter::<'_>::write_fmt(_7, move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

promoted[0] in once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:26:1: 26:43>::fmt::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}"];
        _0 = &_1;
        return;
    }
}

const INCOMPLETE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

const RUNNING: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

const COMPLETE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const PANICKED: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

const once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::INIT: once::Once<T> = {
    let mut _0: once::Once<T>;
    let mut _1: core::sync::atomic::AtomicUsize;
    let mut _2: core::cell::UnsafeCell<core::option::Option<T>>;
    let mut _3: core::option::Option<T>;

    bb0: {
        StorageLive(_1);
        ConstEvalCounter;
        _1 = AtomicUsize::new(const _) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        StorageLive(_2);
        StorageLive(_3);
        _3 = Option::<T>::None;
        ConstEvalCounter;
        _2 = UnsafeCell::<Option<T>>::new(move _3) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        StorageDead(_3);
        _0 = once::Once::<T> { state: move _1, data: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::new() -> once::Once<T> {
    let mut _0: once::Once<T>;

    bb0: {
        _0 = const _;
        return;
    }
}

// MIR FOR CTFE
fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::new() -> once::Once<T> {
    let mut _0: once::Once<T>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::force_get(_1: &once::Once<T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: core::option::Option<&T>;
    let _3: &core::option::Option<T>;
    let _4: *mut core::option::Option<T>;
    let mut _5: &core::cell::UnsafeCell<core::option::Option<T>>;
    let mut _6: isize;
    let mut _7: !;
    scope 1 {
    }
    scope 2 {
    }
    scope 3 {
        debug p => _0;
    }

    bb0: {
        _5 = &((*_1).1: core::cell::UnsafeCell<core::option::Option<T>>);
        _4 = UnsafeCell::<Option<T>>::get(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = &(*_4);
        _2 = Option::<T>::as_ref(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = ((_2 as Some).0: &T);
        return;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = unreachable_unchecked() -> unwind unreachable;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::call_once(_1: &once::Once<T>, _2: F) -> &T {
    debug self => _1;
    debug builder => _2;
    let mut _0: &T;
    let mut _3: usize;
    let mut _4: &core::sync::atomic::AtomicUsize;
    let mut _5: core::sync::atomic::Ordering;
    let mut _6: bool;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: &core::sync::atomic::AtomicUsize;
    let mut _10: core::sync::atomic::Ordering;
    let mut _11: bool;
    let mut _12: usize;
    let _14: &core::sync::atomic::AtomicUsize;
    let mut _15: core::option::Option<T>;
    let mut _16: T;
    let mut _17: F;
    let mut _18: *mut core::option::Option<T>;
    let mut _19: &core::cell::UnsafeCell<core::option::Option<T>>;
    let _20: ();
    let mut _21: &core::sync::atomic::AtomicUsize;
    let mut _22: usize;
    let mut _23: core::sync::atomic::Ordering;
    let _24: &T;
    let mut _25: !;
    let _26: ();
    let mut _27: usize;
    let mut _28: &core::sync::atomic::AtomicUsize;
    let mut _29: core::sync::atomic::Ordering;
    let mut _30: !;
    let _31: &T;
    let mut _32: !;
    let mut _33: bool;
    scope 1 {
        debug status => _3;
        let mut _13: once::Finish<'_>;
        scope 2 {
            debug finish => _13;
            scope 3 {
            }
        }
        scope 4 {
        }
    }

    bb0: {
        _33 = const false;
        _33 = const true;
        _4 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _5 = SeqCst;
        _3 = AtomicUsize::load(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _3;
        _6 = Eq(move _7, const _);
        switchInt(move _6) -> [0: bb10, otherwise: bb2];
    }

    bb2: {
        _9 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _10 = SeqCst;
        _8 = AtomicUsize::compare_and_swap(move _9, const _, const _, move _10) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move _8;
        _12 = _3;
        _11 = Eq(move _12, const _);
        switchInt(move _11) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _14 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _13 = Finish::<'_> { state: _14, panicked: const true };
        _33 = const false;
        _17 = move _2;
        _16 = <F as FnOnce<()>>::call_once(move _17, const ()) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _15 = Option::<T>::Some(move _16);
        _19 = &((*_1).1: core::cell::UnsafeCell<core::option::Option<T>>);
        _18 = UnsafeCell::<Option<T>>::get(move _19) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        drop((*_18)) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        (*_18) = move _15;
        (_13.1: bool) = const false;
        _3 = const _;
        _21 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _22 = _3;
        _23 = SeqCst;
        _20 = AtomicUsize::store(move _21, move _22, move _23) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _24 = once::Once::<T>::force_get(_1) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = _24;
        drop(_13) -> [return: bb19, unwind unreachable];
    }

    bb10: {
        switchInt(_3) -> [0: bb12, 1: bb13, 3: bb16, 2: bb17, otherwise: bb11];
    }

    bb11: {
        _32 = unreachable_unchecked() -> unwind unreachable;
    }

    bb12: {
        _25 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb13: {
        _26 = spin_loop_hint() -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _28 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _29 = SeqCst;
        _27 = AtomicUsize::load(move _28, move _29) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _3 = move _27;
        goto -> bb10;
    }

    bb16: {
        _30 = panic(const "Once has panicked") -> unwind unreachable;
    }

    bb17: {
        _31 = once::Once::<T>::force_get(_1) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = _31;
        goto -> bb19;
    }

    bb19: {
        switchInt(_33) -> [0: bb20, otherwise: bb21];
    }

    bb20: {
        return;
    }

    bb21: {
        drop(_2) -> [return: bb20, unwind unreachable];
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::try(_1: &once::Once<T>) -> Option<&T> {
    debug self => _1;
    let mut _0: core::option::Option<&T>;
    let mut _2: usize;
    let mut _3: &core::sync::atomic::AtomicUsize;
    let mut _4: core::sync::atomic::Ordering;
    let _5: &T;

    bb0: {
        _3 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _4 = SeqCst;
        _2 = AtomicUsize::load(move _3, move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(_2) -> [2: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<&T>::None;
        goto -> bb5;
    }

    bb3: {
        _5 = once::Once::<T>::force_get(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = Option::<&T>::Some(_5);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:51:1: 51:16>::wait(_1: &once::Once<T>) -> Option<&T> {
    debug self => _1;
    let mut _0: core::option::Option<&T>;
    let mut _2: ();
    let mut _3: usize;
    let mut _4: &core::sync::atomic::AtomicUsize;
    let mut _5: core::sync::atomic::Ordering;
    let _6: &T;
    let mut _7: !;
    let mut _8: !;
    scope 1 {
    }

    bb0: {
        goto -> bb1;
    }

    bb1: {
        _4 = &((*_1).0: core::sync::atomic::AtomicUsize);
        _5 = SeqCst;
        _3 = AtomicUsize::load(move _4, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        switchInt(_3) -> [0: bb4, 1: bb5, 2: bb6, 3: bb8, otherwise: bb3];
    }

    bb3: {
        _8 = unreachable_unchecked() -> unwind unreachable;
    }

    bb4: {
        _0 = Option::<&T>::None;
        goto -> bb9;
    }

    bb5: {
        _2 = spin_loop_hint() -> [return: bb1, unwind unreachable];
    }

    bb6: {
        _6 = once::Once::<T>::force_get(_1) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Option::<&T>::Some(_6);
        goto -> bb9;
    }

    bb8: {
        _7 = panic(const "Once has panicked") -> unwind unreachable;
    }

    bb9: {
        return;
    }
}

fn once::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spin-0.5.2/src/once.rs:163:1: 163:29>::drop(_1: &mut Finish<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: bool;
    let _3: ();
    let mut _4: core::sync::atomic::Ordering;
    let mut _5: &core::sync::atomic::AtomicUsize;

    bb0: {
        _2 = ((*_1).1: bool);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = deref_copy ((*_1).0: &core::sync::atomic::AtomicUsize);
        _4 = SeqCst;
        _3 = AtomicUsize::store(_5, const _, move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}
