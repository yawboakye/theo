// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn add::add(_1: F, _2: F) -> F {
    debug a => _1;
    debug b => _2;
    let mut _0: F;
    let _3: <F as float::Float>::Int;
    let mut _11: <F as float::Float>::Int;
    let mut _13: <F as float::Float>::Int;
    let mut _21: <F as float::Float>::Int;
    let mut _23: <F as float::Float>::Int;
    let mut _24: bool;
    let mut _25: &<F as float::Float>::Int;
    let _26: <F as float::Float>::Int;
    let mut _27: <F as float::Float>::Int;
    let mut _28: &<F as float::Float>::Int;
    let _29: <F as float::Float>::Int;
    let mut _30: <F as float::Float>::Int;
    let mut _31: bool;
    let mut _32: &<F as float::Float>::Int;
    let _33: <F as float::Float>::Int;
    let mut _34: <F as float::Float>::Int;
    let mut _35: &<F as float::Float>::Int;
    let _36: <F as float::Float>::Int;
    let mut _37: <F as float::Float>::Int;
    let mut _38: bool;
    let mut _39: &<F as float::Float>::Int;
    let mut _40: &<F as float::Float>::Int;
    let mut _41: <F as float::Float>::Int;
    let mut _42: <F as float::Float>::Int;
    let mut _43: bool;
    let mut _44: &<F as float::Float>::Int;
    let mut _45: &<F as float::Float>::Int;
    let mut _46: <F as float::Float>::Int;
    let mut _47: <F as float::Float>::Int;
    let mut _48: bool;
    let mut _49: &<F as float::Float>::Int;
    let mut _50: &<F as float::Float>::Int;
    let mut _51: bool;
    let mut _52: &<F as float::Float>::Int;
    let _53: <F as float::Float>::Int;
    let mut _54: <F as float::Float>::Int;
    let mut _55: <F as float::Float>::Int;
    let mut _56: &<F as float::Float>::Int;
    let mut _57: bool;
    let mut _58: &<F as float::Float>::Int;
    let mut _59: &<F as float::Float>::Int;
    let mut _60: bool;
    let mut _61: &<F as float::Float>::Int;
    let mut _62: &<F as float::Float>::Int;
    let _63: <F as float::Float>::Int;
    let mut _64: bool;
    let mut _65: &<F as float::Float>::Int;
    let mut _66: &<F as float::Float>::Int;
    let _67: <F as float::Float>::Int;
    let mut _68: <F as float::Float>::Int;
    let mut _69: <F as float::Float>::Int;
    let mut _70: <F as float::Float>::Int;
    let mut _71: bool;
    let mut _72: &<F as float::Float>::Int;
    let mut _73: &<F as float::Float>::Int;
    let _74: <F as float::Float>::Int;
    let mut _75: bool;
    let mut _76: &<F as float::Float>::Int;
    let mut _77: &<F as float::Float>::Int;
    let mut _79: <F as float::Float>::Int;
    let mut _81: <F as float::Float>::Int;
    let mut _82: <F as float::Float>::Int;
    let mut _83: <F as float::Float>::Int;
    let mut _85: <F as float::Float>::Int;
    let mut _86: <F as float::Float>::Int;
    let mut _87: <F as float::Float>::Int;
    let mut _89: <F as float::Float>::Int;
    let mut _91: <F as float::Float>::Int;
    let mut _92: i32;
    let mut _95: (i32, <F as float::Float>::Int);
    let mut _96: <F as float::Float>::Int;
    let mut _97: i32;
    let mut _100: (i32, <F as float::Float>::Int);
    let mut _101: <F as float::Float>::Int;
    let mut _103: <F as float::Float>::Int;
    let mut _104: <F as float::Float>::Int;
    let mut _106: &<F as float::Float>::Int;
    let _107: <F as float::Float>::Int;
    let mut _108: <F as float::Float>::Int;
    let mut _109: <F as float::Float>::Int;
    let mut _110: <F as float::Float>::Int;
    let mut _111: <F as float::Float>::Int;
    let mut _112: &<F as float::Float>::Int;
    let mut _113: <F as float::Float>::Int;
    let mut _114: <F as float::Float>::Int;
    let mut _115: <F as float::Float>::Int;
    let mut _116: <F as float::Float>::Int;
    let mut _117: <F as float::Float>::Int;
    let mut _118: <F as float::Float>::Int;
    let mut _120: i32;
    let mut _121: i32;
    let mut _122: i32;
    let mut _123: bool;
    let mut _124: &<F as float::Float>::Int;
    let mut _125: &<F as float::Float>::Int;
    let _126: <F as float::Float>::Int;
    let mut _127: bool;
    let mut _128: &<F as float::Float>::Int;
    let mut _129: &<F as float::Float>::Int;
    let mut _131: bool;
    let mut _132: &<F as float::Float>::Int;
    let _133: <F as float::Float>::Int;
    let mut _134: <F as float::Float>::Int;
    let mut _135: u32;
    let mut _136: <F as float::Float>::Int;
    let mut _137: <F as float::Float>::Int;
    let mut _138: <F as float::Float>::Int;
    let mut _139: &<F as float::Float>::Int;
    let _140: <F as float::Float>::Int;
    let mut _141: <F as float::Float>::Int;
    let mut _142: <F as float::Float>::Int;
    let mut _143: <F as float::Float>::Int;
    let mut _144: u32;
    let mut _145: <F as float::Float>::Int;
    let mut _146: <F as float::Float>::Int;
    let mut _147: <F as float::Float>::Int;
    let mut _148: <F as float::Float>::Int;
    let mut _149: bool;
    let mut _150: &<F as float::Float>::Int;
    let mut _151: &<F as float::Float>::Int;
    let _152: <F as float::Float>::Int;
    let mut _153: bool;
    let mut _154: &<F as float::Float>::Int;
    let mut _155: &<F as float::Float>::Int;
    let _156: <F as float::Float>::Int;
    let mut _158: i32;
    let mut _159: u32;
    let mut _160: <F as float::Float>::Int;
    let mut _161: i32;
    let mut _162: u32;
    let mut _163: <F as float::Float>::Int;
    let mut _164: (i32, bool);
    let _165: ();
    let mut _166: &mut <F as float::Float>::Int;
    let mut _167: (i32, bool);
    let _168: ();
    let mut _169: &mut <F as float::Float>::Int;
    let mut _170: <F as float::Float>::Int;
    let mut _171: bool;
    let mut _172: &<F as float::Float>::Int;
    let _173: <F as float::Float>::Int;
    let mut _174: <F as float::Float>::Int;
    let mut _175: <F as float::Float>::Int;
    let mut _176: &<F as float::Float>::Int;
    let _177: <F as float::Float>::Int;
    let mut _179: bool;
    let mut _180: &<F as float::Float>::Int;
    let _181: <F as float::Float>::Int;
    let mut _182: <F as float::Float>::Int;
    let mut _183: &<F as float::Float>::Int;
    let _184: <F as float::Float>::Int;
    let mut _185: <F as float::Float>::Int;
    let mut _186: <F as float::Float>::Int;
    let mut _187: <F as float::Float>::Int;
    let mut _188: (i32, bool);
    let mut _189: bool;
    let mut _190: i32;
    let mut _191: i32;
    let mut _192: <F as float::Float>::Int;
    let mut _193: <F as float::Float>::Int;
    let mut _194: bool;
    let mut _195: i32;
    let mut _197: i32;
    let mut _198: i32;
    let mut _199: (i32, bool);
    let mut _201: bool;
    let mut _202: &<F as float::Float>::Int;
    let _203: <F as float::Float>::Int;
    let mut _204: <F as float::Float>::Int;
    let mut _205: u32;
    let mut _206: <F as float::Float>::Int;
    let mut _207: <F as float::Float>::Int;
    let mut _208: &<F as float::Float>::Int;
    let _209: <F as float::Float>::Int;
    let mut _210: <F as float::Float>::Int;
    let mut _211: <F as float::Float>::Int;
    let mut _212: <F as float::Float>::Int;
    let mut _213: u32;
    let mut _215: <F as float::Float>::Int;
    let mut _218: <F as float::Float>::Int;
    let mut _219: <F as float::Float>::Int;
    let _220: ();
    let mut _221: &mut <F as float::Float>::Int;
    let mut _222: <F as float::Float>::Int;
    let mut _223: <F as float::Float>::Int;
    let mut _224: i32;
    let _225: ();
    let mut _226: &mut <F as float::Float>::Int;
    let mut _227: bool;
    let _228: ();
    let mut _229: &mut <F as float::Float>::Int;
    let _230: ();
    let mut _231: &mut <F as float::Float>::Int;
    let mut _232: <F as float::Float>::Int;
    let mut _233: <F as float::Float>::Int;
    let mut _234: <F as float::Float>::Int;
    scope 1 {
        debug one => const _;
        let _4: <F as float::Float>::Int;
        scope 2 {
            debug zero => const _;
            let _5: <F as float::Float>::Int;
            scope 3 {
                debug bits => _5;
                let _6: u32;
                scope 4 {
                    debug significand_bits => const _;
                    let _7: u32;
                    scope 5 {
                        debug max_exponent => const _;
                        let _8: <F as float::Float>::Int;
                        scope 6 {
                            debug implicit_bit => const _;
                            let _9: <F as float::Float>::Int;
                            scope 7 {
                                debug significand_mask => const _;
                                let _10: <F as float::Float>::Int;
                                scope 8 {
                                    debug sign_bit => _10;
                                    let _12: <F as float::Float>::Int;
                                    scope 9 {
                                        debug abs_mask => _12;
                                        let _14: <F as float::Float>::Int;
                                        scope 10 {
                                            debug exponent_mask => const _;
                                            let _15: <F as float::Float>::Int;
                                            scope 11 {
                                                debug inf_rep => _15;
                                                let _16: <F as float::Float>::Int;
                                                scope 12 {
                                                    debug quiet_bit => _16;
                                                    let _17: <F as float::Float>::Int;
                                                    scope 13 {
                                                        debug qnan_rep => _17;
                                                        let mut _18: <F as float::Float>::Int;
                                                        scope 14 {
                                                            debug a_rep => _18;
                                                            let mut _19: <F as float::Float>::Int;
                                                            scope 15 {
                                                                debug b_rep => _19;
                                                                let _20: <F as float::Float>::Int;
                                                                scope 16 {
                                                                    debug a_abs => _20;
                                                                    let _22: <F as float::Float>::Int;
                                                                    scope 17 {
                                                                        debug b_abs => _22;
                                                                        let _78: <F as float::Float>::Int;
                                                                        let mut _80: i32;
                                                                        scope 18 {
                                                                            debug tmp => _78;
                                                                        }
                                                                        scope 19 {
                                                                            debug a_exponent => _80;
                                                                            let mut _84: i32;
                                                                            scope 20 {
                                                                                debug b_exponent => _84;
                                                                                let mut _88: <F as float::Float>::Int;
                                                                                scope 21 {
                                                                                    debug a_significand => _88;
                                                                                    let mut _90: <F as float::Float>::Int;
                                                                                    scope 22 {
                                                                                        debug b_significand => _90;
                                                                                        let _93: i32;
                                                                                        let _94: <F as float::Float>::Int;
                                                                                        let _98: i32;
                                                                                        let _99: <F as float::Float>::Int;
                                                                                        let _102: <F as float::Float>::Int;
                                                                                        scope 23 {
                                                                                            debug exponent => _93;
                                                                                            debug significand => _94;
                                                                                        }
                                                                                        scope 24 {
                                                                                            debug exponent => _98;
                                                                                            debug significand => _99;
                                                                                        }
                                                                                        scope 25 {
                                                                                            debug result_sign => _102;
                                                                                            let _105: bool;
                                                                                            scope 26 {
                                                                                                debug subtraction => _105;
                                                                                                let _119: <F as float::Float>::Int;
                                                                                                scope 27 {
                                                                                                    debug align => _119;
                                                                                                    let _130: <F as float::Float>::Int;
                                                                                                    let _157: i32;
                                                                                                    let _178: <F as float::Float>::Int;
                                                                                                    let _196: <F as float::Float>::Int;
                                                                                                    let _214: i32;
                                                                                                    scope 28 {
                                                                                                        debug sticky => _130;
                                                                                                    }
                                                                                                    scope 29 {
                                                                                                        debug shift => _157;
                                                                                                    }
                                                                                                    scope 30 {
                                                                                                        debug sticky => _178;
                                                                                                    }
                                                                                                    scope 31 {
                                                                                                        debug shift => _196;
                                                                                                        let _200: <F as float::Float>::Int;
                                                                                                        scope 32 {
                                                                                                            debug sticky => _200;
                                                                                                        }
                                                                                                    }
                                                                                                    scope 33 {
                                                                                                        debug a_significand_i32 => _214;
                                                                                                        let _216: i32;
                                                                                                        scope 34 {
                                                                                                            debug round_guard_sticky => _216;
                                                                                                            let mut _217: <F as float::Float>::Int;
                                                                                                            scope 35 {
                                                                                                                debug result => _217;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _5 = <u32 as CastInto<<F as Float>::Int>>::cast(const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const _;
        _7 = const _;
        _8 = const _;
        _9 = const _;
        _11 = const _;
        _10 = _11;
        _13 = _10;
        _12 = <<F as Float>::Int as Sub>::sub(move _13, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _14 = const _;
        _15 = _14;
        _16 = <<F as Float>::Int as Shr<u32>>::shr(_8, const 1_u32) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _17 = <<F as Float>::Int as BitOr>::bitor(_14, _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _18 = <F as Float>::repr(_1) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _19 = <F as Float>::repr(_2) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _21 = _18;
        _20 = <<F as Float>::Int as BitAnd>::bitand(move _21, _12) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _23 = _19;
        _22 = <<F as Float>::Int as BitAnd>::bitand(move _23, _12) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _27 = _20;
        _26 = <<F as Float>::Int as Int>::wrapping_sub(move _27, _3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _25 = &_26;
        _30 = _15;
        _29 = <<F as Float>::Int as Sub>::sub(move _30, _3) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _28 = &_29;
        _24 = <<F as Float>::Int as PartialOrd>::ge(move _25, move _28) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        switchInt(move _24) -> [0: bb12, otherwise: bb16];
    }

    bb12: {
        _34 = _22;
        _33 = <<F as Float>::Int as Int>::wrapping_sub(move _34, _3) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _32 = &_33;
        _37 = _15;
        _36 = <<F as Float>::Int as Sub>::sub(move _37, _3) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _35 = &_36;
        _31 = <<F as Float>::Int as PartialOrd>::ge(move _32, move _35) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(move _31) -> [0: bb48, otherwise: bb16];
    }

    bb16: {
        _39 = &_20;
        _40 = &_15;
        _38 = <<F as Float>::Int as PartialOrd>::gt(move _39, move _40) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _38) -> [0: bb20, otherwise: bb18];
    }

    bb18: {
        _42 = _20;
        _41 = <<F as Float>::Int as BitOr>::bitor(move _42, _16) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _0 = <F as Float>::from_repr(move _41) -> [return: bb144, unwind unreachable];
    }

    bb20: {
        _44 = &_22;
        _45 = &_15;
        _43 = <<F as Float>::Int as PartialOrd>::gt(move _44, move _45) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _43) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _47 = _22;
        _46 = <<F as Float>::Int as BitOr>::bitor(move _47, _16) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = <F as Float>::from_repr(move _46) -> [return: bb144, unwind unreachable];
    }

    bb24: {
        _49 = &_20;
        _50 = &_15;
        _48 = <<F as Float>::Int as PartialEq>::eq(move _49, move _50) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        switchInt(move _48) -> [0: bb33, otherwise: bb26];
    }

    bb26: {
        _54 = <F as Float>::repr(_1) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _55 = <F as Float>::repr(_2) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _53 = <<F as Float>::Int as BitXor>::bitxor(move _54, move _55) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _52 = &_53;
        _56 = &_10;
        _51 = <<F as Float>::Int as PartialEq>::eq(move _52, move _56) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _51) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _0 = <F as Float>::from_repr(_17) -> [return: bb144, unwind unreachable];
    }

    bb32: {
        _0 = _1;
        goto -> bb144;
    }

    bb33: {
        _58 = &_22;
        _59 = &_15;
        _57 = <<F as Float>::Int as PartialEq>::eq(move _58, move _59) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _57) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _0 = _2;
        goto -> bb144;
    }

    bb36: {
        _61 = &_20;
        _63 = const _;
        _62 = &_63;
        _60 = <<F as Float>::Int as PartialEq>::eq(move _61, move _62) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        switchInt(move _60) -> [0: bb45, otherwise: bb38];
    }

    bb38: {
        _65 = &_22;
        _67 = const _;
        _66 = &_67;
        _64 = <<F as Float>::Int as PartialEq>::eq(move _65, move _66) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        switchInt(move _64) -> [0: bb44, otherwise: bb40];
    }

    bb40: {
        _69 = <F as Float>::repr(_1) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _70 = <F as Float>::repr(_2) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _68 = <<F as Float>::Int as BitAnd>::bitand(move _69, move _70) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _0 = <F as Float>::from_repr(move _68) -> [return: bb144, unwind unreachable];
    }

    bb44: {
        _0 = _2;
        goto -> bb144;
    }

    bb45: {
        _72 = &_22;
        _74 = const _;
        _73 = &_74;
        _71 = <<F as Float>::Int as PartialEq>::eq(move _72, move _73) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(move _71) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _0 = _1;
        goto -> bb144;
    }

    bb48: {
        _76 = &_22;
        _77 = &_20;
        _75 = <<F as Float>::Int as PartialOrd>::gt(move _76, move _77) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        switchInt(move _75) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _78 = _18;
        _79 = _19;
        _18 = move _79;
        _19 = _78;
        goto -> bb51;
    }

    bb51: {
        _83 = _18;
        _82 = <<F as Float>::Int as BitAnd>::bitand(move _83, _14) -> [return: bb52, unwind unreachable];
    }

    bb52: {
        _81 = <<F as Float>::Int as Shr<u32>>::shr(move _82, _6) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _80 = <<F as Float>::Int as CastInto<i32>>::cast(move _81) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _87 = _19;
        _86 = <<F as Float>::Int as BitAnd>::bitand(move _87, _14) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _85 = <<F as Float>::Int as Shr<u32>>::shr(move _86, _6) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        _84 = <<F as Float>::Int as CastInto<i32>>::cast(move _85) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        _89 = _18;
        _88 = <<F as Float>::Int as BitAnd>::bitand(move _89, _9) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _91 = _19;
        _90 = <<F as Float>::Int as BitAnd>::bitand(move _91, _9) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _92 = _80;
        switchInt(move _92) -> [0: bb60, otherwise: bb62];
    }

    bb60: {
        _96 = _88;
        _95 = <F as Float>::normalize(move _96) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _93 = (_95.0: i32);
        _94 = (_95.1: <F as float::Float>::Int);
        _80 = _93;
        _88 = _94;
        goto -> bb62;
    }

    bb62: {
        _97 = _84;
        switchInt(move _97) -> [0: bb63, otherwise: bb65];
    }

    bb63: {
        _101 = _90;
        _100 = <F as Float>::normalize(move _101) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _98 = (_100.0: i32);
        _99 = (_100.1: <F as float::Float>::Int);
        _84 = _98;
        _90 = _99;
        goto -> bb65;
    }

    bb65: {
        _103 = _18;
        _104 = _10;
        _102 = <<F as Float>::Int as BitAnd>::bitand(move _103, move _104) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _109 = _18;
        _110 = _19;
        _108 = <<F as Float>::Int as BitXor>::bitxor(move _109, move _110) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _111 = _10;
        _107 = <<F as Float>::Int as BitAnd>::bitand(move _108, move _111) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _106 = &_107;
        _112 = &_4;
        _105 = <<F as Float>::Int as PartialEq>::ne(move _106, move _112) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        _115 = _88;
        _114 = <<F as Float>::Int as BitOr>::bitor(move _115, _8) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _113 = <<F as Float>::Int as Shl<u32>>::shl(move _114, const 3_u32) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _88 = move _113;
        _118 = _90;
        _117 = <<F as Float>::Int as BitOr>::bitor(move _118, _8) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _116 = <<F as Float>::Int as Shl<u32>>::shl(move _117, const 3_u32) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        _90 = move _116;
        _121 = _80;
        _122 = _84;
        _120 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(move _121, move _122) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _119 = <i32 as CastInto<<F as Float>::Int>>::cast(move _120) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _124 = &_119;
        _126 = const _;
        _125 = &_126;
        _123 = <<F as Float>::Int as PartialEq>::ne(move _124, move _125) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        switchInt(move _123) -> [0: bb89, otherwise: bb77];
    }

    bb77: {
        _128 = &_119;
        _129 = &_5;
        _127 = <<F as Float>::Int as PartialOrd>::lt(move _128, move _129) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        switchInt(move _127) -> [0: bb88, otherwise: bb79];
    }

    bb79: {
        _134 = _90;
        _137 = _5;
        _138 = _119;
        _136 = <<F as Float>::Int as Int>::wrapping_sub(move _137, move _138) -> [return: bb80, unwind unreachable];
    }

    bb80: {
        _135 = <<F as Float>::Int as CastInto<u32>>::cast(move _136) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _133 = <<F as Float>::Int as Shl<u32>>::shl(move _134, move _135) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _132 = &_133;
        _140 = const _;
        _139 = &_140;
        _131 = <<F as Float>::Int as PartialEq>::ne(move _132, move _139) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _130 = <<F as Float>::Int as Int>::from_bool(move _131) -> [return: bb84, unwind unreachable];
    }

    bb84: {
        _143 = _90;
        _145 = _119;
        _144 = <<F as Float>::Int as CastInto<u32>>::cast(move _145) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        _142 = <<F as Float>::Int as Shr<u32>>::shr(move _143, move _144) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _141 = <<F as Float>::Int as BitOr>::bitor(move _142, _130) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _90 = move _141;
        goto -> bb89;
    }

    bb88: {
        _90 = _3;
        goto -> bb89;
    }

    bb89: {
        switchInt(_105) -> [0: bb104, otherwise: bb90];
    }

    bb90: {
        _147 = _88;
        _148 = _90;
        _146 = <<F as Float>::Int as Int>::wrapping_sub(move _147, move _148) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _88 = move _146;
        _150 = &_88;
        _152 = const _;
        _151 = &_152;
        _149 = <<F as Float>::Int as PartialEq>::eq(move _150, move _151) -> [return: bb92, unwind unreachable];
    }

    bb92: {
        switchInt(move _149) -> [0: bb94, otherwise: bb93];
    }

    bb93: {
        _0 = <F as Float>::from_repr(const _) -> [return: bb144, unwind unreachable];
    }

    bb94: {
        _154 = &_88;
        _156 = <<F as Float>::Int as Shl<u32>>::shl(_8, const 3_u32) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _155 = &_156;
        _153 = <<F as Float>::Int as PartialOrd>::lt(move _154, move _155) -> [return: bb96, unwind unreachable];
    }

    bb96: {
        switchInt(move _153) -> [0: bb116, otherwise: bb97];
    }

    bb97: {
        _160 = _88;
        _159 = <<F as Float>::Int as Int>::leading_zeros(move _160) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _158 = move _159 as i32 (IntToInt);
        _163 = <<F as Float>::Int as Shl<u32>>::shl(_8, const 3_u32) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _162 = <<F as Float>::Int as Int>::leading_zeros(move _163) -> [return: bb100, unwind unreachable];
    }

    bb100: {
        _161 = move _162 as i32 (IntToInt);
        _164 = CheckedSub(_158, _161);
        assert(!move (_164.1: bool), "attempt to compute `{} - {}`, which would overflow", move _158, move _161) -> [success: bb101, unwind unreachable];
    }

    bb101: {
        _157 = move (_164.0: i32);
        _166 = &mut _88;
        _165 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _166, _157) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _167 = CheckedSub(_80, _157);
        assert(!move (_167.1: bool), "attempt to compute `{} - {}`, which would overflow", _80, _157) -> [success: bb103, unwind unreachable];
    }

    bb103: {
        _80 = move (_167.0: i32);
        goto -> bb116;
    }

    bb104: {
        _169 = &mut _88;
        _170 = _90;
        _168 = <<F as Float>::Int as AddAssign>::add_assign(move _169, move _170) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _174 = _88;
        _175 = <<F as Float>::Int as Shl<u32>>::shl(_8, const 4_u32) -> [return: bb106, unwind unreachable];
    }

    bb106: {
        _173 = <<F as Float>::Int as BitAnd>::bitand(move _174, move _175) -> [return: bb107, unwind unreachable];
    }

    bb107: {
        _172 = &_173;
        _177 = const _;
        _176 = &_177;
        _171 = <<F as Float>::Int as PartialEq>::ne(move _172, move _176) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        switchInt(move _171) -> [0: bb116, otherwise: bb109];
    }

    bb109: {
        _182 = _88;
        _181 = <<F as Float>::Int as BitAnd>::bitand(move _182, _3) -> [return: bb110, unwind unreachable];
    }

    bb110: {
        _180 = &_181;
        _184 = const _;
        _183 = &_184;
        _179 = <<F as Float>::Int as PartialEq>::ne(move _180, move _183) -> [return: bb111, unwind unreachable];
    }

    bb111: {
        _178 = <<F as Float>::Int as Int>::from_bool(move _179) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        _187 = _88;
        _186 = <<F as Float>::Int as Shr<u32>>::shr(move _187, const 1_u32) -> [return: bb113, unwind unreachable];
    }

    bb113: {
        _185 = <<F as Float>::Int as BitOr>::bitor(move _186, _178) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _88 = move _185;
        _188 = CheckedAdd(_80, const 1_i32);
        assert(!move (_188.1: bool), "attempt to compute `{} + {}`, which would overflow", _80, const 1_i32) -> [success: bb115, unwind unreachable];
    }

    bb115: {
        _80 = move (_188.0: i32);
        goto -> bb116;
    }

    bb116: {
        _190 = _80;
        _191 = _7 as i32 (IntToInt);
        _189 = Ge(move _190, move _191);
        switchInt(move _189) -> [0: bb119, otherwise: bb117];
    }

    bb117: {
        _193 = _15;
        _192 = <<F as Float>::Int as BitOr>::bitor(move _193, _102) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _0 = <F as Float>::from_repr(move _192) -> [return: bb144, unwind unreachable];
    }

    bb119: {
        _195 = _80;
        _194 = Le(move _195, const 0_i32);
        switchInt(move _194) -> [0: bb131, otherwise: bb120];
    }

    bb120: {
        _198 = _80;
        _199 = CheckedSub(const 1_i32, _198);
        assert(!move (_199.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1_i32, move _198) -> [success: bb121, unwind unreachable];
    }

    bb121: {
        _197 = move (_199.0: i32);
        _196 = <i32 as CastInto<<F as Float>::Int>>::cast(move _197) -> [return: bb122, unwind unreachable];
    }

    bb122: {
        _204 = _88;
        _207 = _5;
        _206 = <<F as Float>::Int as Int>::wrapping_sub(move _207, _196) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        _205 = <<F as Float>::Int as CastInto<u32>>::cast(move _206) -> [return: bb124, unwind unreachable];
    }

    bb124: {
        _203 = <<F as Float>::Int as Shl<u32>>::shl(move _204, move _205) -> [return: bb125, unwind unreachable];
    }

    bb125: {
        _202 = &_203;
        _209 = const _;
        _208 = &_209;
        _201 = <<F as Float>::Int as PartialEq>::ne(move _202, move _208) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _200 = <<F as Float>::Int as Int>::from_bool(move _201) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _212 = _88;
        _213 = <<F as Float>::Int as CastInto<u32>>::cast(_196) -> [return: bb128, unwind unreachable];
    }

    bb128: {
        _211 = <<F as Float>::Int as Shr<u32>>::shr(move _212, move _213) -> [return: bb129, unwind unreachable];
    }

    bb129: {
        _210 = <<F as Float>::Int as BitOr>::bitor(move _211, _200) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _88 = move _210;
        _80 = const 0_i32;
        goto -> bb131;
    }

    bb131: {
        _215 = _88;
        _214 = <<F as Float>::Int as CastInto<i32>>::cast(move _215) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _216 = BitAnd(_214, const 7_i32);
        _219 = _88;
        _218 = <<F as Float>::Int as Shr<u32>>::shr(move _219, const 3_u32) -> [return: bb133, unwind unreachable];
    }

    bb133: {
        _217 = <<F as Float>::Int as BitAnd>::bitand(move _218, _9) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        _221 = &mut _217;
        _224 = _80;
        _223 = <i32 as CastInto<<F as Float>::Int>>::cast(move _224) -> [return: bb135, unwind unreachable];
    }

    bb135: {
        _222 = <<F as Float>::Int as Shl<u32>>::shl(move _223, _6) -> [return: bb136, unwind unreachable];
    }

    bb136: {
        _220 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _221, move _222) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _226 = &mut _217;
        _225 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _226, _102) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _227 = Gt(_216, const 4_i32);
        switchInt(move _227) -> [0: bb140, otherwise: bb139];
    }

    bb139: {
        _229 = &mut _217;
        _228 = <<F as Float>::Int as AddAssign>::add_assign(move _229, _3) -> [return: bb140, unwind unreachable];
    }

    bb140: {
        switchInt(move _216) -> [4: bb141, otherwise: bb143];
    }

    bb141: {
        _231 = &mut _217;
        _233 = _217;
        _232 = <<F as Float>::Int as BitAnd>::bitand(move _233, _3) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _230 = <<F as Float>::Int as AddAssign>::add_assign(move _231, move _232) -> [return: bb143, unwind unreachable];
    }

    bb143: {
        _234 = _217;
        _0 = <F as Float>::from_repr(move _234) -> [return: bb144, unwind unreachable];
    }

    bb144: {
        return;
    }
}

fn add::__addsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = add::add::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __addsf3::__addsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = add::__addsf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn add::__adddf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = add::add::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __adddf3::__adddf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = add::__adddf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/cmp.rs:6:10: 6:15>::clone(_1: &float::cmp::Result) -> float::cmp::Result {
    debug self => _1;
    let mut _0: float::cmp::Result;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn float::cmp::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/cmp.rs:14:1: 14:12>::to_le_abi(_1: float::cmp::Result) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const 1_i32;
        goto -> bb5;
    }

    bb2: {
        _0 = const -1_i32;
        goto -> bb5;
    }

    bb3: {
        _0 = const 0_i32;
        goto -> bb5;
    }

    bb4: {
        _0 = const 1_i32;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn float::cmp::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/cmp.rs:14:1: 14:12>::to_ge_abi(_1: float::cmp::Result) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb3, 2: bb4, 3: bb1, otherwise: bb6];
    }

    bb1: {
        _0 = const -1_i32;
        goto -> bb5;
    }

    bb2: {
        _0 = const -1_i32;
        goto -> bb5;
    }

    bb3: {
        _0 = const 0_i32;
        goto -> bb5;
    }

    bb4: {
        _0 = const 1_i32;
        goto -> bb5;
    }

    bb5: {
        return;
    }

    bb6: {
        unreachable;
    }
}

fn float::cmp::cmp(_1: F, _2: F) -> float::cmp::Result {
    debug a => _1;
    debug b => _2;
    let mut _0: float::cmp::Result;
    let _3: <F as float::Float>::Int;
    let mut _6: <F as float::Float>::Int;
    let mut _14: bool;
    let mut _15: &<F as float::Float>::Int;
    let mut _16: &<F as float::Float>::Int;
    let mut _17: bool;
    let mut _18: &<F as float::Float>::Int;
    let mut _19: &<F as float::Float>::Int;
    let mut _20: bool;
    let mut _21: &<F as float::Float>::Int;
    let _22: <F as float::Float>::Int;
    let mut _23: <F as float::Float>::Int;
    let mut _24: <F as float::Float>::Int;
    let mut _25: &<F as float::Float>::Int;
    let mut _28: bool;
    let mut _29: &<F as float::Float>::SignedInt;
    let _30: <F as float::Float>::SignedInt;
    let mut _31: <F as float::Float>::SignedInt;
    let mut _32: <F as float::Float>::SignedInt;
    let mut _33: &<F as float::Float>::SignedInt;
    let mut _34: bool;
    let mut _35: &<F as float::Float>::SignedInt;
    let mut _36: &<F as float::Float>::SignedInt;
    let mut _37: bool;
    let mut _38: &<F as float::Float>::SignedInt;
    let mut _39: &<F as float::Float>::SignedInt;
    let mut _40: bool;
    let mut _41: &<F as float::Float>::SignedInt;
    let mut _42: &<F as float::Float>::SignedInt;
    let mut _43: bool;
    let mut _44: &<F as float::Float>::SignedInt;
    let mut _45: &<F as float::Float>::SignedInt;
    scope 1 {
        debug one => const _;
        let _4: <F as float::Float>::Int;
        scope 2 {
            debug zero => const _;
            let _5: <F as float::Float>::SignedInt;
            scope 3 {
                debug szero => const _;
                scope 4 {
                    debug sign_bit => const _;
                    let _7: <F as float::Float>::Int;
                    scope 5 {
                        debug abs_mask => _7;
                        let _8: <F as float::Float>::Int;
                        scope 6 {
                            debug exponent_mask => const _;
                            let _9: <F as float::Float>::Int;
                            scope 7 {
                                debug inf_rep => _9;
                                let _10: <F as float::Float>::Int;
                                scope 8 {
                                    debug a_rep => _10;
                                    let _11: <F as float::Float>::Int;
                                    scope 9 {
                                        debug b_rep => _11;
                                        let _12: <F as float::Float>::Int;
                                        scope 10 {
                                            debug a_abs => _12;
                                            let _13: <F as float::Float>::Int;
                                            scope 11 {
                                                debug b_abs => _13;
                                                let _26: <F as float::Float>::SignedInt;
                                                scope 12 {
                                                    debug a_srep => _26;
                                                    let _27: <F as float::Float>::SignedInt;
                                                    scope 13 {
                                                        debug b_srep => _27;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _5 = const _;
        _6 = const _;
        _7 = <<F as Float>::Int as Sub>::sub(_6, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = const _;
        _9 = _8;
        _10 = <F as Float>::repr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = <F as Float>::repr(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _12 = <<F as Float>::Int as BitAnd>::bitand(_10, _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = <<F as Float>::Int as BitAnd>::bitand(_11, _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _15 = &_12;
        _16 = &_9;
        _14 = <<F as Float>::Int as PartialOrd>::gt(move _15, move _16) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(move _14) -> [0: bb7, otherwise: bb9];
    }

    bb7: {
        _18 = &_13;
        _19 = &_9;
        _17 = <<F as Float>::Int as PartialOrd>::gt(move _18, move _19) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _17) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = float::cmp::Result::Unordered;
        goto -> bb33;
    }

    bb10: {
        _23 = _12;
        _24 = _13;
        _22 = <<F as Float>::Int as BitOr>::bitor(move _23, move _24) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = &_22;
        _25 = &_4;
        _20 = <<F as Float>::Int as PartialEq>::eq(move _21, move _25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        switchInt(move _20) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _0 = float::cmp::Result::Equal;
        goto -> bb33;
    }

    bb14: {
        _26 = <F as Float>::signed_repr(_1) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _27 = <F as Float>::signed_repr(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _31 = _26;
        _32 = _27;
        _30 = <<F as Float>::SignedInt as BitAnd>::bitand(move _31, move _32) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _29 = &_30;
        _33 = &_5;
        _28 = <<F as Float>::SignedInt as PartialOrd>::ge(move _29, move _33) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        switchInt(move _28) -> [0: bb26, otherwise: bb19];
    }

    bb19: {
        _35 = &_26;
        _36 = &_27;
        _34 = <<F as Float>::SignedInt as PartialOrd>::lt(move _35, move _36) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _34) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = float::cmp::Result::Less;
        goto -> bb33;
    }

    bb22: {
        _38 = &_26;
        _39 = &_27;
        _37 = <<F as Float>::SignedInt as PartialEq>::eq(move _38, move _39) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        switchInt(move _37) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _0 = float::cmp::Result::Equal;
        goto -> bb33;
    }

    bb25: {
        _0 = float::cmp::Result::Greater;
        goto -> bb33;
    }

    bb26: {
        _41 = &_26;
        _42 = &_27;
        _40 = <<F as Float>::SignedInt as PartialOrd>::gt(move _41, move _42) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        switchInt(move _40) -> [0: bb29, otherwise: bb28];
    }

    bb28: {
        _0 = float::cmp::Result::Less;
        goto -> bb33;
    }

    bb29: {
        _44 = &_26;
        _45 = &_27;
        _43 = <<F as Float>::SignedInt as PartialEq>::eq(move _44, move _45) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _43) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _0 = float::cmp::Result::Equal;
        goto -> bb33;
    }

    bb32: {
        _0 = float::cmp::Result::Greater;
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

fn unord(_1: F, _2: F) -> bool {
    debug a => _1;
    debug b => _2;
    let mut _0: bool;
    let _3: <F as float::Float>::Int;
    let mut _4: <F as float::Float>::Int;
    let mut _12: bool;
    let mut _13: &<F as float::Float>::Int;
    let mut _14: &<F as float::Float>::Int;
    let mut _15: &<F as float::Float>::Int;
    let mut _16: &<F as float::Float>::Int;
    scope 1 {
        debug one => const _;
        scope 2 {
            debug sign_bit => const _;
            let _5: <F as float::Float>::Int;
            scope 3 {
                debug abs_mask => _5;
                let _6: <F as float::Float>::Int;
                scope 4 {
                    debug exponent_mask => const _;
                    let _7: <F as float::Float>::Int;
                    scope 5 {
                        debug inf_rep => _7;
                        let _8: <F as float::Float>::Int;
                        scope 6 {
                            debug a_rep => _8;
                            let _9: <F as float::Float>::Int;
                            scope 7 {
                                debug b_rep => _9;
                                let _10: <F as float::Float>::Int;
                                scope 8 {
                                    debug a_abs => _10;
                                    let _11: <F as float::Float>::Int;
                                    scope 9 {
                                        debug b_abs => _11;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _5 = <<F as Float>::Int as Sub>::sub(_4, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const _;
        _7 = _6;
        _8 = <F as Float>::repr(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = <F as Float>::repr(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = <<F as Float>::Int as BitAnd>::bitand(_8, _5) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = <<F as Float>::Int as BitAnd>::bitand(_9, _5) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _13 = &_10;
        _14 = &_7;
        _12 = <<F as Float>::Int as PartialOrd>::gt(move _13, move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(move _12) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = const true;
        goto -> bb9;
    }

    bb8: {
        _15 = &_11;
        _16 = &_7;
        _0 = <<F as Float>::Int as PartialOrd>::gt(move _15, move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        return;
    }
}

fn float::cmp::__lesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __lesf2::__lesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__lesf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__gesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_ge_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __gesf2::__gesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__gesf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__unordsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: bool;

    bb0: {
        _3 = unord::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _3 as i32 (IntToInt);
        return;
    }
}

fn __unordsf2::__unordsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__unordsf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__eqsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __eqsf2::__eqsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__eqsf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__ltsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __ltsf2::__ltsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__ltsf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__nesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __nesf2::__nesf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__nesf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__gtsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_ge_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __gtsf2::__gtsf2(_1: f32, _2: f32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__gtsf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__ledf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __ledf2::__ledf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__ledf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__gedf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_ge_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __gedf2::__gedf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__gedf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__unorddf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: bool;

    bb0: {
        _3 = unord::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _3 as i32 (IntToInt);
        return;
    }
}

fn __unorddf2::__unorddf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__unorddf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__eqdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __eqdf2::__eqdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__eqdf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__ltdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __ltdf2::__ltdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__ltdf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__nedf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_le_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __nedf2::__nedf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__nedf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::cmp::__gtdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let mut _3: float::cmp::Result;

    bb0: {
        _3 = float::cmp::cmp::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = float::cmp::Result::to_ge_abi(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __gtdf2::__gtdf2(_1: f64, _2: f64) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = float::cmp::__gtdf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn u32_to_f32_bits(_1: u32) -> u32 {
    debug i => _1;
    let mut _0: u32;
    let _2: u32;
    let mut _4: u32;
    let mut _5: bool;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: (u32, bool);
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: (u32, bool);
    let mut _26: (u32, bool);
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: bool;
    let mut _30: (u32, bool);
    scope 1 {
        debug n => _2;
        let _3: u32;
        scope 2 {
            debug a => _3;
            let _8: u32;
            scope 3 {
                debug b => _8;
                let _13: u32;
                scope 4 {
                    debug m => _13;
                    let _25: u32;
                    scope 5 {
                        debug e => _25;
                    }
                }
            }
        }
    }

    bb0: {
        switchInt(move _1) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 0_u32;
        goto -> bb15;
    }

    bb2: {
        _2 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Lt(_2, const 32_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shl(_1, _2);
        _6 = const 8_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 8_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Shr(move _4, const 8_i32);
        _10 = Lt(_2, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _9 = Shl(_1, _2);
        _11 = const 24_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", const 24_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _8 = Shl(move _9, const 24_i32);
        _18 = const 31_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 32_u32);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shr(_8, const 31_i32);
        _20 = Not(_3);
        _16 = BitAnd(move _17, move _20);
        _21 = CheckedSub(_8, _16);
        assert(!move (_21.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _16) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _15 = move (_21.0: u32);
        _22 = const 31_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 32_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _14 = Shr(move _15, const 31_i32);
        _24 = CheckedAdd(_3, _14);
        assert(!move (_24.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, move _14) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _13 = move (_24.0: u32);
        _26 = CheckedSub(const 157_u32, _2);
        assert(!move (_26.1: bool), "attempt to compute `{} - {}`, which would overflow", const 157_u32, _2) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _25 = move (_26.0: u32);
        _28 = const 23_i32 as u32 (IntToInt);
        _29 = Lt(move _28, const 32_u32);
        assert(move _29, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _27 = Shl(_25, const 23_i32);
        _30 = CheckedAdd(_27, _13);
        assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", move _27, _13) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _0 = move (_30.0: u32);
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn u32_to_f64_bits(_1: u32) -> u64 {
    debug i => _1;
    let mut _0: u64;
    let _2: u32;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: (u32, bool);
    let mut _7: bool;
    let mut _9: u64;
    let mut _10: (u64, bool);
    let mut _11: u64;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: (u64, bool);
    scope 1 {
        debug n => _2;
        let _3: u64;
        scope 2 {
            debug m => _3;
            let _8: u64;
            scope 3 {
                debug e => _8;
            }
        }
    }

    bb0: {
        switchInt(move _1) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 0_u64;
        goto -> bb9;
    }

    bb2: {
        _2 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _4 = _1 as u64 (IntToInt);
        _6 = CheckedAdd(const 21_u32, _2);
        assert(!move (_6.1: bool), "attempt to compute `{} + {}`, which would overflow", const 21_u32, _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _5 = move (_6.0: u32);
        _7 = Lt(_5, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", _5) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Shl(move _4, move _5);
        _9 = _2 as u64 (IntToInt);
        _10 = CheckedSub(const 1053_u64, _9);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1053_u64, move _9) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _8 = move (_10.0: u64);
        _12 = const 52_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _11 = Shl(_8, const 52_i32);
        _14 = CheckedAdd(_11, _3);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, _3) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _0 = move (_14.0: u64);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn u64_to_f32_bits(_1: u64) -> u32 {
    debug i => _1;
    let mut _0: u32;
    let _2: u32;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u64;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: (u32, bool);
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: (u32, bool);
    let mut _27: (u32, bool);
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: (u32, bool);
    scope 1 {
        debug n => _2;
        let _3: u64;
        scope 2 {
            debug y => _3;
            let _4: u32;
            scope 3 {
                debug a => _4;
                let _8: u32;
                scope 4 {
                    debug b => _8;
                    let _14: u32;
                    scope 5 {
                        debug m => _14;
                        let _26: u32;
                        scope 6 {
                            debug e => _26;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u64>::wrapping_shl(_1, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = const 40_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 40_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(_3, const 40_i32);
        _4 = move _5 as u32 (IntToInt);
        _11 = const 8_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 8_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = Shr(_3, const 8_i32);
        _13 = BitAnd(_3, const 65535_u64);
        _9 = BitOr(move _10, move _13);
        _8 = move _9 as u32 (IntToInt);
        _19 = const 31_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 32_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _18 = Shr(_8, const 31_i32);
        _21 = Not(_4);
        _17 = BitAnd(move _18, move _21);
        _22 = CheckedSub(_8, _17);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _17) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _16 = move (_22.0: u32);
        _23 = const 31_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 32_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _15 = Shr(move _16, const 31_i32);
        _25 = CheckedAdd(_4, _15);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _15) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _14 = move (_25.0: u32);
        switchInt(move _1) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _26 = const 0_u32;
        goto -> bb12;
    }

    bb10: {
        _27 = CheckedSub(const 189_u32, _2);
        assert(!move (_27.1: bool), "attempt to compute `{} - {}`, which would overflow", const 189_u32, _2) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _26 = move (_27.0: u32);
        goto -> bb12;
    }

    bb12: {
        _29 = _26;
        _30 = const 23_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 32_u32);
        assert(move _31, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _28 = Shl(move _29, const 23_i32);
        _32 = CheckedAdd(_28, _14);
        assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", move _28, _14) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _0 = move (_32.0: u32);
        return;
    }
}

fn u64_to_f64_bits(_1: u64) -> u64 {
    debug i => _1;
    let mut _0: u64;
    let _2: u32;
    let mut _4: u64;
    let mut _5: bool;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u64;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u64;
    let mut _21: (u64, bool);
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: (u64, bool);
    let mut _26: u64;
    let mut _27: (u64, bool);
    let mut _28: u64;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: (u64, bool);
    scope 1 {
        debug n => _2;
        let _3: u64;
        scope 2 {
            debug a => _3;
            let _8: u64;
            scope 3 {
                debug b => _8;
                let _13: u64;
                scope 4 {
                    debug m => _13;
                    let _25: u64;
                    scope 5 {
                        debug e => _25;
                    }
                }
            }
        }
    }

    bb0: {
        switchInt(move _1) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 0_u64;
        goto -> bb15;
    }

    bb2: {
        _2 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Lt(_2, const 64_u32);
        assert(move _5, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _4 = Shl(_1, _2);
        _6 = const 11_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 11_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3 = Shr(move _4, const 11_i32);
        _10 = Lt(_2, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _9 = Shl(_1, _2);
        _11 = const 53_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _8 = Shl(move _9, const 53_i32);
        _18 = const 63_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shr(_8, const 63_i32);
        _20 = Not(_3);
        _16 = BitAnd(move _17, move _20);
        _21 = CheckedSub(_8, _16);
        assert(!move (_21.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _16) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _15 = move (_21.0: u64);
        _22 = const 63_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 64_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _14 = Shr(move _15, const 63_i32);
        _24 = CheckedAdd(_3, _14);
        assert(!move (_24.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, move _14) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _13 = move (_24.0: u64);
        _26 = _2 as u64 (IntToInt);
        _27 = CheckedSub(const 1085_u64, _26);
        assert(!move (_27.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1085_u64, move _26) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _25 = move (_27.0: u64);
        _29 = const 52_i32 as u32 (IntToInt);
        _30 = Lt(move _29, const 64_u32);
        assert(move _30, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _28 = Shl(_25, const 52_i32);
        _31 = CheckedAdd(_28, _13);
        assert(!move (_31.1: bool), "attempt to compute `{} + {}`, which would overflow", move _28, _13) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _0 = move (_31.0: u64);
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn u128_to_f32_bits(_1: u128) -> u32 {
    debug i => _1;
    let mut _0: u32;
    let _2: u32;
    let mut _5: u128;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u32;
    let mut _10: u128;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u128;
    let mut _16: u128;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: (u32, bool);
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: (u32, bool);
    let mut _34: (u32, bool);
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: (u32, bool);
    scope 1 {
        debug n => _2;
        let _3: u128;
        scope 2 {
            debug y => _3;
            let _4: u32;
            scope 3 {
                debug a => _4;
                let _8: u32;
                scope 4 {
                    debug b => _8;
                    let _21: u32;
                    scope 5 {
                        debug m => _21;
                        let _33: u32;
                        scope 6 {
                            debug e => _33;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = rustc_std_workspace_core::num::<impl u128>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u128>::wrapping_shl(_1, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = const 104_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 128_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 104_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(_3, const 104_i32);
        _4 = move _5 as u32 (IntToInt);
        _11 = const 72_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 128_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 72_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = Shr(_3, const 72_i32);
        _9 = move _10 as u32 (IntToInt);
        _17 = const 32_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 128_u32);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _16 = Shl(_3, const 32_i32);
        _19 = const 32_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 128_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _15 = Shr(move _16, const 32_i32);
        _14 = Ne(move _15, const 0_u128);
        _13 = move _14 as u32 (IntToInt);
        _8 = BitOr(move _9, move _13);
        _26 = const 31_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _25 = Shr(_8, const 31_i32);
        _28 = Not(_4);
        _24 = BitAnd(move _25, move _28);
        _29 = CheckedSub(_8, _24);
        assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _24) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _23 = move (_29.0: u32);
        _30 = const 31_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 32_u32);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _22 = Shr(move _23, const 31_i32);
        _32 = CheckedAdd(_4, _22);
        assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _22) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _21 = move (_32.0: u32);
        switchInt(move _1) -> [0: bb11, otherwise: bb12];
    }

    bb11: {
        _33 = const 0_u32;
        goto -> bb14;
    }

    bb12: {
        _34 = CheckedSub(const 253_u32, _2);
        assert(!move (_34.1: bool), "attempt to compute `{} - {}`, which would overflow", const 253_u32, _2) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _33 = move (_34.0: u32);
        goto -> bb14;
    }

    bb14: {
        _36 = _33;
        _37 = const 23_i32 as u32 (IntToInt);
        _38 = Lt(move _37, const 32_u32);
        assert(move _38, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _35 = Shl(move _36, const 23_i32);
        _39 = CheckedAdd(_35, _21);
        assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", move _35, _21) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _0 = move (_39.0: u32);
        return;
    }
}

fn u128_to_f64_bits(_1: u128) -> u64 {
    debug i => _1;
    let mut _0: u64;
    let _2: u32;
    let mut _5: u128;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u128;
    let mut _10: u128;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u128;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u64;
    let mut _22: (u64, bool);
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: (u64, bool);
    let mut _27: u64;
    let mut _28: (u64, bool);
    let mut _29: u64;
    let mut _30: u64;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: (u64, bool);
    scope 1 {
        debug n => _2;
        let _3: u128;
        scope 2 {
            debug y => _3;
            let _4: u64;
            scope 3 {
                debug a => _4;
                let _8: u64;
                scope 4 {
                    debug b => _8;
                    let _14: u64;
                    scope 5 {
                        debug m => _14;
                        let _26: u64;
                        scope 6 {
                            debug e => _26;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = rustc_std_workspace_core::num::<impl u128>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u128>::wrapping_shl(_1, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = const 75_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 128_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 75_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(_3, const 75_i32);
        _4 = move _5 as u64 (IntToInt);
        _11 = const 11_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 128_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 11_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = Shr(_3, const 11_i32);
        _13 = BitAnd(_3, const 4294967295_u128);
        _9 = BitOr(move _10, move _13);
        _8 = move _9 as u64 (IntToInt);
        _19 = const 63_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 64_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _18 = Shr(_8, const 63_i32);
        _21 = Not(_4);
        _17 = BitAnd(move _18, move _21);
        _22 = CheckedSub(_8, _17);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, move _17) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _16 = move (_22.0: u64);
        _23 = const 63_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 64_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _15 = Shr(move _16, const 63_i32);
        _25 = CheckedAdd(_4, _15);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _15) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _14 = move (_25.0: u64);
        switchInt(move _1) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _26 = const 0_u64;
        goto -> bb12;
    }

    bb10: {
        _27 = _2 as u64 (IntToInt);
        _28 = CheckedSub(const 1149_u64, _27);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1149_u64, move _27) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _26 = move (_28.0: u64);
        goto -> bb12;
    }

    bb12: {
        _30 = _26;
        _31 = const 52_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 64_u32);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _29 = Shl(move _30, const 52_i32);
        _33 = CheckedAdd(_29, _14);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _29, _14) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _0 = move (_33.0: u64);
        return;
    }
}

fn conv::__floatunsisf(_1: u32) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let mut _2: u32;

    bb0: {
        _2 = u32_to_f32_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f32::<impl f32>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatunsisf::__floatunsisf(_1: u32) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floatunsisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatunsidf(_1: u32) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let mut _2: u64;

    bb0: {
        _2 = u32_to_f64_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f64::<impl f64>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatunsidf::__floatunsidf(_1: u32) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floatunsidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatundisf(_1: u64) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let mut _2: u32;

    bb0: {
        _2 = u64_to_f32_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f32::<impl f32>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatundisf::__floatundisf(_1: u64) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floatundisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatundidf(_1: u64) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let mut _2: u64;

    bb0: {
        _2 = u64_to_f64_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f64::<impl f64>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatundidf::__floatundidf(_1: u64) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floatundidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatuntisf(_1: u128) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let mut _2: u32;

    bb0: {
        _2 = u128_to_f32_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f32::<impl f32>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatuntisf::__floatuntisf(_1: u128) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floatuntisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatuntidf(_1: u128) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let mut _2: u64;

    bb0: {
        _2 = u128_to_f64_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = f64::<impl f64>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn __floatuntidf::__floatuntidf(_1: u128) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floatuntidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatsisf(_1: i32) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let _2: u32;
    let mut _3: u32;
    let mut _4: i32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 31_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 31_i32);
        _3 = move _4 as u32 (IntToInt);
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 31_i32);
        _11 = rustc_std_workspace_core::num::<impl i32>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u32_to_f32_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f32::<impl f32>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floatsisf::__floatsisf(_1: i32) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floatsisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatsidf(_1: i32) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _3: u64;
    let mut _4: i32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u32;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 31_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 31_i32);
        _3 = move _4 as u64 (IntToInt);
        _7 = const 63_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 63_i32);
        _11 = rustc_std_workspace_core::num::<impl i32>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u32_to_f64_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f64::<impl f64>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floatsidf::__floatsidf(_1: i32) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floatsidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatdisf(_1: i64) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let _2: u32;
    let mut _3: u32;
    let mut _4: i64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u64;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 63_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 63_i32);
        _3 = move _4 as u32 (IntToInt);
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 31_i32);
        _11 = rustc_std_workspace_core::num::<impl i64>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u64_to_f32_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f32::<impl f32>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floatdisf::__floatdisf(_1: i64) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floatdisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floatdidf(_1: i64) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _3: u64;
    let mut _4: i64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u64;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 63_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 63_i32);
        _3 = move _4 as u64 (IntToInt);
        _7 = const 63_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 63_i32);
        _11 = rustc_std_workspace_core::num::<impl i64>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u64_to_f64_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f64::<impl f64>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floatdidf::__floatdidf(_1: i64) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floatdidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floattisf(_1: i128) -> f32 {
    debug i => _1;
    let mut _0: f32;
    let _2: u32;
    let mut _3: u32;
    let mut _4: i128;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u128;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 127_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 128_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 127_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 127_i32);
        _3 = move _4 as u32 (IntToInt);
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 31_i32);
        _11 = rustc_std_workspace_core::num::<impl i128>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u128_to_f32_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f32::<impl f32>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floattisf::__floattisf(_1: i128) -> f32 {
    debug i => _1;
    let mut _0: f32;

    bb0: {
        _0 = conv::__floattisf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__floattidf(_1: i128) -> f64 {
    debug i => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _3: u64;
    let mut _4: i128;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u128;
    scope 1 {
        debug sign_bit => _2;
    }

    bb0: {
        _5 = const 127_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 128_u32);
        assert(move _6, "attempt to shift right by `{}`, which would overflow", const 127_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shr(_1, const 127_i32);
        _3 = move _4 as u64 (IntToInt);
        _7 = const 63_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shl(move _3, const 63_i32);
        _11 = rustc_std_workspace_core::num::<impl i128>::unsigned_abs(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = u128_to_f64_bits(move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _9 = BitOr(move _10, _2);
        _0 = f64::<impl f64>::from_bits(move _9) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn __floattidf::__floattidf(_1: i128) -> f64 {
    debug i => _1;
    let mut _0: f64;

    bb0: {
        _0 = conv::__floattidf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunssfsi(_1: f32) -> u32 {
    debug f => _1;
    let mut _0: u32;
    let _2: u32;
    let mut _3: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: (u32, bool);
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u32;
        scope 2 {
            debug m => _11;
            let _18: u32;
            scope 3 {
                debug s => _18;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 23_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 127_u32, const 23_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u32;
        goto -> bb16;
    }

    bb4: {
        _9 = const 23_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 159_u32, const 23_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 31_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u32, const 31_i32);
        _16 = const 8_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 32_u32);
        assert(move _17, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Shl(_2, const 8_i32);
        _11 = BitOr(move _12, move _15);
        _20 = const 23_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 32_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _19 = Shr(_2, const 23_i32);
        _22 = CheckedSub(const 158_u32, _19);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const 158_u32, move _19) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _18 = move (_22.0: u32);
        _23 = Lt(_18, const 32_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", _18) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _18);
        goto -> bb16;
    }

    bb12: {
        _26 = const 23_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _25 = Shl(const 255_u32, const 23_i32);
        _24 = Le(_2, move _25);
        switchInt(move _24) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u32;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunssfsi::__fixunssfsi(_1: f32) -> u32 {
    debug f => _1;
    let mut _0: u32;

    bb0: {
        _0 = conv::__fixunssfsi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunssfdi(_1: f32) -> u64 {
    debug f => _1;
    let mut _0: u64;
    let _2: u32;
    let mut _3: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u64;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u32, bool);
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u64;
        scope 2 {
            debug m => _11;
            let _19: u32;
            scope 3 {
                debug s => _19;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 23_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 127_u32, const 23_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u64;
        goto -> bb16;
    }

    bb4: {
        _9 = const 23_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 191_u32, const 23_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 63_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 64_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u64, const 63_i32);
        _16 = _2 as u64 (IntToInt);
        _17 = const 40_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", const 40_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Shl(move _16, const 40_i32);
        _11 = BitOr(move _12, move _15);
        _21 = const 23_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shr(_2, const 23_i32);
        _23 = CheckedSub(const 190_u32, _20);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", const 190_u32, move _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _19 = move (_23.0: u32);
        _24 = Lt(_19, const 64_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _19) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _19);
        goto -> bb16;
    }

    bb12: {
        _27 = const 23_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 32_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _26 = Shl(const 255_u32, const 23_i32);
        _25 = Le(_2, move _26);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u64;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunssfdi::__fixunssfdi(_1: f32) -> u64 {
    debug f => _1;
    let mut _0: u64;

    bb0: {
        _0 = conv::__fixunssfdi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunssfti(_1: f32) -> u128 {
    debug f => _1;
    let mut _0: u128;
    let _2: u32;
    let mut _3: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u128;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u128;
    let mut _16: u128;
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u32, bool);
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u128;
        scope 2 {
            debug m => _11;
            let _19: u32;
            scope 3 {
                debug s => _19;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 23_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 127_u32, const 23_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u128;
        goto -> bb16;
    }

    bb4: {
        _9 = const 23_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 255_u32, const 23_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 127_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 128_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 127_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u128, const 127_i32);
        _16 = _2 as u128 (IntToInt);
        _17 = const 104_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 128_u32);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", const 104_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Shl(move _16, const 104_i32);
        _11 = BitOr(move _12, move _15);
        _21 = const 23_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shr(_2, const 23_i32);
        _23 = CheckedSub(const 254_u32, _20);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", const 254_u32, move _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _19 = move (_23.0: u32);
        _24 = Lt(_19, const 128_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _19) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _19);
        goto -> bb16;
    }

    bb12: {
        _27 = const 23_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 32_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _26 = Shl(const 255_u32, const 23_i32);
        _25 = Eq(_2, move _26);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u128;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunssfti::__fixunssfti(_1: f32) -> u128 {
    debug f => _1;
    let mut _0: u128;

    bb0: {
        _0 = conv::__fixunssfti(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunsdfsi(_1: f64) -> u32 {
    debug f => _1;
    let mut _0: u32;
    let _2: u64;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u64;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u64, bool);
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u32;
        scope 2 {
            debug m => _11;
            let _19: u64;
            scope 3 {
                debug s => _19;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 52_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 1023_u64, const 52_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u32;
        goto -> bb16;
    }

    bb4: {
        _9 = const 52_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 1055_u64, const 52_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 31_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u32, const 31_i32);
        _17 = const 21_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 21_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _16 = Shr(_2, const 21_i32);
        _15 = move _16 as u32 (IntToInt);
        _11 = BitOr(move _12, move _15);
        _21 = const 52_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shr(_2, const 52_i32);
        _23 = CheckedSub(const 1054_u64, _20);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1054_u64, move _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _19 = move (_23.0: u64);
        _24 = Lt(_19, const 32_u64);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _19) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _19);
        goto -> bb16;
    }

    bb12: {
        _27 = const 52_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _26 = Shl(const 2047_u64, const 52_i32);
        _25 = Le(_2, move _26);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u32;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunsdfsi::__fixunsdfsi(_1: f64) -> u32 {
    debug f => _1;
    let mut _0: u32;

    bb0: {
        _0 = conv::__fixunsdfsi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunsdfdi(_1: f64) -> u64 {
    debug f => _1;
    let mut _0: u64;
    let _2: u64;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u64;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u64;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u64;
    let mut _16: u32;
    let mut _17: bool;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: (u64, bool);
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: u64;
    let mut _26: u32;
    let mut _27: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u64;
        scope 2 {
            debug m => _11;
            let _18: u64;
            scope 3 {
                debug s => _18;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 52_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 1023_u64, const 52_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u64;
        goto -> bb16;
    }

    bb4: {
        _9 = const 52_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 1087_u64, const 52_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 63_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 64_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u64, const 63_i32);
        _16 = const 11_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 64_u32);
        assert(move _17, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Shl(_2, const 11_i32);
        _11 = BitOr(move _12, move _15);
        _20 = const 52_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _19 = Shr(_2, const 52_i32);
        _22 = CheckedSub(const 1086_u64, _19);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1086_u64, move _19) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _18 = move (_22.0: u64);
        _23 = Lt(_18, const 64_u64);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", _18) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _18);
        goto -> bb16;
    }

    bb12: {
        _26 = const 52_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _25 = Shl(const 2047_u64, const 52_i32);
        _24 = Le(_2, move _25);
        switchInt(move _24) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u64;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunsdfdi::__fixunsdfdi(_1: f64) -> u64 {
    debug f => _1;
    let mut _0: u64;

    bb0: {
        _0 = conv::__fixunsdfdi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixunsdfti(_1: f64) -> u128 {
    debug f => _1;
    let mut _0: u128;
    let _2: u64;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: u64;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u128;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u128;
    let mut _16: u128;
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u64, bool);
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    scope 1 {
        debug fbits => _2;
        let _11: u128;
        scope 2 {
            debug m => _11;
            let _19: u64;
            scope 3 {
                debug s => _19;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = const 52_i32 as u32 (IntToInt);
        _6 = Lt(move _5, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(const 1023_u64, const 52_i32);
        _3 = Lt(_2, move _4);
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const 0_u128;
        goto -> bb16;
    }

    bb4: {
        _9 = const 52_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Shl(const 1151_u64, const 52_i32);
        _7 = Lt(_2, move _8);
        switchInt(move _7) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _13 = const 127_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 128_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 127_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _12 = Shl(const 1_u128, const 127_i32);
        _16 = _2 as u128 (IntToInt);
        _17 = const 75_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 128_u32);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", const 75_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Shl(move _16, const 75_i32);
        _11 = BitOr(move _12, move _15);
        _21 = const 52_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shr(_2, const 52_i32);
        _23 = CheckedSub(const 1150_u64, _20);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1150_u64, move _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _19 = move (_23.0: u64);
        _24 = Lt(_19, const 128_u64);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _19) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Shr(_11, _19);
        goto -> bb16;
    }

    bb12: {
        _27 = const 52_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _26 = Shl(const 2047_u64, const 52_i32);
        _25 = Le(_2, move _26);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const _;
        goto -> bb16;
    }

    bb15: {
        _0 = const 0_u128;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn __fixunsdfti::__fixunsdfti(_1: f64) -> u128 {
    debug f => _1;
    let mut _0: u128;

    bb0: {
        _0 = conv::__fixunsdfti(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixsfsi(_1: f32) -> i32 {
    debug f => _1;
    let mut _0: i32;
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: (u32, bool);
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u32;
        scope 2 {
            debug m => _16;
            let _23: u32;
            scope 3 {
                debug s => _23;
                let _28: i32;
                scope 4 {
                    debug u => _28;
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u32);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 127_u32, const 23_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i32;
        goto -> bb24;
    }

    bb5: {
        _14 = const 23_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 158_u32, const 23_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 31_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 32_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u32, const 31_i32);
        _21 = const 8_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(_2, const 8_i32);
        _16 = BitOr(move _17, move _20);
        _25 = const 23_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 32_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _24 = Shr(_2, const 23_i32);
        _27 = CheckedSub(const 158_u32, _24);
        assert(!move (_27.1: bool), "attempt to compute `{} - {}`, which would overflow", const 158_u32, move _24) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _23 = move (_27.0: u32);
        _30 = Lt(_23, const 32_u32);
        assert(move _30, "attempt to shift right by `{}`, which would overflow", _23) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _29 = Shr(_16, _23);
        _28 = move _29 as i32 (IntToInt);
        _31 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _31) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _32 = Eq(_28, const i32::MIN);
        assert(!move _32, "attempt to negate `{}`, which would overflow", _28) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_28);
        goto -> bb24;
    }

    bb16: {
        _0 = _28;
        goto -> bb24;
    }

    bb17: {
        _35 = const 23_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _34 = Shl(const 255_u32, const 23_i32);
        _33 = Le(_2, move _34);
        switchInt(move _33) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _37 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _37) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i32;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixsfsi::__fixsfsi(_1: f32) -> i32 {
    debug f => _1;
    let mut _0: i32;

    bb0: {
        _0 = conv::__fixsfsi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixsfdi(_1: f32) -> i64 {
    debug f => _1;
    let mut _0: i64;
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u32;
    let mut _23: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (u32, bool);
    let mut _30: u64;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u64;
        scope 2 {
            debug m => _16;
            let _24: u32;
            scope 3 {
                debug s => _24;
                let _29: i64;
                scope 4 {
                    debug u => _29;
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u32);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 127_u32, const 23_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i64;
        goto -> bb24;
    }

    bb5: {
        _14 = const 23_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 190_u32, const 23_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 63_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u64, const 63_i32);
        _21 = _2 as u64 (IntToInt);
        _22 = const 40_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 64_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 40_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(move _21, const 40_i32);
        _16 = BitOr(move _17, move _20);
        _26 = const 23_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _25 = Shr(_2, const 23_i32);
        _28 = CheckedSub(const 190_u32, _25);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", const 190_u32, move _25) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _24 = move (_28.0: u32);
        _31 = Lt(_24, const 64_u32);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", _24) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _30 = Shr(_16, _24);
        _29 = move _30 as i64 (IntToInt);
        _32 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _32) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _33 = Eq(_29, const i64::MIN);
        assert(!move _33, "attempt to negate `{}`, which would overflow", _29) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_29);
        goto -> bb24;
    }

    bb16: {
        _0 = _29;
        goto -> bb24;
    }

    bb17: {
        _36 = const 23_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 32_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _35 = Shl(const 255_u32, const 23_i32);
        _34 = Le(_2, move _35);
        switchInt(move _34) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _38 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _38) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i64;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixsfdi::__fixsfdi(_1: f32) -> i64 {
    debug f => _1;
    let mut _0: i64;

    bb0: {
        _0 = conv::__fixsfdi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixsfti(_1: f32) -> i128 {
    debug f => _1;
    let mut _0: i128;
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u128;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u128;
    let mut _21: u128;
    let mut _22: u32;
    let mut _23: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (u32, bool);
    let mut _30: u128;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u128;
        scope 2 {
            debug m => _16;
            let _24: u32;
            scope 3 {
                debug s => _24;
                let _29: i128;
                scope 4 {
                    debug u => _29;
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u32);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 127_u32, const 23_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i128;
        goto -> bb24;
    }

    bb5: {
        _14 = const 23_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 254_u32, const 23_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 127_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 128_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 127_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u128, const 127_i32);
        _21 = _2 as u128 (IntToInt);
        _22 = const 104_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 128_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 104_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(move _21, const 104_i32);
        _16 = BitOr(move _17, move _20);
        _26 = const 23_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _25 = Shr(_2, const 23_i32);
        _28 = CheckedSub(const 254_u32, _25);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", const 254_u32, move _25) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _24 = move (_28.0: u32);
        _31 = Lt(_24, const 128_u32);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", _24) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _30 = Shr(_16, _24);
        _29 = move _30 as i128 (IntToInt);
        _32 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _32) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _33 = Eq(_29, const i128::MIN);
        assert(!move _33, "attempt to negate `{}`, which would overflow", _29) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_29);
        goto -> bb24;
    }

    bb16: {
        _0 = _29;
        goto -> bb24;
    }

    bb17: {
        _36 = const 23_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 32_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _35 = Shl(const 255_u32, const 23_i32);
        _34 = Le(_2, move _35);
        switchInt(move _34) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _38 = f32::<impl f32>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _38) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i128;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixsfti::__fixsfti(_1: f32) -> i128 {
    debug f => _1;
    let mut _0: i128;

    bb0: {
        _0 = conv::__fixsfti(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixdfsi(_1: f64) -> i32 {
    debug f => _1;
    let mut _0: i32;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u64;
    let mut _22: u32;
    let mut _23: bool;
    let mut _25: u64;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (u64, bool);
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: u64;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u32;
        scope 2 {
            debug m => _16;
            let _24: u64;
            scope 3 {
                debug s => _24;
                let _29: i32;
                scope 4 {
                    debug u => _29;
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u64);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 1023_u64, const 52_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i32;
        goto -> bb24;
    }

    bb5: {
        _14 = const 52_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 1054_u64, const 52_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 31_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 32_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 31_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u32, const 31_i32);
        _22 = const 21_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 64_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", const 21_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _21 = Shr(_2, const 21_i32);
        _20 = move _21 as u32 (IntToInt);
        _16 = BitOr(move _17, move _20);
        _26 = const 52_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _25 = Shr(_2, const 52_i32);
        _28 = CheckedSub(const 1054_u64, _25);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1054_u64, move _25) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _24 = move (_28.0: u64);
        _31 = Lt(_24, const 32_u64);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", _24) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _30 = Shr(_16, _24);
        _29 = move _30 as i32 (IntToInt);
        _32 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _32) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _33 = Eq(_29, const i32::MIN);
        assert(!move _33, "attempt to negate `{}`, which would overflow", _29) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_29);
        goto -> bb24;
    }

    bb16: {
        _0 = _29;
        goto -> bb24;
    }

    bb17: {
        _36 = const 52_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _35 = Shl(const 2047_u64, const 52_i32);
        _34 = Le(_2, move _35);
        switchInt(move _34) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _38 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _38) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i32;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixdfsi::__fixdfsi(_1: f64) -> i32 {
    debug f => _1;
    let mut _0: i32;

    bb0: {
        _0 = conv::__fixdfsi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixdfdi(_1: f64) -> i64 {
    debug f => _1;
    let mut _0: i64;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _24: u64;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: (u64, bool);
    let mut _29: u64;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: u64;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u64;
        scope 2 {
            debug m => _16;
            let _23: u64;
            scope 3 {
                debug s => _23;
                let _28: i64;
                scope 4 {
                    debug u => _28;
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u64);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 1023_u64, const 52_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i64;
        goto -> bb24;
    }

    bb5: {
        _14 = const 52_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 1086_u64, const 52_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 63_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u64, const 63_i32);
        _21 = const 11_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift left by `{}`, which would overflow", const 11_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(_2, const 11_i32);
        _16 = BitOr(move _17, move _20);
        _25 = const 52_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 64_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _24 = Shr(_2, const 52_i32);
        _27 = CheckedSub(const 1086_u64, _24);
        assert(!move (_27.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1086_u64, move _24) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _23 = move (_27.0: u64);
        _30 = Lt(_23, const 64_u64);
        assert(move _30, "attempt to shift right by `{}`, which would overflow", _23) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _29 = Shr(_16, _23);
        _28 = move _29 as i64 (IntToInt);
        _31 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _31) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _32 = Eq(_28, const i64::MIN);
        assert(!move _32, "attempt to negate `{}`, which would overflow", _28) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_28);
        goto -> bb24;
    }

    bb16: {
        _0 = _28;
        goto -> bb24;
    }

    bb17: {
        _35 = const 52_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 64_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _34 = Shl(const 2047_u64, const 52_i32);
        _33 = Le(_2, move _34);
        switchInt(move _33) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _37 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _37) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i64;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixdfdi::__fixdfdi(_1: f64) -> i64 {
    debug f => _1;
    let mut _0: i64;

    bb0: {
        _0 = conv::__fixdfdi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn conv::__fixdfti(_1: f64) -> i128 {
    debug f => _1;
    let mut _0: i128;
    let _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u128;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u128;
    let mut _21: u128;
    let mut _22: u32;
    let mut _23: bool;
    let mut _25: u64;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (u64, bool);
    let mut _30: u128;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: u64;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: bool;
    scope 1 {
        debug fbits => _2;
        let _16: u128;
        scope 2 {
            debug m => _16;
            let _24: u64;
            scope 3 {
                debug s => _24;
                let _29: i128;
                scope 4 {
                    debug u => _29;
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Not(const 0_u64);
        _6 = const 1_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 1_i32);
        _2 = BitAnd(move _3, move _4);
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shl(const 1023_u64, const 52_i32);
        _8 = Lt(_2, move _9);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const 0_i128;
        goto -> bb24;
    }

    bb5: {
        _14 = const 52_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _13 = Shl(const 1150_u64, const 52_i32);
        _12 = Lt(_2, move _13);
        switchInt(move _12) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _18 = const 127_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 128_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 127_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _17 = Shl(const 1_u128, const 127_i32);
        _21 = _2 as u128 (IntToInt);
        _22 = const 75_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 128_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 75_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(move _21, const 75_i32);
        _16 = BitOr(move _17, move _20);
        _26 = const 52_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _25 = Shr(_2, const 52_i32);
        _28 = CheckedSub(const 1150_u64, _25);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1150_u64, move _25) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _24 = move (_28.0: u64);
        _31 = Lt(_24, const 128_u64);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", _24) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _30 = Shr(_16, _24);
        _29 = move _30 as i128 (IntToInt);
        _32 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _32) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _33 = Eq(_29, const i128::MIN);
        assert(!move _33, "attempt to negate `{}`, which would overflow", _29) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(_29);
        goto -> bb24;
    }

    bb16: {
        _0 = _29;
        goto -> bb24;
    }

    bb17: {
        _36 = const 52_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _35 = Shl(const 2047_u64, const 52_i32);
        _34 = Le(_2, move _35);
        switchInt(move _34) -> [0: bb23, otherwise: bb19];
    }

    bb19: {
        _38 = f64::<impl f64>::is_sign_negative(_1) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        switchInt(move _38) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const _;
        goto -> bb24;
    }

    bb22: {
        _0 = const _;
        goto -> bb24;
    }

    bb23: {
        _0 = const 0_i128;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn __fixdfti::__fixdfti(_1: f64) -> i128 {
    debug f => _1;
    let mut _0: i128;

    bb0: {
        _0 = conv::__fixdfti(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn div32(_1: F, _2: F) -> F {
    debug a => _1;
    debug b => _2;
    let mut _0: F;
    let _3: <F as float::Float>::Int;
    let mut _6: bool;
    let mut _8: bool;
    let mut _14: <F as float::Float>::Int;
    let mut _19: <F as float::Float>::Int;
    let mut _24: <F as float::Float>::Int;
    let mut _25: <F as float::Float>::Int;
    let mut _27: <F as float::Float>::Int;
    let mut _28: <F as float::Float>::Int;
    let mut _30: <F as float::Float>::Int;
    let mut _34: bool;
    let mut _35: &<F as float::Float>::Int;
    let _36: <F as float::Float>::Int;
    let mut _37: &<F as float::Float>::Int;
    let _38: <F as float::Float>::Int;
    let mut _39: u32;
    let mut _40: (u32, bool);
    let mut _41: bool;
    let mut _42: &<F as float::Float>::Int;
    let _43: <F as float::Float>::Int;
    let mut _44: &<F as float::Float>::Int;
    let _45: <F as float::Float>::Int;
    let mut _46: u32;
    let mut _47: (u32, bool);
    let mut _50: bool;
    let mut _51: &<F as float::Float>::Int;
    let mut _52: &<F as float::Float>::Int;
    let mut _53: <F as float::Float>::Int;
    let mut _54: bool;
    let mut _55: &<F as float::Float>::Int;
    let mut _56: &<F as float::Float>::Int;
    let mut _57: <F as float::Float>::Int;
    let mut _58: bool;
    let mut _59: &<F as float::Float>::Int;
    let mut _60: &<F as float::Float>::Int;
    let mut _61: bool;
    let mut _62: &<F as float::Float>::Int;
    let mut _63: &<F as float::Float>::Int;
    let mut _64: <F as float::Float>::Int;
    let mut _65: <F as float::Float>::Int;
    let mut _66: bool;
    let mut _67: &<F as float::Float>::Int;
    let mut _68: &<F as float::Float>::Int;
    let mut _69: bool;
    let mut _70: &<F as float::Float>::Int;
    let mut _71: &<F as float::Float>::Int;
    let mut _72: bool;
    let mut _73: &<F as float::Float>::Int;
    let mut _74: &<F as float::Float>::Int;
    let mut _75: bool;
    let mut _76: &<F as float::Float>::Int;
    let mut _77: &<F as float::Float>::Int;
    let mut _78: <F as float::Float>::Int;
    let mut _79: <F as float::Float>::Int;
    let mut _80: bool;
    let mut _81: &<F as float::Float>::Int;
    let mut _82: &<F as float::Float>::Int;
    let mut _85: (i32, <F as float::Float>::Int);
    let mut _86: <F as float::Float>::Int;
    let mut _87: (i32, bool);
    let mut _88: bool;
    let mut _89: &<F as float::Float>::Int;
    let mut _90: &<F as float::Float>::Int;
    let mut _93: (i32, <F as float::Float>::Int);
    let mut _94: <F as float::Float>::Int;
    let mut _95: (i32, bool);
    let _96: ();
    let mut _97: &mut <F as float::Float>::Int;
    let mut _98: <F as float::Float>::Int;
    let _99: ();
    let mut _100: &mut <F as float::Float>::Int;
    let mut _101: <F as float::Float>::Int;
    let mut _103: u32;
    let mut _104: u32;
    let mut _105: <F as float::Float>::Int;
    let mut _106: <F as float::Float>::Int;
    let mut _107: <F as float::Float>::Int;
    let mut _108: i32;
    let mut _110: <F as float::Float>::Int;
    let mut _111: u32;
    let mut _112: u32;
    let mut _113: (u32, bool);
    let mut _114: (u32, bool);
    let mut _116: bool;
    let mut _118: u32;
    let mut _119: u32;
    let mut _120: <F as float::Float>::Int;
    let mut _121: u32;
    let mut _122: u32;
    let mut _123: (u32, bool);
    let mut _124: (u32, bool);
    let mut _125: bool;
    let mut _127: u16;
    let mut _128: u32;
    let mut _131: rustc_std_workspace_core::ops::Range<usize>;
    let mut _132: rustc_std_workspace_core::ops::Range<usize>;
    let mut _134: rustc_std_workspace_core::option::Option<usize>;
    let mut _135: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _136: isize;
    let mut _138: u32;
    let mut _139: u32;
    let mut _140: u32;
    let mut _141: u32;
    let mut _142: u16;
    let mut _143: u32;
    let mut _144: bool;
    let mut _145: u32;
    let mut _146: u32;
    let mut _147: u32;
    let mut _148: u16;
    let mut _149: u32;
    let mut _150: u32;
    let mut _151: (u32, bool);
    let mut _152: bool;
    let mut _153: u16;
    let mut _155: u32;
    let mut _157: u32;
    let mut _158: u32;
    let mut _159: u32;
    let mut _160: u32;
    let mut _161: u32;
    let mut _162: (u32, bool);
    let mut _163: u32;
    let mut _164: u32;
    let mut _165: u32;
    let mut _166: (u32, bool);
    let mut _167: bool;
    let mut _168: (u32, bool);
    let mut _169: (u32, bool);
    let mut _172: bool;
    let mut _174: u32;
    let mut _175: u32;
    let mut _176: u32;
    let mut _177: u32;
    let mut _178: u32;
    let mut _179: (u32, bool);
    let mut _180: u32;
    let mut _181: bool;
    let mut _182: u32;
    let mut _183: u32;
    let mut _184: u32;
    let mut _185: (u32, bool);
    let mut _186: u32;
    let mut _187: (u32, bool);
    let mut _188: bool;
    let _189: ();
    let mut _190: &mut <F as float::Float>::Int;
    let mut _192: i32;
    let mut _193: u32;
    let mut _194: (u32, bool);
    let mut _195: bool;
    let mut _198: bool;
    let mut _199: rustc_std_workspace_core::ops::Range<usize>;
    let mut _200: rustc_std_workspace_core::ops::Range<usize>;
    let mut _202: rustc_std_workspace_core::option::Option<usize>;
    let mut _203: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _204: isize;
    let mut _206: u64;
    let mut _207: u64;
    let mut _208: u64;
    let mut _209: u64;
    let mut _210: u32;
    let mut _211: <F as float::Float>::Int;
    let mut _212: u64;
    let mut _213: u32;
    let mut _214: (u64, bool);
    let mut _215: bool;
    let mut _216: <F as float::Float>::Int;
    let mut _217: u32;
    let mut _218: u64;
    let mut _219: u64;
    let mut _220: u64;
    let mut _221: u32;
    let mut _222: <F as float::Float>::Int;
    let mut _223: u64;
    let mut _224: (u64, bool);
    let mut _225: u32;
    let mut _226: (u32, bool);
    let mut _227: bool;
    let mut _228: <F as float::Float>::Int;
    let mut _229: <F as float::Float>::Int;
    let mut _230: <F as float::Float>::Int;
    let mut _233: <F as float::Float>::Int;
    let mut _235: <<F as float::Float>::Int as int::HInt>::D;
    let mut _236: <F as float::Float>::Int;
    let mut _237: <F as float::Float>::Int;
    let mut _240: (<F as float::Float>::Int, i32);
    let mut _241: bool;
    let mut _242: &<F as float::Float>::Int;
    let mut _243: &<F as float::Float>::Int;
    let _244: <F as float::Float>::Int;
    let mut _245: <F as float::Float>::Int;
    let mut _247: <F as float::Float>::Int;
    let mut _248: <F as float::Float>::Int;
    let mut _249: u32;
    let mut _250: (u32, bool);
    let mut _251: <F as float::Float>::Int;
    let mut _252: u32;
    let mut _253: u32;
    let mut _254: <F as float::Float>::Int;
    let mut _255: u32;
    let mut _256: <F as float::Float>::Int;
    let _257: ();
    let mut _258: &mut <F as float::Float>::Int;
    let mut _259: i32;
    let _260: ();
    let mut _261: &mut <F as float::Float>::Int;
    let mut _263: <F as float::Float>::Int;
    let mut _264: <F as float::Float>::Int;
    let mut _265: <F as float::Float>::Int;
    let mut _266: u32;
    let mut _267: u32;
    let mut _268: <F as float::Float>::Int;
    let mut _269: u32;
    let mut _270: <F as float::Float>::Int;
    let mut _272: bool;
    let mut _273: i32;
    let mut _274: <F as float::Float>::Int;
    let mut _275: <F as float::Float>::Int;
    let mut _277: bool;
    let _279: ();
    let mut _280: &mut <F as float::Float>::Int;
    let mut _281: <F as float::Float>::Int;
    let mut _282: u32;
    let mut _283: u32;
    let mut _284: bool;
    let _285: ();
    let mut _286: &mut <F as float::Float>::Int;
    let mut _287: bool;
    let mut _288: i32;
    let mut _289: i32;
    let mut _290: (i32, bool);
    let mut _292: u32;
    let mut _293: u32;
    let mut _294: u32;
    let mut _295: (u32, bool);
    let mut _296: <F as float::Float>::Int;
    let mut _297: u32;
    let mut _298: u32;
    let mut _299: <F as float::Float>::Int;
    let mut _300: <F as float::Float>::Int;
    let mut _301: u32;
    let mut _302: u32;
    let mut _303: u32;
    let mut _304: u32;
    let mut _305: u32;
    let mut _306: u32;
    let mut _307: <F as float::Float>::Int;
    let mut _308: u32;
    let mut _309: bool;
    let _311: ();
    let mut _312: &mut <F as float::Float>::Int;
    let mut _313: <F as float::Float>::Int;
    let mut _314: <F as float::Float>::Int;
    let mut _315: bool;
    let mut _316: &<F as float::Float>::Int;
    let mut _317: &<F as float::Float>::Int;
    let mut _318: <F as float::Float>::Int;
    let mut _319: <F as float::Float>::Int;
    let mut _320: <F as float::Float>::Int;
    scope 1 {
        debug one => const _;
        let _4: <F as float::Float>::Int;
        scope 2 {
            debug zero => const _;
            let _5: u32;
            scope 3 {
                debug hw => _5;
                let _7: u32;
                scope 4 {
                    debug lo_mask => _7;
                    let _9: u32;
                    scope 5 {
                        debug significand_bits => const _;
                        let _10: u32;
                        scope 6 {
                            debug max_exponent => const _;
                            let _11: u32;
                            scope 7 {
                                debug exponent_bias => const _;
                                let _12: <F as float::Float>::Int;
                                scope 8 {
                                    debug implicit_bit => const _;
                                    let _13: <F as float::Float>::Int;
                                    scope 9 {
                                        debug significand_mask => const _;
                                        scope 10 {
                                            debug sign_bit => const _;
                                            let _15: <F as float::Float>::Int;
                                            scope 11 {
                                                debug abs_mask => _15;
                                                let _16: <F as float::Float>::Int;
                                                scope 12 {
                                                    debug exponent_mask => const _;
                                                    let _17: <F as float::Float>::Int;
                                                    scope 13 {
                                                        debug inf_rep => _17;
                                                        let _18: <F as float::Float>::Int;
                                                        scope 14 {
                                                            debug quiet_bit => _18;
                                                            let _20: <F as float::Float>::Int;
                                                            scope 15 {
                                                                debug qnan_rep => _20;
                                                                let _21: <F as float::Float>::Int;
                                                                scope 16 {
                                                                    debug a_rep => _21;
                                                                    let _22: <F as float::Float>::Int;
                                                                    scope 17 {
                                                                        debug b_rep => _22;
                                                                        let _23: <F as float::Float>::Int;
                                                                        scope 18 {
                                                                            debug a_exponent => _23;
                                                                            let _26: <F as float::Float>::Int;
                                                                            scope 19 {
                                                                                debug b_exponent => _26;
                                                                                let _29: <F as float::Float>::Int;
                                                                                scope 20 {
                                                                                    debug quotient_sign => _29;
                                                                                    let mut _31: <F as float::Float>::Int;
                                                                                    scope 21 {
                                                                                        debug a_significand => _31;
                                                                                        let mut _32: <F as float::Float>::Int;
                                                                                        scope 22 {
                                                                                            debug b_significand => _32;
                                                                                            let mut _33: i32;
                                                                                            scope 23 {
                                                                                                debug scale => _33;
                                                                                                let _48: <F as float::Float>::Int;
                                                                                                let _102: i32;
                                                                                                scope 24 {
                                                                                                    debug a_abs => _48;
                                                                                                    let _49: <F as float::Float>::Int;
                                                                                                    scope 25 {
                                                                                                        debug b_abs => _49;
                                                                                                        let _83: i32;
                                                                                                        let _84: <F as float::Float>::Int;
                                                                                                        let _91: i32;
                                                                                                        let _92: <F as float::Float>::Int;
                                                                                                        scope 26 {
                                                                                                            debug exponent => _83;
                                                                                                            debug significand => _84;
                                                                                                        }
                                                                                                        scope 27 {
                                                                                                            debug exponent => _91;
                                                                                                            debug significand => _92;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                scope 28 {
                                                                                                    debug written_exponent => _102;
                                                                                                    let _109: <F as float::Float>::Int;
                                                                                                    scope 29 {
                                                                                                        debug b_uq1 => _109;
                                                                                                        scope 30 {
                                                                                                            debug x_uq0 => _115;
                                                                                                            let mut _197: <F as float::Float>::Int;
                                                                                                            let mut _201: rustc_std_workspace_core::ops::Range<usize>;
                                                                                                            scope 46 {
                                                                                                                debug x_uq0 => _197;
                                                                                                                let _231: <F as float::Float>::Int;
                                                                                                                scope 49 {
                                                                                                                    debug reciprocal_precision => _231;
                                                                                                                    let _232: <F as float::Float>::Int;
                                                                                                                    scope 50 {
                                                                                                                        debug x_uq0 => _232;
                                                                                                                        let mut _234: <F as float::Float>::Int;
                                                                                                                        scope 51 {
                                                                                                                            debug quotient => _234;
                                                                                                                            let mut _238: <F as float::Float>::Int;
                                                                                                                            let _239: i32;
                                                                                                                            let _246: <F as float::Float>::Int;
                                                                                                                            let _262: <F as float::Float>::Int;
                                                                                                                            scope 52 {
                                                                                                                                debug residual => _238;
                                                                                                                                debug written_exponent => _239;
                                                                                                                                let _271: <F as float::Float>::Int;
                                                                                                                                scope 55 {
                                                                                                                                    debug quotient => _271;
                                                                                                                                    let _276: <F as float::Float>::Int;
                                                                                                                                    let mut _278: <F as float::Float>::Int;
                                                                                                                                    let _291: <F as float::Float>::Int;
                                                                                                                                    scope 56 {
                                                                                                                                        debug abs_result => _276;
                                                                                                                                        let _310: <F as float::Float>::Int;
                                                                                                                                        scope 59 {
                                                                                                                                            debug abs_result => _310;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    scope 57 {
                                                                                                                                        debug ret => _278;
                                                                                                                                    }
                                                                                                                                    scope 58 {
                                                                                                                                        debug ret => _291;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            scope 53 {
                                                                                                                                debug residual_lo => _246;
                                                                                                                            }
                                                                                                                            scope 54 {
                                                                                                                                debug residual_lo => _262;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            scope 47 {
                                                                                                                debug iter => _201;
                                                                                                                let _205: u32;
                                                                                                                scope 48 {
                                                                                                                    debug corr_uq1 => _205;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        scope 31 {
                                                                                                            let mut _115: <F as float::Float>::Int;
                                                                                                            let _117: u16;
                                                                                                            let _191: <F as float::Float>::Int;
                                                                                                            scope 32 {
                                                                                                                debug b_uq1_hw => _117;
                                                                                                                let _126: u16;
                                                                                                                scope 33 {
                                                                                                                    debug c_hw => _126;
                                                                                                                    let _129: u16;
                                                                                                                    let mut _130: u16;
                                                                                                                    scope 34 {
                                                                                                                        debug x_uq0_hw => _129;
                                                                                                                        let _154: u32;
                                                                                                                        scope 39 {
                                                                                                                            debug blo => _154;
                                                                                                                            let _156: u32;
                                                                                                                            scope 40 {
                                                                                                                                debug corr_uq1 => _156;
                                                                                                                                let _170: u32;
                                                                                                                                scope 41 {
                                                                                                                                    debug lo_corr => _170;
                                                                                                                                    let _171: u32;
                                                                                                                                    scope 42 {
                                                                                                                                        debug hi_corr => _171;
                                                                                                                                        let mut _173: <F as float::Float>::Int;
                                                                                                                                        scope 43 {
                                                                                                                                            debug x_uq0 => _173;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    scope 35 {
                                                                                                                        debug x_uq0_hw => _130;
                                                                                                                        scope 36 {
                                                                                                                            let mut _133: rustc_std_workspace_core::ops::Range<usize>;
                                                                                                                            scope 37 {
                                                                                                                                debug iter => _133;
                                                                                                                                let _137: u16;
                                                                                                                                scope 38 {
                                                                                                                                    debug corr_uq1_hw => _137;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            scope 44 {
                                                                                                                debug c => _191;
                                                                                                                let _196: <F as float::Float>::Int;
                                                                                                                scope 45 {
                                                                                                                    debug x_uq0 => _196;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _6 = Eq(const 2_u32, const 0_u32);
        assert(!move _6, "attempt to divide `{}` by zero", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Div(const _, const 2_u32);
        _8 = Lt(_5, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Shr(const _, _5);
        _9 = const _;
        _10 = const _;
        _11 = const _;
        _12 = const _;
        _13 = const _;
        _14 = const _;
        _15 = <<F as Float>::Int as Sub>::sub(_14, _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = const _;
        _17 = _16;
        _19 = _12;
        _18 = <<F as Float>::Int as Shr<u32>>::shr(move _19, const 1_u32) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _20 = <<F as Float>::Int as BitOr>::bitor(_16, _18) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _21 = <F as Float>::repr(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _22 = <F as Float>::repr(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _24 = <<F as Float>::Int as Shr<u32>>::shr(_21, _9) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _25 = <u32 as CastInto<<F as Float>::Int>>::cast(_10) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _23 = <<F as Float>::Int as BitAnd>::bitand(move _24, move _25) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _27 = <<F as Float>::Int as Shr<u32>>::shr(_22, _9) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = <u32 as CastInto<<F as Float>::Int>>::cast(_10) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _26 = <<F as Float>::Int as BitAnd>::bitand(move _27, move _28) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _30 = <<F as Float>::Int as BitXor>::bitxor(_21, _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _29 = <<F as Float>::Int as BitAnd>::bitand(move _30, _14) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _31 = <<F as Float>::Int as BitAnd>::bitand(_21, _13) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _32 = <<F as Float>::Int as BitAnd>::bitand(_22, _13) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _33 = const 0_i32;
        _36 = <<F as Float>::Int as Int>::wrapping_sub(_23, _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _35 = &_36;
        _40 = CheckedSub(_10, const 1_u32);
        assert(!move (_40.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _39 = move (_40.0: u32);
        _38 = <u32 as CastInto<<F as Float>::Int>>::cast(move _39) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _37 = &_38;
        _34 = <<F as Float>::Int as PartialOrd>::ge(move _35, move _37) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _34) -> [0: bb22, otherwise: bb27];
    }

    bb22: {
        _43 = <<F as Float>::Int as Int>::wrapping_sub(_26, _3) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _42 = &_43;
        _47 = CheckedSub(_10, const 1_u32);
        assert(!move (_47.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_u32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _46 = move (_47.0: u32);
        _45 = <u32 as CastInto<<F as Float>::Int>>::cast(move _46) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _44 = &_45;
        _41 = <<F as Float>::Int as PartialOrd>::ge(move _42, move _44) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        switchInt(move _41) -> [0: bb67, otherwise: bb27];
    }

    bb27: {
        _48 = <<F as Float>::Int as BitAnd>::bitand(_21, _15) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _49 = <<F as Float>::Int as BitAnd>::bitand(_22, _15) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _51 = &_48;
        _52 = &_17;
        _50 = <<F as Float>::Int as PartialOrd>::gt(move _51, move _52) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _50) -> [0: bb33, otherwise: bb31];
    }

    bb31: {
        _53 = <<F as Float>::Int as BitOr>::bitor(_21, _18) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _0 = <F as Float>::from_repr(move _53) -> [return: bb203, unwind unreachable];
    }

    bb33: {
        _55 = &_49;
        _56 = &_17;
        _54 = <<F as Float>::Int as PartialOrd>::gt(move _55, move _56) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _54) -> [0: bb37, otherwise: bb35];
    }

    bb35: {
        _57 = <<F as Float>::Int as BitOr>::bitor(_22, _18) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _0 = <F as Float>::from_repr(move _57) -> [return: bb203, unwind unreachable];
    }

    bb37: {
        _59 = &_48;
        _60 = &_17;
        _58 = <<F as Float>::Int as PartialEq>::eq(move _59, move _60) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        switchInt(move _58) -> [0: bb44, otherwise: bb39];
    }

    bb39: {
        _62 = &_49;
        _63 = &_17;
        _61 = <<F as Float>::Int as PartialEq>::eq(move _62, move _63) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        switchInt(move _61) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _0 = <F as Float>::from_repr(_20) -> [return: bb203, unwind unreachable];
    }

    bb42: {
        _65 = _48;
        _64 = <<F as Float>::Int as BitOr>::bitor(move _65, _29) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _0 = <F as Float>::from_repr(move _64) -> [return: bb203, unwind unreachable];
    }

    bb44: {
        _67 = &_49;
        _68 = &_17;
        _66 = <<F as Float>::Int as PartialEq>::eq(move _67, move _68) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _66) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb203, unwind unreachable];
    }

    bb47: {
        _70 = &_48;
        _71 = &_4;
        _69 = <<F as Float>::Int as PartialEq>::eq(move _70, move _71) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        switchInt(move _69) -> [0: bb53, otherwise: bb49];
    }

    bb49: {
        _73 = &_49;
        _74 = &_4;
        _72 = <<F as Float>::Int as PartialEq>::eq(move _73, move _74) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        switchInt(move _72) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _0 = <F as Float>::from_repr(_20) -> [return: bb203, unwind unreachable];
    }

    bb52: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb203, unwind unreachable];
    }

    bb53: {
        _76 = &_49;
        _77 = &_4;
        _75 = <<F as Float>::Int as PartialEq>::eq(move _76, move _77) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        switchInt(move _75) -> [0: bb57, otherwise: bb55];
    }

    bb55: {
        _79 = _17;
        _78 = <<F as Float>::Int as BitOr>::bitor(move _79, _29) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        _0 = <F as Float>::from_repr(move _78) -> [return: bb203, unwind unreachable];
    }

    bb57: {
        _81 = &_48;
        _82 = &_12;
        _80 = <<F as Float>::Int as PartialOrd>::lt(move _81, move _82) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        switchInt(move _80) -> [0: bb62, otherwise: bb59];
    }

    bb59: {
        _86 = _31;
        _85 = <F as Float>::normalize(move _86) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _83 = (_85.0: i32);
        _84 = (_85.1: <F as float::Float>::Int);
        _87 = CheckedAdd(_33, _83);
        assert(!move (_87.1: bool), "attempt to compute `{} + {}`, which would overflow", _33, _83) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _33 = move (_87.0: i32);
        _31 = _84;
        goto -> bb62;
    }

    bb62: {
        _89 = &_49;
        _90 = &_12;
        _88 = <<F as Float>::Int as PartialOrd>::lt(move _89, move _90) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        switchInt(move _88) -> [0: bb67, otherwise: bb64];
    }

    bb64: {
        _94 = _32;
        _93 = <F as Float>::normalize(move _94) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _91 = (_93.0: i32);
        _92 = (_93.1: <F as float::Float>::Int);
        _95 = CheckedSub(_33, _91);
        assert(!move (_95.1: bool), "attempt to compute `{} - {}`, which would overflow", _33, _91) -> [success: bb66, unwind unreachable];
    }

    bb66: {
        _33 = move (_95.0: i32);
        _32 = _92;
        goto -> bb67;
    }

    bb67: {
        _97 = &mut _31;
        _98 = _12;
        _96 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _97, move _98) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _100 = &mut _32;
        _101 = _12;
        _99 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _100, move _101) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        _106 = <<F as Float>::Int as Int>::wrapping_sub(_23, _26) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _108 = _33;
        _107 = <i32 as CastInto<<F as Float>::Int>>::cast(move _108) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _105 = <<F as Float>::Int as Int>::wrapping_add(move _106, move _107) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _104 = <<F as Float>::Int as CastInto<u32>>::cast(move _105) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        _103 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _104, _11) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _102 = move _103 as i32 (IntToInt);
        _110 = _32;
        _113 = CheckedSub(const _, _9);
        assert(!move (_113.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, _9) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _112 = move (_113.0: u32);
        _114 = CheckedSub(_112, const 1_u32);
        assert(!move (_114.1: bool), "attempt to compute `{} - {}`, which would overflow", move _112, const 1_u32) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _111 = move (_114.0: u32);
        _109 = <<F as Float>::Int as Shl<u32>>::shl(move _110, move _111) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        _116 = Gt(const _, const 0_usize);
        switchInt(move _116) -> [0: bb116, otherwise: bb78];
    }

    bb78: {
        _120 = _32;
        _119 = <<F as Float>::Int as CastInto<u32>>::cast(move _120) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _123 = CheckedAdd(_9, const 1_u32);
        assert(!move (_123.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_u32) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _122 = move (_123.0: u32);
        _124 = CheckedSub(_122, _5);
        assert(!move (_124.1: bool), "attempt to compute `{} - {}`, which would overflow", move _122, _5) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _121 = move (_124.0: u32);
        _125 = Lt(_121, const 32_u32);
        assert(move _125, "attempt to shift right by `{}`, which would overflow", _121) -> [success: bb82, unwind unreachable];
    }

    bb82: {
        _118 = Shr(move _119, move _121);
        _117 = move _118 as u16 (IntToInt);
        _127 = const 29956_u32 as u16 (IntToInt);
        _128 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_5, const 32_u32) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _126 = rustc_std_workspace_core::num::<impl u16>::wrapping_shl(move _127, move _128) -> [return: bb84, unwind unreachable];
    }

    bb84: {
        _130 = rustc_std_workspace_core::num::<impl u16>::wrapping_sub(_126, _117) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        _132 = Range::<usize> { start: const 0_usize, end: const _ };
        _131 = <Range<usize> as IntoIterator>::into_iter(move _132) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _133 = move _131;
        goto -> bb87;
    }

    bb87: {
        _135 = &mut _133;
        _134 = <Range<usize> as Iterator>::next(_135) -> [return: bb88, unwind unreachable];
    }

    bb88: {
        _136 = discriminant(_134);
        switchInt(move _136) -> [0: bb90, 1: bb89, otherwise: bb204];
    }

    bb89: {
        _142 = _130;
        _141 = move _142 as u32 (IntToInt);
        _143 = <u16 as CastInto<u32>>::cast(_117) -> [return: bb91, unwind unreachable];
    }

    bb90: {
        _153 = _130;
        _129 = rustc_std_workspace_core::num::<impl u16>::wrapping_sub(move _153, const 1_u16) -> [return: bb98, unwind unreachable];
    }

    bb91: {
        _140 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _141, move _143) -> [return: bb92, unwind unreachable];
    }

    bb92: {
        _144 = Lt(_5, const 32_u32);
        assert(move _144, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _139 = Shr(move _140, _5);
        _138 = <u32 as Int>::wrapping_sub(const 0_u32, move _139) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _137 = move _138 as u16 (IntToInt);
        _148 = _130;
        _147 = move _148 as u32 (IntToInt);
        _149 = _137 as u32 (IntToInt);
        _146 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _147, move _149) -> [return: bb95, unwind unreachable];
    }

    bb95: {
        _151 = CheckedSub(_5, const 1_u32);
        assert(!move (_151.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _150 = move (_151.0: u32);
        _152 = Lt(_150, const 32_u32);
        assert(move _152, "attempt to shift right by `{}`, which would overflow", _150) -> [success: bb97, unwind unreachable];
    }

    bb97: {
        _145 = Shr(move _146, move _150);
        _130 = move _145 as u16 (IntToInt);
        goto -> bb87;
    }

    bb98: {
        _155 = <<F as Float>::Int as CastInto<u32>>::cast(_109) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _154 = BitAnd(move _155, _7);
        _160 = _129 as u32 (IntToInt);
        _161 = _117 as u32 (IntToInt);
        _162 = CheckedMul(_160, _161);
        assert(!move (_162.1: bool), "attempt to compute `{} * {}`, which would overflow", move _160, move _161) -> [success: bb100, unwind unreachable];
    }

    bb100: {
        _159 = move (_162.0: u32);
        _165 = _129 as u32 (IntToInt);
        _166 = CheckedMul(_165, _154);
        assert(!move (_166.1: bool), "attempt to compute `{} * {}`, which would overflow", move _165, _154) -> [success: bb101, unwind unreachable];
    }

    bb101: {
        _164 = move (_166.0: u32);
        _167 = Lt(_5, const 32_u32);
        assert(move _167, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb102, unwind unreachable];
    }

    bb102: {
        _163 = Shr(move _164, _5);
        _168 = CheckedAdd(_159, _163);
        assert(!move (_168.1: bool), "attempt to compute `{} + {}`, which would overflow", move _159, move _163) -> [success: bb103, unwind unreachable];
    }

    bb103: {
        _158 = move (_168.0: u32);
        _169 = CheckedSub(_158, const 1_u32);
        assert(!move (_169.1: bool), "attempt to compute `{} - {}`, which would overflow", move _158, const 1_u32) -> [success: bb104, unwind unreachable];
    }

    bb104: {
        _157 = move (_169.0: u32);
        _156 = negate_u32(move _157) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _170 = BitAnd(_156, _7);
        _172 = Lt(_5, const 32_u32);
        assert(move _172, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb106, unwind unreachable];
    }

    bb106: {
        _171 = Shr(_156, _5);
        _178 = _129 as u32 (IntToInt);
        _179 = CheckedMul(_178, _171);
        assert(!move (_179.1: bool), "attempt to compute `{} * {}`, which would overflow", move _178, _171) -> [success: bb107, unwind unreachable];
    }

    bb107: {
        _177 = move (_179.0: u32);
        _180 = const 1_i32 as u32 (IntToInt);
        _181 = Lt(move _180, const 32_u32);
        assert(move _181, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb108, unwind unreachable];
    }

    bb108: {
        _176 = Shl(move _177, const 1_i32);
        _184 = _129 as u32 (IntToInt);
        _185 = CheckedMul(_184, _170);
        assert(!move (_185.1: bool), "attempt to compute `{} * {}`, which would overflow", move _184, _170) -> [success: bb109, unwind unreachable];
    }

    bb109: {
        _183 = move (_185.0: u32);
        _187 = CheckedSub(_5, const 1_u32);
        assert(!move (_187.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb110, unwind unreachable];
    }

    bb110: {
        _186 = move (_187.0: u32);
        _188 = Lt(_186, const 32_u32);
        assert(move _188, "attempt to shift right by `{}`, which would overflow", _186) -> [success: bb111, unwind unreachable];
    }

    bb111: {
        _182 = Shr(move _183, move _186);
        _175 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _176, move _182) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        _174 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _175, const 2_u32) -> [return: bb113, unwind unreachable];
    }

    bb113: {
        _173 = <u32 as CastInto<<F as Float>::Int>>::cast(move _174) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _190 = &mut _173;
        _189 = <<F as Float>::Int as SubAssign>::sub_assign(move _190, _3) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _115 = _173;
        goto -> bb121;
    }

    bb116: {
        _194 = CheckedSub(const _, const 32_u32);
        assert(!move (_194.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 32_u32) -> [success: bb117, unwind unreachable];
    }

    bb117: {
        _193 = move (_194.0: u32);
        _195 = Lt(_193, const 32_u32);
        assert(move _195, "attempt to shift left by `{}`, which would overflow", _193) -> [success: bb118, unwind unreachable];
    }

    bb118: {
        _192 = Shl(const 1963258675_i32, move _193);
        _191 = <i32 as CastInto<<F as Float>::Int>>::cast(move _192) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _196 = <<F as Float>::Int as Int>::wrapping_sub(_191, _109) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _115 = _196;
        goto -> bb121;
    }

    bb121: {
        _198 = const _;
        switchInt(move _198) -> [0: bb138, otherwise: bb122];
    }

    bb122: {
        _200 = Range::<usize> { start: const 0_usize, end: const _ };
        _199 = <Range<usize> as IntoIterator>::into_iter(move _200) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        _201 = move _199;
        goto -> bb124;
    }

    bb124: {
        _203 = &mut _201;
        _202 = <Range<usize> as Iterator>::next(_203) -> [return: bb125, unwind unreachable];
    }

    bb125: {
        _204 = discriminant(_202);
        switchInt(move _204) -> [0: bb127, 1: bb126, otherwise: bb204];
    }

    bb126: {
        _211 = _115;
        _210 = <<F as Float>::Int as CastInto<u32>>::cast(move _211) -> [return: bb128, unwind unreachable];
    }

    bb127: {
        _197 = _115;
        goto -> bb139;
    }

    bb128: {
        _209 = move _210 as u64 (IntToInt);
        _213 = <<F as Float>::Int as CastInto<u32>>::cast(_109) -> [return: bb129, unwind unreachable];
    }

    bb129: {
        _212 = move _213 as u64 (IntToInt);
        _214 = CheckedMul(_209, _212);
        assert(!move (_214.1: bool), "attempt to compute `{} * {}`, which would overflow", move _209, move _212) -> [success: bb130, unwind unreachable];
    }

    bb130: {
        _208 = move (_214.0: u64);
        _215 = Lt(const _, const 64_u32);
        assert(move _215, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb131, unwind unreachable];
    }

    bb131: {
        _207 = Shr(move _208, const _);
        _206 = <u64 as Int>::wrapping_sub(const 0_u64, move _207) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _205 = move _206 as u32 (IntToInt);
        _222 = _115;
        _221 = <<F as Float>::Int as CastInto<u32>>::cast(move _222) -> [return: bb133, unwind unreachable];
    }

    bb133: {
        _220 = move _221 as u64 (IntToInt);
        _223 = _205 as u64 (IntToInt);
        _224 = CheckedMul(_220, _223);
        assert(!move (_224.1: bool), "attempt to compute `{} * {}`, which would overflow", move _220, move _223) -> [success: bb134, unwind unreachable];
    }

    bb134: {
        _219 = move (_224.0: u64);
        _226 = CheckedSub(const _, const 1_u32);
        assert(!move (_226.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb135, unwind unreachable];
    }

    bb135: {
        _225 = move (_226.0: u32);
        _227 = Lt(_225, const 64_u32);
        assert(move _227, "attempt to shift right by `{}`, which would overflow", _225) -> [success: bb136, unwind unreachable];
    }

    bb136: {
        _218 = Shr(move _219, move _225);
        _217 = move _218 as u32 (IntToInt);
        _216 = <u32 as CastInto<<F as Float>::Int>>::cast(move _217) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _115 = move _216;
        goto -> bb124;
    }

    bb138: {
        _197 = _115;
        goto -> bb139;
    }

    bb139: {
        _229 = _197;
        _230 = <i32 as CastInto<<F as Float>::Int>>::cast(const 2_i32) -> [return: bb140, unwind unreachable];
    }

    bb140: {
        _228 = <<F as Float>::Int as Int>::wrapping_sub(move _229, move _230) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _197 = move _228;
        _231 = <i32 as CastInto<<F as Float>::Int>>::cast(const 10_i32) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _233 = _197;
        _232 = <<F as Float>::Int as Sub>::sub(move _233, _231) -> [return: bb143, unwind unreachable];
    }

    bb143: {
        _237 = _31;
        _236 = <<F as Float>::Int as Shl<u32>>::shl(move _237, const 1_u32) -> [return: bb144, unwind unreachable];
    }

    bb144: {
        _235 = <<F as Float>::Int as HInt>::widen_mul(_232, move _236) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        _234 = <<<F as Float>::Int as HInt>::D as DInt>::hi(move _235) -> [return: bb146, unwind unreachable];
    }

    bb146: {
        _242 = &_234;
        _245 = _12;
        _244 = <<F as Float>::Int as Shl<u32>>::shl(move _245, const 1_u32) -> [return: bb147, unwind unreachable];
    }

    bb147: {
        _243 = &_244;
        _241 = <<F as Float>::Int as PartialOrd>::lt(move _242, move _243) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        switchInt(move _241) -> [0: bb159, otherwise: bb149];
    }

    bb149: {
        _248 = _31;
        _250 = CheckedAdd(_9, const 1_u32);
        assert(!move (_250.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_u32) -> [success: bb150, unwind unreachable];
    }

    bb150: {
        _249 = move (_250.0: u32);
        _247 = <<F as Float>::Int as Shl<u32>>::shl(move _248, move _249) -> [return: bb151, unwind unreachable];
    }

    bb151: {
        _254 = _234;
        _253 = <<F as Float>::Int as CastInto<u32>>::cast(move _254) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _256 = _32;
        _255 = <<F as Float>::Int as CastInto<u32>>::cast(move _256) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _252 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _253, move _255) -> [return: bb154, unwind unreachable];
    }

    bb154: {
        _251 = <u32 as CastInto<<F as Float>::Int>>::cast(move _252) -> [return: bb155, unwind unreachable];
    }

    bb155: {
        _246 = <<F as Float>::Int as Int>::wrapping_sub(move _247, move _251) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        _258 = &mut _31;
        _257 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _258, const 1_i32) -> [return: bb157, unwind unreachable];
    }

    bb157: {
        _259 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(_102, const 1_i32) -> [return: bb158, unwind unreachable];
    }

    bb158: {
        _240 = (_246, move _259);
        goto -> bb167;
    }

    bb159: {
        _261 = &mut _234;
        _260 = <<F as Float>::Int as ShrAssign<u32>>::shr_assign(move _261, const 1_u32) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _264 = _31;
        _263 = <<F as Float>::Int as Shl<u32>>::shl(move _264, _9) -> [return: bb161, unwind unreachable];
    }

    bb161: {
        _268 = _234;
        _267 = <<F as Float>::Int as CastInto<u32>>::cast(move _268) -> [return: bb162, unwind unreachable];
    }

    bb162: {
        _270 = _32;
        _269 = <<F as Float>::Int as CastInto<u32>>::cast(move _270) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _266 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _267, move _269) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _265 = <u32 as CastInto<<F as Float>::Int>>::cast(move _266) -> [return: bb165, unwind unreachable];
    }

    bb165: {
        _262 = <<F as Float>::Int as Int>::wrapping_sub(move _263, move _265) -> [return: bb166, unwind unreachable];
    }

    bb166: {
        _240 = (_262, _102);
        goto -> bb167;
    }

    bb167: {
        _238 = (_240.0: <F as float::Float>::Int);
        _239 = (_240.1: i32);
        _271 = _234;
        _273 = _10 as i32 (IntToInt);
        _272 = Ge(_239, move _273);
        switchInt(move _272) -> [0: bb170, otherwise: bb168];
    }

    bb168: {
        _275 = _17;
        _274 = <<F as Float>::Int as BitOr>::bitor(move _275, _29) -> [return: bb169, unwind unreachable];
    }

    bb169: {
        _0 = <F as Float>::from_repr(move _274) -> [return: bb203, unwind unreachable];
    }

    bb170: {
        _277 = Gt(_239, const 0_i32);
        switchInt(move _277) -> [0: bb172, otherwise: bb171];
    }

    bb171: {
        _278 = <<F as Float>::Int as BitAnd>::bitand(_271, _13) -> [return: bb173, unwind unreachable];
    }

    bb172: {
        _289 = _9 as i32 (IntToInt);
        _290 = CheckedAdd(_289, _239);
        assert(!move (_290.1: bool), "attempt to compute `{} + {}`, which would overflow", move _289, _239) -> [success: bb178, unwind unreachable];
    }

    bb173: {
        _280 = &mut _278;
        _283 = _239 as u32 (IntToInt);
        _284 = Lt(_9, const 32_u32);
        assert(move _284, "attempt to shift left by `{}`, which would overflow", _9) -> [success: bb174, unwind unreachable];
    }

    bb174: {
        _282 = Shl(move _283, _9);
        _281 = <u32 as CastInto<<F as Float>::Int>>::cast(move _282) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _279 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _280, move _281) -> [return: bb176, unwind unreachable];
    }

    bb176: {
        _286 = &mut _238;
        _285 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _286, const 1_i32) -> [return: bb177, unwind unreachable];
    }

    bb177: {
        _276 = _278;
        goto -> bb195;
    }

    bb178: {
        _288 = move (_290.0: i32);
        _287 = Lt(move _288, const 0_i32);
        switchInt(move _287) -> [0: bb180, otherwise: bb179];
    }

    bb179: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb203, unwind unreachable];
    }

    bb180: {
        _294 = <i32 as CastInto<u32>>::cast(_239) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _293 = negate_u32(move _294) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _295 = CheckedAdd(_293, const 1_u32);
        assert(!move (_295.1: bool), "attempt to compute `{} + {}`, which would overflow", move _293, const 1_u32) -> [success: bb183, unwind unreachable];
    }

    bb183: {
        _292 = move (_295.0: u32);
        _291 = <<F as Float>::Int as Int>::wrapping_shr(_271, move _292) -> [return: bb184, unwind unreachable];
    }

    bb184: {
        _300 = _31;
        _302 = <i32 as CastInto<u32>>::cast(_239) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _301 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(_9, move _302) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _299 = <<F as Float>::Int as Int>::wrapping_shl(move _300, move _301) -> [return: bb187, unwind unreachable];
    }

    bb187: {
        _298 = <<F as Float>::Int as CastInto<u32>>::cast(move _299) -> [return: bb188, unwind unreachable];
    }

    bb188: {
        _305 = <<F as Float>::Int as CastInto<u32>>::cast(_291) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        _307 = _32;
        _306 = <<F as Float>::Int as CastInto<u32>>::cast(move _307) -> [return: bb190, unwind unreachable];
    }

    bb190: {
        _304 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _305, move _306) -> [return: bb191, unwind unreachable];
    }

    bb191: {
        _308 = const 1_i32 as u32 (IntToInt);
        _309 = Lt(move _308, const 32_u32);
        assert(move _309, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb192, unwind unreachable];
    }

    bb192: {
        _303 = Shl(move _304, const 1_i32);
        _297 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _298, move _303) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _296 = <u32 as CastInto<<F as Float>::Int>>::cast(move _297) -> [return: bb194, unwind unreachable];
    }

    bb194: {
        _238 = move _296;
        _276 = _291;
        goto -> bb195;
    }

    bb195: {
        _312 = &mut _238;
        _314 = _276;
        _313 = <<F as Float>::Int as BitAnd>::bitand(move _314, _3) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _311 = <<F as Float>::Int as AddAssign>::add_assign(move _312, move _313) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        _316 = &_238;
        _317 = &_32;
        _315 = <<F as Float>::Int as PartialOrd>::gt(move _316, move _317) -> [return: bb198, unwind unreachable];
    }

    bb198: {
        switchInt(move _315) -> [0: bb200, otherwise: bb199];
    }

    bb199: {
        _318 = _276;
        _310 = <<F as Float>::Int as Add>::add(move _318, _3) -> [return: bb201, unwind unreachable];
    }

    bb200: {
        _310 = _276;
        goto -> bb201;
    }

    bb201: {
        _320 = _310;
        _319 = <<F as Float>::Int as BitOr>::bitor(move _320, _29) -> [return: bb202, unwind unreachable];
    }

    bb202: {
        _0 = <F as Float>::from_repr(move _319) -> [return: bb203, unwind unreachable];
    }

    bb203: {
        return;
    }

    bb204: {
        unreachable;
    }
}

const div32::NUMBER_OF_HALF_ITERATIONS: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

const div32::NUMBER_OF_FULL_ITERATIONS: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

const div32::USE_NATIVE_FULL_ITERATIONS: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn negate_u32(_1: u32) -> u32 {
    debug a => _1;
    let mut _0: u32;
    let mut _2: i32;
    let mut _3: i32;

    bb0: {
        _3 = _1 as i32 (IntToInt);
        _2 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as u32 (IntToInt);
        return;
    }
}

fn div64(_1: F, _2: F) -> F {
    debug a => _1;
    debug b => _2;
    let mut _0: F;
    let _3: <F as float::Float>::Int;
    let mut _6: bool;
    let mut _8: bool;
    let mut _14: <F as float::Float>::Int;
    let mut _19: <F as float::Float>::Int;
    let mut _24: <F as float::Float>::Int;
    let mut _25: <F as float::Float>::Int;
    let mut _27: <F as float::Float>::Int;
    let mut _28: <F as float::Float>::Int;
    let mut _30: <F as float::Float>::Int;
    let mut _34: bool;
    let mut _35: &<F as float::Float>::Int;
    let _36: <F as float::Float>::Int;
    let mut _37: &<F as float::Float>::Int;
    let _38: <F as float::Float>::Int;
    let mut _39: u32;
    let mut _40: (u32, bool);
    let mut _41: bool;
    let mut _42: &<F as float::Float>::Int;
    let _43: <F as float::Float>::Int;
    let mut _44: &<F as float::Float>::Int;
    let _45: <F as float::Float>::Int;
    let mut _46: u32;
    let mut _47: (u32, bool);
    let mut _50: bool;
    let mut _51: &<F as float::Float>::Int;
    let mut _52: &<F as float::Float>::Int;
    let mut _53: <F as float::Float>::Int;
    let mut _54: bool;
    let mut _55: &<F as float::Float>::Int;
    let mut _56: &<F as float::Float>::Int;
    let mut _57: <F as float::Float>::Int;
    let mut _58: bool;
    let mut _59: &<F as float::Float>::Int;
    let mut _60: &<F as float::Float>::Int;
    let mut _61: bool;
    let mut _62: &<F as float::Float>::Int;
    let mut _63: &<F as float::Float>::Int;
    let mut _64: <F as float::Float>::Int;
    let mut _65: <F as float::Float>::Int;
    let mut _66: bool;
    let mut _67: &<F as float::Float>::Int;
    let mut _68: &<F as float::Float>::Int;
    let mut _69: bool;
    let mut _70: &<F as float::Float>::Int;
    let mut _71: &<F as float::Float>::Int;
    let mut _72: bool;
    let mut _73: &<F as float::Float>::Int;
    let mut _74: &<F as float::Float>::Int;
    let mut _75: bool;
    let mut _76: &<F as float::Float>::Int;
    let mut _77: &<F as float::Float>::Int;
    let mut _78: <F as float::Float>::Int;
    let mut _79: <F as float::Float>::Int;
    let mut _80: bool;
    let mut _81: &<F as float::Float>::Int;
    let mut _82: &<F as float::Float>::Int;
    let mut _85: (i32, <F as float::Float>::Int);
    let mut _86: <F as float::Float>::Int;
    let mut _87: (i32, bool);
    let mut _88: bool;
    let mut _89: &<F as float::Float>::Int;
    let mut _90: &<F as float::Float>::Int;
    let mut _93: (i32, <F as float::Float>::Int);
    let mut _94: <F as float::Float>::Int;
    let mut _95: (i32, bool);
    let _96: ();
    let mut _97: &mut <F as float::Float>::Int;
    let mut _98: <F as float::Float>::Int;
    let _99: ();
    let mut _100: &mut <F as float::Float>::Int;
    let mut _101: <F as float::Float>::Int;
    let mut _103: u64;
    let mut _104: u64;
    let mut _105: <F as float::Float>::Int;
    let mut _106: <F as float::Float>::Int;
    let mut _107: <F as float::Float>::Int;
    let mut _108: i32;
    let mut _109: u64;
    let mut _111: <F as float::Float>::Int;
    let mut _112: u32;
    let mut _113: u32;
    let mut _114: (u32, bool);
    let mut _115: (u32, bool);
    let mut _117: bool;
    let mut _119: u64;
    let mut _120: u64;
    let mut _121: <F as float::Float>::Int;
    let mut _122: u32;
    let mut _123: u32;
    let mut _124: (u32, bool);
    let mut _125: (u32, bool);
    let mut _126: bool;
    let mut _128: u32;
    let mut _129: u32;
    let mut _132: rustc_std_workspace_core::ops::Range<usize>;
    let mut _133: rustc_std_workspace_core::ops::Range<usize>;
    let mut _135: rustc_std_workspace_core::option::Option<usize>;
    let mut _136: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _137: isize;
    let mut _139: u64;
    let mut _140: u64;
    let mut _141: u64;
    let mut _142: u64;
    let mut _143: u32;
    let mut _144: u64;
    let mut _145: bool;
    let mut _146: u64;
    let mut _147: u64;
    let mut _148: u64;
    let mut _149: u32;
    let mut _150: u64;
    let mut _151: u32;
    let mut _152: (u32, bool);
    let mut _153: bool;
    let mut _154: u32;
    let mut _156: u64;
    let mut _158: u64;
    let mut _159: u64;
    let mut _160: u64;
    let mut _161: u64;
    let mut _162: u64;
    let mut _163: (u64, bool);
    let mut _164: u64;
    let mut _165: u64;
    let mut _166: u64;
    let mut _167: (u64, bool);
    let mut _168: bool;
    let mut _169: (u64, bool);
    let mut _170: (u64, bool);
    let mut _173: bool;
    let mut _175: u64;
    let mut _176: u64;
    let mut _177: u64;
    let mut _178: u64;
    let mut _179: u64;
    let mut _180: (u64, bool);
    let mut _181: u32;
    let mut _182: bool;
    let mut _183: u64;
    let mut _184: u64;
    let mut _185: u64;
    let mut _186: (u64, bool);
    let mut _187: u32;
    let mut _188: (u32, bool);
    let mut _189: bool;
    let _190: ();
    let mut _191: &mut <F as float::Float>::Int;
    let mut _193: i32;
    let mut _194: u32;
    let mut _195: (u32, bool);
    let mut _196: bool;
    let mut _199: bool;
    let mut _200: rustc_std_workspace_core::ops::Range<usize>;
    let mut _201: rustc_std_workspace_core::ops::Range<usize>;
    let mut _203: rustc_std_workspace_core::option::Option<usize>;
    let mut _204: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _205: isize;
    let mut _207: u64;
    let mut _208: u64;
    let mut _209: u64;
    let mut _210: <F as float::Float>::Int;
    let mut _211: u64;
    let mut _212: (u64, bool);
    let mut _213: bool;
    let mut _214: <F as float::Float>::Int;
    let mut _215: u64;
    let mut _216: u128;
    let mut _217: u128;
    let mut _218: u128;
    let mut _219: u64;
    let mut _220: <F as float::Float>::Int;
    let mut _221: u128;
    let mut _222: (u128, bool);
    let mut _223: u32;
    let mut _224: (u32, bool);
    let mut _225: bool;
    let mut _226: <F as float::Float>::Int;
    let mut _227: <F as float::Float>::Int;
    let mut _228: <F as float::Float>::Int;
    let mut _231: <F as float::Float>::Int;
    let mut _233: <<F as float::Float>::Int as int::HInt>::D;
    let mut _234: <F as float::Float>::Int;
    let mut _235: <F as float::Float>::Int;
    let mut _238: (<F as float::Float>::Int, i64);
    let mut _239: bool;
    let mut _240: &<F as float::Float>::Int;
    let mut _241: &<F as float::Float>::Int;
    let _242: <F as float::Float>::Int;
    let mut _243: <F as float::Float>::Int;
    let mut _245: <F as float::Float>::Int;
    let mut _246: <F as float::Float>::Int;
    let mut _247: u32;
    let mut _248: (u32, bool);
    let mut _249: <F as float::Float>::Int;
    let mut _250: u64;
    let mut _251: u64;
    let mut _252: <F as float::Float>::Int;
    let mut _253: u64;
    let mut _254: <F as float::Float>::Int;
    let _255: ();
    let mut _256: &mut <F as float::Float>::Int;
    let mut _257: i64;
    let _258: ();
    let mut _259: &mut <F as float::Float>::Int;
    let mut _261: <F as float::Float>::Int;
    let mut _262: <F as float::Float>::Int;
    let mut _263: <F as float::Float>::Int;
    let mut _264: u64;
    let mut _265: u64;
    let mut _266: <F as float::Float>::Int;
    let mut _267: u64;
    let mut _268: <F as float::Float>::Int;
    let mut _270: bool;
    let mut _271: i64;
    let mut _272: <F as float::Float>::Int;
    let mut _273: <F as float::Float>::Int;
    let mut _275: bool;
    let _277: ();
    let mut _278: &mut <F as float::Float>::Int;
    let mut _279: <F as float::Float>::Int;
    let mut _280: u64;
    let mut _281: u64;
    let mut _282: bool;
    let _283: ();
    let mut _284: &mut <F as float::Float>::Int;
    let mut _285: bool;
    let mut _286: i64;
    let mut _287: i64;
    let mut _288: (i64, bool);
    let mut _290: u32;
    let mut _291: u64;
    let mut _292: u64;
    let mut _293: u64;
    let mut _294: (u64, bool);
    let mut _295: <F as float::Float>::Int;
    let mut _296: u64;
    let mut _297: u64;
    let mut _298: <F as float::Float>::Int;
    let mut _299: <F as float::Float>::Int;
    let mut _300: u32;
    let mut _301: u32;
    let mut _302: u64;
    let mut _303: u64;
    let mut _304: u64;
    let mut _305: u64;
    let mut _306: <F as float::Float>::Int;
    let mut _307: u32;
    let mut _308: bool;
    let _310: ();
    let mut _311: &mut <F as float::Float>::Int;
    let mut _312: <F as float::Float>::Int;
    let mut _313: <F as float::Float>::Int;
    let mut _314: bool;
    let mut _315: &<F as float::Float>::Int;
    let mut _316: &<F as float::Float>::Int;
    let mut _317: <F as float::Float>::Int;
    let mut _318: <F as float::Float>::Int;
    let mut _319: <F as float::Float>::Int;
    scope 1 {
        debug one => const _;
        let _4: <F as float::Float>::Int;
        scope 2 {
            debug zero => const _;
            let _5: u32;
            scope 3 {
                debug hw => _5;
                let _7: u64;
                scope 4 {
                    debug lo_mask => _7;
                    let _9: u32;
                    scope 5 {
                        debug significand_bits => const _;
                        let _10: u32;
                        scope 6 {
                            debug max_exponent => const _;
                            let _11: u32;
                            scope 7 {
                                debug exponent_bias => const _;
                                let _12: <F as float::Float>::Int;
                                scope 8 {
                                    debug implicit_bit => const _;
                                    let _13: <F as float::Float>::Int;
                                    scope 9 {
                                        debug significand_mask => const _;
                                        scope 10 {
                                            debug sign_bit => const _;
                                            let _15: <F as float::Float>::Int;
                                            scope 11 {
                                                debug abs_mask => _15;
                                                let _16: <F as float::Float>::Int;
                                                scope 12 {
                                                    debug exponent_mask => const _;
                                                    let _17: <F as float::Float>::Int;
                                                    scope 13 {
                                                        debug inf_rep => _17;
                                                        let _18: <F as float::Float>::Int;
                                                        scope 14 {
                                                            debug quiet_bit => _18;
                                                            let _20: <F as float::Float>::Int;
                                                            scope 15 {
                                                                debug qnan_rep => _20;
                                                                let _21: <F as float::Float>::Int;
                                                                scope 16 {
                                                                    debug a_rep => _21;
                                                                    let _22: <F as float::Float>::Int;
                                                                    scope 17 {
                                                                        debug b_rep => _22;
                                                                        let _23: <F as float::Float>::Int;
                                                                        scope 18 {
                                                                            debug a_exponent => _23;
                                                                            let _26: <F as float::Float>::Int;
                                                                            scope 19 {
                                                                                debug b_exponent => _26;
                                                                                let _29: <F as float::Float>::Int;
                                                                                scope 20 {
                                                                                    debug quotient_sign => _29;
                                                                                    let mut _31: <F as float::Float>::Int;
                                                                                    scope 21 {
                                                                                        debug a_significand => _31;
                                                                                        let mut _32: <F as float::Float>::Int;
                                                                                        scope 22 {
                                                                                            debug b_significand => _32;
                                                                                            let mut _33: i32;
                                                                                            scope 23 {
                                                                                                debug scale => _33;
                                                                                                let _48: <F as float::Float>::Int;
                                                                                                let _102: i64;
                                                                                                scope 24 {
                                                                                                    debug a_abs => _48;
                                                                                                    let _49: <F as float::Float>::Int;
                                                                                                    scope 25 {
                                                                                                        debug b_abs => _49;
                                                                                                        let _83: i32;
                                                                                                        let _84: <F as float::Float>::Int;
                                                                                                        let _91: i32;
                                                                                                        let _92: <F as float::Float>::Int;
                                                                                                        scope 26 {
                                                                                                            debug exponent => _83;
                                                                                                            debug significand => _84;
                                                                                                        }
                                                                                                        scope 27 {
                                                                                                            debug exponent => _91;
                                                                                                            debug significand => _92;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                scope 28 {
                                                                                                    debug written_exponent => _102;
                                                                                                    let _110: <F as float::Float>::Int;
                                                                                                    scope 29 {
                                                                                                        debug b_uq1 => _110;
                                                                                                        let mut _116: <F as float::Float>::Int;
                                                                                                        let _118: u32;
                                                                                                        let _192: <F as float::Float>::Int;
                                                                                                        scope 30 {
                                                                                                            debug x_uq0 => _116;
                                                                                                            let mut _198: <F as float::Float>::Int;
                                                                                                            let mut _202: rustc_std_workspace_core::ops::Range<usize>;
                                                                                                            scope 44 {
                                                                                                                debug x_uq0 => _198;
                                                                                                                let _229: <F as float::Float>::Int;
                                                                                                                scope 47 {
                                                                                                                    debug reciprocal_precision => _229;
                                                                                                                    let _230: <F as float::Float>::Int;
                                                                                                                    scope 48 {
                                                                                                                        debug x_uq0 => _230;
                                                                                                                        let mut _232: <F as float::Float>::Int;
                                                                                                                        scope 49 {
                                                                                                                            debug quotient => _232;
                                                                                                                            let mut _236: <F as float::Float>::Int;
                                                                                                                            let _237: i64;
                                                                                                                            let _244: <F as float::Float>::Int;
                                                                                                                            let _260: <F as float::Float>::Int;
                                                                                                                            scope 50 {
                                                                                                                                debug residual => _236;
                                                                                                                                debug written_exponent => _237;
                                                                                                                                let _269: <F as float::Float>::Int;
                                                                                                                                scope 53 {
                                                                                                                                    debug quotient => _269;
                                                                                                                                    let _274: <F as float::Float>::Int;
                                                                                                                                    let mut _276: <F as float::Float>::Int;
                                                                                                                                    let _289: <F as float::Float>::Int;
                                                                                                                                    scope 54 {
                                                                                                                                        debug abs_result => _274;
                                                                                                                                        let _309: <F as float::Float>::Int;
                                                                                                                                        scope 57 {
                                                                                                                                            debug abs_result => _309;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    scope 55 {
                                                                                                                                        debug ret => _276;
                                                                                                                                    }
                                                                                                                                    scope 56 {
                                                                                                                                        debug ret => _289;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                            scope 51 {
                                                                                                                                debug residual_lo => _244;
                                                                                                                            }
                                                                                                                            scope 52 {
                                                                                                                                debug residual_lo => _260;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            scope 45 {
                                                                                                                debug iter => _202;
                                                                                                                let _206: u64;
                                                                                                                scope 46 {
                                                                                                                    debug corr_uq1 => _206;
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        scope 31 {
                                                                                                            debug b_uq1_hw => _118;
                                                                                                            let _127: u32;
                                                                                                            scope 32 {
                                                                                                                debug c_hw => _127;
                                                                                                                let _130: u32;
                                                                                                                let mut _131: u32;
                                                                                                                scope 33 {
                                                                                                                    debug x_uq0_hw => _130;
                                                                                                                    let _155: u64;
                                                                                                                    scope 37 {
                                                                                                                        debug blo => _155;
                                                                                                                        let _157: u64;
                                                                                                                        scope 38 {
                                                                                                                            debug corr_uq1 => _157;
                                                                                                                            let _171: u64;
                                                                                                                            scope 39 {
                                                                                                                                debug lo_corr => _171;
                                                                                                                                let _172: u64;
                                                                                                                                scope 40 {
                                                                                                                                    debug hi_corr => _172;
                                                                                                                                    let mut _174: <F as float::Float>::Int;
                                                                                                                                    scope 41 {
                                                                                                                                        debug x_uq0 => _174;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                                scope 34 {
                                                                                                                    debug x_uq0_hw => _131;
                                                                                                                    let mut _134: rustc_std_workspace_core::ops::Range<usize>;
                                                                                                                    scope 35 {
                                                                                                                        debug iter => _134;
                                                                                                                        let _138: u32;
                                                                                                                        scope 36 {
                                                                                                                            debug corr_uq1_hw => _138;
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                        scope 42 {
                                                                                                            debug c => _192;
                                                                                                            let _197: <F as float::Float>::Int;
                                                                                                            scope 43 {
                                                                                                                debug x_uq0 => _197;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _6 = Eq(const 2_u32, const 0_u32);
        assert(!move _6, "attempt to divide `{}` by zero", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Div(const _, const 2_u32);
        _8 = Lt(_5, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Shr(const _, _5);
        _9 = const _;
        _10 = const _;
        _11 = const _;
        _12 = const _;
        _13 = const _;
        _14 = const _;
        _15 = <<F as Float>::Int as Sub>::sub(_14, _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _16 = const _;
        _17 = _16;
        _19 = _12;
        _18 = <<F as Float>::Int as Shr<u32>>::shr(move _19, const 1_u32) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _20 = <<F as Float>::Int as BitOr>::bitor(_16, _18) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _21 = <F as Float>::repr(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _22 = <F as Float>::repr(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _24 = <<F as Float>::Int as Shr<u32>>::shr(_21, _9) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _25 = <u32 as CastInto<<F as Float>::Int>>::cast(_10) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _23 = <<F as Float>::Int as BitAnd>::bitand(move _24, move _25) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _27 = <<F as Float>::Int as Shr<u32>>::shr(_22, _9) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _28 = <u32 as CastInto<<F as Float>::Int>>::cast(_10) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _26 = <<F as Float>::Int as BitAnd>::bitand(move _27, move _28) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _30 = <<F as Float>::Int as BitXor>::bitxor(_21, _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _29 = <<F as Float>::Int as BitAnd>::bitand(move _30, _14) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _31 = <<F as Float>::Int as BitAnd>::bitand(_21, _13) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _32 = <<F as Float>::Int as BitAnd>::bitand(_22, _13) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _33 = const 0_i32;
        _36 = <<F as Float>::Int as Int>::wrapping_sub(_23, _3) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _35 = &_36;
        _40 = CheckedSub(_10, const 1_u32);
        assert(!move (_40.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _39 = move (_40.0: u32);
        _38 = <u32 as CastInto<<F as Float>::Int>>::cast(move _39) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _37 = &_38;
        _34 = <<F as Float>::Int as PartialOrd>::ge(move _35, move _37) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(move _34) -> [0: bb22, otherwise: bb27];
    }

    bb22: {
        _43 = <<F as Float>::Int as Int>::wrapping_sub(_26, _3) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _42 = &_43;
        _47 = CheckedSub(_10, const 1_u32);
        assert(!move (_47.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 1_u32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _46 = move (_47.0: u32);
        _45 = <u32 as CastInto<<F as Float>::Int>>::cast(move _46) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _44 = &_45;
        _41 = <<F as Float>::Int as PartialOrd>::ge(move _42, move _44) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        switchInt(move _41) -> [0: bb67, otherwise: bb27];
    }

    bb27: {
        _48 = <<F as Float>::Int as BitAnd>::bitand(_21, _15) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _49 = <<F as Float>::Int as BitAnd>::bitand(_22, _15) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _51 = &_48;
        _52 = &_17;
        _50 = <<F as Float>::Int as PartialOrd>::gt(move _51, move _52) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        switchInt(move _50) -> [0: bb33, otherwise: bb31];
    }

    bb31: {
        _53 = <<F as Float>::Int as BitOr>::bitor(_21, _18) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _0 = <F as Float>::from_repr(move _53) -> [return: bb202, unwind unreachable];
    }

    bb33: {
        _55 = &_49;
        _56 = &_17;
        _54 = <<F as Float>::Int as PartialOrd>::gt(move _55, move _56) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        switchInt(move _54) -> [0: bb37, otherwise: bb35];
    }

    bb35: {
        _57 = <<F as Float>::Int as BitOr>::bitor(_22, _18) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _0 = <F as Float>::from_repr(move _57) -> [return: bb202, unwind unreachable];
    }

    bb37: {
        _59 = &_48;
        _60 = &_17;
        _58 = <<F as Float>::Int as PartialEq>::eq(move _59, move _60) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        switchInt(move _58) -> [0: bb44, otherwise: bb39];
    }

    bb39: {
        _62 = &_49;
        _63 = &_17;
        _61 = <<F as Float>::Int as PartialEq>::eq(move _62, move _63) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        switchInt(move _61) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _0 = <F as Float>::from_repr(_20) -> [return: bb202, unwind unreachable];
    }

    bb42: {
        _65 = _48;
        _64 = <<F as Float>::Int as BitOr>::bitor(move _65, _29) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _0 = <F as Float>::from_repr(move _64) -> [return: bb202, unwind unreachable];
    }

    bb44: {
        _67 = &_49;
        _68 = &_17;
        _66 = <<F as Float>::Int as PartialEq>::eq(move _67, move _68) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _66) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb202, unwind unreachable];
    }

    bb47: {
        _70 = &_48;
        _71 = &_4;
        _69 = <<F as Float>::Int as PartialEq>::eq(move _70, move _71) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        switchInt(move _69) -> [0: bb53, otherwise: bb49];
    }

    bb49: {
        _73 = &_49;
        _74 = &_4;
        _72 = <<F as Float>::Int as PartialEq>::eq(move _73, move _74) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        switchInt(move _72) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _0 = <F as Float>::from_repr(_20) -> [return: bb202, unwind unreachable];
    }

    bb52: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb202, unwind unreachable];
    }

    bb53: {
        _76 = &_49;
        _77 = &_4;
        _75 = <<F as Float>::Int as PartialEq>::eq(move _76, move _77) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        switchInt(move _75) -> [0: bb57, otherwise: bb55];
    }

    bb55: {
        _79 = _17;
        _78 = <<F as Float>::Int as BitOr>::bitor(move _79, _29) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        _0 = <F as Float>::from_repr(move _78) -> [return: bb202, unwind unreachable];
    }

    bb57: {
        _81 = &_48;
        _82 = &_12;
        _80 = <<F as Float>::Int as PartialOrd>::lt(move _81, move _82) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        switchInt(move _80) -> [0: bb62, otherwise: bb59];
    }

    bb59: {
        _86 = _31;
        _85 = <F as Float>::normalize(move _86) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _83 = (_85.0: i32);
        _84 = (_85.1: <F as float::Float>::Int);
        _87 = CheckedAdd(_33, _83);
        assert(!move (_87.1: bool), "attempt to compute `{} + {}`, which would overflow", _33, _83) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _33 = move (_87.0: i32);
        _31 = _84;
        goto -> bb62;
    }

    bb62: {
        _89 = &_49;
        _90 = &_12;
        _88 = <<F as Float>::Int as PartialOrd>::lt(move _89, move _90) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        switchInt(move _88) -> [0: bb67, otherwise: bb64];
    }

    bb64: {
        _94 = _32;
        _93 = <F as Float>::normalize(move _94) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _91 = (_93.0: i32);
        _92 = (_93.1: <F as float::Float>::Int);
        _95 = CheckedSub(_33, _91);
        assert(!move (_95.1: bool), "attempt to compute `{} - {}`, which would overflow", _33, _91) -> [success: bb66, unwind unreachable];
    }

    bb66: {
        _33 = move (_95.0: i32);
        _32 = _92;
        goto -> bb67;
    }

    bb67: {
        _97 = &mut _31;
        _98 = _12;
        _96 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _97, move _98) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _100 = &mut _32;
        _101 = _12;
        _99 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _100, move _101) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        _106 = <<F as Float>::Int as Int>::wrapping_sub(_23, _26) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _108 = _33;
        _107 = <i32 as CastInto<<F as Float>::Int>>::cast(move _108) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _105 = <<F as Float>::Int as Int>::wrapping_add(move _106, move _107) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _104 = <<F as Float>::Int as CastInto<u64>>::cast(move _105) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        _109 = _11 as u64 (IntToInt);
        _103 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(move _104, move _109) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _102 = move _103 as i64 (IntToInt);
        _111 = _32;
        _114 = CheckedSub(const _, _9);
        assert(!move (_114.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, _9) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _113 = move (_114.0: u32);
        _115 = CheckedSub(_113, const 1_u32);
        assert(!move (_115.1: bool), "attempt to compute `{} - {}`, which would overflow", move _113, const 1_u32) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _112 = move (_115.0: u32);
        _110 = <<F as Float>::Int as Shl<u32>>::shl(move _111, move _112) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        _117 = Gt(const _, const 0_usize);
        switchInt(move _117) -> [0: bb115, otherwise: bb78];
    }

    bb78: {
        _121 = _32;
        _120 = <<F as Float>::Int as CastInto<u64>>::cast(move _121) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _124 = CheckedAdd(_9, const 1_u32);
        assert(!move (_124.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_u32) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _123 = move (_124.0: u32);
        _125 = CheckedSub(_123, _5);
        assert(!move (_125.1: bool), "attempt to compute `{} - {}`, which would overflow", move _123, _5) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _122 = move (_125.0: u32);
        _126 = Lt(_122, const 64_u32);
        assert(move _126, "attempt to shift right by `{}`, which would overflow", _122) -> [success: bb82, unwind unreachable];
    }

    bb82: {
        _119 = Shr(move _120, move _122);
        _118 = move _119 as u32 (IntToInt);
        _128 = const 1963258675_u64 as u32 (IntToInt);
        _129 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_5, const 32_u32) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _127 = rustc_std_workspace_core::num::<impl u32>::wrapping_shl(move _128, move _129) -> [return: bb84, unwind unreachable];
    }

    bb84: {
        _131 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_127, _118) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        _133 = Range::<usize> { start: const 0_usize, end: const _ };
        _132 = <Range<usize> as IntoIterator>::into_iter(move _133) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _134 = move _132;
        goto -> bb87;
    }

    bb87: {
        _136 = &mut _134;
        _135 = <Range<usize> as Iterator>::next(_136) -> [return: bb88, unwind unreachable];
    }

    bb88: {
        _137 = discriminant(_135);
        switchInt(move _137) -> [0: bb90, 1: bb89, otherwise: bb203];
    }

    bb89: {
        _143 = _131;
        _142 = move _143 as u64 (IntToInt);
        _144 = _118 as u64 (IntToInt);
        _141 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _142, move _144) -> [return: bb91, unwind unreachable];
    }

    bb90: {
        _154 = _131;
        _130 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _154, const 1_u32) -> [return: bb97, unwind unreachable];
    }

    bb91: {
        _145 = Lt(_5, const 64_u32);
        assert(move _145, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb92, unwind unreachable];
    }

    bb92: {
        _140 = Shr(move _141, _5);
        _139 = <u64 as Int>::wrapping_sub(const 0_u64, move _140) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _138 = move _139 as u32 (IntToInt);
        _149 = _131;
        _148 = move _149 as u64 (IntToInt);
        _150 = _138 as u64 (IntToInt);
        _147 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _148, move _150) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        _152 = CheckedSub(_5, const 1_u32);
        assert(!move (_152.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb95, unwind unreachable];
    }

    bb95: {
        _151 = move (_152.0: u32);
        _153 = Lt(_151, const 64_u32);
        assert(move _153, "attempt to shift right by `{}`, which would overflow", _151) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _146 = Shr(move _147, move _151);
        _131 = move _146 as u32 (IntToInt);
        goto -> bb87;
    }

    bb97: {
        _156 = <<F as Float>::Int as CastInto<u64>>::cast(_110) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _155 = BitAnd(move _156, _7);
        _161 = _130 as u64 (IntToInt);
        _162 = _118 as u64 (IntToInt);
        _163 = CheckedMul(_161, _162);
        assert(!move (_163.1: bool), "attempt to compute `{} * {}`, which would overflow", move _161, move _162) -> [success: bb99, unwind unreachable];
    }

    bb99: {
        _160 = move (_163.0: u64);
        _166 = _130 as u64 (IntToInt);
        _167 = CheckedMul(_166, _155);
        assert(!move (_167.1: bool), "attempt to compute `{} * {}`, which would overflow", move _166, _155) -> [success: bb100, unwind unreachable];
    }

    bb100: {
        _165 = move (_167.0: u64);
        _168 = Lt(_5, const 64_u32);
        assert(move _168, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb101, unwind unreachable];
    }

    bb101: {
        _164 = Shr(move _165, _5);
        _169 = CheckedAdd(_160, _164);
        assert(!move (_169.1: bool), "attempt to compute `{} + {}`, which would overflow", move _160, move _164) -> [success: bb102, unwind unreachable];
    }

    bb102: {
        _159 = move (_169.0: u64);
        _170 = CheckedSub(_159, const 1_u64);
        assert(!move (_170.1: bool), "attempt to compute `{} - {}`, which would overflow", move _159, const 1_u64) -> [success: bb103, unwind unreachable];
    }

    bb103: {
        _158 = move (_170.0: u64);
        _157 = negate_u64(move _158) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _171 = BitAnd(_157, _7);
        _173 = Lt(_5, const 64_u32);
        assert(move _173, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb105, unwind unreachable];
    }

    bb105: {
        _172 = Shr(_157, _5);
        _179 = _130 as u64 (IntToInt);
        _180 = CheckedMul(_179, _172);
        assert(!move (_180.1: bool), "attempt to compute `{} * {}`, which would overflow", move _179, _172) -> [success: bb106, unwind unreachable];
    }

    bb106: {
        _178 = move (_180.0: u64);
        _181 = const 1_i32 as u32 (IntToInt);
        _182 = Lt(move _181, const 64_u32);
        assert(move _182, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb107, unwind unreachable];
    }

    bb107: {
        _177 = Shl(move _178, const 1_i32);
        _185 = _130 as u64 (IntToInt);
        _186 = CheckedMul(_185, _171);
        assert(!move (_186.1: bool), "attempt to compute `{} * {}`, which would overflow", move _185, _171) -> [success: bb108, unwind unreachable];
    }

    bb108: {
        _184 = move (_186.0: u64);
        _188 = CheckedSub(_5, const 1_u32);
        assert(!move (_188.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb109, unwind unreachable];
    }

    bb109: {
        _187 = move (_188.0: u32);
        _189 = Lt(_187, const 64_u32);
        assert(move _189, "attempt to shift right by `{}`, which would overflow", _187) -> [success: bb110, unwind unreachable];
    }

    bb110: {
        _183 = Shr(move _184, move _187);
        _176 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(move _177, move _183) -> [return: bb111, unwind unreachable];
    }

    bb111: {
        _175 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _176, const 2_u64) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        _174 = <u64 as CastInto<<F as Float>::Int>>::cast(move _175) -> [return: bb113, unwind unreachable];
    }

    bb113: {
        _191 = &mut _174;
        _190 = <<F as Float>::Int as SubAssign>::sub_assign(move _191, _3) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _116 = _174;
        goto -> bb120;
    }

    bb115: {
        _195 = CheckedSub(const _, const 32_u32);
        assert(!move (_195.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 32_u32) -> [success: bb116, unwind unreachable];
    }

    bb116: {
        _194 = move (_195.0: u32);
        _196 = Lt(_194, const 32_u32);
        assert(move _196, "attempt to shift left by `{}`, which would overflow", _194) -> [success: bb117, unwind unreachable];
    }

    bb117: {
        _193 = Shl(const 1963258675_i32, move _194);
        _192 = <i32 as CastInto<<F as Float>::Int>>::cast(move _193) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _197 = <<F as Float>::Int as Int>::wrapping_sub(_192, _110) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _116 = _197;
        goto -> bb120;
    }

    bb120: {
        _199 = const _;
        switchInt(move _199) -> [0: bb137, otherwise: bb121];
    }

    bb121: {
        _201 = Range::<usize> { start: const 0_usize, end: const _ };
        _200 = <Range<usize> as IntoIterator>::into_iter(move _201) -> [return: bb122, unwind unreachable];
    }

    bb122: {
        _202 = move _200;
        goto -> bb123;
    }

    bb123: {
        _204 = &mut _202;
        _203 = <Range<usize> as Iterator>::next(_204) -> [return: bb124, unwind unreachable];
    }

    bb124: {
        _205 = discriminant(_203);
        switchInt(move _205) -> [0: bb126, 1: bb125, otherwise: bb203];
    }

    bb125: {
        _210 = _116;
        _209 = <<F as Float>::Int as CastInto<u64>>::cast(move _210) -> [return: bb127, unwind unreachable];
    }

    bb126: {
        _198 = _116;
        goto -> bb138;
    }

    bb127: {
        _211 = <<F as Float>::Int as CastInto<u64>>::cast(_110) -> [return: bb128, unwind unreachable];
    }

    bb128: {
        _212 = CheckedMul(_209, _211);
        assert(!move (_212.1: bool), "attempt to compute `{} * {}`, which would overflow", move _209, move _211) -> [success: bb129, unwind unreachable];
    }

    bb129: {
        _208 = move (_212.0: u64);
        _213 = Lt(const _, const 64_u32);
        assert(move _213, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb130, unwind unreachable];
    }

    bb130: {
        _207 = Shr(move _208, const _);
        _206 = <u64 as Int>::wrapping_sub(const 0_u64, move _207) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _220 = _116;
        _219 = <<F as Float>::Int as CastInto<u64>>::cast(move _220) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _218 = move _219 as u128 (IntToInt);
        _221 = _206 as u128 (IntToInt);
        _222 = CheckedMul(_218, _221);
        assert(!move (_222.1: bool), "attempt to compute `{} * {}`, which would overflow", move _218, move _221) -> [success: bb133, unwind unreachable];
    }

    bb133: {
        _217 = move (_222.0: u128);
        _224 = CheckedSub(const _, const 1_u32);
        assert(!move (_224.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb134, unwind unreachable];
    }

    bb134: {
        _223 = move (_224.0: u32);
        _225 = Lt(_223, const 128_u32);
        assert(move _225, "attempt to shift right by `{}`, which would overflow", _223) -> [success: bb135, unwind unreachable];
    }

    bb135: {
        _216 = Shr(move _217, move _223);
        _215 = move _216 as u64 (IntToInt);
        _214 = <u64 as CastInto<<F as Float>::Int>>::cast(move _215) -> [return: bb136, unwind unreachable];
    }

    bb136: {
        _116 = move _214;
        goto -> bb123;
    }

    bb137: {
        _198 = _116;
        goto -> bb138;
    }

    bb138: {
        _227 = _198;
        _228 = <i32 as CastInto<<F as Float>::Int>>::cast(const 2_i32) -> [return: bb139, unwind unreachable];
    }

    bb139: {
        _226 = <<F as Float>::Int as Int>::wrapping_sub(move _227, move _228) -> [return: bb140, unwind unreachable];
    }

    bb140: {
        _198 = move _226;
        _229 = <i32 as CastInto<<F as Float>::Int>>::cast(const 220_i32) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _231 = _198;
        _230 = <<F as Float>::Int as Sub>::sub(move _231, _229) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _235 = _31;
        _234 = <<F as Float>::Int as Shl<u32>>::shl(move _235, const 1_u32) -> [return: bb143, unwind unreachable];
    }

    bb143: {
        _233 = <<F as Float>::Int as HInt>::widen_mul(_230, move _234) -> [return: bb144, unwind unreachable];
    }

    bb144: {
        _232 = <<<F as Float>::Int as HInt>::D as DInt>::hi(move _233) -> [return: bb145, unwind unreachable];
    }

    bb145: {
        _240 = &_232;
        _243 = _12;
        _242 = <<F as Float>::Int as Shl<u32>>::shl(move _243, const 1_u32) -> [return: bb146, unwind unreachable];
    }

    bb146: {
        _241 = &_242;
        _239 = <<F as Float>::Int as PartialOrd>::lt(move _240, move _241) -> [return: bb147, unwind unreachable];
    }

    bb147: {
        switchInt(move _239) -> [0: bb158, otherwise: bb148];
    }

    bb148: {
        _246 = _31;
        _248 = CheckedAdd(_9, const 1_u32);
        assert(!move (_248.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_u32) -> [success: bb149, unwind unreachable];
    }

    bb149: {
        _247 = move (_248.0: u32);
        _245 = <<F as Float>::Int as Shl<u32>>::shl(move _246, move _247) -> [return: bb150, unwind unreachable];
    }

    bb150: {
        _252 = _232;
        _251 = <<F as Float>::Int as CastInto<u64>>::cast(move _252) -> [return: bb151, unwind unreachable];
    }

    bb151: {
        _254 = _32;
        _253 = <<F as Float>::Int as CastInto<u64>>::cast(move _254) -> [return: bb152, unwind unreachable];
    }

    bb152: {
        _250 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _251, move _253) -> [return: bb153, unwind unreachable];
    }

    bb153: {
        _249 = <u64 as CastInto<<F as Float>::Int>>::cast(move _250) -> [return: bb154, unwind unreachable];
    }

    bb154: {
        _244 = <<F as Float>::Int as Int>::wrapping_sub(move _245, move _249) -> [return: bb155, unwind unreachable];
    }

    bb155: {
        _256 = &mut _31;
        _255 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _256, const 1_i32) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        _257 = rustc_std_workspace_core::num::<impl i64>::wrapping_sub(_102, const 1_i64) -> [return: bb157, unwind unreachable];
    }

    bb157: {
        _238 = (_244, move _257);
        goto -> bb166;
    }

    bb158: {
        _259 = &mut _232;
        _258 = <<F as Float>::Int as ShrAssign<u32>>::shr_assign(move _259, const 1_u32) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        _262 = _31;
        _261 = <<F as Float>::Int as Shl<u32>>::shl(move _262, _9) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _266 = _232;
        _265 = <<F as Float>::Int as CastInto<u64>>::cast(move _266) -> [return: bb161, unwind unreachable];
    }

    bb161: {
        _268 = _32;
        _267 = <<F as Float>::Int as CastInto<u64>>::cast(move _268) -> [return: bb162, unwind unreachable];
    }

    bb162: {
        _264 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _265, move _267) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _263 = <u64 as CastInto<<F as Float>::Int>>::cast(move _264) -> [return: bb164, unwind unreachable];
    }

    bb164: {
        _260 = <<F as Float>::Int as Int>::wrapping_sub(move _261, move _263) -> [return: bb165, unwind unreachable];
    }

    bb165: {
        _238 = (_260, _102);
        goto -> bb166;
    }

    bb166: {
        _236 = (_238.0: <F as float::Float>::Int);
        _237 = (_238.1: i64);
        _269 = _232;
        _271 = _10 as i64 (IntToInt);
        _270 = Ge(_237, move _271);
        switchInt(move _270) -> [0: bb169, otherwise: bb167];
    }

    bb167: {
        _273 = _17;
        _272 = <<F as Float>::Int as BitOr>::bitor(move _273, _29) -> [return: bb168, unwind unreachable];
    }

    bb168: {
        _0 = <F as Float>::from_repr(move _272) -> [return: bb202, unwind unreachable];
    }

    bb169: {
        _275 = Gt(_237, const 0_i64);
        switchInt(move _275) -> [0: bb171, otherwise: bb170];
    }

    bb170: {
        _276 = <<F as Float>::Int as BitAnd>::bitand(_269, _13) -> [return: bb172, unwind unreachable];
    }

    bb171: {
        _287 = _9 as i64 (IntToInt);
        _288 = CheckedAdd(_287, _237);
        assert(!move (_288.1: bool), "attempt to compute `{} + {}`, which would overflow", move _287, _237) -> [success: bb177, unwind unreachable];
    }

    bb172: {
        _278 = &mut _276;
        _281 = _237 as u64 (IntToInt);
        _282 = Lt(_9, const 64_u32);
        assert(move _282, "attempt to shift left by `{}`, which would overflow", _9) -> [success: bb173, unwind unreachable];
    }

    bb173: {
        _280 = Shl(move _281, _9);
        _279 = <u64 as CastInto<<F as Float>::Int>>::cast(move _280) -> [return: bb174, unwind unreachable];
    }

    bb174: {
        _277 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _278, move _279) -> [return: bb175, unwind unreachable];
    }

    bb175: {
        _284 = &mut _236;
        _283 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _284, const 1_i32) -> [return: bb176, unwind unreachable];
    }

    bb176: {
        _274 = _276;
        goto -> bb194;
    }

    bb177: {
        _286 = move (_288.0: i64);
        _285 = Lt(move _286, const 0_i64);
        switchInt(move _285) -> [0: bb179, otherwise: bb178];
    }

    bb178: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb202, unwind unreachable];
    }

    bb179: {
        _293 = <i64 as CastInto<u64>>::cast(_237) -> [return: bb180, unwind unreachable];
    }

    bb180: {
        _292 = negate_u64(move _293) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _294 = CheckedAdd(_292, const 1_u64);
        assert(!move (_294.1: bool), "attempt to compute `{} + {}`, which would overflow", move _292, const 1_u64) -> [success: bb182, unwind unreachable];
    }

    bb182: {
        _291 = move (_294.0: u64);
        _290 = move _291 as u32 (IntToInt);
        _289 = <<F as Float>::Int as Int>::wrapping_shr(_269, move _290) -> [return: bb183, unwind unreachable];
    }

    bb183: {
        _299 = _31;
        _301 = <i64 as CastInto<u32>>::cast(_237) -> [return: bb184, unwind unreachable];
    }

    bb184: {
        _300 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(_9, move _301) -> [return: bb185, unwind unreachable];
    }

    bb185: {
        _298 = <<F as Float>::Int as Int>::wrapping_shl(move _299, move _300) -> [return: bb186, unwind unreachable];
    }

    bb186: {
        _297 = <<F as Float>::Int as CastInto<u64>>::cast(move _298) -> [return: bb187, unwind unreachable];
    }

    bb187: {
        _304 = <<F as Float>::Int as CastInto<u64>>::cast(_289) -> [return: bb188, unwind unreachable];
    }

    bb188: {
        _306 = _32;
        _305 = <<F as Float>::Int as CastInto<u64>>::cast(move _306) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        _303 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _304, move _305) -> [return: bb190, unwind unreachable];
    }

    bb190: {
        _307 = const 1_i32 as u32 (IntToInt);
        _308 = Lt(move _307, const 64_u32);
        assert(move _308, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb191, unwind unreachable];
    }

    bb191: {
        _302 = Shl(move _303, const 1_i32);
        _296 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _297, move _302) -> [return: bb192, unwind unreachable];
    }

    bb192: {
        _295 = <u64 as CastInto<<F as Float>::Int>>::cast(move _296) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _236 = move _295;
        _274 = _289;
        goto -> bb194;
    }

    bb194: {
        _311 = &mut _236;
        _313 = _274;
        _312 = <<F as Float>::Int as BitAnd>::bitand(move _313, _3) -> [return: bb195, unwind unreachable];
    }

    bb195: {
        _310 = <<F as Float>::Int as AddAssign>::add_assign(move _311, move _312) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _315 = &_236;
        _316 = &_32;
        _314 = <<F as Float>::Int as PartialOrd>::gt(move _315, move _316) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        switchInt(move _314) -> [0: bb199, otherwise: bb198];
    }

    bb198: {
        _317 = _274;
        _309 = <<F as Float>::Int as Add>::add(move _317, _3) -> [return: bb200, unwind unreachable];
    }

    bb199: {
        _309 = _274;
        goto -> bb200;
    }

    bb200: {
        _319 = _309;
        _318 = <<F as Float>::Int as BitOr>::bitor(move _319, _29) -> [return: bb201, unwind unreachable];
    }

    bb201: {
        _0 = <F as Float>::from_repr(move _318) -> [return: bb202, unwind unreachable];
    }

    bb202: {
        return;
    }

    bb203: {
        unreachable;
    }
}

const div64::NUMBER_OF_HALF_ITERATIONS: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

const div64::NUMBER_OF_FULL_ITERATIONS: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

const div64::USE_NATIVE_FULL_ITERATIONS: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn negate_u64(_1: u64) -> u64 {
    debug a => _1;
    let mut _0: u64;
    let mut _2: i64;
    let mut _3: i64;

    bb0: {
        _3 = _1 as i64 (IntToInt);
        _2 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as u64 (IntToInt);
        return;
    }
}

fn div::__divsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = div32::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __divsf3::__divsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = div::__divsf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn div::__divdf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = div64::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __divdf3::__divdf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = div::__divdf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn extend::extend(_1: F) -> R {
    debug a => _1;
    let mut _0: R;
    let _2: <F as float::Float>::Int;
    let mut _9: <F as float::Float>::Int;
    let mut _19: (u32, bool);
    let mut _21: (u32, bool);
    let mut _23: <F as float::Float>::Int;
    let mut _25: bool;
    let mut _26: &<F as float::Float>::Int;
    let _27: <F as float::Float>::Int;
    let mut _28: <F as float::Float>::Int;
    let mut _29: &<F as float::Float>::Int;
    let _30: <F as float::Float>::Int;
    let mut _31: <F as float::Float>::Int;
    let mut _33: <F as float::Float>::Int;
    let mut _35: <R as float::Float>::Int;
    let _36: ();
    let mut _37: &mut <R as float::Float>::Int;
    let mut _38: <R as float::Float>::Int;
    let mut _39: bool;
    let mut _40: &<F as float::Float>::Int;
    let mut _41: &<F as float::Float>::Int;
    let mut _43: <F as float::Float>::Int;
    let mut _44: <F as float::Float>::Int;
    let mut _46: <F as float::Float>::Int;
    let mut _47: <F as float::Float>::Int;
    let mut _49: <R as float::Float>::Int;
    let _50: ();
    let mut _51: &mut <R as float::Float>::Int;
    let mut _52: <R as float::Float>::Int;
    let _53: ();
    let mut _54: &mut <R as float::Float>::Int;
    let mut _55: <R as float::Float>::Int;
    let mut _56: bool;
    let mut _57: &<F as float::Float>::Int;
    let mut _58: &<F as float::Float>::Int;
    let mut _60: u32;
    let mut _61: <F as float::Float>::Int;
    let mut _62: u32;
    let mut _63: (u32, bool);
    let mut _65: <F as float::Float>::Int;
    let mut _67: u32;
    let mut _68: u32;
    let mut _69: (u32, bool);
    let mut _70: (u32, bool);
    let mut _71: <R as float::Float>::Int;
    let mut _72: u32;
    let mut _73: (u32, bool);
    let mut _74: <R as float::Float>::Int;
    let mut _75: <R as float::Float>::Int;
    let mut _76: <R as float::Float>::Int;
    let mut _77: <R as float::Float>::Int;
    let mut _79: <F as float::Float>::Int;
    let mut _80: <F as float::Float>::Int;
    let mut _81: <R as float::Float>::Int;
    let mut _82: <R as float::Float>::Int;
    let mut _83: <R as float::Float>::Int;
    let mut _84: u32;
    let mut _85: (u32, bool);
    scope 1 {
        debug src_zero => const _;
        let _3: <F as float::Float>::Int;
        scope 2 {
            debug src_one => const _;
            let _4: u32;
            scope 3 {
                debug src_bits => const _;
                let _5: u32;
                scope 4 {
                    debug src_sign_bits => const _;
                    let _6: u32;
                    scope 5 {
                        debug src_exp_bias => const _;
                        let _7: <F as float::Float>::Int;
                        scope 6 {
                            debug src_min_normal => const _;
                            let _8: <F as float::Float>::Int;
                            scope 7 {
                                debug src_infinity => const _;
                                scope 8 {
                                    debug src_sign_mask => const _;
                                    let _10: <F as float::Float>::Int;
                                    scope 9 {
                                        debug src_abs_mask => _10;
                                        let _11: <F as float::Float>::Int;
                                        scope 10 {
                                            debug src_qnan => const _;
                                            let _12: <F as float::Float>::Int;
                                            scope 11 {
                                                debug src_nan_code => _12;
                                                let _13: u32;
                                                scope 12 {
                                                    debug dst_bits => const _;
                                                    let _14: u32;
                                                    scope 13 {
                                                        debug dst_sign_bits => const _;
                                                        let _15: u32;
                                                        scope 14 {
                                                            debug dst_inf_exp => const _;
                                                            let _16: u32;
                                                            scope 15 {
                                                                debug dst_exp_bias => const _;
                                                                let _17: <R as float::Float>::Int;
                                                                scope 16 {
                                                                    debug dst_min_normal => const _;
                                                                    let _18: u32;
                                                                    scope 17 {
                                                                        debug sign_bits_delta => _18;
                                                                        let _20: u32;
                                                                        scope 18 {
                                                                            debug exp_bias_delta => _20;
                                                                            let _22: <F as float::Float>::Int;
                                                                            scope 19 {
                                                                                debug a_abs => _22;
                                                                                let mut _24: <R as float::Float>::Int;
                                                                                scope 20 {
                                                                                    debug abs_result => _24;
                                                                                    let _32: <R as float::Float>::Int;
                                                                                    let _42: <R as float::Float>::Int;
                                                                                    let _59: u32;
                                                                                    let _78: <R as float::Float>::Int;
                                                                                    scope 21 {
                                                                                        debug abs_dst => _32;
                                                                                        let _34: <R as float::Float>::Int;
                                                                                        scope 22 {
                                                                                            debug bias_dst => _34;
                                                                                        }
                                                                                    }
                                                                                    scope 23 {
                                                                                        debug qnan_dst => _42;
                                                                                        let _45: <R as float::Float>::Int;
                                                                                        scope 24 {
                                                                                            debug nan_code_dst => _45;
                                                                                            let _48: <R as float::Float>::Int;
                                                                                            scope 25 {
                                                                                                debug inf_exp_dst => _48;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 26 {
                                                                                        debug scale => _59;
                                                                                        let _64: <R as float::Float>::Int;
                                                                                        scope 27 {
                                                                                            debug abs_dst => _64;
                                                                                            let _66: <R as float::Float>::Int;
                                                                                            scope 28 {
                                                                                                debug bias_dst => _66;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 29 {
                                                                                        debug sign_result => _78;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const _;
        _3 = const _;
        _4 = const _;
        _5 = const _;
        _6 = const _;
        _7 = const _;
        _8 = const _;
        _9 = const _;
        _10 = <<F as Float>::Int as Sub>::sub(_9, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = const _;
        _12 = <<F as Float>::Int as Sub>::sub(_11, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = const _;
        _14 = const _;
        _15 = const _;
        _16 = const _;
        _17 = const _;
        _19 = CheckedSub(_14, _5);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", _14, _5) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _18 = move (_19.0: u32);
        _21 = CheckedSub(_16, _6);
        assert(!move (_21.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, _6) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _20 = move (_21.0: u32);
        _23 = <F as Float>::repr(_1) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _22 = <<F as Float>::Int as BitAnd>::bitand(move _23, _10) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _24 = const _;
        _28 = _22;
        _27 = <<F as Float>::Int as Int>::wrapping_sub(move _28, _7) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _26 = &_27;
        _31 = _8;
        _30 = <<F as Float>::Int as Int>::wrapping_sub(move _31, _7) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _29 = &_30;
        _25 = <<F as Float>::Int as PartialOrd>::lt(move _26, move _29) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _25) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        _33 = _22;
        _32 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _33) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _34 = <u32 as CastInto<<R as Float>::Int>>::cast(_20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _35 = <<R as Float>::Int as Int>::wrapping_shl(_32, _18) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _24 = move _35;
        _37 = &mut _24;
        _38 = <<R as Float>::Int as Int>::wrapping_shl(_34, _14) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _36 = <<R as Float>::Int as AddAssign>::add_assign(move _37, move _38) -> [return: bb42, unwind unreachable];
    }

    bb15: {
        _40 = &_22;
        _41 = &_8;
        _39 = <<F as Float>::Int as PartialOrd>::ge(move _40, move _41) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _39) -> [0: bb27, otherwise: bb17];
    }

    bb17: {
        _44 = _22;
        _43 = <<F as Float>::Int as BitAnd>::bitand(move _44, _11) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _42 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _43) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _47 = _22;
        _46 = <<F as Float>::Int as BitAnd>::bitand(move _47, _12) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _45 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _46) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _48 = <u32 as CastInto<<R as Float>::Int>>::cast(_15) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _49 = <<R as Float>::Int as Int>::wrapping_shl(_48, _14) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _24 = move _49;
        _51 = &mut _24;
        _52 = <<R as Float>::Int as Int>::wrapping_shl(_42, _18) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _50 = <<R as Float>::Int as BitOrAssign>::bitor_assign(move _51, move _52) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _54 = &mut _24;
        _55 = <<R as Float>::Int as Int>::wrapping_shl(_45, _18) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _53 = <<R as Float>::Int as BitOrAssign>::bitor_assign(move _54, move _55) -> [return: bb42, unwind unreachable];
    }

    bb27: {
        _57 = &_22;
        _58 = &_2;
        _56 = <<F as Float>::Int as PartialEq>::ne(move _57, move _58) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        switchInt(move _56) -> [0: bb42, otherwise: bb29];
    }

    bb29: {
        _61 = _22;
        _60 = <<F as Float>::Int as Int>::leading_zeros(move _61) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _62 = <<F as Float>::Int as Int>::leading_zeros(_7) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _63 = CheckedSub(_60, _62);
        assert(!move (_63.1: bool), "attempt to compute `{} - {}`, which would overflow", move _60, move _62) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _59 = move (_63.0: u32);
        _65 = _22;
        _64 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _65) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _69 = CheckedSub(_20, _59);
        assert(!move (_69.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, _59) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _68 = move (_69.0: u32);
        _70 = CheckedAdd(_68, const 1_u32);
        assert(!move (_70.1: bool), "attempt to compute `{} + {}`, which would overflow", move _68, const 1_u32) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _67 = move (_70.0: u32);
        _66 = <u32 as CastInto<<R as Float>::Int>>::cast(move _67) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _73 = CheckedAdd(_18, _59);
        assert(!move (_73.1: bool), "attempt to compute `{} + {}`, which would overflow", _18, _59) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _72 = move (_73.0: u32);
        _71 = <<R as Float>::Int as Int>::wrapping_shl(_64, move _72) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _24 = move _71;
        _76 = _24;
        _75 = <<R as Float>::Int as BitXor>::bitxor(move _76, _17) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _77 = <<R as Float>::Int as Int>::wrapping_shl(_66, _14) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _74 = <<R as Float>::Int as BitOr>::bitor(move _75, move _77) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _24 = move _74;
        goto -> bb42;
    }

    bb42: {
        _80 = <F as Float>::repr(_1) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _79 = <<F as Float>::Int as BitAnd>::bitand(move _80, _9) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _78 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _79) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _82 = _24;
        _85 = CheckedSub(_13, _4);
        assert(!move (_85.1: bool), "attempt to compute `{} - {}`, which would overflow", _13, _4) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _84 = move (_85.0: u32);
        _83 = <<R as Float>::Int as Int>::wrapping_shl(_78, move _84) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _81 = <<R as Float>::Int as BitOr>::bitor(move _82, move _83) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        _0 = <R as Float>::from_repr(move _81) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        return;
    }
}

fn extend::__extendsfdf2(_1: f32) -> f64 {
    debug a => _1;
    let mut _0: f64;

    bb0: {
        _0 = extend::extend::<f32, f64>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __extendsfdf2::__extendsfdf2(_1: f32) -> f64 {
    debug a => _1;
    let mut _0: f64;

    bb0: {
        _0 = extend::__extendsfdf2(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::mul::mul(_1: F, _2: F) -> F {
    debug a => _1;
    debug b => _2;
    let mut _0: F;
    let _3: <F as float::Float>::Int;
    let mut _12: <F as float::Float>::Int;
    let mut _14: <F as float::Float>::Int;
    let mut _18: <F as float::Float>::Int;
    let mut _24: <F as float::Float>::Int;
    let mut _25: <F as float::Float>::Int;
    let mut _27: <F as float::Float>::Int;
    let mut _28: <F as float::Float>::Int;
    let mut _30: <F as float::Float>::Int;
    let mut _31: <F as float::Float>::Int;
    let mut _35: bool;
    let mut _36: &<F as float::Float>::Int;
    let _37: <F as float::Float>::Int;
    let mut _38: &<F as float::Float>::Int;
    let _39: <F as float::Float>::Int;
    let mut _40: u32;
    let mut _41: (u32, bool);
    let mut _42: bool;
    let mut _43: &<F as float::Float>::Int;
    let _44: <F as float::Float>::Int;
    let mut _45: &<F as float::Float>::Int;
    let _46: <F as float::Float>::Int;
    let mut _47: u32;
    let mut _48: (u32, bool);
    let mut _51: bool;
    let mut _52: &<F as float::Float>::Int;
    let mut _53: &<F as float::Float>::Int;
    let mut _54: <F as float::Float>::Int;
    let mut _55: bool;
    let mut _56: &<F as float::Float>::Int;
    let mut _57: &<F as float::Float>::Int;
    let mut _58: <F as float::Float>::Int;
    let mut _59: bool;
    let mut _60: &<F as float::Float>::Int;
    let mut _61: &<F as float::Float>::Int;
    let mut _62: bool;
    let mut _63: &<F as float::Float>::Int;
    let mut _64: &<F as float::Float>::Int;
    let mut _65: <F as float::Float>::Int;
    let mut _66: <F as float::Float>::Int;
    let mut _67: bool;
    let mut _68: &<F as float::Float>::Int;
    let mut _69: &<F as float::Float>::Int;
    let mut _70: bool;
    let mut _71: &<F as float::Float>::Int;
    let mut _72: &<F as float::Float>::Int;
    let mut _73: <F as float::Float>::Int;
    let mut _74: <F as float::Float>::Int;
    let mut _75: bool;
    let mut _76: &<F as float::Float>::Int;
    let mut _77: &<F as float::Float>::Int;
    let mut _78: bool;
    let mut _79: &<F as float::Float>::Int;
    let mut _80: &<F as float::Float>::Int;
    let mut _81: bool;
    let mut _82: &<F as float::Float>::Int;
    let mut _83: &<F as float::Float>::Int;
    let mut _86: (i32, <F as float::Float>::Int);
    let mut _87: <F as float::Float>::Int;
    let mut _88: (i32, bool);
    let mut _89: bool;
    let mut _90: &<F as float::Float>::Int;
    let mut _91: &<F as float::Float>::Int;
    let mut _94: (i32, <F as float::Float>::Int);
    let mut _95: <F as float::Float>::Int;
    let mut _96: (i32, bool);
    let _97: ();
    let mut _98: &mut <F as float::Float>::Int;
    let mut _99: <F as float::Float>::Int;
    let _100: ();
    let mut _101: &mut <F as float::Float>::Int;
    let mut _102: <F as float::Float>::Int;
    let mut _105: (<F as float::Float>::Int, <F as float::Float>::Int);
    let mut _106: <<F as float::Float>::Int as int::HInt>::D;
    let mut _107: <F as float::Float>::Int;
    let mut _108: <F as float::Float>::Int;
    let mut _109: <F as float::Float>::Int;
    let mut _113: i32;
    let mut _114: i32;
    let mut _115: i32;
    let mut _116: i32;
    let mut _117: bool;
    let mut _118: &<F as float::Float>::Int;
    let _119: <F as float::Float>::Int;
    let mut _120: <F as float::Float>::Int;
    let mut _121: <F as float::Float>::Int;
    let mut _122: &<F as float::Float>::Int;
    let mut _123: i32;
    let mut _124: i32;
    let mut _125: <F as float::Float>::Int;
    let mut _126: <F as float::Float>::Int;
    let mut _127: <F as float::Float>::Int;
    let mut _128: <F as float::Float>::Int;
    let mut _129: <F as float::Float>::Int;
    let mut _130: u32;
    let mut _131: (u32, bool);
    let _132: ();
    let mut _133: &mut <F as float::Float>::Int;
    let mut _134: bool;
    let mut _135: i32;
    let mut _136: i32;
    let mut _137: <F as float::Float>::Int;
    let mut _138: <F as float::Float>::Int;
    let mut _139: bool;
    let mut _140: i32;
    let mut _142: <F as float::Float>::Int;
    let mut _143: <F as float::Float>::Int;
    let mut _144: i32;
    let mut _145: bool;
    let mut _146: bool;
    let mut _148: <F as float::Float>::Int;
    let mut _149: u32;
    let mut _150: (u32, bool);
    let mut _151: <F as float::Float>::Int;
    let mut _152: <F as float::Float>::Int;
    let mut _153: <F as float::Float>::Int;
    let mut _154: <F as float::Float>::Int;
    let mut _155: u32;
    let mut _156: (u32, bool);
    let mut _157: <F as float::Float>::Int;
    let mut _158: <F as float::Float>::Int;
    let _159: ();
    let mut _160: &mut <F as float::Float>::Int;
    let mut _161: bool;
    let mut _162: u32;
    let mut _163: (u32, bool);
    let mut _165: <F as float::Float>::Int;
    let mut _166: <F as float::Float>::Int;
    let mut _167: u32;
    let mut _168: u32;
    let mut _169: (u32, bool);
    let mut _170: (u32, bool);
    let mut _171: <F as float::Float>::Int;
    let mut _172: <F as float::Float>::Int;
    let mut _173: <F as float::Float>::Int;
    let mut _174: <F as float::Float>::Int;
    let mut _175: u32;
    let mut _176: (u32, bool);
    let mut _177: <F as float::Float>::Int;
    let mut _178: <F as float::Float>::Int;
    let _179: ();
    let mut _180: &mut <F as float::Float>::Int;
    let _181: ();
    let mut _182: &mut <F as float::Float>::Int;
    let mut _183: <F as float::Float>::Int;
    let mut _184: <F as float::Float>::Int;
    let mut _185: i32;
    let _186: ();
    let mut _187: &mut <F as float::Float>::Int;
    let mut _188: bool;
    let mut _189: &<F as float::Float>::Int;
    let mut _190: &<F as float::Float>::Int;
    let _191: ();
    let mut _192: &mut <F as float::Float>::Int;
    let mut _193: bool;
    let mut _194: &<F as float::Float>::Int;
    let mut _195: &<F as float::Float>::Int;
    let _196: ();
    let mut _197: &mut <F as float::Float>::Int;
    let mut _198: <F as float::Float>::Int;
    let mut _199: <F as float::Float>::Int;
    let mut _200: <F as float::Float>::Int;
    scope 1 {
        debug one => const _;
        let _4: <F as float::Float>::Int;
        scope 2 {
            debug zero => const _;
            let _5: u32;
            scope 3 {
                debug bits => const _;
                let _6: u32;
                scope 4 {
                    debug significand_bits => const _;
                    let _7: u32;
                    scope 5 {
                        debug max_exponent => const _;
                        let _8: u32;
                        scope 6 {
                            debug exponent_bias => const _;
                            let _9: <F as float::Float>::Int;
                            scope 7 {
                                debug implicit_bit => const _;
                                let _10: <F as float::Float>::Int;
                                scope 8 {
                                    debug significand_mask => const _;
                                    let _11: <F as float::Float>::Int;
                                    scope 9 {
                                        debug sign_bit => _11;
                                        let _13: <F as float::Float>::Int;
                                        scope 10 {
                                            debug abs_mask => _13;
                                            let _15: <F as float::Float>::Int;
                                            scope 11 {
                                                debug exponent_mask => const _;
                                                let _16: <F as float::Float>::Int;
                                                scope 12 {
                                                    debug inf_rep => _16;
                                                    let _17: <F as float::Float>::Int;
                                                    scope 13 {
                                                        debug quiet_bit => _17;
                                                        let _19: <F as float::Float>::Int;
                                                        scope 14 {
                                                            debug qnan_rep => _19;
                                                            let _20: u32;
                                                            scope 15 {
                                                                debug exponent_bits => const _;
                                                                let _21: <F as float::Float>::Int;
                                                                scope 16 {
                                                                    debug a_rep => _21;
                                                                    let _22: <F as float::Float>::Int;
                                                                    scope 17 {
                                                                        debug b_rep => _22;
                                                                        let _23: <F as float::Float>::Int;
                                                                        scope 18 {
                                                                            debug a_exponent => _23;
                                                                            let _26: <F as float::Float>::Int;
                                                                            scope 19 {
                                                                                debug b_exponent => _26;
                                                                                let _29: <F as float::Float>::Int;
                                                                                scope 20 {
                                                                                    debug product_sign => _29;
                                                                                    let mut _32: <F as float::Float>::Int;
                                                                                    scope 21 {
                                                                                        debug a_significand => _32;
                                                                                        let mut _33: <F as float::Float>::Int;
                                                                                        scope 22 {
                                                                                            debug b_significand => _33;
                                                                                            let mut _34: i32;
                                                                                            scope 23 {
                                                                                                debug scale => _34;
                                                                                                let _49: <F as float::Float>::Int;
                                                                                                let mut _103: <F as float::Float>::Int;
                                                                                                let mut _104: <F as float::Float>::Int;
                                                                                                scope 24 {
                                                                                                    debug a_abs => _49;
                                                                                                    let _50: <F as float::Float>::Int;
                                                                                                    scope 25 {
                                                                                                        debug b_abs => _50;
                                                                                                        let _84: i32;
                                                                                                        let _85: <F as float::Float>::Int;
                                                                                                        let _92: i32;
                                                                                                        let _93: <F as float::Float>::Int;
                                                                                                        scope 26 {
                                                                                                            debug exponent => _84;
                                                                                                            debug significand => _85;
                                                                                                        }
                                                                                                        scope 27 {
                                                                                                            debug exponent => _92;
                                                                                                            debug significand => _93;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                                scope 28 {
                                                                                                    debug product_low => _103;
                                                                                                    debug product_high => _104;
                                                                                                    let _110: i32;
                                                                                                    scope 29 {
                                                                                                        debug a_exponent_i32 => _110;
                                                                                                        let _111: i32;
                                                                                                        scope 30 {
                                                                                                            debug b_exponent_i32 => _111;
                                                                                                            let mut _112: i32;
                                                                                                            scope 31 {
                                                                                                                debug product_exponent => _112;
                                                                                                                let _141: u32;
                                                                                                                scope 32 {
                                                                                                                    debug shift => _141;
                                                                                                                    let _147: <F as float::Float>::Int;
                                                                                                                    let _164: <F as float::Float>::Int;
                                                                                                                    scope 33 {
                                                                                                                        debug sticky => _147;
                                                                                                                    }
                                                                                                                    scope 34 {
                                                                                                                        debug sticky => _164;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const _;
        _4 = const _;
        _5 = const _;
        _6 = const _;
        _7 = const _;
        _8 = const _;
        _9 = const _;
        _10 = const _;
        _12 = const _;
        _11 = _12;
        _14 = _11;
        _13 = <<F as Float>::Int as Sub>::sub(move _14, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _15 = const _;
        _16 = _15;
        _18 = _9;
        _17 = <<F as Float>::Int as Shr<u32>>::shr(move _18, const 1_u32) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _19 = <<F as Float>::Int as BitOr>::bitor(_15, _17) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _20 = const _;
        _21 = <F as Float>::repr(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _22 = <F as Float>::repr(_2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _24 = <<F as Float>::Int as Shr<u32>>::shr(_21, _6) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _25 = <u32 as CastInto<<F as Float>::Int>>::cast(_7) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _23 = <<F as Float>::Int as BitAnd>::bitand(move _24, move _25) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _27 = <<F as Float>::Int as Shr<u32>>::shr(_22, _6) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _28 = <u32 as CastInto<<F as Float>::Int>>::cast(_7) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _26 = <<F as Float>::Int as BitAnd>::bitand(move _27, move _28) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _30 = <<F as Float>::Int as BitXor>::bitxor(_21, _22) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _31 = _11;
        _29 = <<F as Float>::Int as BitAnd>::bitand(move _30, move _31) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _32 = <<F as Float>::Int as BitAnd>::bitand(_21, _10) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _33 = <<F as Float>::Int as BitAnd>::bitand(_22, _10) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _34 = const 0_i32;
        _37 = <<F as Float>::Int as Int>::wrapping_sub(_23, _3) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _36 = &_37;
        _41 = CheckedSub(_7, const 1_u32);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_u32) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _40 = move (_41.0: u32);
        _39 = <u32 as CastInto<<F as Float>::Int>>::cast(move _40) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _38 = &_39;
        _35 = <<F as Float>::Int as PartialOrd>::ge(move _36, move _38) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        switchInt(move _35) -> [0: bb20, otherwise: bb25];
    }

    bb20: {
        _44 = <<F as Float>::Int as Int>::wrapping_sub(_26, _3) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _43 = &_44;
        _48 = CheckedSub(_7, const 1_u32);
        assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_u32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _47 = move (_48.0: u32);
        _46 = <u32 as CastInto<<F as Float>::Int>>::cast(move _47) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _45 = &_46;
        _42 = <<F as Float>::Int as PartialOrd>::ge(move _43, move _45) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        switchInt(move _42) -> [0: bb65, otherwise: bb25];
    }

    bb25: {
        _49 = <<F as Float>::Int as BitAnd>::bitand(_21, _13) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _50 = <<F as Float>::Int as BitAnd>::bitand(_22, _13) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _52 = &_49;
        _53 = &_16;
        _51 = <<F as Float>::Int as PartialOrd>::gt(move _52, move _53) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        switchInt(move _51) -> [0: bb31, otherwise: bb29];
    }

    bb29: {
        _54 = <<F as Float>::Int as BitOr>::bitor(_21, _17) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _0 = <F as Float>::from_repr(move _54) -> [return: bb127, unwind unreachable];
    }

    bb31: {
        _56 = &_50;
        _57 = &_16;
        _55 = <<F as Float>::Int as PartialOrd>::gt(move _56, move _57) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        switchInt(move _55) -> [0: bb35, otherwise: bb33];
    }

    bb33: {
        _58 = <<F as Float>::Int as BitOr>::bitor(_22, _17) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _0 = <F as Float>::from_repr(move _58) -> [return: bb127, unwind unreachable];
    }

    bb35: {
        _60 = &_49;
        _61 = &_16;
        _59 = <<F as Float>::Int as PartialEq>::eq(move _60, move _61) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        switchInt(move _59) -> [0: bb42, otherwise: bb37];
    }

    bb37: {
        _63 = &_50;
        _64 = &_4;
        _62 = <<F as Float>::Int as PartialEq>::ne(move _63, move _64) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        switchInt(move _62) -> [0: bb41, otherwise: bb39];
    }

    bb39: {
        _66 = _49;
        _65 = <<F as Float>::Int as BitOr>::bitor(move _66, _29) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _0 = <F as Float>::from_repr(move _65) -> [return: bb127, unwind unreachable];
    }

    bb41: {
        _0 = <F as Float>::from_repr(_19) -> [return: bb127, unwind unreachable];
    }

    bb42: {
        _68 = &_50;
        _69 = &_16;
        _67 = <<F as Float>::Int as PartialEq>::eq(move _68, move _69) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        switchInt(move _67) -> [0: bb49, otherwise: bb44];
    }

    bb44: {
        _71 = &_49;
        _72 = &_4;
        _70 = <<F as Float>::Int as PartialEq>::ne(move _71, move _72) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _70) -> [0: bb48, otherwise: bb46];
    }

    bb46: {
        _74 = _50;
        _73 = <<F as Float>::Int as BitOr>::bitor(move _74, _29) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _0 = <F as Float>::from_repr(move _73) -> [return: bb127, unwind unreachable];
    }

    bb48: {
        _0 = <F as Float>::from_repr(_19) -> [return: bb127, unwind unreachable];
    }

    bb49: {
        _76 = &_49;
        _77 = &_4;
        _75 = <<F as Float>::Int as PartialEq>::eq(move _76, move _77) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        switchInt(move _75) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb127, unwind unreachable];
    }

    bb52: {
        _79 = &_50;
        _80 = &_4;
        _78 = <<F as Float>::Int as PartialEq>::eq(move _79, move _80) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        switchInt(move _78) -> [0: bb55, otherwise: bb54];
    }

    bb54: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb127, unwind unreachable];
    }

    bb55: {
        _82 = &_49;
        _83 = &_9;
        _81 = <<F as Float>::Int as PartialOrd>::lt(move _82, move _83) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        switchInt(move _81) -> [0: bb60, otherwise: bb57];
    }

    bb57: {
        _87 = _32;
        _86 = <F as Float>::normalize(move _87) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _84 = (_86.0: i32);
        _85 = (_86.1: <F as float::Float>::Int);
        _88 = CheckedAdd(_34, _84);
        assert(!move (_88.1: bool), "attempt to compute `{} + {}`, which would overflow", _34, _84) -> [success: bb59, unwind unreachable];
    }

    bb59: {
        _34 = move (_88.0: i32);
        _32 = _85;
        goto -> bb60;
    }

    bb60: {
        _90 = &_50;
        _91 = &_9;
        _89 = <<F as Float>::Int as PartialOrd>::lt(move _90, move _91) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        switchInt(move _89) -> [0: bb65, otherwise: bb62];
    }

    bb62: {
        _95 = _33;
        _94 = <F as Float>::normalize(move _95) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _92 = (_94.0: i32);
        _93 = (_94.1: <F as float::Float>::Int);
        _96 = CheckedAdd(_34, _92);
        assert(!move (_96.1: bool), "attempt to compute `{} + {}`, which would overflow", _34, _92) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _34 = move (_96.0: i32);
        _33 = _93;
        goto -> bb65;
    }

    bb65: {
        _98 = &mut _32;
        _99 = _9;
        _97 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _98, move _99) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _101 = &mut _33;
        _102 = _9;
        _100 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _101, move _102) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _107 = _32;
        _109 = _33;
        _108 = <<F as Float>::Int as Shl<u32>>::shl(move _109, _20) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _106 = <<F as Float>::Int as HInt>::widen_mul(move _107, move _108) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        _105 = <<<F as Float>::Int as HInt>::D as DInt>::lo_hi(move _106) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _103 = (_105.0: <F as float::Float>::Int);
        _104 = (_105.1: <F as float::Float>::Int);
        _110 = <<F as Float>::Int as CastInto<i32>>::cast(_23) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _111 = <<F as Float>::Int as CastInto<i32>>::cast(_26) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _114 = rustc_std_workspace_core::num::<impl i32>::wrapping_add(_110, _111) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        _115 = _34;
        _113 = rustc_std_workspace_core::num::<impl i32>::wrapping_add(move _114, move _115) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _116 = _8 as i32 (IntToInt);
        _112 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(move _113, move _116) -> [return: bb75, unwind unreachable];
    }

    bb75: {
        _120 = _104;
        _121 = _9;
        _119 = <<F as Float>::Int as BitAnd>::bitand(move _120, move _121) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _118 = &_119;
        _122 = &_4;
        _117 = <<F as Float>::Int as PartialEq>::ne(move _118, move _122) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        switchInt(move _117) -> [0: bb80, otherwise: bb78];
    }

    bb78: {
        _124 = _112;
        _123 = rustc_std_workspace_core::num::<impl i32>::wrapping_add(move _124, const 1_i32) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _112 = move _123;
        goto -> bb85;
    }

    bb80: {
        _127 = _104;
        _126 = <<F as Float>::Int as Shl<u32>>::shl(move _127, const 1_u32) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _129 = _103;
        _131 = CheckedSub(_5, const 1_u32);
        assert(!move (_131.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb82, unwind unreachable];
    }

    bb82: {
        _130 = move (_131.0: u32);
        _128 = <<F as Float>::Int as Shr<u32>>::shr(move _129, move _130) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _125 = <<F as Float>::Int as BitOr>::bitor(move _126, move _128) -> [return: bb84, unwind unreachable];
    }

    bb84: {
        _104 = move _125;
        _133 = &mut _103;
        _132 = <<F as Float>::Int as ShlAssign<i32>>::shl_assign(move _133, const 1_i32) -> [return: bb85, unwind unreachable];
    }

    bb85: {
        _135 = _112;
        _136 = _7 as i32 (IntToInt);
        _134 = Ge(move _135, move _136);
        switchInt(move _134) -> [0: bb88, otherwise: bb86];
    }

    bb86: {
        _138 = _16;
        _137 = <<F as Float>::Int as BitOr>::bitor(move _138, _29) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _0 = <F as Float>::from_repr(move _137) -> [return: bb127, unwind unreachable];
    }

    bb88: {
        _140 = _112;
        _139 = Le(move _140, const 0_i32);
        switchInt(move _139) -> [0: bb90, otherwise: bb89];
    }

    bb89: {
        _144 = _112;
        _143 = <i32 as CastInto<<F as Float>::Int>>::cast(move _144) -> [return: bb91, unwind unreachable];
    }

    bb90: {
        _180 = &mut _104;
        _179 = <<F as Float>::Int as BitAndAssign>::bitand_assign(move _180, _10) -> [return: bb115, unwind unreachable];
    }

    bb91: {
        _142 = <<F as Float>::Int as Int>::wrapping_sub(_3, move _143) -> [return: bb92, unwind unreachable];
    }

    bb92: {
        _141 = <<F as Float>::Int as CastInto<u32>>::cast(move _142) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _145 = Ge(_141, _5);
        switchInt(move _145) -> [0: bb95, otherwise: bb94];
    }

    bb94: {
        _0 = <F as Float>::from_repr(_29) -> [return: bb127, unwind unreachable];
    }

    bb95: {
        _146 = Lt(_141, _5);
        switchInt(move _146) -> [0: bb97, otherwise: bb96];
    }

    bb96: {
        _148 = _103;
        _150 = CheckedSub(_5, _141);
        assert(!move (_150.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, _141) -> [success: bb98, unwind unreachable];
    }

    bb97: {
        _163 = CheckedMul(const 2_u32, _5);
        assert(!move (_163.1: bool), "attempt to compute `{} * {}`, which would overflow", const 2_u32, _5) -> [success: bb105, unwind unreachable];
    }

    bb98: {
        _149 = move (_150.0: u32);
        _147 = <<F as Float>::Int as Shl<u32>>::shl(move _148, move _149) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _154 = _104;
        _156 = CheckedSub(_5, _141);
        assert(!move (_156.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, _141) -> [success: bb100, unwind unreachable];
    }

    bb100: {
        _155 = move (_156.0: u32);
        _153 = <<F as Float>::Int as Shl<u32>>::shl(move _154, move _155) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        _158 = _103;
        _157 = <<F as Float>::Int as Shr<u32>>::shr(move _158, _141) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _152 = <<F as Float>::Int as BitOr>::bitor(move _153, move _157) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _151 = <<F as Float>::Int as BitOr>::bitor(move _152, _147) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _103 = move _151;
        _160 = &mut _104;
        _159 = <<F as Float>::Int as ShrAssign<u32>>::shr_assign(move _160, _141) -> [return: bb118, unwind unreachable];
    }

    bb105: {
        _162 = move (_163.0: u32);
        _161 = Lt(_141, move _162);
        switchInt(move _161) -> [0: bb114, otherwise: bb106];
    }

    bb106: {
        _166 = _104;
        _169 = CheckedMul(const 2_u32, _5);
        assert(!move (_169.1: bool), "attempt to compute `{} * {}`, which would overflow", const 2_u32, _5) -> [success: bb107, unwind unreachable];
    }

    bb107: {
        _168 = move (_169.0: u32);
        _170 = CheckedSub(_168, _141);
        assert(!move (_170.1: bool), "attempt to compute `{} - {}`, which would overflow", move _168, _141) -> [success: bb108, unwind unreachable];
    }

    bb108: {
        _167 = move (_170.0: u32);
        _165 = <<F as Float>::Int as Shl<u32>>::shl(move _166, move _167) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _171 = _103;
        _164 = <<F as Float>::Int as BitOr>::bitor(move _165, move _171) -> [return: bb110, unwind unreachable];
    }

    bb110: {
        _174 = _104;
        _176 = CheckedSub(_141, _5);
        assert(!move (_176.1: bool), "attempt to compute `{} - {}`, which would overflow", _141, _5) -> [success: bb111, unwind unreachable];
    }

    bb111: {
        _175 = move (_176.0: u32);
        _173 = <<F as Float>::Int as Shr<u32>>::shr(move _174, move _175) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        _172 = <<F as Float>::Int as BitOr>::bitor(move _173, _164) -> [return: bb113, unwind unreachable];
    }

    bb113: {
        _103 = move _172;
        _177 = _4;
        _104 = move _177;
        goto -> bb118;
    }

    bb114: {
        _178 = _4;
        _104 = move _178;
        goto -> bb118;
    }

    bb115: {
        _182 = &mut _104;
        _185 = _112;
        _184 = <i32 as CastInto<<F as Float>::Int>>::cast(move _185) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _183 = <<F as Float>::Int as Shl<u32>>::shl(move _184, _6) -> [return: bb117, unwind unreachable];
    }

    bb117: {
        _181 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _182, move _183) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _187 = &mut _104;
        _186 = <<F as Float>::Int as BitOrAssign>::bitor_assign(move _187, _29) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _189 = &_103;
        _190 = &_11;
        _188 = <<F as Float>::Int as PartialOrd>::gt(move _189, move _190) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        switchInt(move _188) -> [0: bb122, otherwise: bb121];
    }

    bb121: {
        _192 = &mut _104;
        _191 = <<F as Float>::Int as AddAssign>::add_assign(move _192, _3) -> [return: bb122, unwind unreachable];
    }

    bb122: {
        _194 = &_103;
        _195 = &_11;
        _193 = <<F as Float>::Int as PartialEq>::eq(move _194, move _195) -> [return: bb123, unwind unreachable];
    }

    bb123: {
        switchInt(move _193) -> [0: bb126, otherwise: bb124];
    }

    bb124: {
        _197 = &mut _104;
        _199 = _104;
        _198 = <<F as Float>::Int as BitAnd>::bitand(move _199, _3) -> [return: bb125, unwind unreachable];
    }

    bb125: {
        _196 = <<F as Float>::Int as AddAssign>::add_assign(move _197, move _198) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _200 = _104;
        _0 = <F as Float>::from_repr(move _200) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        return;
    }
}

fn float::mul::__mulsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = float::mul::mul::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __mulsf3::__mulsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = float::mul::__mulsf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::mul::__muldf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = float::mul::mul::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __muldf3::__muldf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = float::mul::__muldf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::pow::pow(_1: F, _2: i32) -> F {
    debug a => _1;
    debug b => _2;
    let mut _0: F;
    let mut _3: F;
    let mut _7: u32;
    let mut _8: u32;
    let _9: ();
    let mut _10: &mut F;
    let mut _11: F;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let _15: ();
    let mut _16: &mut F;
    let mut _17: F;
    let mut _18: F;
    scope 1 {
        debug a => _3;
        let _4: bool;
        scope 2 {
            debug recip => _4;
            let mut _5: u32;
            scope 3 {
                debug pow => _5;
                let mut _6: F;
                scope 4 {
                    debug mul => _6;
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _4 = Lt(_2, const 0_i32);
        _5 = <i32 as Int>::abs_diff(_2, const 0_i32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const _;
        goto -> bb2;
    }

    bb2: {
        _8 = _5;
        _7 = BitAnd(move _8, const 1_u32);
        switchInt(move _7) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _10 = &mut _6;
        _11 = _3;
        _9 = <F as MulAssign>::mul_assign(move _10, move _11) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = const 1_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _5 = Shr(_5, const 1_i32);
        _14 = _5;
        switchInt(move _14) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        switchInt(_4) -> [0: bb9, otherwise: bb8];
    }

    bb7: {
        _16 = &mut _3;
        _17 = _3;
        _15 = <F as MulAssign>::mul_assign(move _16, move _17) -> [return: bb2, unwind unreachable];
    }

    bb8: {
        _18 = _6;
        _0 = <F as Div>::div(const _, move _18) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _6;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn float::pow::__powisf2(_1: f32, _2: i32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = float::pow::pow::<f32>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __powisf2::__powisf2(_1: f32, _2: i32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = float::pow::__powisf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::pow::__powidf2(_1: f64, _2: i32) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = float::pow::pow::<f64>(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __powidf2::__powidf2(_1: f64, _2: i32) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = float::pow::__powidf2(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sub::__subsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;
    let mut _3: f32;
    let mut _4: u32;
    let mut _5: u32;

    bb0: {
        _5 = <f32 as Float>::repr(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = BitXor(move _5, const _);
        _3 = <f32 as Float>::from_repr(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = add::__addsf3(_1, move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn __subsf3::__subsf3(_1: f32, _2: f32) -> f32 {
    debug a => _1;
    debug b => _2;
    let mut _0: f32;

    bb0: {
        _0 = sub::__subsf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sub::__subdf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;
    let mut _3: f64;
    let mut _4: u64;
    let mut _5: u64;

    bb0: {
        _5 = <f64 as Float>::repr(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = BitXor(move _5, const _);
        _3 = <f64 as Float>::from_repr(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = add::__adddf3(_1, move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn __subdf3::__subdf3(_1: f64, _2: f64) -> f64 {
    debug a => _1;
    debug b => _2;
    let mut _0: f64;

    bb0: {
        _0 = sub::__subdf3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::trunc::trunc(_1: F) -> R {
    debug a => _1;
    let mut _0: R;
    let _2: <F as float::Float>::Int;
    let mut _12: <F as float::Float>::Int;
    let mut _13: u32;
    let mut _14: (u32, bool);
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: (u32, bool);
    let mut _19: (u32, bool);
    let mut _21: u32;
    let mut _22: (u32, bool);
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: (u32, bool);
    let mut _33: (u32, bool);
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: (u32, bool);
    let mut _38: (u32, bool);
    let mut _42: u32;
    let mut _43: (u32, bool);
    let mut _46: (u32, bool);
    let mut _48: <F as float::Float>::Int;
    let mut _50: <F as float::Float>::Int;
    let mut _52: bool;
    let mut _53: &<F as float::Float>::Int;
    let _54: <F as float::Float>::Int;
    let mut _55: <F as float::Float>::Int;
    let mut _56: &<F as float::Float>::Int;
    let _57: <F as float::Float>::Int;
    let mut _58: <F as float::Float>::Int;
    let mut _59: <F as float::Float>::Int;
    let mut _60: <R as float::Float>::Int;
    let mut _61: <F as float::Float>::Int;
    let mut _62: <F as float::Float>::Int;
    let mut _64: u32;
    let mut _65: bool;
    let mut _66: <R as float::Float>::Int;
    let mut _67: <R as float::Float>::Int;
    let mut _68: <R as float::Float>::Int;
    let mut _70: <F as float::Float>::Int;
    let mut _71: bool;
    let mut _72: &<F as float::Float>::Int;
    let mut _73: &<F as float::Float>::Int;
    let _74: ();
    let mut _75: &mut <R as float::Float>::Int;
    let mut _76: bool;
    let mut _77: &<F as float::Float>::Int;
    let mut _78: &<F as float::Float>::Int;
    let _79: ();
    let mut _80: &mut <R as float::Float>::Int;
    let mut _81: <R as float::Float>::Int;
    let mut _82: <R as float::Float>::Int;
    let mut _83: bool;
    let mut _84: &<F as float::Float>::Int;
    let mut _85: &<F as float::Float>::Int;
    let mut _86: <R as float::Float>::Int;
    let mut _87: u32;
    let mut _88: bool;
    let _89: ();
    let mut _90: &mut <R as float::Float>::Int;
    let _91: ();
    let mut _92: &mut <R as float::Float>::Int;
    let mut _93: <R as float::Float>::Int;
    let mut _94: <R as float::Float>::Int;
    let mut _95: <F as float::Float>::Int;
    let mut _96: <F as float::Float>::Int;
    let mut _97: <F as float::Float>::Int;
    let mut _98: u32;
    let mut _99: (u32, bool);
    let mut _100: bool;
    let mut _101: &<F as float::Float>::Int;
    let mut _102: &<F as float::Float>::Int;
    let mut _103: <R as float::Float>::Int;
    let mut _104: u32;
    let mut _105: bool;
    let mut _107: <F as float::Float>::Int;
    let mut _108: <F as float::Float>::Int;
    let mut _110: u32;
    let mut _111: u32;
    let mut _112: (u32, bool);
    let mut _113: (u32, bool);
    let mut _114: (u32, bool);
    let mut _116: <F as float::Float>::Int;
    let mut _117: <F as float::Float>::Int;
    let mut _118: bool;
    let mut _120: bool;
    let mut _121: &<F as float::Float>::Int;
    let _122: <F as float::Float>::Int;
    let mut _123: u32;
    let mut _124: (u32, bool);
    let mut _125: &<F as float::Float>::Int;
    let mut _127: <F as float::Float>::Int;
    let mut _128: <F as float::Float>::Int;
    let mut _129: <R as float::Float>::Int;
    let mut _130: <F as float::Float>::Int;
    let mut _131: u32;
    let mut _132: (u32, bool);
    let mut _134: bool;
    let mut _135: &<F as float::Float>::Int;
    let mut _136: &<F as float::Float>::Int;
    let _137: ();
    let mut _138: &mut <R as float::Float>::Int;
    let mut _139: bool;
    let mut _140: &<F as float::Float>::Int;
    let mut _141: &<F as float::Float>::Int;
    let _142: ();
    let mut _143: &mut <R as float::Float>::Int;
    let mut _144: <R as float::Float>::Int;
    let mut _145: <R as float::Float>::Int;
    let mut _146: <R as float::Float>::Int;
    let mut _147: <R as float::Float>::Int;
    let mut _148: <R as float::Float>::Int;
    let mut _149: <F as float::Float>::Int;
    let mut _150: u32;
    let mut _151: (u32, bool);
    scope 1 {
        debug src_zero => const _;
        let _3: <F as float::Float>::Int;
        scope 2 {
            debug src_one => const _;
            let _4: u32;
            scope 3 {
                debug src_bits => const _;
                let _5: u32;
                scope 4 {
                    debug src_exp_bias => const _;
                    let _6: <F as float::Float>::Int;
                    scope 5 {
                        debug src_min_normal => const _;
                        let _7: <F as float::Float>::Int;
                        scope 6 {
                            debug src_significand_mask => const _;
                            let _8: <F as float::Float>::Int;
                            scope 7 {
                                debug src_infinity => const _;
                                let _9: <F as float::Float>::Int;
                                scope 8 {
                                    debug src_sign_mask => const _;
                                    let _10: <F as float::Float>::Int;
                                    scope 9 {
                                        debug src_abs_mask => _10;
                                        let _11: <F as float::Float>::Int;
                                        scope 10 {
                                            debug round_mask => _11;
                                            let _15: <F as float::Float>::Int;
                                            scope 11 {
                                                debug halfway => _15;
                                                let _20: <F as float::Float>::Int;
                                                scope 12 {
                                                    debug src_qnan => _20;
                                                    let _23: <F as float::Float>::Int;
                                                    scope 13 {
                                                        debug src_nan_code => _23;
                                                        let _24: <R as float::Float>::Int;
                                                        scope 14 {
                                                            debug dst_zero => const _;
                                                            let _25: <R as float::Float>::Int;
                                                            scope 15 {
                                                                debug dst_one => const _;
                                                                let _26: u32;
                                                                scope 16 {
                                                                    debug dst_bits => const _;
                                                                    let _27: u32;
                                                                    scope 17 {
                                                                        debug dst_inf_exp => const _;
                                                                        let _28: u32;
                                                                        scope 18 {
                                                                            debug dst_exp_bias => const _;
                                                                            let _29: <F as float::Float>::Int;
                                                                            scope 19 {
                                                                                debug underflow_exponent => _29;
                                                                                let _34: <F as float::Float>::Int;
                                                                                scope 20 {
                                                                                    debug overflow_exponent => _34;
                                                                                    let _39: <F as float::Float>::Int;
                                                                                    scope 21 {
                                                                                        debug underflow => _39;
                                                                                        let _40: <F as float::Float>::Int;
                                                                                        scope 22 {
                                                                                            debug overflow => _40;
                                                                                            let _41: <R as float::Float>::Int;
                                                                                            scope 23 {
                                                                                                debug dst_qnan => _41;
                                                                                                let _44: <R as float::Float>::Int;
                                                                                                scope 24 {
                                                                                                    debug dst_nan_code => _44;
                                                                                                    let _45: u32;
                                                                                                    scope 25 {
                                                                                                        debug sign_bits_delta => _45;
                                                                                                        let _47: <F as float::Float>::Int;
                                                                                                        scope 26 {
                                                                                                            debug a_abs => _47;
                                                                                                            let _49: <F as float::Float>::Int;
                                                                                                            scope 27 {
                                                                                                                debug sign => _49;
                                                                                                                let mut _51: <R as float::Float>::Int;
                                                                                                                scope 28 {
                                                                                                                    debug abs_result => _51;
                                                                                                                    let _63: u32;
                                                                                                                    let _106: u32;
                                                                                                                    scope 29 {
                                                                                                                        debug tmp => _63;
                                                                                                                        let _69: <F as float::Float>::Int;
                                                                                                                        scope 30 {
                                                                                                                            debug round_bits => _69;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    scope 31 {
                                                                                                                        debug a_exp => _106;
                                                                                                                        let _109: u32;
                                                                                                                        scope 32 {
                                                                                                                            debug shift => _109;
                                                                                                                            let _115: <F as float::Float>::Int;
                                                                                                                            scope 33 {
                                                                                                                                debug significand => _115;
                                                                                                                                let _119: <F as float::Float>::Int;
                                                                                                                                scope 34 {
                                                                                                                                    debug sticky => _119;
                                                                                                                                    let _126: <F as float::Float>::Int;
                                                                                                                                    scope 35 {
                                                                                                                                        debug denormalized_significand => _126;
                                                                                                                                        let _133: <F as float::Float>::Int;
                                                                                                                                        scope 36 {
                                                                                                                                            debug round_bits => _133;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const _;
        _3 = const _;
        _4 = const _;
        _5 = const _;
        _6 = const _;
        _7 = const _;
        _8 = const _;
        _9 = const _;
        _10 = <<F as Float>::Int as Sub>::sub(_9, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _14 = CheckedSub(const _, const _);
        assert(!move (_14.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _13 = move (_14.0: u32);
        _12 = <<F as Float>::Int as Shl<u32>>::shl(_3, move _13) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = <<F as Float>::Int as Sub>::sub(move _12, _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _18 = CheckedSub(const _, const _);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _17 = move (_18.0: u32);
        _19 = CheckedSub(_17, const 1_u32);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", move _17, const 1_u32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _16 = move (_19.0: u32);
        _15 = <<F as Float>::Int as Shl<u32>>::shl(_3, move _16) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _22 = CheckedSub(const _, const 1_u32);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _21 = move (_22.0: u32);
        _20 = <<F as Float>::Int as Shl<u32>>::shl(_3, move _21) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _23 = <<F as Float>::Int as Sub>::sub(_20, _3) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _24 = const _;
        _25 = const _;
        _26 = const _;
        _27 = const _;
        _28 = const _;
        _32 = CheckedAdd(_5, const 1_u32);
        assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_u32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _31 = move (_32.0: u32);
        _33 = CheckedSub(_31, _28);
        assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", move _31, _28) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _30 = move (_33.0: u32);
        _29 = <u32 as CastInto<<F as Float>::Int>>::cast(move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _37 = CheckedAdd(_5, _27);
        assert(!move (_37.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, _27) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _36 = move (_37.0: u32);
        _38 = CheckedSub(_36, _28);
        assert(!move (_38.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, _28) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _35 = move (_38.0: u32);
        _34 = <u32 as CastInto<<F as Float>::Int>>::cast(move _35) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _39 = <<F as Float>::Int as Shl<u32>>::shl(_29, const _) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _40 = <<F as Float>::Int as Shl<u32>>::shl(_34, const _) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _43 = CheckedSub(const _, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _42 = move (_43.0: u32);
        _41 = <<R as Float>::Int as Shl<u32>>::shl(const _, move _42) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _44 = <<R as Float>::Int as Sub>::sub(_41, _25) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _46 = CheckedSub(const _, const _);
        assert(!move (_46.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _45 = move (_46.0: u32);
        _48 = <F as Float>::repr(_1) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _47 = <<F as Float>::Int as BitAnd>::bitand(move _48, _10) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _50 = <F as Float>::repr(_1) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _49 = <<F as Float>::Int as BitAnd>::bitand(move _50, _9) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _55 = _47;
        _54 = <<F as Float>::Int as Int>::wrapping_sub(move _55, _39) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _53 = &_54;
        _58 = _47;
        _59 = _40;
        _57 = <<F as Float>::Int as Int>::wrapping_sub(move _58, move _59) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _56 = &_57;
        _52 = <<F as Float>::Int as PartialOrd>::lt(move _53, move _56) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        switchInt(move _52) -> [0: bb44, otherwise: bb30];
    }

    bb30: {
        _62 = _47;
        _61 = <<F as Float>::Int as Shr<u32>>::shr(move _62, _45) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _60 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _61) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _51 = move _60;
        _64 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_5, _28) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _65 = Lt(const _, const 32_u32);
        assert(move _65, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _63 = Shl(move _64, const _);
        _67 = _51;
        _68 = <u32 as CastInto<<R as Float>::Int>>::cast(_63) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _66 = <<R as Float>::Int as Int>::wrapping_sub(move _67, move _68) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _51 = move _66;
        _70 = _47;
        _69 = <<F as Float>::Int as BitAnd>::bitand(move _70, _11) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _72 = &_69;
        _73 = &_15;
        _71 = <<F as Float>::Int as PartialOrd>::gt(move _72, move _73) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        switchInt(move _71) -> [0: bb40, otherwise: bb39];
    }

    bb39: {
        _75 = &mut _51;
        _74 = <<R as Float>::Int as AddAssign>::add_assign(move _75, _25) -> [return: bb89, unwind unreachable];
    }

    bb40: {
        _77 = &_69;
        _78 = &_15;
        _76 = <<F as Float>::Int as PartialEq>::eq(move _77, move _78) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        switchInt(move _76) -> [0: bb89, otherwise: bb42];
    }

    bb42: {
        _80 = &mut _51;
        _82 = _51;
        _81 = <<R as Float>::Int as BitAnd>::bitand(move _82, _25) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _79 = <<R as Float>::Int as AddAssign>::add_assign(move _80, move _81) -> [return: bb89, unwind unreachable];
    }

    bb44: {
        _84 = &_47;
        _85 = &_8;
        _83 = <<F as Float>::Int as PartialOrd>::gt(move _84, move _85) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        switchInt(move _83) -> [0: bb55, otherwise: bb46];
    }

    bb46: {
        _88 = Lt(const _, const 32_u32);
        assert(move _88, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _87 = Shl(_27, const _);
        _86 = <u32 as CastInto<<R as Float>::Int>>::cast(move _87) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        _51 = move _86;
        _90 = &mut _51;
        _89 = <<R as Float>::Int as BitOrAssign>::bitor_assign(move _90, _41) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _92 = &mut _51;
        _97 = _47;
        _96 = <<F as Float>::Int as BitAnd>::bitand(move _97, _23) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _99 = CheckedSub(const _, const _);
        assert(!move (_99.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb51, unwind unreachable];
    }

    bb51: {
        _98 = move (_99.0: u32);
        _95 = <<F as Float>::Int as Shr<u32>>::shr(move _96, move _98) -> [return: bb52, unwind unreachable];
    }

    bb52: {
        _94 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _95) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _93 = <<R as Float>::Int as BitAnd>::bitand(_44, move _94) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _91 = <<R as Float>::Int as BitOrAssign>::bitor_assign(move _92, move _93) -> [return: bb89, unwind unreachable];
    }

    bb55: {
        _101 = &_47;
        _102 = &_40;
        _100 = <<F as Float>::Int as PartialOrd>::ge(move _101, move _102) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        switchInt(move _100) -> [0: bb60, otherwise: bb57];
    }

    bb57: {
        _105 = Lt(const _, const 32_u32);
        assert(move _105, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb58, unwind unreachable];
    }

    bb58: {
        _104 = Shl(_27, const _);
        _103 = <u32 as CastInto<<R as Float>::Int>>::cast(move _104) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _51 = move _103;
        goto -> bb89;
    }

    bb60: {
        _108 = _47;
        _107 = <<F as Float>::Int as Shr<u32>>::shr(move _108, const _) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        _106 = <<F as Float>::Int as CastInto<u32>>::cast(move _107) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _112 = CheckedSub(_5, _28);
        assert(!move (_112.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, _28) -> [success: bb63, unwind unreachable];
    }

    bb63: {
        _111 = move (_112.0: u32);
        _113 = CheckedSub(_111, _106);
        assert(!move (_113.1: bool), "attempt to compute `{} - {}`, which would overflow", move _111, _106) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _110 = move (_113.0: u32);
        _114 = CheckedAdd(_110, const 1_u32);
        assert(!move (_114.1: bool), "attempt to compute `{} + {}`, which would overflow", move _110, const 1_u32) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _109 = move (_114.0: u32);
        _117 = <F as Float>::repr(_1) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        _116 = <<F as Float>::Int as BitAnd>::bitand(move _117, _7) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _115 = <<F as Float>::Int as BitOr>::bitor(move _116, _6) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _118 = Gt(_109, const _);
        switchInt(move _118) -> [0: bb70, otherwise: bb69];
    }

    bb69: {
        _51 = _24;
        goto -> bb89;
    }

    bb70: {
        _124 = CheckedSub(_4, _109);
        assert(!move (_124.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, _109) -> [success: bb71, unwind unreachable];
    }

    bb71: {
        _123 = move (_124.0: u32);
        _122 = <<F as Float>::Int as Shl<u32>>::shl(_115, move _123) -> [return: bb72, unwind unreachable];
    }

    bb72: {
        _121 = &_122;
        _125 = &_2;
        _120 = <<F as Float>::Int as PartialEq>::ne(move _121, move _125) -> [return: bb73, unwind unreachable];
    }

    bb73: {
        switchInt(move _120) -> [0: bb75, otherwise: bb74];
    }

    bb74: {
        _119 = _3;
        goto -> bb76;
    }

    bb75: {
        _119 = _2;
        goto -> bb76;
    }

    bb76: {
        _127 = <<F as Float>::Int as Shr<u32>>::shr(_115, _109) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        _128 = _119;
        _126 = <<F as Float>::Int as BitOr>::bitor(move _127, move _128) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _132 = CheckedSub(const _, const _);
        assert(!move (_132.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb79, unwind unreachable];
    }

    bb79: {
        _131 = move (_132.0: u32);
        _130 = <<F as Float>::Int as Shr<u32>>::shr(_126, move _131) -> [return: bb80, unwind unreachable];
    }

    bb80: {
        _129 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _130) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _51 = move _129;
        _133 = <<F as Float>::Int as BitAnd>::bitand(_126, _11) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _135 = &_133;
        _136 = &_15;
        _134 = <<F as Float>::Int as PartialOrd>::gt(move _135, move _136) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        switchInt(move _134) -> [0: bb85, otherwise: bb84];
    }

    bb84: {
        _138 = &mut _51;
        _137 = <<R as Float>::Int as AddAssign>::add_assign(move _138, _25) -> [return: bb89, unwind unreachable];
    }

    bb85: {
        _140 = &_133;
        _141 = &_15;
        _139 = <<F as Float>::Int as PartialEq>::eq(move _140, move _141) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        switchInt(move _139) -> [0: bb89, otherwise: bb87];
    }

    bb87: {
        _143 = &mut _51;
        _145 = _51;
        _144 = <<R as Float>::Int as BitAnd>::bitand(move _145, _25) -> [return: bb88, unwind unreachable];
    }

    bb88: {
        _142 = <<R as Float>::Int as AddAssign>::add_assign(move _143, move _144) -> [return: bb89, unwind unreachable];
    }

    bb89: {
        _147 = _51;
        _151 = CheckedSub(_4, _26);
        assert(!move (_151.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, _26) -> [success: bb90, unwind unreachable];
    }

    bb90: {
        _150 = move (_151.0: u32);
        _149 = <<F as Float>::Int as Int>::wrapping_shr(_49, move _150) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _148 = <<F as Float>::Int as CastInto<<R as Float>::Int>>::cast(move _149) -> [return: bb92, unwind unreachable];
    }

    bb92: {
        _146 = <<R as Float>::Int as BitOr>::bitor(move _147, move _148) -> [return: bb93, unwind unreachable];
    }

    bb93: {
        _0 = <R as Float>::from_repr(move _146) -> [return: bb94, unwind unreachable];
    }

    bb94: {
        return;
    }
}

fn float::trunc::__truncdfsf2(_1: f64) -> f32 {
    debug a => _1;
    let mut _0: f32;

    bb0: {
        _0 = float::trunc::trunc::<f64, f32>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __truncdfsf2::__truncdfsf2(_1: f64) -> f32 {
    debug a => _1;
    let mut _0: f32;

    bb0: {
        _0 = float::trunc::__truncdfsf2(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

const Float::EXPONENT_BITS: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: (u32, bool);
    let mut _3: (u32, bool);

    bb0: {
        StorageLive(_1);
        _2 = CheckedSub(const _, const _);
        assert(!move (_2.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const _) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = move (_2.0: u32);
        _3 = CheckedSub(_1, const 1_u32);
        assert(!move (_3.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1, const 1_u32) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move (_3.0: u32);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const Float::EXPONENT_MAX: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: bool;
    let mut _3: (u32, bool);

    bb0: {
        StorageLive(_1);
        _2 = Lt(const _, const 32_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const _);
        _3 = CheckedSub(_1, const 1_u32);
        assert(!move (_3.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1, const 1_u32) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move (_3.0: u32);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const Float::EXPONENT_BIAS: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: bool;

    bb0: {
        _1 = const 1_i32 as u32 (IntToInt);
        _2 = Lt(move _1, const 32_u32);
        assert(move _2, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shr(const _, const 1_i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::ZERO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0f32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::ONE: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1f32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 32_u32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGNIFICAND_BITS: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 23_u32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGN_MASK: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: (u32, bool);
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = CheckedSub(const _, const 1_u32);
        assert(!move (_2.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = move (_2.0: u32);
        _3 = Lt(_1, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", _1) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = Shl(const 1_u32, move _1);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGNIFICAND_MASK: u32 = {
    let mut _0: u32;
    let mut _1: u32;
    let mut _2: bool;
    let mut _3: (u32, bool);

    bb0: {
        StorageLive(_1);
        _2 = Lt(const _, const 32_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u32, const _);
        _3 = CheckedSub(_1, const 1_u32);
        assert(!move (_3.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1, const 1_u32) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move (_3.0: u32);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::IMPLICIT_BIT: u32 = {
    let mut _0: u32;
    let mut _1: bool;

    bb0: {
        _1 = Lt(const _, const 32_u32);
        assert(move _1, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_u32, const _);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::EXPONENT_MASK: u32 = {
    let mut _0: u32;
    let mut _1: u32;

    bb0: {
        StorageLive(_1);
        _1 = BitOr(const _, const _);
        _0 = Not(move _1);
        StorageDead(_1);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::repr(_1: f32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::signed_repr(_1: f32) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: u32;

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as i32 (IntToInt);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::eq_repr(_1: f32, _2: f32) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u32;
    let mut _6: u32;

    bb0: {
        _3 = f32::<impl f32>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _4 = f32::<impl f32>::is_nan(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb8;
    }

    bb5: {
        _5 = <f32 as Float>::repr(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _6 = <f32 as Float>::repr(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Eq(move _5, move _6);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::sign(_1: f32) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: i32;

    bb0: {
        _2 = <f32 as Float>::signed_repr(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Lt(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::exp(_1: f32) -> i16 {
    debug self => _1;
    let mut _0: i16;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: bool;

    bb0: {
        _4 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(move _4, const _);
        _5 = Lt(const _, const 32_u32);
        assert(move _5, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shr(move _3, const _);
        _0 = move _2 as i16 (IntToInt);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::frac(_1: f32) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: u32;

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = BitAnd(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::imp_frac(_1: f32) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: u32;

    bb0: {
        _2 = <f32 as Float>::frac(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = BitOr(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::from_repr(_1: u32) -> f32 {
    debug a => _1;
    let mut _0: f32;

    bb0: {
        _0 = f32::<impl f32>::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::from_parts(_1: bool, _2: u32, _3: u32) -> f32 {
    debug sign => _1;
    debug exponent => _2;
    debug significand => _3;
    let mut _0: f32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: (u32, bool);
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;

    bb0: {
        _7 = _1 as u32 (IntToInt);
        _9 = CheckedSub(const _, const 1_u32);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _8 = move (_9.0: u32);
        _10 = Lt(_8, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", _8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shl(_7, move _8);
        _13 = Lt(const _, const 32_u32);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _12 = Shl(_2, const _);
        _11 = BitAnd(move _12, const _);
        _5 = BitOr(move _6, move _11);
        _14 = BitAnd(_3, const _);
        _4 = BitOr(move _5, move _14);
        _0 = <f32 as Float>::from_repr(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::normalize(_1: u32) -> (i32, u32) {
    debug significand => _1;
    let mut _0: (i32, u32);
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: i32;
    let mut _8: i32;
    let mut _9: u32;
    let mut _10: bool;
    scope 1 {
        debug shift => _2;
    }

    bb0: {
        _3 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Lt(const _, const 32_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const _, const _);
        _4 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _3, move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = _2 as i32 (IntToInt);
        _7 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(const 1_i32, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = Lt(_2, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", _2) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _9 = Shl(_1, _2);
        _0 = (move _7, move _9);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::is_subnormal(_1: f32) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u32;
    let mut _3: u32;

    bb0: {
        _3 = <f32 as Float>::repr(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, const _);
        _0 = Eq(move _2, const _);
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::ZERO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0f64;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::ONE: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1f64;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 64_u32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGNIFICAND_BITS: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 52_u32;
        return;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGN_MASK: u64 = {
    let mut _0: u64;
    let mut _1: u32;
    let mut _2: (u32, bool);
    let mut _3: bool;

    bb0: {
        StorageLive(_1);
        _2 = CheckedSub(const _, const 1_u32);
        assert(!move (_2.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = move (_2.0: u32);
        _3 = Lt(_1, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", _1) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = Shl(const 1_u64, move _1);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::SIGNIFICAND_MASK: u64 = {
    let mut _0: u64;
    let mut _1: u64;
    let mut _2: bool;
    let mut _3: (u64, bool);

    bb0: {
        StorageLive(_1);
        _2 = Lt(const _, const 64_u32);
        assert(move _2, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind: bb3];
    }

    bb1: {
        _1 = Shl(const 1_u64, const _);
        _3 = CheckedSub(_1, const 1_u64);
        assert(!move (_3.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1, const 1_u64) -> [success: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move (_3.0: u64);
        StorageDead(_1);
        return;
    }

    bb3 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::IMPLICIT_BIT: u64 = {
    let mut _0: u64;
    let mut _1: bool;

    bb0: {
        _1 = Lt(const _, const 64_u32);
        assert(move _1, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = Shl(const 1_u64, const _);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::EXPONENT_MASK: u64 = {
    let mut _0: u64;
    let mut _1: u64;

    bb0: {
        StorageLive(_1);
        _1 = BitOr(const _, const _);
        _0 = Not(move _1);
        StorageDead(_1);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::repr(_1: f64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::signed_repr(_1: f64) -> i64 {
    debug self => _1;
    let mut _0: i64;
    let mut _2: u64;

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as i64 (IntToInt);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::eq_repr(_1: f64, _2: f64) -> bool {
    debug self => _1;
    debug rhs => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u64;
    let mut _6: u64;

    bb0: {
        _3 = f64::<impl f64>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _4 = f64::<impl f64>::is_nan(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb8;
    }

    bb5: {
        _5 = <f64 as Float>::repr(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _6 = <f64 as Float>::repr(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = Eq(move _5, move _6);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::sign(_1: f64) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: i64;

    bb0: {
        _2 = <f64 as Float>::signed_repr(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Lt(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::exp(_1: f64) -> i16 {
    debug self => _1;
    let mut _0: i16;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: bool;

    bb0: {
        _4 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(move _4, const _);
        _5 = Lt(const _, const 64_u32);
        assert(move _5, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shr(move _3, const _);
        _0 = move _2 as i16 (IntToInt);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::frac(_1: f64) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u64;

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = BitAnd(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::imp_frac(_1: f64) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u64;

    bb0: {
        _2 = <f64 as Float>::frac(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = BitOr(move _2, const _);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::from_repr(_1: u64) -> f64 {
    debug a => _1;
    let mut _0: f64;

    bb0: {
        _0 = f64::<impl f64>::from_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::from_parts(_1: bool, _2: u64, _3: u64) -> f64 {
    debug sign => _1;
    debug exponent => _2;
    debug significand => _3;
    let mut _0: f64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: (u32, bool);
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: bool;
    let mut _14: u64;

    bb0: {
        _7 = _1 as u64 (IntToInt);
        _9 = CheckedSub(const _, const 1_u32);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _8 = move (_9.0: u32);
        _10 = Lt(_8, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", _8) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shl(_7, move _8);
        _13 = Lt(const _, const 64_u32);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _12 = Shl(_2, const _);
        _11 = BitAnd(move _12, const _);
        _5 = BitOr(move _6, move _11);
        _14 = BitAnd(_3, const _);
        _4 = BitOr(move _5, move _14);
        _0 = <f64 as Float>::from_repr(move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::normalize(_1: u64) -> (i32, u64) {
    debug significand => _1;
    let mut _0: (i32, u64);
    let _2: u32;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: u64;
    let mut _6: bool;
    let mut _7: i32;
    let mut _8: i32;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: bool;
    scope 1 {
        debug shift => _2;
    }

    bb0: {
        _3 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Lt(const _, const 64_u32);
        assert(move _6, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shl(const _, const _);
        _4 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _3, move _4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = _2 as i32 (IntToInt);
        _7 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(const 1_i32, move _8) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = _2 as u64 (IntToInt);
        _11 = Lt(_10, const 64_u64);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", _10) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _9 = Shl(_1, _10);
        _0 = (move _7, move _9);
        return;
    }
}

fn float::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/float/mod.rs:107:9: 107:27>::is_subnormal(_1: f64) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = <f64 as Float>::repr(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, const _);
        _0 = Eq(move _2, const _);
        return;
    }
}

fn u128_divide_sparc(_1: u128, _2: u128, _3: &mut u128) -> u128 {
    debug duo => _1;
    debug div => _2;
    debug rem => _3;
    let mut _0: u128;
    let _4: u64;
    let mut _6: u128;
    let mut _7: u32;
    let mut _8: bool;
    let mut _11: u128;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: (bool, bool, bool);
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: !;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: bool;
    let mut _25: (usize, bool);
    let mut _26: (usize, bool);
    let mut _28: usize;
    let mut _29: bool;
    let mut _31: usize;
    let mut _32: bool;
    let mut _36: u128;
    let mut _37: u128;
    let mut _38: bool;
    let mut _39: i128;
    let mut _40: u64;
    let mut _42: u128;
    let mut _43: u128;
    let mut _44: u32;
    let mut _45: bool;
    let mut _47: u64;
    let mut _48: u128;
    let mut _49: u64;
    let mut _50: u64;
    let mut _51: u64;
    let mut _52: u64;
    let mut _53: u32;
    let mut _54: bool;
    let mut _55: u32;
    let mut _56: bool;
    let mut _57: bool;
    let mut _59: u64;
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: u128;
    let mut _63: u32;
    let mut _64: bool;
    let mut _65: u128;
    let mut _66: u64;
    let mut _67: u64;
    let mut _68: u32;
    let mut _69: bool;
    let mut _71: u32;
    let mut _74: (u64, u64);
    let mut _76: u64;
    let mut _77: u32;
    let mut _78: u128;
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: u64;
    let mut _82: u32;
    let mut _83: bool;
    let mut _86: (u64, u64);
    let mut _88: u64;
    let mut _89: u32;
    let mut _90: u64;
    let mut _91: u32;
    let mut _92: bool;
    let mut _95: (u64, u64);
    let mut _96: u128;
    let mut _97: u128;
    let mut _98: u128;
    let mut _99: u128;
    let mut _100: u32;
    let mut _101: bool;
    let mut _102: u128;
    let mut _103: u128;
    let mut _104: u32;
    let mut _105: bool;
    let mut _110: u128;
    let mut _111: u128;
    let mut _112: u128;
    let mut _113: u64;
    let mut _114: u32;
    let mut _115: bool;
    let mut _116: bool;
    let mut _117: u128;
    let mut _118: u128;
    let mut _119: u128;
    let mut _120: u32;
    let mut _121: bool;
    let mut _123: i32;
    let mut _124: (i32, bool);
    let mut _125: u32;
    let mut _126: bool;
    let mut _128: i32;
    let mut _129: (i32, bool);
    let mut _130: u32;
    let mut _131: bool;
    let mut _134: u128;
    let mut _135: u128;
    let mut _136: bool;
    let mut _137: i128;
    let mut _138: u64;
    let mut _140: u128;
    let mut _141: u128;
    let mut _142: u32;
    let mut _143: bool;
    let mut _145: u64;
    let mut _146: u128;
    let mut _147: u64;
    let mut _148: u128;
    let mut _149: u128;
    let mut _150: u64;
    let mut _151: u128;
    let mut _152: u64;
    let mut _153: u128;
    let mut _154: u128;
    let mut _155: u32;
    let mut _156: bool;
    let mut _157: u32;
    let mut _158: bool;
    let mut _159: u32;
    let mut _160: bool;
    let mut _161: bool;
    let mut _165: bool;
    let mut _167: bool;
    let mut _170: u128;
    let mut _171: u128;
    let mut _172: bool;
    let mut _173: i128;
    let mut _174: u64;
    let mut _175: bool;
    let mut _176: u128;
    let mut _177: u128;
    let mut _178: u64;
    let mut _179: u32;
    let mut _180: bool;
    let mut _181: u32;
    let mut _182: bool;
    scope 1 {
        debug duo_lo => _4;
        let _5: u64;
        scope 2 {
            debug duo_hi => _5;
            let _9: u64;
            scope 3 {
                debug div_lo => _9;
                let _10: u64;
                scope 4 {
                    debug div_hi => _10;
                    let _19: (u64, u64);
                    let _23: usize;
                    let _58: (u64, u64);
                    let _70: u64;
                    let _106: u64;
                    scope 5 {
                        debug tmp => _19;
                    }
                    scope 6 {
                        debug norm_shift => _23;
                        let _24: usize;
                        scope 7 {
                            debug shl => _24;
                            let mut _27: u128;
                            scope 8 {
                                debug div => _27;
                                let mut _30: u64;
                                scope 9 {
                                    debug pow_lo => _30;
                                    let mut _33: u64;
                                    scope 10 {
                                        debug quo_lo => _33;
                                        let mut _34: u128;
                                        scope 11 {
                                            debug duo => _34;
                                            let _35: u128;
                                            scope 12 {
                                                debug sub => _35;
                                                let _41: u64;
                                                scope 13 {
                                                    debug duo_hi => _41;
                                                    let _46: (u64, u64);
                                                    scope 14 {
                                                        debug tmp => _46;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 15 {
                        debug tmp => _58;
                    }
                    scope 16 {
                        debug div_0 => _70;
                        let _72: u64;
                        let _73: u64;
                        scope 17 {
                            debug quo_hi => _72;
                            debug rem_3 => _73;
                            let _75: u64;
                            scope 18 {
                                debug duo_mid => _75;
                                let _84: u64;
                                let _85: u64;
                                scope 19 {
                                    debug quo_1 => _84;
                                    debug rem_2 => _85;
                                    let _87: u64;
                                    scope 20 {
                                        debug duo_lo => _87;
                                        let _93: u64;
                                        let _94: u64;
                                        scope 21 {
                                            debug quo_0 => _93;
                                            debug rem_1 => _94;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 22 {
                        debug duo_lo => _106;
                        let _107: (u64, u64);
                        scope 23 {
                            debug tmp => _107;
                            let _108: u64;
                            scope 24 {
                                debug quo_hi => _108;
                                let mut _109: u128;
                                scope 25 {
                                    debug duo => _109;
                                    let mut _122: u128;
                                    scope 26 {
                                        debug div => _122;
                                        let mut _127: u64;
                                        scope 27 {
                                            debug pow_lo => _127;
                                            let mut _132: u64;
                                            scope 28 {
                                                debug quo_lo => _132;
                                                let _133: u128;
                                                scope 29 {
                                                    debug sub => _133;
                                                    let _139: u64;
                                                    scope 30 {
                                                        debug duo_hi => _139;
                                                        let _144: (u64, u64);
                                                        scope 31 {
                                                            debug tmp => _144;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 32 {
                        debug div_original => _2;
                        let _162: usize;
                        scope 33 {
                            debug shl => _162;
                            let mut _163: u128;
                            scope 34 {
                                debug duo => _163;
                                let mut _164: u128;
                                scope 35 {
                                    debug div => _164;
                                    let mut _166: u64;
                                    scope 36 {
                                        debug pow_lo => _166;
                                        let mut _168: u64;
                                        scope 37 {
                                            debug quo_lo => _168;
                                            let _169: u128;
                                            scope 38 {
                                                debug sub => _169;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = _1 as u64 (IntToInt);
        _7 = const 64_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 128_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _6 = Shr(_1, const 64_i32);
        _5 = move _6 as u64 (IntToInt);
        _9 = _2 as u64 (IntToInt);
        _12 = const 64_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 128_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Shr(_2, const 64_i32);
        _10 = move _11 as u64 (IntToInt);
        _15 = Eq(_9, const 0_u64);
        _16 = Eq(_10, const 0_u64);
        _17 = Eq(_5, const 0_u64);
        _14 = (move _15, move _16, move _17);
        switchInt((_14.0: bool)) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        switchInt((_14.1: bool)) -> [0: bb4, otherwise: bb10];
    }

    bb4: {
        switchInt((_14.1: bool)) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        switchInt((_14.2: bool)) -> [0: bb6, otherwise: bb11];
    }

    bb6: {
        _161 = Lt(_1, _2);
        switchInt(move _161) -> [0: bb69, otherwise: bb68];
    }

    bb7: {
        switchInt((_14.0: bool)) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        switchInt((_14.2: bool)) -> [0: bb14, otherwise: bb12];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _18 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }

    bb11: {
        (*_3) = _1;
        _0 = const 0_u128;
        goto -> bb80;
    }

    bb12: {
        _19 = specialized_div_rem::u64_by_u64_div_rem(_4, _9) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _20 = (_19.1: u64);
        (*_3) = move _20 as u128 (IntToInt);
        _21 = (_19.0: u64);
        _0 = move _21 as u128 (IntToInt);
        goto -> bb80;
    }

    bb14: {
        _22 = Lt(_5, _9);
        switchInt(move _22) -> [0: bb33, otherwise: bb15];
    }

    bb15: {
        _23 = specialized_div_rem::u64_normalization_shift(_9, _5, const false) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        switchInt(move _23) -> [0: bb17, otherwise: bb19];
    }

    bb17: {
        _25 = CheckedSub(const 64_usize, const 1_usize);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_usize, const 1_usize) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _24 = move (_25.0: usize);
        goto -> bb21;
    }

    bb19: {
        _26 = CheckedSub(const 64_usize, _23);
        assert(!move (_26.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_usize, _23) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _24 = move (_26.0: usize);
        goto -> bb21;
    }

    bb21: {
        _28 = _24;
        _29 = Lt(_28, const 128_usize);
        assert(move _29, "attempt to shift left by `{}`, which would overflow", _28) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _27 = Shl(_2, move _28);
        _31 = _24;
        _32 = Lt(_31, const 64_usize);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", _31) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _30 = Shl(const 1_u64, move _31);
        _33 = const 0_u64;
        _34 = _1;
        goto -> bb24;
    }

    bb24: {
        _36 = _34;
        _37 = _27;
        _35 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(move _36, move _37) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _39 = _35 as i128 (IntToInt);
        _38 = Le(const 0_i128, move _39);
        switchInt(move _38) -> [0: bb30, otherwise: bb26];
    }

    bb26: {
        _34 = _35;
        _40 = _30;
        _33 = BitOr(_33, move _40);
        _43 = _34;
        _44 = const 64_i32 as u32 (IntToInt);
        _45 = Lt(move _44, const 128_u32);
        assert(move _45, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _42 = Shr(move _43, const 64_i32);
        _41 = move _42 as u64 (IntToInt);
        switchInt(move _41) -> [0: bb28, otherwise: bb30];
    }

    bb28: {
        _48 = _34;
        _47 = move _48 as u64 (IntToInt);
        _46 = specialized_div_rem::u64_by_u64_div_rem(move _47, _9) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _49 = (_46.1: u64);
        (*_3) = move _49 as u128 (IntToInt);
        _51 = _33;
        _52 = (_46.0: u64);
        _50 = BitOr(move _51, move _52);
        _0 = move _50 as u128 (IntToInt);
        goto -> bb80;
    }

    bb30: {
        _53 = const 1_i32 as u32 (IntToInt);
        _54 = Lt(move _53, const 128_u32);
        assert(move _54, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _27 = Shr(_27, const 1_i32);
        _55 = const 1_i32 as u32 (IntToInt);
        _56 = Lt(move _55, const 64_u32);
        assert(move _56, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _30 = Shr(_30, const 1_i32);
        goto -> bb24;
    }

    bb33: {
        _57 = Eq(_5, _9);
        switchInt(move _57) -> [0: bb37, otherwise: bb34];
    }

    bb34: {
        _59 = _1 as u64 (IntToInt);
        _60 = _2 as u64 (IntToInt);
        _58 = specialized_div_rem::u64_by_u64_div_rem(move _59, move _60) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _61 = (_58.1: u64);
        (*_3) = move _61 as u128 (IntToInt);
        _63 = const 64_i32 as u32 (IntToInt);
        _64 = Lt(move _63, const 128_u32);
        assert(move _64, "attempt to shift left by `{}`, which would overflow", const 64_i32) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _62 = Shl(const 1_u128, const 64_i32);
        _66 = (_58.0: u64);
        _65 = move _66 as u128 (IntToInt);
        _0 = BitOr(move _62, move _65);
        goto -> bb80;
    }

    bb37: {
        _68 = const 32_i32 as u32 (IntToInt);
        _69 = Lt(move _68, const 64_u32);
        assert(move _69, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb38, unwind unreachable];
    }

    bb38: {
        _67 = Shr(_9, const 32_i32);
        switchInt(move _67) -> [0: bb39, otherwise: bb48];
    }

    bb39: {
        _71 = _9 as u32 (IntToInt);
        _70 = move _71 as u64 (IntToInt);
        _74 = specialized_div_rem::u64_by_u64_div_rem(_5, _70) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _72 = (_74.0: u64);
        _73 = (_74.1: u64);
        _79 = const 32_i32 as u32 (IntToInt);
        _80 = Lt(move _79, const 128_u32);
        assert(move _80, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _78 = Shr(_1, const 32_i32);
        _77 = move _78 as u32 (IntToInt);
        _76 = move _77 as u64 (IntToInt);
        _82 = const 32_i32 as u32 (IntToInt);
        _83 = Lt(move _82, const 64_u32);
        assert(move _83, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb42, unwind unreachable];
    }

    bb42: {
        _81 = Shl(_73, const 32_i32);
        _75 = BitOr(move _76, move _81);
        _86 = specialized_div_rem::u64_by_u64_div_rem(_75, _70) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _84 = (_86.0: u64);
        _85 = (_86.1: u64);
        _89 = _1 as u32 (IntToInt);
        _88 = move _89 as u64 (IntToInt);
        _91 = const 32_i32 as u32 (IntToInt);
        _92 = Lt(move _91, const 64_u32);
        assert(move _92, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _90 = Shl(_85, const 32_i32);
        _87 = BitOr(move _88, move _90);
        _95 = specialized_div_rem::u64_by_u64_div_rem(_87, _70) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _93 = (_95.0: u64);
        _94 = (_95.1: u64);
        (*_3) = _94 as u128 (IntToInt);
        _97 = _93 as u128 (IntToInt);
        _99 = _84 as u128 (IntToInt);
        _100 = const 32_i32 as u32 (IntToInt);
        _101 = Lt(move _100, const 128_u32);
        assert(move _101, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _98 = Shl(move _99, const 32_i32);
        _96 = BitOr(move _97, move _98);
        _103 = _72 as u128 (IntToInt);
        _104 = const 64_i32 as u32 (IntToInt);
        _105 = Lt(move _104, const 128_u32);
        assert(move _105, "attempt to shift left by `{}`, which would overflow", const 64_i32) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _102 = Shl(move _103, const 64_i32);
        _0 = BitOr(move _96, move _102);
        goto -> bb80;
    }

    bb48: {
        _106 = _1 as u64 (IntToInt);
        _107 = specialized_div_rem::u64_by_u64_div_rem(_5, _9) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _108 = (_107.0: u64);
        _110 = _106 as u128 (IntToInt);
        _113 = (_107.1: u64);
        _112 = move _113 as u128 (IntToInt);
        _114 = const 64_i32 as u32 (IntToInt);
        _115 = Lt(move _114, const 128_u32);
        assert(move _115, "attempt to shift left by `{}`, which would overflow", const 64_i32) -> [success: bb50, unwind unreachable];
    }

    bb50: {
        _111 = Shl(move _112, const 64_i32);
        _109 = BitOr(move _110, move _111);
        _117 = _109;
        _116 = Lt(move _117, _2);
        switchInt(move _116) -> [0: bb53, otherwise: bb51];
    }

    bb51: {
        _118 = _109;
        (*_3) = move _118;
        _119 = _108 as u128 (IntToInt);
        _120 = const 64_i32 as u32 (IntToInt);
        _121 = Lt(move _120, const 128_u32);
        assert(move _121, "attempt to shift left by `{}`, which would overflow", const 64_i32) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _0 = Shl(move _119, const 64_i32);
        goto -> bb80;
    }

    bb53: {
        _124 = CheckedSub(const 64_i32, const 1_i32);
        assert(!move (_124.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, const 1_i32) -> [success: bb54, unwind unreachable];
    }

    bb54: {
        _123 = move (_124.0: i32);
        _125 = _123 as u32 (IntToInt);
        _126 = Lt(move _125, const 128_u32);
        assert(move _126, "attempt to shift left by `{}`, which would overflow", _123) -> [success: bb55, unwind unreachable];
    }

    bb55: {
        _122 = Shl(_2, move _123);
        _129 = CheckedSub(const 64_i32, const 1_i32);
        assert(!move (_129.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, const 1_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _128 = move (_129.0: i32);
        _130 = _128 as u32 (IntToInt);
        _131 = Lt(move _130, const 64_u32);
        assert(move _131, "attempt to shift left by `{}`, which would overflow", _128) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _127 = Shl(const 1_u64, move _128);
        _132 = const 0_u64;
        goto -> bb58;
    }

    bb58: {
        _134 = _109;
        _135 = _122;
        _133 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(move _134, move _135) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _137 = _133 as i128 (IntToInt);
        _136 = Le(const 0_i128, move _137);
        switchInt(move _136) -> [0: bb65, otherwise: bb60];
    }

    bb60: {
        _109 = _133;
        _138 = _127;
        _132 = BitOr(_132, move _138);
        _141 = _109;
        _142 = const 64_i32 as u32 (IntToInt);
        _143 = Lt(move _142, const 128_u32);
        assert(move _143, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _140 = Shr(move _141, const 64_i32);
        _139 = move _140 as u64 (IntToInt);
        switchInt(move _139) -> [0: bb62, otherwise: bb65];
    }

    bb62: {
        _146 = _109;
        _145 = move _146 as u64 (IntToInt);
        _144 = specialized_div_rem::u64_by_u64_div_rem(move _145, _9) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _147 = (_144.1: u64);
        (*_3) = move _147 as u128 (IntToInt);
        _150 = (_144.0: u64);
        _149 = move _150 as u128 (IntToInt);
        _152 = _132;
        _151 = move _152 as u128 (IntToInt);
        _148 = BitOr(move _149, move _151);
        _154 = _108 as u128 (IntToInt);
        _155 = const 64_i32 as u32 (IntToInt);
        _156 = Lt(move _155, const 128_u32);
        assert(move _156, "attempt to shift left by `{}`, which would overflow", const 64_i32) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _153 = Shl(move _154, const 64_i32);
        _0 = BitOr(move _148, move _153);
        goto -> bb80;
    }

    bb65: {
        _157 = const 1_i32 as u32 (IntToInt);
        _158 = Lt(move _157, const 128_u32);
        assert(move _158, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb66, unwind unreachable];
    }

    bb66: {
        _122 = Shr(_122, const 1_i32);
        _159 = const 1_i32 as u32 (IntToInt);
        _160 = Lt(move _159, const 64_u32);
        assert(move _160, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb67, unwind unreachable];
    }

    bb67: {
        _127 = Shr(_127, const 1_i32);
        goto -> bb58;
    }

    bb68: {
        (*_3) = _1;
        _0 = const 0_u128;
        goto -> bb80;
    }

    bb69: {
        _162 = specialized_div_rem::u64_normalization_shift(_5, _10, const false) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _163 = _1;
        _165 = Lt(_162, const 128_usize);
        assert(move _165, "attempt to shift left by `{}`, which would overflow", _162) -> [success: bb71, unwind unreachable];
    }

    bb71: {
        _164 = Shl(_2, _162);
        _167 = Lt(_162, const 64_usize);
        assert(move _167, "attempt to shift left by `{}`, which would overflow", _162) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _166 = Shl(const 1_u64, _162);
        _168 = const 0_u64;
        goto -> bb73;
    }

    bb73: {
        _170 = _163;
        _171 = _164;
        _169 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(move _170, move _171) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _173 = _169 as i128 (IntToInt);
        _172 = Le(const 0_i128, move _173);
        switchInt(move _172) -> [0: bb77, otherwise: bb75];
    }

    bb75: {
        _163 = _169;
        _174 = _166;
        _168 = BitOr(_168, move _174);
        _176 = _163;
        _175 = Lt(move _176, _2);
        switchInt(move _175) -> [0: bb77, otherwise: bb76];
    }

    bb76: {
        _177 = _163;
        (*_3) = move _177;
        _178 = _168;
        _0 = move _178 as u128 (IntToInt);
        goto -> bb80;
    }

    bb77: {
        _179 = const 1_i32 as u32 (IntToInt);
        _180 = Lt(move _179, const 128_u32);
        assert(move _180, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _164 = Shr(_164, const 1_i32);
        _181 = const 1_i32 as u32 (IntToInt);
        _182 = Lt(move _181, const 64_u32);
        assert(move _182, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb79, unwind unreachable];
    }

    bb79: {
        _166 = Shr(_166, const 1_i32);
        goto -> bb73;
    }

    bb80: {
        return;
    }
}

fn specialized_div_rem::zero_div_fn() -> ! {
    let mut _0: !;
    scope 1 {
    }

    bb0: {
        unreachable;
    }
}

const USE_LZ: bool = {
    let mut _0: bool;
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;

    bb0: {
        StorageLive(_1);
        _1 = const false;
        switchInt(move _1) -> [0: bb5, otherwise: bb1];
    }

    bb1: {
        StorageLive(_2);
        _2 = const false;
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb4;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        StorageDead(_2);
        goto -> bb12;
    }

    bb5: {
        StorageLive(_3);
        _3 = const false;
        switchInt(move _3) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = const false;
        goto -> bb11;
    }

    bb7: {
        StorageLive(_4);
        _4 = const false;
        switchInt(move _4) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = const false;
        goto -> bb10;
    }

    bb9: {
        _0 = const true;
        goto -> bb10;
    }

    bb10: {
        StorageDead(_4);
        goto -> bb11;
    }

    bb11: {
        StorageDead(_3);
        goto -> bb12;
    }

    bb12: {
        StorageDead(_1);
        return;
    }
}

fn u32_normalization_shift(_1: u32, _2: u32, _3: bool) -> usize {
    debug duo => _1;
    debug div => _2;
    debug full_normalization => _3;
    let mut _0: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: (u32, bool);
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: usize;
    let mut _13: bool;
    let mut _14: (usize, bool);
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u32;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: (usize, bool);
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: usize;
    scope 1 {
        debug shl => _4;
        let mut _15: u32;
        scope 2 {
            debug test => _15;
            let mut _16: usize;
            scope 3 {
                debug lvl => _16;
                let _19: u32;
                scope 4 {
                    debug tmp => _19;
                }
            }
        }
    }

    bb0: {
        _5 = const _;
        switchInt(move _5) -> [0: bb9, otherwise: bb1];
    }

    bb1: {
        _7 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = CheckedSub(_7, _8);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _7, move _8) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _6 = move (_9.0: u32);
        _4 = move _6 as usize (IntToInt);
        switchInt(_3) -> [0: bb17, otherwise: bb5];
    }

    bb5: {
        _12 = _4;
        _13 = Lt(_12, const 32_usize);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", _12) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = Shl(_2, move _12);
        _10 = Lt(_1, move _11);
        switchInt(move _10) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _14 = CheckedSub(_4, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _4 = move (_14.0: usize);
        goto -> bb17;
    }

    bb9: {
        _15 = _1;
        _4 = const 0_usize;
        _17 = const 1_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _16 = Shr(const 32_usize, const 1_i32);
        goto -> bb11;
    }

    bb11: {
        _20 = _15;
        _21 = _16;
        _22 = Lt(_21, const 32_usize);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", _21) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _19 = Shr(move _20, move _21);
        _23 = Le(_2, _19);
        switchInt(move _23) -> [0: bb15, otherwise: bb13];
    }

    bb13: {
        _15 = _19;
        _24 = _16;
        _25 = CheckedAdd(_4, _24);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _24) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _4 = move (_25.0: usize);
        goto -> bb15;
    }

    bb15: {
        _26 = const 1_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _16 = Shr(_16, const 1_i32);
        _28 = _16;
        switchInt(move _28) -> [0: bb17, otherwise: bb11];
    }

    bb17: {
        _0 = _4;
        return;
    }
}

fn specialized_div_rem::u64_normalization_shift(_1: u64, _2: u64, _3: bool) -> usize {
    debug duo => _1;
    debug div => _2;
    debug full_normalization => _3;
    let mut _0: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: (u32, bool);
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: usize;
    let mut _13: bool;
    let mut _14: (usize, bool);
    let mut _17: u32;
    let mut _18: bool;
    let mut _20: u64;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: (usize, bool);
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: usize;
    scope 1 {
        debug shl => _4;
        let mut _15: u64;
        scope 2 {
            debug test => _15;
            let mut _16: usize;
            scope 3 {
                debug lvl => _16;
                let _19: u64;
                scope 4 {
                    debug tmp => _19;
                }
            }
        }
    }

    bb0: {
        _5 = const _;
        switchInt(move _5) -> [0: bb9, otherwise: bb1];
    }

    bb1: {
        _7 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _9 = CheckedSub(_7, _8);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _7, move _8) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _6 = move (_9.0: u32);
        _4 = move _6 as usize (IntToInt);
        switchInt(_3) -> [0: bb17, otherwise: bb5];
    }

    bb5: {
        _12 = _4;
        _13 = Lt(_12, const 64_usize);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", _12) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = Shl(_2, move _12);
        _10 = Lt(_1, move _11);
        switchInt(move _10) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _14 = CheckedSub(_4, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 1_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _4 = move (_14.0: usize);
        goto -> bb17;
    }

    bb9: {
        _15 = _1;
        _4 = const 0_usize;
        _17 = const 1_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _16 = Shr(const 64_usize, const 1_i32);
        goto -> bb11;
    }

    bb11: {
        _20 = _15;
        _21 = _16;
        _22 = Lt(_21, const 64_usize);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", _21) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _19 = Shr(move _20, move _21);
        _23 = Le(_2, _19);
        switchInt(move _23) -> [0: bb15, otherwise: bb13];
    }

    bb13: {
        _15 = _19;
        _24 = _16;
        _25 = CheckedAdd(_4, _24);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _24) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _4 = move (_25.0: usize);
        goto -> bb15;
    }

    bb15: {
        _26 = const 1_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _16 = Shr(_16, const 1_i32);
        _28 = _16;
        switchInt(move _28) -> [0: bb17, otherwise: bb11];
    }

    bb17: {
        _0 = _4;
        return;
    }
}

fn specialized_div_rem::u64_by_u64_div_rem(_1: u64, _2: u64) -> (u64, u64) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u64, u64);
    let mut _3: rustc_std_workspace_core::option::Option<u64>;
    let mut _4: isize;
    let mut _6: rustc_std_workspace_core::option::Option<u64>;
    let mut _7: isize;
    let mut _9: !;
    scope 1 {
        debug quo => _5;
        let _5: u64;
        scope 2 {
            debug rem => _8;
            let _8: u64;
        }
    }

    bb0: {
        _3 = rustc_std_workspace_core::num::<impl u64>::checked_div(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_3 as Some).0: u64);
        _6 = rustc_std_workspace_core::num::<impl u64>::checked_rem(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = discriminant(_6);
        switchInt(move _7) -> [1: bb4, otherwise: bb5];
    }

    bb4: {
        _8 = ((_6 as Some).0: u64);
        _0 = (_5, _8);
        return;
    }

    bb5: {
        _9 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }
}

fn u128_by_u64_div_rem(_1: u128, _2: u64) -> (u64, u64) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u64, u64);
    let _3: u64;
    let mut _5: u128;
    let mut _6: u32;
    let mut _7: bool;
    let mut _10: u64;
    let mut _11: u64;
    scope 1 {
        debug duo_lo => _3;
        let _4: u64;
        scope 2 {
            debug duo_hi => _4;
            let _8: u64;
            scope 3 {
                debug quo => _8;
                let _9: u64;
                scope 4 {
                    debug rem => _9;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1 as u64 (IntToInt);
        _6 = const 64_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 128_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Shr(_1, const 64_i32);
        _4 = move _5 as u64 (IntToInt);
        asm!("div {0}", in(reg) _2, inlateout("ax") _3 => _8, inlateout("dx") _4 => _9, options(PURE | NOMEM | NOSTACK | ATT_SYNTAX)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = _8;
        _11 = _9;
        _0 = (move _10, move _11);
        return;
    }
}

fn specialized_div_rem::u128_div_rem(_1: u128, _2: u128) -> (u128, u128) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u128, u128);
    let _3: u32;
    let mut _4: (u32, bool);
    let mut _7: u128;
    let mut _8: bool;
    let mut _11: u128;
    let mut _12: bool;
    let mut _13: !;
    let mut _14: bool;
    let mut _17: (u64, u64);
    let mut _18: u128;
    let mut _19: u128;
    let mut _22: (u64, u64);
    let mut _24: u128;
    let mut _25: u128;
    let mut _26: u128;
    let mut _27: u128;
    let mut _28: bool;
    let mut _29: u128;
    let mut _30: u128;
    let mut _31: u64;
    let mut _32: u128;
    let mut _33: u128;
    let mut _34: bool;
    let mut _35: u128;
    let mut _36: u64;
    let mut _39: (u32, bool);
    let mut _41: u128;
    let mut _42: bool;
    let mut _44: u128;
    let mut _45: u32;
    let mut _46: bool;
    let mut _48: u64;
    let mut _49: u32;
    let mut _50: u32;
    let mut _51: (u32, bool);
    let mut _52: (u32, bool);
    let mut _53: bool;
    let mut _54: u64;
    let mut _55: (u64, bool);
    let mut _57: u128;
    let mut _58: u128;
    let mut _59: u64;
    let mut _60: (u128, bool);
    let mut _61: bool;
    let mut _62: u128;
    let mut _63: (u64, bool);
    let mut _64: (u128, bool);
    let mut _65: u128;
    let mut _66: u64;
    let mut _67: u128;
    scope 1 {
        debug n => _3;
        let _5: u64;
        scope 2 {
            debug duo_lo => _5;
            let _6: u64;
            scope 3 {
                debug duo_hi => _6;
                let _9: u64;
                scope 4 {
                    debug div_lo => _9;
                    let _10: u64;
                    scope 5 {
                        debug div_hi => _10;
                        let _15: u64;
                        let _16: u64;
                        let _20: u64;
                        let _21: u64;
                        let _37: u32;
                        scope 6 {
                            debug quo => _15;
                            debug rem => _16;
                        }
                        scope 7 {
                        }
                        scope 8 {
                            debug quo_hi => _20;
                            debug rem_hi => _21;
                            let _23: (u64, u64);
                            scope 9 {
                                debug tmp => _23;
                            }
                            scope 10 {
                            }
                        }
                        scope 11 {
                            debug div_lz => _37;
                            let _38: u32;
                            scope 12 {
                                debug div_extra => _38;
                                let _40: u64;
                                scope 13 {
                                    debug div_sig_n => _40;
                                    let _43: (u64, u64);
                                    scope 14 {
                                        debug tmp => _43;
                                        let mut _47: u64;
                                        scope 16 {
                                            debug quo => _47;
                                            let mut _56: u128;
                                            scope 17 {
                                                debug rem => _56;
                                            }
                                        }
                                    }
                                    scope 15 {
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = CheckedMul(const 32_u32, const 2_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} * {}`, which would overflow", const 32_u32, const 2_u32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move (_4.0: u32);
        _5 = _1 as u64 (IntToInt);
        _8 = Lt(_3, const 128_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", _3) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Shr(_1, _3);
        _6 = move _7 as u64 (IntToInt);
        _9 = _2 as u64 (IntToInt);
        _12 = Lt(_3, const 128_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _11 = Shr(_2, _3);
        _10 = move _11 as u64 (IntToInt);
        switchInt(move _10) -> [0: bb4, otherwise: bb14];
    }

    bb4: {
        switchInt(move _9) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _13 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }

    bb6: {
        _14 = Lt(_6, _9);
        switchInt(move _14) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _17 = u128_by_u64_div_rem(_1, _9) -> [return: bb9, unwind unreachable];
    }

    bb8: {
        _22 = specialized_div_rem::u64_by_u64_div_rem(_6, _9) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _15 = (_17.0: u64);
        _16 = (_17.1: u64);
        _18 = _15 as u128 (IntToInt);
        _19 = _16 as u128 (IntToInt);
        _0 = (move _18, move _19);
        goto -> bb32;
    }

    bb10: {
        _20 = (_22.0: u64);
        _21 = (_22.1: u64);
        _25 = _5 as u128 (IntToInt);
        _27 = _21 as u128 (IntToInt);
        _28 = Lt(_3, const 128_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", _3) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _26 = Shl(move _27, _3);
        _24 = BitOr(move _25, move _26);
        _23 = u128_by_u64_div_rem(move _24, _9) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _31 = (_23.0: u64);
        _30 = move _31 as u128 (IntToInt);
        _33 = _20 as u128 (IntToInt);
        _34 = Lt(_3, const 128_u32);
        assert(move _34, "attempt to shift left by `{}`, which would overflow", _3) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _32 = Shl(move _33, _3);
        _29 = BitOr(move _30, move _32);
        _36 = (_23.1: u64);
        _35 = move _36 as u128 (IntToInt);
        _0 = (move _29, move _35);
        goto -> bb32;
    }

    bb14: {
        _37 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_10) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _39 = CheckedSub(_3, _37);
        assert(!move (_39.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, _37) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _38 = move (_39.0: u32);
        _42 = Lt(_38, const 128_u32);
        assert(move _42, "attempt to shift right by `{}`, which would overflow", _38) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = Shr(_2, _38);
        _40 = move _41 as u64 (IntToInt);
        _45 = const 1_i32 as u32 (IntToInt);
        _46 = Lt(move _45, const 128_u32);
        assert(move _46, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _44 = Shr(_1, const 1_i32);
        _43 = u128_by_u64_div_rem(move _44, _40) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _48 = (_43.0: u64);
        _51 = CheckedSub(_3, const 1_u32);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_u32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _50 = move (_51.0: u32);
        _52 = CheckedSub(_50, _37);
        assert(!move (_52.1: bool), "attempt to compute `{} - {}`, which would overflow", move _50, _37) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _49 = move (_52.0: u32);
        _53 = Lt(_49, const 64_u32);
        assert(move _53, "attempt to shift right by `{}`, which would overflow", _49) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _47 = Shr(move _48, move _49);
        _54 = _47;
        switchInt(move _54) -> [0: bb25, otherwise: bb23];
    }

    bb23: {
        _55 = CheckedSub(_47, const 1_u64);
        assert(!move (_55.1: bool), "attempt to compute `{} - {}`, which would overflow", _47, const 1_u64) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _47 = move (_55.0: u64);
        goto -> bb25;
    }

    bb25: {
        _59 = _47;
        _58 = move _59 as u128 (IntToInt);
        _57 = rustc_std_workspace_core::num::<impl u128>::wrapping_mul(move _58, _2) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _60 = CheckedSub(_1, _57);
        assert(!move (_60.1: bool), "attempt to compute `{} - {}`, which would overflow", _1, move _57) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _56 = move (_60.0: u128);
        _62 = _56;
        _61 = Le(_2, move _62);
        switchInt(move _61) -> [0: bb31, otherwise: bb28];
    }

    bb28: {
        _63 = CheckedAdd(_47, const 1_u64);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", _47, const 1_u64) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _47 = move (_63.0: u64);
        _64 = CheckedSub(_56, _2);
        assert(!move (_64.1: bool), "attempt to compute `{} - {}`, which would overflow", _56, _2) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _56 = move (_64.0: u128);
        goto -> bb31;
    }

    bb31: {
        _66 = _47;
        _65 = move _66 as u128 (IntToInt);
        _67 = _56;
        _0 = (move _65, move _67);
        goto -> bb32;
    }

    bb32: {
        return;
    }
}

fn u32_by_u32_div_rem(_1: u32, _2: u32) -> (u32, u32) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u32, u32);
    let mut _3: rustc_std_workspace_core::option::Option<u32>;
    let mut _4: isize;
    let mut _6: rustc_std_workspace_core::option::Option<u32>;
    let mut _7: isize;
    let mut _9: !;
    scope 1 {
        debug quo => _5;
        let _5: u32;
        scope 2 {
            debug rem => _8;
            let _8: u32;
        }
    }

    bb0: {
        _3 = rustc_std_workspace_core::num::<impl u32>::checked_div(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _5 = ((_3 as Some).0: u32);
        _6 = rustc_std_workspace_core::num::<impl u32>::checked_rem(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = discriminant(_6);
        switchInt(move _7) -> [1: bb4, otherwise: bb5];
    }

    bb4: {
        _8 = ((_6 as Some).0: u32);
        _0 = (_5, _8);
        return;
    }

    bb5: {
        _9 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }
}

fn specialized_div_rem::u64_div_rem(_1: u64, _2: u64) -> (u64, u64) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u64, u64);
    let mut _3: u64;
    let mut _4: !;
    let mut _5: bool;
    let mut _6: u64;
    let mut _7: u64;
    let mut _9: u64;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _24: bool;
    let mut _25: i64;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _31: usize;
    let mut _32: bool;
    let mut _33: (u64, bool);
    let mut _35: u64;
    let mut _36: u64;
    let mut _37: bool;
    let mut _38: i64;
    let mut _39: bool;
    let mut _40: u64;
    let mut _41: u64;
    let mut _42: u64;
    let mut _43: u64;
    let mut _44: (u64, bool);
    let mut _45: u64;
    let mut _46: u64;
    let mut _48: usize;
    let mut _49: (usize, bool);
    let mut _50: u64;
    let mut _51: u64;
    let mut _52: u64;
    let mut _53: u64;
    let mut _55: i64;
    let mut _56: i64;
    let mut _57: u64;
    let mut _58: u32;
    let mut _59: (u32, bool);
    let mut _60: u64;
    let mut _61: u64;
    let mut _62: u64;
    let mut _63: u64;
    let mut _64: u64;
    let mut _65: u64;
    let mut _66: u64;
    let mut _67: u64;
    let mut _68: u64;
    let mut _69: u64;
    let mut _70: u64;
    let mut _71: usize;
    let mut _72: bool;
    scope 1 {
        debug duo => _3;
        scope 2 {
            debug div_original => _2;
            let mut _8: usize;
            scope 3 {
                debug shl => _8;
                let mut _10: u64;
                scope 4 {
                    debug div => _10;
                    let mut _16: u64;
                    scope 5 {
                        debug quo => _16;
                        let _23: u64;
                        scope 6 {
                            debug mask => _23;
                            let _30: u64;
                            let mut _47: usize;
                            scope 7 {
                                debug tmp => _30;
                                let _34: u64;
                                scope 8 {
                                    debug sub => _34;
                                }
                            }
                            scope 9 {
                                debug i => _47;
                                let _54: u64;
                                scope 10 {
                                    debug mask => _54;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }

    bb2: {
        _6 = _3;
        _5 = Lt(move _6, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _7 = _3;
        _0 = (const 0_u64, move _7);
        goto -> bb34;
    }

    bb4: {
        _9 = _3;
        _8 = specialized_div_rem::u64_normalization_shift(move _9, _2, const true) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = _8;
        _12 = Lt(_11, const 64_usize);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", _11) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _10 = Shl(_2, move _11);
        _14 = _3;
        _15 = _10;
        _13 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _14, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = move _13;
        _17 = _8;
        _18 = Lt(_17, const 64_usize);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", _17) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _16 = Shl(const 1_u64, move _17);
        _20 = _3;
        _19 = Lt(move _20, _2);
        switchInt(move _19) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _21 = _16;
        _22 = _3;
        _0 = (move _21, move _22);
        goto -> bb34;
    }

    bb10: {
        _26 = _10;
        _25 = move _26 as i64 (IntToInt);
        _24 = Lt(move _25, const 0_i64);
        switchInt(move _24) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _27 = const 1_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb12: {
        _43 = _16;
        _44 = CheckedSub(_43, const 1_u64);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", move _43, const 1_u64) -> [success: bb21, unwind unreachable];
    }

    bb13: {
        _10 = Shr(_10, const 1_i32);
        _29 = CheckedSub(_8, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_usize) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _8 = move (_29.0: usize);
        _31 = _8;
        _32 = Lt(_31, const 64_usize);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", _31) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _30 = Shl(const 1_u64, move _31);
        _33 = CheckedSub(_30, const 1_u64);
        assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", _30, const 1_u64) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _23 = move (_33.0: u64);
        _35 = _3;
        _36 = _10;
        _34 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _35, move _36) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _38 = _34 as i64 (IntToInt);
        _37 = Ge(move _38, const 0_i64);
        switchInt(move _37) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _3 = _34;
        _16 = BitOr(_16, _30);
        goto -> bb19;
    }

    bb19: {
        _40 = _3;
        _39 = Lt(move _40, _2);
        switchInt(move _39) -> [0: bb22, otherwise: bb20];
    }

    bb20: {
        _41 = _16;
        _42 = _3;
        _0 = (move _41, move _42);
        goto -> bb34;
    }

    bb21: {
        _23 = move (_44.0: u64);
        goto -> bb22;
    }

    bb22: {
        _46 = _10;
        _45 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _46, const 1_u64) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _10 = move _45;
        _47 = _8;
        goto -> bb24;
    }

    bb24: {
        _48 = _47;
        switchInt(move _48) -> [0: bb25, otherwise: bb26];
    }

    bb25: {
        _66 = _3;
        _67 = _23;
        _65 = BitAnd(move _66, move _67);
        _68 = _16;
        _64 = BitOr(move _65, move _68);
        _70 = _3;
        _71 = _8;
        _72 = Lt(_71, const 64_usize);
        assert(move _72, "attempt to shift right by `{}`, which would overflow", _71) -> [success: bb33, unwind unreachable];
    }

    bb26: {
        _49 = CheckedSub(_47, const 1_usize);
        assert(!move (_49.1: bool), "attempt to compute `{} - {}`, which would overflow", _47, const 1_usize) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _47 = move (_49.0: usize);
        _52 = _3;
        _51 = rustc_std_workspace_core::num::<impl u64>::wrapping_shl(move _52, const 1_u32) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _53 = _10;
        _50 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _51, move _53) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _3 = move _50;
        _57 = _3;
        _56 = move _57 as i64 (IntToInt);
        _59 = CheckedSub(const 64_u32, const 1_u32);
        assert(!move (_59.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_u32, const 1_u32) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _58 = move (_59.0: u32);
        _55 = rustc_std_workspace_core::num::<impl i64>::wrapping_shr(move _56, move _58) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _54 = move _55 as u64 (IntToInt);
        _61 = _3;
        _63 = _10;
        _62 = BitAnd(move _63, _54);
        _60 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(move _61, move _62) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _3 = move _60;
        goto -> bb24;
    }

    bb33: {
        _69 = Shr(move _70, move _71);
        _0 = (move _64, move _69);
        goto -> bb34;
    }

    bb34: {
        return;
    }
}

fn specialized_div_rem::u32_div_rem(_1: u32, _2: u32) -> (u32, u32) {
    debug duo => _1;
    debug div => _2;
    let mut _0: (u32, u32);
    let mut _3: u32;
    let mut _4: !;
    let mut _5: bool;
    let mut _6: u32;
    let mut _7: u32;
    let mut _9: u32;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _24: bool;
    let mut _25: i32;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _31: usize;
    let mut _32: bool;
    let mut _33: (u32, bool);
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: i32;
    let mut _39: bool;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: (u32, bool);
    let mut _45: u32;
    let mut _46: u32;
    let mut _48: usize;
    let mut _49: (usize, bool);
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: u32;
    let mut _53: u32;
    let mut _55: i32;
    let mut _56: i32;
    let mut _57: u32;
    let mut _58: u32;
    let mut _59: (u32, bool);
    let mut _60: u32;
    let mut _61: u32;
    let mut _62: u32;
    let mut _63: u32;
    let mut _64: u32;
    let mut _65: u32;
    let mut _66: u32;
    let mut _67: u32;
    let mut _68: u32;
    let mut _69: u32;
    let mut _70: u32;
    let mut _71: usize;
    let mut _72: bool;
    scope 1 {
        debug duo => _3;
        scope 2 {
            debug div_original => _2;
            let mut _8: usize;
            scope 3 {
                debug shl => _8;
                let mut _10: u32;
                scope 4 {
                    debug div => _10;
                    let mut _16: u32;
                    scope 5 {
                        debug quo => _16;
                        let _23: u32;
                        scope 6 {
                            debug mask => _23;
                            let _30: u32;
                            let mut _47: usize;
                            scope 7 {
                                debug tmp => _30;
                                let _34: u32;
                                scope 8 {
                                    debug sub => _34;
                                }
                            }
                            scope 9 {
                                debug i => _47;
                                let _54: u32;
                                scope 10 {
                                    debug mask => _54;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = specialized_div_rem::zero_div_fn() -> unwind unreachable;
    }

    bb2: {
        _6 = _3;
        _5 = Lt(move _6, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _7 = _3;
        _0 = (const 0_u32, move _7);
        goto -> bb34;
    }

    bb4: {
        _9 = _3;
        _8 = u32_normalization_shift(move _9, _2, const true) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = _8;
        _12 = Lt(_11, const 32_usize);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", _11) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _10 = Shl(_2, move _11);
        _14 = _3;
        _15 = _10;
        _13 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _14, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _3 = move _13;
        _17 = _8;
        _18 = Lt(_17, const 32_usize);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", _17) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _16 = Shl(const 1_u32, move _17);
        _20 = _3;
        _19 = Lt(move _20, _2);
        switchInt(move _19) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _21 = _16;
        _22 = _3;
        _0 = (move _21, move _22);
        goto -> bb34;
    }

    bb10: {
        _26 = _10;
        _25 = move _26 as i32 (IntToInt);
        _24 = Lt(move _25, const 0_i32);
        switchInt(move _24) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _27 = const 1_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 32_u32);
        assert(move _28, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb12: {
        _43 = _16;
        _44 = CheckedSub(_43, const 1_u32);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", move _43, const 1_u32) -> [success: bb21, unwind unreachable];
    }

    bb13: {
        _10 = Shr(_10, const 1_i32);
        _29 = CheckedSub(_8, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_usize) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _8 = move (_29.0: usize);
        _31 = _8;
        _32 = Lt(_31, const 32_usize);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", _31) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _30 = Shl(const 1_u32, move _31);
        _33 = CheckedSub(_30, const 1_u32);
        assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", _30, const 1_u32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _23 = move (_33.0: u32);
        _35 = _3;
        _36 = _10;
        _34 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _35, move _36) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _38 = _34 as i32 (IntToInt);
        _37 = Ge(move _38, const 0_i32);
        switchInt(move _37) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _3 = _34;
        _16 = BitOr(_16, _30);
        goto -> bb19;
    }

    bb19: {
        _40 = _3;
        _39 = Lt(move _40, _2);
        switchInt(move _39) -> [0: bb22, otherwise: bb20];
    }

    bb20: {
        _41 = _16;
        _42 = _3;
        _0 = (move _41, move _42);
        goto -> bb34;
    }

    bb21: {
        _23 = move (_44.0: u32);
        goto -> bb22;
    }

    bb22: {
        _46 = _10;
        _45 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _46, const 1_u32) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _10 = move _45;
        _47 = _8;
        goto -> bb24;
    }

    bb24: {
        _48 = _47;
        switchInt(move _48) -> [0: bb25, otherwise: bb26];
    }

    bb25: {
        _66 = _3;
        _67 = _23;
        _65 = BitAnd(move _66, move _67);
        _68 = _16;
        _64 = BitOr(move _65, move _68);
        _70 = _3;
        _71 = _8;
        _72 = Lt(_71, const 32_usize);
        assert(move _72, "attempt to shift right by `{}`, which would overflow", _71) -> [success: bb33, unwind unreachable];
    }

    bb26: {
        _49 = CheckedSub(_47, const 1_usize);
        assert(!move (_49.1: bool), "attempt to compute `{} - {}`, which would overflow", _47, const 1_usize) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _47 = move (_49.0: usize);
        _52 = _3;
        _51 = rustc_std_workspace_core::num::<impl u32>::wrapping_shl(move _52, const 1_u32) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _53 = _10;
        _50 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _51, move _53) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _3 = move _50;
        _57 = _3;
        _56 = move _57 as i32 (IntToInt);
        _59 = CheckedSub(const 32_u32, const 1_u32);
        assert(!move (_59.1: bool), "attempt to compute `{} - {}`, which would overflow", const 32_u32, const 1_u32) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _58 = move (_59.0: u32);
        _55 = rustc_std_workspace_core::num::<impl i32>::wrapping_shr(move _56, move _58) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _54 = move _55 as u32 (IntToInt);
        _61 = _3;
        _63 = _10;
        _62 = BitAnd(move _63, _54);
        _60 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _61, move _62) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _3 = move _60;
        goto -> bb24;
    }

    bb33: {
        _69 = Shr(move _70, move _71);
        _0 = (move _64, move _69);
        goto -> bb34;
    }

    bb34: {
        return;
    }
}

fn UAddSub::uadd(_1: Self, _2: Self) -> Self {
    debug self => _1;
    debug other => _2;
    let mut _0: Self;
    let _3: <Self as int::DInt>::H;
    let _4: bool;
    let mut _5: (<Self as int::DInt>::H, bool);
    let mut _6: <Self as int::DInt>::H;
    let mut _7: <Self as int::DInt>::H;
    let mut _9: <Self as int::DInt>::H;
    let mut _10: <Self as int::DInt>::H;
    let mut _12: <Self as int::DInt>::H;
    let mut _13: <Self as int::DInt>::H;
    scope 1 {
        debug lo => _3;
        debug carry => _4;
        let _8: <Self as int::DInt>::H;
        scope 2 {
            debug hi => _8;
            let _11: <Self as int::DInt>::H;
            scope 3 {
                debug carry => _11;
            }
        }
    }

    bb0: {
        _6 = <Self as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = <Self as DInt>::lo(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = <<Self as DInt>::H as Int>::overflowing_add(move _6, move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = (_5.0: <Self as int::DInt>::H);
        _4 = (_5.1: bool);
        _9 = <Self as DInt>::hi(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Self as DInt>::hi(_2) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = <<Self as DInt>::H as Int>::wrapping_add(move _9, move _10) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(_4) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _11 = const _;
        goto -> bb9;
    }

    bb8: {
        _11 = const _;
        goto -> bb9;
    }

    bb9: {
        _13 = _11;
        _12 = <<Self as DInt>::H as Int>::wrapping_add(_8, move _13) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = <Self as DInt>::from_lo_hi(_3, move _12) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        return;
    }
}

fn UAddSub::uadd_one(_1: Self) -> Self {
    debug self => _1;
    let mut _0: Self;
    let _2: <Self as int::DInt>::H;
    let _3: bool;
    let mut _4: (<Self as int::DInt>::H, bool);
    let mut _5: <Self as int::DInt>::H;
    let mut _7: <Self as int::DInt>::H;
    let mut _8: <Self as int::DInt>::H;
    let mut _9: <Self as int::DInt>::H;
    scope 1 {
        debug lo => _2;
        debug carry => _3;
        let _6: <Self as int::DInt>::H;
        scope 2 {
            debug carry => _6;
        }
    }

    bb0: {
        _5 = <Self as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <<Self as DInt>::H as Int>::overflowing_add(move _5, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _2 = (_4.0: <Self as int::DInt>::H);
        _3 = (_4.1: bool);
        switchInt(_3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _6 = const _;
        goto -> bb5;
    }

    bb4: {
        _6 = const _;
        goto -> bb5;
    }

    bb5: {
        _8 = <Self as DInt>::hi(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _9 = _6;
        _7 = <<Self as DInt>::H as Int>::wrapping_add(move _8, move _9) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = <Self as DInt>::from_lo_hi(_2, move _7) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        return;
    }
}

fn UAddSub::usub(_1: Self, _2: Self) -> Self {
    debug self => _1;
    debug other => _2;
    let mut _0: Self;
    let _3: Self;
    let mut _4: Self;
    scope 1 {
        debug uneg => _3;
    }

    bb0: {
        _4 = <Self as Not>::not(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <Self as UAddSub>::uadd_one(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <Self as UAddSub>::uadd(_1, _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn AddSub::add(_1: Self, _2: Self) -> Self {
    debug self => _1;
    debug other => _2;
    let mut _0: Self;
    let mut _3: <Self as int::Int>::UnsignedInt;
    let mut _4: <Self as int::Int>::UnsignedInt;
    let mut _5: <Self as int::Int>::UnsignedInt;

    bb0: {
        _4 = <Self as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Self as Int>::unsigned(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <<Self as Int>::UnsignedInt as UAddSub>::uadd(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <Self as Int>::from_unsigned(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn AddSub::sub(_1: Self, _2: Self) -> Self {
    debug self => _1;
    debug other => _2;
    let mut _0: Self;
    let mut _3: <Self as int::Int>::UnsignedInt;
    let mut _4: <Self as int::Int>::UnsignedInt;
    let mut _5: <Self as int::Int>::UnsignedInt;

    bb0: {
        _4 = <Self as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = <Self as Int>::unsigned(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = <<Self as Int>::UnsignedInt as UAddSub>::usub(move _4, move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _0 = <Self as Int>::from_unsigned(move _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn Addo::addo(_1: Self, _2: Self) -> (Self, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (Self, bool);
    let _3: Self;
    let mut _4: Self;
    let mut _5: Self;
    let mut _6: Self;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: &Self;
    let mut _10: &Self;
    let _11: Self;
    let mut _12: bool;
    let mut _13: &Self;
    let mut _14: &Self;
    scope 1 {
        debug sum => _3;
    }

    bb0: {
        _4 = _1;
        _5 = _2;
        _3 = <Self as AddSub>::add(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _3;
        _9 = &_2;
        _11 = const _;
        _10 = &_11;
        _8 = <Self as PartialOrd>::lt(move _9, move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = &_3;
        _14 = &_1;
        _12 = <Self as PartialOrd>::lt(move _13, move _14) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Ne(move _8, move _12);
        _0 = (move _6, move _7);
        return;
    }
}

fn Subo::subo(_1: Self, _2: Self) -> (Self, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (Self, bool);
    let _3: Self;
    let mut _4: Self;
    let mut _5: Self;
    let mut _6: Self;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: &Self;
    let mut _10: &Self;
    let _11: Self;
    let mut _12: bool;
    let mut _13: &Self;
    let mut _14: &Self;
    scope 1 {
        debug sum => _3;
    }

    bb0: {
        _4 = _1;
        _5 = _2;
        _3 = <Self as AddSub>::sub(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _3;
        _9 = &_2;
        _11 = const _;
        _10 = &_11;
        _8 = <Self as PartialOrd>::lt(move _9, move _10) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _13 = &_1;
        _14 = &_3;
        _12 = <Self as PartialOrd>::lt(move _13, move _14) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Ne(move _8, move _12);
        _0 = (move _6, move _7);
        return;
    }
}

fn addsub::__rust_i128_add(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = <i128 as AddSub>::add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_i128_add::__rust_i128_add(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = addsub::__rust_i128_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_i128_addo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = <i128 as Addo>::addo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_i128_addo::__rust_i128_addo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = addsub::__rust_i128_addo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_u128_add(_1: u128, _2: u128) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = <u128 as AddSub>::add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_u128_add::__rust_u128_add(_1: u128, _2: u128) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = addsub::__rust_u128_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_u128_addo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = <u128 as Addo>::addo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_u128_addo::__rust_u128_addo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = addsub::__rust_u128_addo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_i128_sub(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = <i128 as AddSub>::sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_i128_sub::__rust_i128_sub(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = addsub::__rust_i128_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_i128_subo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = <i128 as Subo>::subo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_i128_subo::__rust_i128_subo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = addsub::__rust_i128_subo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_u128_sub(_1: u128, _2: u128) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = <u128 as AddSub>::sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_u128_sub::__rust_u128_sub(_1: u128, _2: u128) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = addsub::__rust_u128_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn addsub::__rust_u128_subo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = <u128 as Subo>::subo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_u128_subo::__rust_u128_subo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = addsub::__rust_u128_subo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn usize_leading_zeros_default(_1: usize) -> usize {
    debug x => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _4: u32;
    let mut _6: usize;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: usize;
    let mut _12: usize;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: usize;
    let mut _16: (usize, bool);
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: usize;
    let mut _22: (usize, bool);
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: usize;
    let mut _28: (usize, bool);
    let mut _29: usize;
    let mut _30: usize;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: usize;
    let mut _34: (usize, bool);
    let mut _35: usize;
    let mut _36: usize;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: usize;
    let mut _40: usize;
    let mut _41: (usize, bool);
    let mut _42: usize;
    let mut _43: usize;
    let mut _44: (usize, bool);
    scope 1 {
        debug x => _2;
        let mut _3: usize;
        scope 2 {
            debug z => _3;
            let mut _5: usize;
            scope 3 {
                debug t => _5;
            }
        }
    }

    bb0: {
        _2 = _1;
        _4 = rustc_std_workspace_core::num::<impl usize>::count_ones(const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _4 as usize (IntToInt);
        _6 = _2;
        _7 = const 32_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 32_i32);
        _9 = _5;
        switchInt(move _9) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _10 = CheckedSub(_3, const 32_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 32_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = move (_10.0: usize);
        _11 = _5;
        _2 = move _11;
        goto -> bb5;
    }

    bb5: {
        _12 = _2;
        _13 = const 16_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 64_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", const 16_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _5 = Shr(move _12, const 16_i32);
        _15 = _5;
        switchInt(move _15) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _16 = CheckedSub(_3, const 16_usize);
        assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 16_usize) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _3 = move (_16.0: usize);
        _17 = _5;
        _2 = move _17;
        goto -> bb9;
    }

    bb9: {
        _18 = _2;
        _19 = const 8_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 64_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 8_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _5 = Shr(move _18, const 8_i32);
        _21 = _5;
        switchInt(move _21) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _22 = CheckedSub(_3, const 8_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 8_usize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _3 = move (_22.0: usize);
        _23 = _5;
        _2 = move _23;
        goto -> bb13;
    }

    bb13: {
        _24 = _2;
        _25 = const 4_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 64_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 4_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _5 = Shr(move _24, const 4_i32);
        _27 = _5;
        switchInt(move _27) -> [0: bb17, otherwise: bb15];
    }

    bb15: {
        _28 = CheckedSub(_3, const 4_usize);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 4_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _3 = move (_28.0: usize);
        _29 = _5;
        _2 = move _29;
        goto -> bb17;
    }

    bb17: {
        _30 = _2;
        _31 = const 2_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 64_u32);
        assert(move _32, "attempt to shift right by `{}`, which would overflow", const 2_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _5 = Shr(move _30, const 2_i32);
        _33 = _5;
        switchInt(move _33) -> [0: bb21, otherwise: bb19];
    }

    bb19: {
        _34 = CheckedSub(_3, const 2_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 2_usize) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _3 = move (_34.0: usize);
        _35 = _5;
        _2 = move _35;
        goto -> bb21;
    }

    bb21: {
        _36 = _2;
        _37 = const 1_i32 as u32 (IntToInt);
        _38 = Lt(move _37, const 64_u32);
        assert(move _38, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _5 = Shr(move _36, const 1_i32);
        _39 = _5;
        switchInt(move _39) -> [0: bb25, otherwise: bb23];
    }

    bb23: {
        _40 = _3;
        _41 = CheckedSub(_40, const 2_usize);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 2_usize) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _0 = move (_41.0: usize);
        goto -> bb27;
    }

    bb25: {
        _42 = _3;
        _43 = _2;
        _44 = CheckedSub(_42, _43);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", move _42, move _43) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _0 = move (_44.0: usize);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn usize_leading_zeros_riscv(_1: usize) -> usize {
    debug x => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _4: u32;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: bool;
    let mut _16: usize;
    let mut _17: (usize, bool);
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: usize;
    let mut _27: bool;
    let mut _28: usize;
    let mut _29: (usize, bool);
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: usize;
    let mut _33: usize;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: usize;
    let mut _41: (usize, bool);
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: usize;
    let mut _45: usize;
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: u32;
    let mut _49: bool;
    let mut _50: usize;
    let mut _51: bool;
    let mut _52: usize;
    let mut _53: (usize, bool);
    let mut _54: usize;
    let mut _55: bool;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: u32;
    let mut _59: bool;
    let mut _60: u32;
    let mut _61: bool;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: usize;
    let mut _65: (usize, bool);
    let mut _66: bool;
    let mut _67: usize;
    let mut _68: usize;
    let mut _69: u32;
    let mut _70: bool;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: usize;
    let mut _74: (usize, bool);
    let mut _75: usize;
    let mut _76: usize;
    let mut _77: (usize, bool);
    scope 1 {
        debug x => _2;
        let mut _3: usize;
        scope 2 {
            debug z => _3;
            let mut _5: usize;
            scope 3 {
                debug t => _5;
            }
        }
    }

    bb0: {
        _2 = _1;
        _4 = rustc_std_workspace_core::num::<impl usize>::count_ones(const _) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _4 as usize (IntToInt);
        _8 = _2;
        _10 = const 32_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shl(const 1_usize, const 32_i32);
        _7 = Ge(move _8, move _9);
        _6 = move _7 as usize (IntToInt);
        _12 = const 5_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", const 5_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shl(move _6, const 5_i32);
        _14 = _5;
        _15 = Lt(_14, const 64_usize);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", _14) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = Shr(_2, move _14);
        _16 = _5;
        _17 = CheckedSub(_3, _16);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _16) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move (_17.0: usize);
        _20 = _2;
        _22 = const 16_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 64_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 16_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _21 = Shl(const 1_usize, const 16_i32);
        _19 = Ge(move _20, move _21);
        _18 = move _19 as usize (IntToInt);
        _24 = const 4_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 64_u32);
        assert(move _25, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _5 = Shl(move _18, const 4_i32);
        _26 = _5;
        _27 = Lt(_26, const 64_usize);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", _26) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _2 = Shr(_2, move _26);
        _28 = _5;
        _29 = CheckedSub(_3, _28);
        assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _28) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _3 = move (_29.0: usize);
        _32 = _2;
        _34 = const 8_i32 as u32 (IntToInt);
        _35 = Lt(move _34, const 64_u32);
        assert(move _35, "attempt to shift left by `{}`, which would overflow", const 8_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _33 = Shl(const 1_usize, const 8_i32);
        _31 = Ge(move _32, move _33);
        _30 = move _31 as usize (IntToInt);
        _36 = const 3_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 3_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _5 = Shl(move _30, const 3_i32);
        _38 = _5;
        _39 = Lt(_38, const 64_usize);
        assert(move _39, "attempt to shift right by `{}`, which would overflow", _38) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = Shr(_2, move _38);
        _40 = _5;
        _41 = CheckedSub(_3, _40);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _40) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _3 = move (_41.0: usize);
        _44 = _2;
        _46 = const 4_i32 as u32 (IntToInt);
        _47 = Lt(move _46, const 64_u32);
        assert(move _47, "attempt to shift left by `{}`, which would overflow", const 4_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = Shl(const 1_usize, const 4_i32);
        _43 = Ge(move _44, move _45);
        _42 = move _43 as usize (IntToInt);
        _48 = const 2_i32 as u32 (IntToInt);
        _49 = Lt(move _48, const 64_u32);
        assert(move _49, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _5 = Shl(move _42, const 2_i32);
        _50 = _5;
        _51 = Lt(_50, const 64_usize);
        assert(move _51, "attempt to shift right by `{}`, which would overflow", _50) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _2 = Shr(_2, move _50);
        _52 = _5;
        _53 = CheckedSub(_3, _52);
        assert(!move (_53.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _52) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _3 = move (_53.0: usize);
        _56 = _2;
        _58 = const 2_i32 as u32 (IntToInt);
        _59 = Lt(move _58, const 64_u32);
        assert(move _59, "attempt to shift left by `{}`, which would overflow", const 2_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _57 = Shl(const 1_usize, const 2_i32);
        _55 = Ge(move _56, move _57);
        _54 = move _55 as usize (IntToInt);
        _60 = const 1_i32 as u32 (IntToInt);
        _61 = Lt(move _60, const 64_u32);
        assert(move _61, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _5 = Shl(move _54, const 1_i32);
        _62 = _5;
        _63 = Lt(_62, const 64_usize);
        assert(move _63, "attempt to shift right by `{}`, which would overflow", _62) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _2 = Shr(_2, move _62);
        _64 = _5;
        _65 = CheckedSub(_3, _64);
        assert(!move (_65.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _64) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _3 = move (_65.0: usize);
        _67 = _2;
        _69 = const 1_i32 as u32 (IntToInt);
        _70 = Lt(move _69, const 64_u32);
        assert(move _70, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _68 = Shl(const 1_usize, const 1_i32);
        _66 = Ge(move _67, move _68);
        _5 = move _66 as usize (IntToInt);
        _71 = _5;
        _72 = Lt(_71, const 64_usize);
        assert(move _72, "attempt to shift right by `{}`, which would overflow", _71) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _2 = Shr(_2, move _71);
        _73 = _5;
        _74 = CheckedSub(_3, _73);
        assert(!move (_74.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _73) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _3 = move (_74.0: usize);
        _75 = _3;
        _76 = _2;
        _77 = CheckedSub(_75, _76);
        assert(!move (_77.1: bool), "attempt to compute `{} - {}`, which would overflow", move _75, move _76) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _0 = move (_77.0: usize);
        return;
    }
}

fn leading_zeros::__clzsi2(_1: usize) -> usize {
    debug x => _1;
    let mut _0: usize;
    let mut _2: bool;

    bb0: {
        _2 = const false;
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = usize_leading_zeros_riscv(_1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = usize_leading_zeros_default(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn __clzsi2::__clzsi2(_1: usize) -> usize {
    debug x => _1;
    let mut _0: usize;

    bb0: {
        _0 = leading_zeros::__clzsi2(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::Mul::mul(_1: Self, _2: Self) -> Self {
    debug self => _1;
    debug rhs => _2;
    let mut _0: Self;
    let _3: <Self as int::DInt>::H;
    let mut _6: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _7: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _9: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _10: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _12: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _13: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _15: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _16: <<Self as int::DInt>::H as int::DInt>::H;
    let mut _18: Self;
    let mut _19: Self;
    let mut _20: Self;
    let mut _21: Self;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: Self;
    let mut _25: Self;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: Self;
    let mut _29: Self;
    let mut _30: <Self as int::DInt>::H;
    let mut _31: <Self as int::DInt>::H;
    let mut _32: Self;
    let mut _33: <Self as int::DInt>::H;
    let mut _34: <Self as int::DInt>::H;
    scope 1 {
        debug lhs_lo => _3;
        let _4: <Self as int::DInt>::H;
        scope 2 {
            debug rhs_lo => _4;
            let _5: <Self as int::DInt>::H;
            scope 3 {
                debug tmp_0 => _5;
                let _8: <Self as int::DInt>::H;
                scope 4 {
                    debug tmp_1 => _8;
                    let _11: <Self as int::DInt>::H;
                    scope 5 {
                        debug tmp_2 => _11;
                        let _14: <Self as int::DInt>::H;
                        scope 6 {
                            debug tmp_3 => _14;
                            let _17: Self;
                            scope 7 {
                                debug mul => _17;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = <Self as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <Self as DInt>::lo(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = <<Self as DInt>::H as DInt>::lo(_3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = <<Self as DInt>::H as DInt>::lo(_4) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _5 = <<<Self as DInt>::H as DInt>::H as HInt>::zero_widen_mul(move _6, move _7) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = <<Self as DInt>::H as DInt>::lo(_3) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = <<Self as DInt>::H as DInt>::hi(_4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _8 = <<<Self as DInt>::H as DInt>::H as HInt>::zero_widen_mul(move _9, move _10) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = <<Self as DInt>::H as DInt>::hi(_3) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <<Self as DInt>::H as DInt>::lo(_4) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _11 = <<<Self as DInt>::H as DInt>::H as HInt>::zero_widen_mul(move _12, move _13) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _15 = <<Self as DInt>::H as DInt>::hi(_3) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = <<Self as DInt>::H as DInt>::hi(_4) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _14 = <<<Self as DInt>::H as DInt>::H as HInt>::zero_widen_mul(move _15, move _16) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _19 = <Self as DInt>::from_lo_hi(_5, _14) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _21 = <<Self as DInt>::H as HInt>::zero_widen(_8) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _23 = Eq(const 4_u32, const 0_u32);
        assert(!move _23, "attempt to divide `{}` by zero", const _) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _22 = Div(const _, const 4_u32);
        _20 = <Self as Shl<u32>>::shl(move _21, move _22) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _18 = <Self as Int>::wrapping_add(move _19, move _20) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _25 = <<Self as DInt>::H as HInt>::zero_widen(_11) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _27 = Eq(const 4_u32, const 0_u32);
        assert(!move _27, "attempt to divide `{}` by zero", const _) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _26 = Div(const _, const 4_u32);
        _24 = <Self as Shl<u32>>::shl(move _25, move _26) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _17 = <Self as Int>::wrapping_add(move _18, move _24) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _31 = <Self as DInt>::hi(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _30 = <<Self as DInt>::H as Int>::wrapping_mul(_3, move _31) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _29 = <<Self as DInt>::H as HInt>::widen_hi(move _30) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _28 = <Self as Int>::wrapping_add(_17, move _29) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _34 = <Self as DInt>::hi(_1) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _33 = <<Self as DInt>::H as Int>::wrapping_mul(move _34, _4) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _32 = <<Self as DInt>::H as HInt>::widen_hi(move _33) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _0 = <Self as Int>::wrapping_add(move _28, move _32) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        return;
    }
}

fn UMulo::mulo(_1: Self, _2: Self) -> (Self, bool) {
    debug self => _1;
    debug rhs => _2;
    let mut _0: (Self, bool);
    let mut _3: (bool, bool);
    let mut _4: bool;
    let mut _5: <Self as int::DInt>::H;
    let mut _6: bool;
    let mut _7: <Self as int::DInt>::H;
    let mut _8: Self;
    let _9: Self;
    let mut _10: <Self as int::DInt>::H;
    let mut _11: <Self as int::DInt>::H;
    let mut _13: <Self as int::DInt>::H;
    let mut _14: <Self as int::DInt>::H;
    let mut _17: (Self, bool);
    let mut _18: Self;
    let mut _19: <Self as int::DInt>::H;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: <Self as int::DInt>::H;
    let _23: Self;
    let mut _24: <Self as int::DInt>::H;
    let mut _25: <Self as int::DInt>::H;
    let mut _27: <Self as int::DInt>::H;
    let mut _28: <Self as int::DInt>::H;
    let mut _31: (Self, bool);
    let mut _32: Self;
    let mut _33: <Self as int::DInt>::H;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: <Self as int::DInt>::H;
    let mut _37: Self;
    let mut _38: <Self as int::DInt>::H;
    let mut _39: <Self as int::DInt>::H;
    scope 1 {
        debug mul_lo => _9;
        let _12: Self;
        scope 2 {
            debug mul_hi => _12;
            let _15: Self;
            let _16: bool;
            scope 3 {
                debug mul => _15;
                debug o => _16;
            }
        }
    }
    scope 4 {
        debug mul_lo => _23;
        let _26: Self;
        scope 5 {
            debug mul_hi => _26;
            let _29: Self;
            let _30: bool;
            scope 6 {
                debug mul => _29;
                debug o => _30;
            }
        }
    }

    bb0: {
        _5 = <Self as DInt>::hi(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <<Self as DInt>::H as Int>::is_zero(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = <Self as DInt>::hi(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = <<Self as DInt>::H as Int>::is_zero(move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _3 = (move _4, move _6);
        switchInt((_3.0: bool)) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        switchInt((_3.1: bool)) -> [0: bb8, otherwise: bb25];
    }

    bb6: {
        switchInt((_3.1: bool)) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _38 = <Self as DInt>::lo(_1) -> [return: bb40, unwind unreachable];
    }

    bb8: {
        _8 = <Self as Int>::wrapping_mul(_1, _2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = (move _8, const true);
        goto -> bb43;
    }

    bb10: {
        _10 = <Self as DInt>::lo(_1) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _11 = <Self as DInt>::lo(_2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _9 = <<Self as DInt>::H as HInt>::widen_mul(move _10, move _11) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _13 = <Self as DInt>::lo(_1) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _14 = <Self as DInt>::hi(_2) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _12 = <<Self as DInt>::H as HInt>::widen_mul(move _13, move _14) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _19 = <Self as DInt>::lo(_12) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _18 = <<Self as DInt>::H as HInt>::widen_hi(move _19) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _17 = <Self as Int>::overflowing_add(_9, move _18) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _15 = (_17.0: Self);
        _16 = (_17.1: bool);
        switchInt(_16) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _20 = const true;
        goto -> bb24;
    }

    bb21: {
        _22 = <Self as DInt>::hi(_12) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _21 = <<Self as DInt>::H as Int>::is_zero(move _22) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _20 = Not(move _21);
        goto -> bb24;
    }

    bb24: {
        _0 = (_15, move _20);
        goto -> bb43;
    }

    bb25: {
        _24 = <Self as DInt>::lo(_2) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _25 = <Self as DInt>::lo(_1) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _23 = <<Self as DInt>::H as HInt>::widen_mul(move _24, move _25) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _27 = <Self as DInt>::lo(_2) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _28 = <Self as DInt>::hi(_1) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _26 = <<Self as DInt>::H as HInt>::widen_mul(move _27, move _28) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _33 = <Self as DInt>::lo(_26) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _32 = <<Self as DInt>::H as HInt>::widen_hi(move _33) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _31 = <Self as Int>::overflowing_add(_23, move _32) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _29 = (_31.0: Self);
        _30 = (_31.1: bool);
        switchInt(_30) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _34 = const true;
        goto -> bb39;
    }

    bb36: {
        _36 = <Self as DInt>::hi(_26) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _35 = <<Self as DInt>::H as Int>::is_zero(move _36) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _34 = Not(move _35);
        goto -> bb39;
    }

    bb39: {
        _0 = (_29, move _34);
        goto -> bb43;
    }

    bb40: {
        _39 = <Self as DInt>::lo(_2) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _37 = <<Self as DInt>::H as HInt>::widen_mul(move _38, move _39) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _0 = (move _37, const false);
        goto -> bb43;
    }

    bb43: {
        return;
    }
}

fn i32_overflowing_mul(_1: i32, _2: i32) -> (i32, bool) {
    debug lhs => _1;
    debug rhs => _2;
    let mut _0: (i32, bool);
    let mut _3: i32;
    let mut _5: i32;
    let mut _6: i32;
    let mut _8: i32;
    let mut _10: i32;
    let mut _11: i32;
    let mut _12: i32;
    let mut _13: i32;
    let mut _14: i32;
    let mut _18: (u32, bool);
    let mut _19: u32;
    let mut _20: i32;
    let mut _21: u32;
    let mut _22: i32;
    let mut _24: i32;
    let mut _25: i32;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: i32;
    let mut _29: i32;
    let mut _30: i32;
    scope 1 {
        debug lhs => _3;
        let mut _4: i32;
        scope 2 {
            debug rhs => _4;
            let _7: bool;
            scope 3 {
                debug lhs_neg => _7;
                let _9: bool;
                scope 4 {
                    debug rhs_neg => _9;
                    let _15: bool;
                    scope 5 {
                        debug mul_neg => _15;
                        let _16: u32;
                        let _17: bool;
                        scope 6 {
                            debug mul => _16;
                            debug o => _17;
                            let mut _23: i32;
                            scope 7 {
                                debug mul => _23;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _5 = _3;
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = _4;
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = (const 0_i32, const false);
        goto -> bb16;
    }

    bb3: {
        _8 = _3;
        _7 = Lt(move _8, const 0_i32);
        _10 = _4;
        _9 = Lt(move _10, const 0_i32);
        switchInt(_7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _12 = _3;
        _11 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move _11;
        goto -> bb6;
    }

    bb6: {
        switchInt(_9) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _14 = _4;
        _13 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _4 = move _13;
        goto -> bb9;
    }

    bb9: {
        _15 = Ne(_7, _9);
        _20 = _3;
        _19 = move _20 as u32 (IntToInt);
        _22 = _4;
        _21 = move _22 as u32 (IntToInt);
        _18 = <u32 as UMulo>::mulo(move _19, move _21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = (_18.0: u32);
        _17 = (_18.1: bool);
        _23 = _16 as i32 (IntToInt);
        switchInt(_15) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _25 = _23;
        _24 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = move _24;
        goto -> bb13;
    }

    bb13: {
        _28 = _23;
        _27 = Lt(move _28, const 0_i32);
        _26 = Ne(move _27, _15);
        switchInt(move _26) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _29 = _23;
        _0 = (move _29, const true);
        goto -> bb16;
    }

    bb15: {
        _30 = _23;
        _0 = (move _30, _17);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn i64_overflowing_mul(_1: i64, _2: i64) -> (i64, bool) {
    debug lhs => _1;
    debug rhs => _2;
    let mut _0: (i64, bool);
    let mut _3: i64;
    let mut _5: i64;
    let mut _6: i64;
    let mut _8: i64;
    let mut _10: i64;
    let mut _11: i64;
    let mut _12: i64;
    let mut _13: i64;
    let mut _14: i64;
    let mut _18: (u64, bool);
    let mut _19: u64;
    let mut _20: i64;
    let mut _21: u64;
    let mut _22: i64;
    let mut _24: i64;
    let mut _25: i64;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: i64;
    let mut _29: i64;
    let mut _30: i64;
    scope 1 {
        debug lhs => _3;
        let mut _4: i64;
        scope 2 {
            debug rhs => _4;
            let _7: bool;
            scope 3 {
                debug lhs_neg => _7;
                let _9: bool;
                scope 4 {
                    debug rhs_neg => _9;
                    let _15: bool;
                    scope 5 {
                        debug mul_neg => _15;
                        let _16: u64;
                        let _17: bool;
                        scope 6 {
                            debug mul => _16;
                            debug o => _17;
                            let mut _23: i64;
                            scope 7 {
                                debug mul => _23;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _5 = _3;
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = _4;
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = (const 0_i64, const false);
        goto -> bb16;
    }

    bb3: {
        _8 = _3;
        _7 = Lt(move _8, const 0_i64);
        _10 = _4;
        _9 = Lt(move _10, const 0_i64);
        switchInt(_7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _12 = _3;
        _11 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move _11;
        goto -> bb6;
    }

    bb6: {
        switchInt(_9) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _14 = _4;
        _13 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _4 = move _13;
        goto -> bb9;
    }

    bb9: {
        _15 = Ne(_7, _9);
        _20 = _3;
        _19 = move _20 as u64 (IntToInt);
        _22 = _4;
        _21 = move _22 as u64 (IntToInt);
        _18 = <u64 as UMulo>::mulo(move _19, move _21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = (_18.0: u64);
        _17 = (_18.1: bool);
        _23 = _16 as i64 (IntToInt);
        switchInt(_15) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _25 = _23;
        _24 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = move _24;
        goto -> bb13;
    }

    bb13: {
        _28 = _23;
        _27 = Lt(move _28, const 0_i64);
        _26 = Ne(move _27, _15);
        switchInt(move _26) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _29 = _23;
        _0 = (move _29, const true);
        goto -> bb16;
    }

    bb15: {
        _30 = _23;
        _0 = (move _30, _17);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn i128_overflowing_mul(_1: i128, _2: i128) -> (i128, bool) {
    debug lhs => _1;
    debug rhs => _2;
    let mut _0: (i128, bool);
    let mut _3: i128;
    let mut _5: i128;
    let mut _6: i128;
    let mut _8: i128;
    let mut _10: i128;
    let mut _11: i128;
    let mut _12: i128;
    let mut _13: i128;
    let mut _14: i128;
    let mut _18: (u128, bool);
    let mut _19: u128;
    let mut _20: i128;
    let mut _21: u128;
    let mut _22: i128;
    let mut _24: i128;
    let mut _25: i128;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: i128;
    let mut _29: i128;
    let mut _30: i128;
    scope 1 {
        debug lhs => _3;
        let mut _4: i128;
        scope 2 {
            debug rhs => _4;
            let _7: bool;
            scope 3 {
                debug lhs_neg => _7;
                let _9: bool;
                scope 4 {
                    debug rhs_neg => _9;
                    let _15: bool;
                    scope 5 {
                        debug mul_neg => _15;
                        let _16: u128;
                        let _17: bool;
                        scope 6 {
                            debug mul => _16;
                            debug o => _17;
                            let mut _23: i128;
                            scope 7 {
                                debug mul => _23;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _4 = _2;
        _5 = _3;
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = _4;
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = (const 0_i128, const false);
        goto -> bb16;
    }

    bb3: {
        _8 = _3;
        _7 = Lt(move _8, const 0_i128);
        _10 = _4;
        _9 = Lt(move _10, const 0_i128);
        switchInt(_7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _12 = _3;
        _11 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move _11;
        goto -> bb6;
    }

    bb6: {
        switchInt(_9) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _14 = _4;
        _13 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _14) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _4 = move _13;
        goto -> bb9;
    }

    bb9: {
        _15 = Ne(_7, _9);
        _20 = _3;
        _19 = move _20 as u128 (IntToInt);
        _22 = _4;
        _21 = move _22 as u128 (IntToInt);
        _18 = <u128 as UMulo>::mulo(move _19, move _21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _16 = (_18.0: u128);
        _17 = (_18.1: bool);
        _23 = _16 as i128 (IntToInt);
        switchInt(_15) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _25 = _23;
        _24 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _25) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = move _24;
        goto -> bb13;
    }

    bb13: {
        _28 = _23;
        _27 = Lt(move _28, const 0_i128);
        _26 = Ne(move _27, _15);
        switchInt(move _26) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _29 = _23;
        _0 = (move _29, const true);
        goto -> bb16;
    }

    bb15: {
        _30 = _23;
        _0 = (move _30, _17);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn int::mul::__muldi3(_1: u64, _2: u64) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = <u64 as int::mul::Mul>::mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __muldi3::__muldi3(_1: u64, _2: u64) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = int::mul::__muldi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__multi3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = <i128 as int::mul::Mul>::mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __multi3::__multi3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = int::mul::__multi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__mulosi4(_1: i32, _2: i32, _3: &mut i32) -> i32 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i32;
    let _4: bool;
    let mut _5: (i32, bool);
    scope 1 {
        debug mul => _0;
        debug o => _4;
    }

    bb0: {
        _5 = i32_overflowing_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_5.0: i32);
        _4 = (_5.1: bool);
        (*_3) = _4 as i32 (IntToInt);
        return;
    }
}

fn __mulosi4::__mulosi4(_1: i32, _2: i32, _3: &mut i32) -> i32 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i32;

    bb0: {
        _0 = int::mul::__mulosi4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__mulodi4(_1: i64, _2: i64, _3: &mut i32) -> i64 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i64;
    let _4: bool;
    let mut _5: (i64, bool);
    scope 1 {
        debug mul => _0;
        debug o => _4;
    }

    bb0: {
        _5 = i64_overflowing_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_5.0: i64);
        _4 = (_5.1: bool);
        (*_3) = _4 as i32 (IntToInt);
        return;
    }
}

fn __mulodi4::__mulodi4(_1: i64, _2: i64, _3: &mut i32) -> i64 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i64;

    bb0: {
        _0 = int::mul::__mulodi4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__muloti4(_1: i128, _2: i128, _3: &mut i32) -> i128 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i128;
    let _4: bool;
    let mut _5: (i128, bool);
    scope 1 {
        debug mul => _0;
        debug o => _4;
    }

    bb0: {
        _5 = i128_overflowing_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_5.0: i128);
        _4 = (_5.1: bool);
        (*_3) = _4 as i32 (IntToInt);
        return;
    }
}

fn __muloti4::__muloti4(_1: i128, _2: i128, _3: &mut i32) -> i128 {
    debug a => _1;
    debug b => _2;
    debug oflow => _3;
    let mut _0: i128;

    bb0: {
        _0 = int::mul::__muloti4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__rust_i128_mulo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = i128_overflowing_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_i128_mulo::__rust_i128_mulo(_1: i128, _2: i128) -> (i128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = int::mul::__rust_i128_mulo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::mul::__rust_u128_mulo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = <u128 as UMulo>::mulo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __rust_u128_mulo::__rust_u128_mulo(_1: u128, _2: u128) -> (u128, bool) {
    debug a => _1;
    debug b => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = int::mul::__rust_u128_mulo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divmodsi4(_1: i32, _2: i32, _3: &mut i32) -> i32 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i32;
    let _4: bool;
    let mut _8: i32;
    let mut _9: i32;
    let mut _10: i32;
    let mut _11: i32;
    let mut _13: i32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: i32;
    let mut _18: u32;
    let mut _19: i32;
    let mut _20: rustc_std_workspace_core::option::Option<&mut u32>;
    let mut _21: &mut u32;
    let mut _23: u32;
    let mut _24: i32;
    let mut _25: i32;
    let mut _26: i32;
    let mut _27: bool;
    scope 1 {
        debug a_neg => _4;
        let _5: bool;
        scope 2 {
            debug b_neg => _5;
            let mut _6: i32;
            scope 3 {
                debug a => _6;
                let mut _7: i32;
                scope 4 {
                    debug b => _7;
                    let mut _12: u32;
                    scope 5 {
                        debug r => _12;
                        let _14: i32;
                        scope 6 {
                            debug t => _14;
                            let mut _22: i32;
                            scope 7 {
                                debug r => _22;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Lt(_1, const 0_i32);
        _5 = Lt(_2, const 0_i32);
        _6 = _1;
        _7 = _2;
        switchInt(_4) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _9 = _6;
        _8 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = move _8;
        goto -> bb3;
    }

    bb3: {
        switchInt(_5) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _11 = _7;
        _10 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = move _10;
        goto -> bb6;
    }

    bb6: {
        _13 = (*_3);
        _12 = move _13 as u32 (IntToInt);
        _17 = _6;
        _16 = move _17 as u32 (IntToInt);
        _19 = _7;
        _18 = move _19 as u32 (IntToInt);
        _21 = &mut _12;
        _20 = Option::<&mut u32>::Some(_21);
        _15 = udiv::__udivmodsi4(move _16, move _18, move _20) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = move _15 as i32 (IntToInt);
        _23 = _12;
        _22 = move _23 as i32 (IntToInt);
        switchInt(_4) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _25 = _22;
        _24 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _25) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _22 = move _24;
        goto -> bb10;
    }

    bb10: {
        _26 = _22;
        (*_3) = move _26;
        _27 = Ne(_4, _5);
        switchInt(move _27) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(_14) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _0 = _14;
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

fn __divmodsi4::__divmodsi4(_1: i32, _2: i32, _3: &mut i32) -> i32 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i32;

    bb0: {
        _0 = sdiv::__divmodsi4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divsi3(_1: i32, _2: i32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let _3: bool;
    let mut _7: i32;
    let mut _8: i32;
    let mut _9: i32;
    let mut _10: i32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: i32;
    let mut _15: u32;
    let mut _16: i32;
    let mut _17: bool;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i32;
            scope 3 {
                debug a => _5;
                let mut _6: i32;
                scope 4 {
                    debug b => _6;
                    let _11: i32;
                    scope 5 {
                        debug t => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i32);
        _4 = Lt(_2, const 0_i32);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u32 (IntToInt);
        _16 = _6;
        _15 = move _16 as u32 (IntToInt);
        _12 = udiv::__udivsi3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i32 (IntToInt);
        _17 = Ne(_3, _4);
        switchInt(move _17) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __divsi3::__divsi3(_1: i32, _2: i32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = sdiv::__divsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__modsi3(_1: i32, _2: i32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;
    let _3: bool;
    let mut _7: i32;
    let mut _8: i32;
    let mut _9: i32;
    let mut _10: i32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: i32;
    let mut _15: u32;
    let mut _16: i32;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i32;
            scope 3 {
                debug a => _5;
                let mut _6: i32;
                scope 4 {
                    debug b => _6;
                    let _11: i32;
                    scope 5 {
                        debug r => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i32);
        _4 = Lt(_2, const 0_i32);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u32 (IntToInt);
        _16 = _6;
        _15 = move _16 as u32 (IntToInt);
        _12 = udiv::__umodsi3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i32 (IntToInt);
        switchInt(_3) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __modsi3::__modsi3(_1: i32, _2: i32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = sdiv::__modsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divmoddi4(_1: i64, _2: i64, _3: &mut i64) -> i64 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i64;
    let _4: bool;
    let mut _8: i64;
    let mut _9: i64;
    let mut _10: i64;
    let mut _11: i64;
    let mut _13: i64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: i64;
    let mut _18: u64;
    let mut _19: i64;
    let mut _20: rustc_std_workspace_core::option::Option<&mut u64>;
    let mut _21: &mut u64;
    let mut _23: u64;
    let mut _24: i64;
    let mut _25: i64;
    let mut _26: i64;
    let mut _27: bool;
    scope 1 {
        debug a_neg => _4;
        let _5: bool;
        scope 2 {
            debug b_neg => _5;
            let mut _6: i64;
            scope 3 {
                debug a => _6;
                let mut _7: i64;
                scope 4 {
                    debug b => _7;
                    let mut _12: u64;
                    scope 5 {
                        debug r => _12;
                        let _14: i64;
                        scope 6 {
                            debug t => _14;
                            let mut _22: i64;
                            scope 7 {
                                debug r => _22;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Lt(_1, const 0_i64);
        _5 = Lt(_2, const 0_i64);
        _6 = _1;
        _7 = _2;
        switchInt(_4) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _9 = _6;
        _8 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = move _8;
        goto -> bb3;
    }

    bb3: {
        switchInt(_5) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _11 = _7;
        _10 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = move _10;
        goto -> bb6;
    }

    bb6: {
        _13 = (*_3);
        _12 = move _13 as u64 (IntToInt);
        _17 = _6;
        _16 = move _17 as u64 (IntToInt);
        _19 = _7;
        _18 = move _19 as u64 (IntToInt);
        _21 = &mut _12;
        _20 = Option::<&mut u64>::Some(_21);
        _15 = udiv::__udivmoddi4(move _16, move _18, move _20) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = move _15 as i64 (IntToInt);
        _23 = _12;
        _22 = move _23 as i64 (IntToInt);
        switchInt(_4) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _25 = _22;
        _24 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _25) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _22 = move _24;
        goto -> bb10;
    }

    bb10: {
        _26 = _22;
        (*_3) = move _26;
        _27 = Ne(_4, _5);
        switchInt(move _27) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(_14) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _0 = _14;
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

fn __divmoddi4::__divmoddi4(_1: i64, _2: i64, _3: &mut i64) -> i64 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i64;

    bb0: {
        _0 = sdiv::__divmoddi4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divdi3(_1: i64, _2: i64) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;
    let _3: bool;
    let mut _7: i64;
    let mut _8: i64;
    let mut _9: i64;
    let mut _10: i64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: i64;
    let mut _15: u64;
    let mut _16: i64;
    let mut _17: bool;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i64;
            scope 3 {
                debug a => _5;
                let mut _6: i64;
                scope 4 {
                    debug b => _6;
                    let _11: i64;
                    scope 5 {
                        debug t => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i64);
        _4 = Lt(_2, const 0_i64);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u64 (IntToInt);
        _16 = _6;
        _15 = move _16 as u64 (IntToInt);
        _12 = udiv::__udivdi3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i64 (IntToInt);
        _17 = Ne(_3, _4);
        switchInt(move _17) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __divdi3::__divdi3(_1: i64, _2: i64) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;

    bb0: {
        _0 = sdiv::__divdi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__moddi3(_1: i64, _2: i64) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;
    let _3: bool;
    let mut _7: i64;
    let mut _8: i64;
    let mut _9: i64;
    let mut _10: i64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: i64;
    let mut _15: u64;
    let mut _16: i64;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i64;
            scope 3 {
                debug a => _5;
                let mut _6: i64;
                scope 4 {
                    debug b => _6;
                    let _11: i64;
                    scope 5 {
                        debug r => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i64);
        _4 = Lt(_2, const 0_i64);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u64 (IntToInt);
        _16 = _6;
        _15 = move _16 as u64 (IntToInt);
        _12 = udiv::__umoddi3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i64 (IntToInt);
        switchInt(_3) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __moddi3::__moddi3(_1: i64, _2: i64) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;

    bb0: {
        _0 = sdiv::__moddi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divmodti4(_1: i128, _2: i128, _3: &mut i128) -> i128 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i128;
    let _4: bool;
    let mut _8: i128;
    let mut _9: i128;
    let mut _10: i128;
    let mut _11: i128;
    let mut _13: i128;
    let mut _15: u128;
    let mut _16: u128;
    let mut _17: i128;
    let mut _18: u128;
    let mut _19: i128;
    let mut _20: rustc_std_workspace_core::option::Option<&mut u128>;
    let mut _21: &mut u128;
    let mut _23: u128;
    let mut _24: i128;
    let mut _25: i128;
    let mut _26: i128;
    let mut _27: bool;
    scope 1 {
        debug a_neg => _4;
        let _5: bool;
        scope 2 {
            debug b_neg => _5;
            let mut _6: i128;
            scope 3 {
                debug a => _6;
                let mut _7: i128;
                scope 4 {
                    debug b => _7;
                    let mut _12: u128;
                    scope 5 {
                        debug r => _12;
                        let _14: i128;
                        scope 6 {
                            debug t => _14;
                            let mut _22: i128;
                            scope 7 {
                                debug r => _22;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Lt(_1, const 0_i128);
        _5 = Lt(_2, const 0_i128);
        _6 = _1;
        _7 = _2;
        switchInt(_4) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _9 = _6;
        _8 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = move _8;
        goto -> bb3;
    }

    bb3: {
        switchInt(_5) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _11 = _7;
        _10 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _7 = move _10;
        goto -> bb6;
    }

    bb6: {
        _13 = (*_3);
        _12 = move _13 as u128 (IntToInt);
        _17 = _6;
        _16 = move _17 as u128 (IntToInt);
        _19 = _7;
        _18 = move _19 as u128 (IntToInt);
        _21 = &mut _12;
        _20 = Option::<&mut u128>::Some(_21);
        _15 = udiv::__udivmodti4(move _16, move _18, move _20) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = move _15 as i128 (IntToInt);
        _23 = _12;
        _22 = move _23 as i128 (IntToInt);
        switchInt(_4) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _25 = _22;
        _24 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _25) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _22 = move _24;
        goto -> bb10;
    }

    bb10: {
        _26 = _22;
        (*_3) = move _26;
        _27 = Ne(_4, _5);
        switchInt(move _27) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(_14) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _0 = _14;
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

fn __divmodti4::__divmodti4(_1: i128, _2: i128, _3: &mut i128) -> i128 {
    debug a => _1;
    debug b => _2;
    debug rem => _3;
    let mut _0: i128;

    bb0: {
        _0 = sdiv::__divmodti4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__divti3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;
    let _3: bool;
    let mut _7: i128;
    let mut _8: i128;
    let mut _9: i128;
    let mut _10: i128;
    let mut _12: u128;
    let mut _13: u128;
    let mut _14: i128;
    let mut _15: u128;
    let mut _16: i128;
    let mut _17: bool;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i128;
            scope 3 {
                debug a => _5;
                let mut _6: i128;
                scope 4 {
                    debug b => _6;
                    let _11: i128;
                    scope 5 {
                        debug t => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i128);
        _4 = Lt(_2, const 0_i128);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u128 (IntToInt);
        _16 = _6;
        _15 = move _16 as u128 (IntToInt);
        _12 = udiv::__udivti3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i128 (IntToInt);
        _17 = Ne(_3, _4);
        switchInt(move _17) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __divti3::__divti3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = sdiv::__divti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn sdiv::__modti3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;
    let _3: bool;
    let mut _7: i128;
    let mut _8: i128;
    let mut _9: i128;
    let mut _10: i128;
    let mut _12: u128;
    let mut _13: u128;
    let mut _14: i128;
    let mut _15: u128;
    let mut _16: i128;
    scope 1 {
        debug a_neg => _3;
        let _4: bool;
        scope 2 {
            debug b_neg => _4;
            let mut _5: i128;
            scope 3 {
                debug a => _5;
                let mut _6: i128;
                scope 4 {
                    debug b => _6;
                    let _11: i128;
                    scope 5 {
                        debug r => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Lt(_1, const 0_i128);
        _4 = Lt(_2, const 0_i128);
        _5 = _1;
        _6 = _2;
        switchInt(_3) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _8 = _5;
        _7 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _8) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _7;
        goto -> bb3;
    }

    bb3: {
        switchInt(_4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _6;
        _9 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _6 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = _5;
        _13 = move _14 as u128 (IntToInt);
        _16 = _6;
        _15 = move _16 as u128 (IntToInt);
        _12 = udiv::__umodti3(move _13, move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = move _12 as i128 (IntToInt);
        switchInt(_3) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(_11) -> [return: bb10, unwind unreachable];
    }

    bb9: {
        _0 = _11;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn __modti3::__modti3(_1: i128, _2: i128) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = sdiv::__modti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn Ashl::ashl(_1: Self, _2: u32) -> Self {
    debug self => _1;
    debug shl => _2;
    let mut _0: Self;
    let _3: u32;
    let mut _4: u32;
    let mut _5: <Self as int::DInt>::H;
    let mut _6: <Self as int::DInt>::H;
    let mut _7: u32;
    let mut _8: (u32, bool);
    let mut _9: <Self as int::DInt>::H;
    let mut _10: <Self as int::DInt>::H;
    let mut _11: <Self as int::DInt>::H;
    let mut _12: <Self as int::DInt>::H;
    let mut _13: <Self as int::DInt>::H;
    let mut _14: u32;
    let mut _15: <Self as int::DInt>::H;
    let mut _16: <Self as int::DInt>::H;
    scope 1 {
        debug n_h => const _;
    }

    bb0: {
        _3 = const _;
        _4 = BitAnd(_2, _3);
        switchInt(move _4) -> [0: bb5, otherwise: bb1];
    }

    bb1: {
        _6 = <Self as DInt>::lo(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = CheckedSub(_2, _3);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = move (_8.0: u32);
        _5 = <<Self as DInt>::H as Int>::wrapping_shl(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <<Self as DInt>::H as HInt>::widen_hi(move _5) -> [return: bb16, unwind unreachable];
    }

    bb5: {
        switchInt(move _2) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        _0 = _1;
        goto -> bb16;
    }

    bb7: {
        _10 = <Self as DInt>::lo(_1) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _9 = <<Self as DInt>::H as Int>::wrapping_shl(move _10, _2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Self as DInt>::lo(_1) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _14 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_3, _2) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _12 = <<Self as DInt>::H as Int>::logical_shr(move _13, move _14) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _16 = <Self as DInt>::hi(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _15 = <<Self as DInt>::H as Int>::wrapping_shl(move _16, _2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _11 = <<Self as DInt>::H as BitOr>::bitor(move _12, move _15) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = <Self as DInt>::from_lo_hi(move _9, move _11) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        return;
    }
}

fn Ashr::ashr(_1: Self, _2: u32) -> Self {
    debug self => _1;
    debug shr => _2;
    let mut _0: Self;
    let _3: u32;
    let mut _4: u32;
    let mut _5: <Self as int::DInt>::H;
    let mut _6: <Self as int::DInt>::H;
    let mut _7: u32;
    let mut _8: (u32, bool);
    let mut _9: <Self as int::DInt>::H;
    let mut _10: <Self as int::DInt>::H;
    let mut _11: u32;
    let mut _12: (u32, bool);
    let mut _13: <Self as int::DInt>::H;
    let mut _14: <Self as int::DInt>::H;
    let mut _15: <Self as int::DInt>::H;
    let mut _16: <Self as int::DInt>::H;
    let mut _17: <Self as int::DInt>::H;
    let mut _18: u32;
    let mut _19: <Self as int::DInt>::H;
    let mut _20: <Self as int::DInt>::H;
    scope 1 {
        debug n_h => const _;
    }

    bb0: {
        _3 = const _;
        _4 = BitAnd(_2, _3);
        switchInt(move _4) -> [0: bb8, otherwise: bb1];
    }

    bb1: {
        _6 = <Self as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = CheckedSub(_2, _3);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = move (_8.0: u32);
        _5 = <<Self as DInt>::H as Int>::wrapping_shr(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = <Self as DInt>::hi(_1) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _12 = CheckedSub(_3, const 1_u32);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_u32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = move (_12.0: u32);
        _9 = <<Self as DInt>::H as Int>::wrapping_shr(move _10, move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = <Self as DInt>::from_lo_hi(move _5, move _9) -> [return: bb19, unwind unreachable];
    }

    bb8: {
        switchInt(move _2) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _0 = _1;
        goto -> bb19;
    }

    bb10: {
        _15 = <Self as DInt>::lo(_1) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _14 = <<Self as DInt>::H as Int>::logical_shr(move _15, _2) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _17 = <Self as DInt>::hi(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _18 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_3, _2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _16 = <<Self as DInt>::H as Int>::wrapping_shl(move _17, move _18) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _13 = <<Self as DInt>::H as BitOr>::bitor(move _14, move _16) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _20 = <Self as DInt>::hi(_1) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _19 = <<Self as DInt>::H as Int>::wrapping_shr(move _20, _2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = <Self as DInt>::from_lo_hi(move _13, move _19) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        return;
    }
}

fn Lshr::lshr(_1: Self, _2: u32) -> Self {
    debug self => _1;
    debug shr => _2;
    let mut _0: Self;
    let _3: u32;
    let mut _4: u32;
    let mut _5: <Self as int::DInt>::H;
    let mut _6: <Self as int::DInt>::H;
    let mut _7: u32;
    let mut _8: (u32, bool);
    let mut _9: <Self as int::DInt>::H;
    let mut _10: <Self as int::DInt>::H;
    let mut _11: <Self as int::DInt>::H;
    let mut _12: <Self as int::DInt>::H;
    let mut _13: <Self as int::DInt>::H;
    let mut _14: u32;
    let mut _15: <Self as int::DInt>::H;
    let mut _16: <Self as int::DInt>::H;
    scope 1 {
        debug n_h => const _;
    }

    bb0: {
        _3 = const _;
        _4 = BitAnd(_2, _3);
        switchInt(move _4) -> [0: bb5, otherwise: bb1];
    }

    bb1: {
        _6 = <Self as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = CheckedSub(_2, _3);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = move (_8.0: u32);
        _5 = <<Self as DInt>::H as Int>::logical_shr(move _6, move _7) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = <<Self as DInt>::H as HInt>::zero_widen(move _5) -> [return: bb16, unwind unreachable];
    }

    bb5: {
        switchInt(move _2) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        _0 = _1;
        goto -> bb16;
    }

    bb7: {
        _11 = <Self as DInt>::lo(_1) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _10 = <<Self as DInt>::H as Int>::logical_shr(move _11, _2) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _13 = <Self as DInt>::hi(_1) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _14 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_3, _2) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _12 = <<Self as DInt>::H as Int>::wrapping_shl(move _13, move _14) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _9 = <<Self as DInt>::H as BitOr>::bitor(move _10, move _12) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _16 = <Self as DInt>::hi(_1) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _15 = <<Self as DInt>::H as Int>::logical_shr(move _16, _2) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = <Self as DInt>::from_lo_hi(move _9, move _15) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        return;
    }
}

fn shift::__ashlsi3(_1: u32, _2: u32) -> u32 {
    debug a => _1;
    debug b => _2;
    let mut _0: u32;

    bb0: {
        _0 = <u32 as Ashl>::ashl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashlsi3::__ashlsi3(_1: u32, _2: u32) -> u32 {
    debug a => _1;
    debug b => _2;
    let mut _0: u32;

    bb0: {
        _0 = shift::__ashlsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__ashldi3(_1: u64, _2: u32) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = <u64 as Ashl>::ashl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashldi3::__ashldi3(_1: u64, _2: u32) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = shift::__ashldi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__ashlti3(_1: u128, _2: u32) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = <u128 as Ashl>::ashl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashlti3::__ashlti3(_1: u128, _2: u32) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = shift::__ashlti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__ashrsi3(_1: i32, _2: u32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = <i32 as Ashr>::ashr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashrsi3::__ashrsi3(_1: i32, _2: u32) -> i32 {
    debug a => _1;
    debug b => _2;
    let mut _0: i32;

    bb0: {
        _0 = shift::__ashrsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__ashrdi3(_1: i64, _2: u32) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;

    bb0: {
        _0 = <i64 as Ashr>::ashr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashrdi3::__ashrdi3(_1: i64, _2: u32) -> i64 {
    debug a => _1;
    debug b => _2;
    let mut _0: i64;

    bb0: {
        _0 = shift::__ashrdi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__ashrti3(_1: i128, _2: u32) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = <i128 as Ashr>::ashr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __ashrti3::__ashrti3(_1: i128, _2: u32) -> i128 {
    debug a => _1;
    debug b => _2;
    let mut _0: i128;

    bb0: {
        _0 = shift::__ashrti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__lshrsi3(_1: u32, _2: u32) -> u32 {
    debug a => _1;
    debug b => _2;
    let mut _0: u32;

    bb0: {
        _0 = <u32 as Lshr>::lshr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __lshrsi3::__lshrsi3(_1: u32, _2: u32) -> u32 {
    debug a => _1;
    debug b => _2;
    let mut _0: u32;

    bb0: {
        _0 = shift::__lshrsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__lshrdi3(_1: u64, _2: u32) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = <u64 as Lshr>::lshr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __lshrdi3::__lshrdi3(_1: u64, _2: u32) -> u64 {
    debug a => _1;
    debug b => _2;
    let mut _0: u64;

    bb0: {
        _0 = shift::__lshrdi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn shift::__lshrti3(_1: u128, _2: u32) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = <u128 as Lshr>::lshr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __lshrti3::__lshrti3(_1: u128, _2: u32) -> u128 {
    debug a => _1;
    debug b => _2;
    let mut _0: u128;

    bb0: {
        _0 = shift::__lshrti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivsi3(_1: u32, _2: u32) -> u32 {
    debug n => _1;
    debug d => _2;
    let mut _0: u32;
    let mut _3: (u32, u32);

    bb0: {
        _3 = specialized_div_rem::u32_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.0: u32);
        return;
    }
}

fn udiv::__udivsi3::__udivsi3(_1: u32, _2: u32) -> u32 {
    debug n => _1;
    debug d => _2;
    let mut _0: u32;

    bb0: {
        _0 = udiv::__udivsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__umodsi3(_1: u32, _2: u32) -> u32 {
    debug n => _1;
    debug d => _2;
    let mut _0: u32;
    let mut _3: (u32, u32);

    bb0: {
        _3 = specialized_div_rem::u32_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.1: u32);
        return;
    }
}

fn udiv::__umodsi3::__umodsi3(_1: u32, _2: u32) -> u32 {
    debug n => _1;
    debug d => _2;
    let mut _0: u32;

    bb0: {
        _0 = udiv::__umodsi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivmodsi4(_1: u32, _2: u32, _3: Option<&mut u32>) -> u32 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u32;
    let _4: (u32, u32);
    let mut _5: isize;
    let mut _7: u32;
    scope 1 {
        debug quo_rem => _4;
        scope 2 {
            debug rem => _6;
            let _6: &mut u32;
        }
    }

    bb0: {
        _4 = specialized_div_rem::u32_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Some).0: &mut u32);
        _7 = (_4.1: u32);
        (*_6) = move _7;
        goto -> bb3;
    }

    bb3: {
        _0 = (_4.0: u32);
        return;
    }
}

fn udiv::__udivmodsi4::__udivmodsi4(_1: u32, _2: u32, _3: Option<&mut u32>) -> u32 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u32;

    bb0: {
        _0 = udiv::__udivmodsi4(_1, _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivdi3(_1: u64, _2: u64) -> u64 {
    debug n => _1;
    debug d => _2;
    let mut _0: u64;
    let mut _3: (u64, u64);

    bb0: {
        _3 = specialized_div_rem::u64_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.0: u64);
        return;
    }
}

fn udiv::__udivdi3::__udivdi3(_1: u64, _2: u64) -> u64 {
    debug n => _1;
    debug d => _2;
    let mut _0: u64;

    bb0: {
        _0 = udiv::__udivdi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__umoddi3(_1: u64, _2: u64) -> u64 {
    debug n => _1;
    debug d => _2;
    let mut _0: u64;
    let mut _3: (u64, u64);

    bb0: {
        _3 = specialized_div_rem::u64_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.1: u64);
        return;
    }
}

fn udiv::__umoddi3::__umoddi3(_1: u64, _2: u64) -> u64 {
    debug n => _1;
    debug d => _2;
    let mut _0: u64;

    bb0: {
        _0 = udiv::__umoddi3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivmoddi4(_1: u64, _2: u64, _3: Option<&mut u64>) -> u64 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u64;
    let _4: (u64, u64);
    let mut _5: isize;
    let mut _7: u64;
    scope 1 {
        debug quo_rem => _4;
        scope 2 {
            debug rem => _6;
            let _6: &mut u64;
        }
    }

    bb0: {
        _4 = specialized_div_rem::u64_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Some).0: &mut u64);
        _7 = (_4.1: u64);
        (*_6) = move _7;
        goto -> bb3;
    }

    bb3: {
        _0 = (_4.0: u64);
        return;
    }
}

fn udiv::__udivmoddi4::__udivmoddi4(_1: u64, _2: u64, _3: Option<&mut u64>) -> u64 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u64;

    bb0: {
        _0 = udiv::__udivmoddi4(_1, _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivti3(_1: u128, _2: u128) -> u128 {
    debug n => _1;
    debug d => _2;
    let mut _0: u128;
    let mut _3: (u128, u128);

    bb0: {
        _3 = specialized_div_rem::u128_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.0: u128);
        return;
    }
}

fn udiv::__udivti3::__udivti3(_1: u128, _2: u128) -> u128 {
    debug n => _1;
    debug d => _2;
    let mut _0: u128;

    bb0: {
        _0 = udiv::__udivti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__umodti3(_1: u128, _2: u128) -> u128 {
    debug n => _1;
    debug d => _2;
    let mut _0: u128;
    let mut _3: (u128, u128);

    bb0: {
        _3 = specialized_div_rem::u128_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.1: u128);
        return;
    }
}

fn udiv::__umodti3::__umodti3(_1: u128, _2: u128) -> u128 {
    debug n => _1;
    debug d => _2;
    let mut _0: u128;

    bb0: {
        _0 = udiv::__umodti3(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn udiv::__udivmodti4(_1: u128, _2: u128, _3: Option<&mut u128>) -> u128 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u128;
    let _4: (u128, u128);
    let mut _5: isize;
    let mut _7: u128;
    scope 1 {
        debug quo_rem => _4;
        scope 2 {
            debug rem => _6;
            let _6: &mut u128;
        }
    }

    bb0: {
        _4 = specialized_div_rem::u128_div_rem(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Some).0: &mut u128);
        _7 = (_4.1: u128);
        (*_6) = move _7;
        goto -> bb3;
    }

    bb3: {
        _0 = (_4.0: u128);
        return;
    }
}

fn udiv::__udivmodti4::__udivmodti4(_1: u128, _2: u128, _3: Option<&mut u128>) -> u128 {
    debug n => _1;
    debug d => _2;
    debug rem => _3;
    let mut _0: u128;

    bb0: {
        _0 = udiv::__udivmodti4(_1, _2, move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

Int::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: usize) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: usize) -> usize {
    debug me => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: usize, _2: usize) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl usize>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 0_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> usize {
    debug b => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: usize, _2: u32) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: usize;

    bb0: {
        _4 = <usize as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl usize>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <usize as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: usize) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: usize) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: usize, _2: usize) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: usize, _2: usize) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: usize, _2: usize) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: usize, _2: u32) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: usize, _2: u32) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: usize, _2: u32) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: usize, _2: usize) -> (usize, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (usize, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: usize) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl usize>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: isize) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: usize) -> isize {
    debug me => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: isize, _2: isize) -> usize {
    debug self => _1;
    debug other => _2;
    let mut _0: usize;
    let mut _3: isize;
    let mut _4: isize;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl isize>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl isize>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as usize (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl isize>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 0_isize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 1_isize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> isize {
    debug b => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: isize, _2: u32) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;
    let mut _3: usize;
    let mut _4: usize;

    bb0: {
        _4 = <isize as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl usize>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <isize as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: isize) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: isize, _2: isize) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: isize, _2: isize) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: isize, _2: isize) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: isize, _2: u32) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: isize, _2: u32) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: isize, _2: u32) -> isize {
    debug self => _1;
    debug other => _2;
    let mut _0: isize;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: isize, _2: isize) -> (isize, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (isize, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: isize) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl isize>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: u8) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: u8) -> u8 {
    debug me => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: u8, _2: u8) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl u8>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 0_u8;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> u8 {
    debug b => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: u8, _2: u32) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;
    let mut _3: u8;
    let mut _4: u8;

    bb0: {
        _4 = <u8 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u8>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <u8 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: u8) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: u8) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: u8, _2: u8) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: u8, _2: u8) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: u8, _2: u8) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: u8, _2: u32) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: u8, _2: u32) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: u8, _2: u32) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: u8, _2: u8) -> (u8, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (u8, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: u8) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u8>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: i8) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: u8) -> i8 {
    debug me => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: i8, _2: i8) -> u8 {
    debug self => _1;
    debug other => _2;
    let mut _0: u8;
    let mut _3: i8;
    let mut _4: i8;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl i8>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl i8>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as u8 (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl i8>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: i8 = {
    let mut _0: i8;

    bb0: {
        _0 = const 0_i8;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: i8 = {
    let mut _0: i8;

    bb0: {
        _0 = const 1_i8;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: i8 = {
    let mut _0: i8;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: i8 = {
    let mut _0: i8;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> i8 {
    debug b => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: i8, _2: u32) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;
    let mut _3: u8;
    let mut _4: u8;

    bb0: {
        _4 = <i8 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u8>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <i8 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: i8) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: i8) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: i8, _2: i8) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: i8, _2: i8) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: i8, _2: i8) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: i8, _2: u32) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: i8, _2: u32) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: i8, _2: u32) -> i8 {
    debug self => _1;
    debug other => _2;
    let mut _0: i8;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: i8, _2: i8) -> (i8, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (i8, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: i8) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i8>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: u16) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: u16) -> u16 {
    debug me => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: u16, _2: u16) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl u16>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: u16 = {
    let mut _0: u16;

    bb0: {
        _0 = const 0_u16;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: u16 = {
    let mut _0: u16;

    bb0: {
        _0 = const 1_u16;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: u16 = {
    let mut _0: u16;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: u16 = {
    let mut _0: u16;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> u16 {
    debug b => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: u16, _2: u32) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _4 = <u16 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u16>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <u16 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: u16) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: u16) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: u16, _2: u16) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: u16, _2: u16) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: u16, _2: u16) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: u16, _2: u32) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: u16, _2: u32) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: u16, _2: u32) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: u16, _2: u16) -> (u16, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (u16, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: u16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u16>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: i16) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: u16) -> i16 {
    debug me => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: i16, _2: i16) -> u16 {
    debug self => _1;
    debug other => _2;
    let mut _0: u16;
    let mut _3: i16;
    let mut _4: i16;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl i16>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl i16>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as u16 (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl i16>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: i16 = {
    let mut _0: i16;

    bb0: {
        _0 = const 0_i16;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: i16 = {
    let mut _0: i16;

    bb0: {
        _0 = const 1_i16;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: i16 = {
    let mut _0: i16;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: i16 = {
    let mut _0: i16;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> i16 {
    debug b => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: i16, _2: u32) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _4 = <i16 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u16>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <i16 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: i16) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: i16) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: i16, _2: i16) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: i16, _2: i16) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: i16, _2: i16) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: i16, _2: u32) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: i16, _2: u32) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: i16, _2: u32) -> i16 {
    debug self => _1;
    debug other => _2;
    let mut _0: i16;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: i16, _2: i16) -> (i16, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (i16, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: i16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i16>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: u32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: u32) -> u32 {
    debug me => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl u32>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 0_u32;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 1_u32;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> u32 {
    debug b => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _4 = <u32 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u32>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <u32 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: u32) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: u32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: u32, _2: u32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: u32, _2: u32) -> (u32, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (u32, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: u32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u32>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: i32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: u32) -> i32 {
    debug me => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: i32, _2: i32) -> u32 {
    debug self => _1;
    debug other => _2;
    let mut _0: u32;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl i32>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as u32 (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl i32>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 1_i32;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> i32 {
    debug b => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: i32, _2: u32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _4 = <i32 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u32>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <i32 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: i32) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: i32) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: i32, _2: i32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: i32, _2: i32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: i32, _2: i32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: i32, _2: u32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: i32, _2: u32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: i32, _2: u32) -> i32 {
    debug self => _1;
    debug other => _2;
    let mut _0: i32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: i32, _2: i32) -> (i32, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (i32, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: i32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i32>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: u64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: u64) -> u64 {
    debug me => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: u64, _2: u64) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl u64>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 1_u64;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> u64 {
    debug b => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: u64, _2: u32) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = <u64 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u64>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <u64 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: u64) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: u64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: u64, _2: u64) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: u64, _2: u64) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: u64, _2: u64) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: u64, _2: u32) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: u64, _2: u32) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: u64, _2: u32) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: u64, _2: u64) -> (u64, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (u64, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: u64) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: i64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: u64) -> i64 {
    debug me => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: i64, _2: i64) -> u64 {
    debug self => _1;
    debug other => _2;
    let mut _0: u64;
    let mut _3: i64;
    let mut _4: i64;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl i64>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl i64>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as u64 (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl i64>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: i64 = {
    let mut _0: i64;

    bb0: {
        _0 = const 0_i64;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: i64 = {
    let mut _0: i64;

    bb0: {
        _0 = const 1_i64;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: i64 = {
    let mut _0: i64;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: i64 = {
    let mut _0: i64;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> i64 {
    debug b => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: i64, _2: u32) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _4 = <i64 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u64>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <i64 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: i64) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: i64) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: i64, _2: i64) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: i64, _2: i64) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: i64, _2: i64) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: i64, _2: u32) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: i64, _2: u32) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: i64, _2: u32) -> i64 {
    debug self => _1;
    debug other => _2;
    let mut _0: i64;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: i64, _2: i64) -> (i64, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (i64, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: i64) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i64>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::unsigned(_1: u128) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_unsigned(_1: u128) -> u128 {
    debug me => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::abs_diff(_1: u128, _2: u128) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;
    let mut _3: bool;

    bb0: {
        _3 = Lt(_1, _2);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(_2, _1) -> [return: bb3, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(_1, _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl u128>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ZERO: u128 = {
    let mut _0: u128;

    bb0: {
        _0 = const 0_u128;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::ONE: u128 = {
    let mut _0: u128;

    bb0: {
        _0 = const 1_u128;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MIN: u128 = {
    let mut _0: u128;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::MAX: u128 = {
    let mut _0: u128;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::from_bool(_1: bool) -> u128 {
    debug b => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::logical_shr(_1: u128, _2: u32) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;
    let mut _3: u128;
    let mut _4: u128;

    bb0: {
        _4 = <u128 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u128>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <u128 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::is_zero(_1: u128) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_neg(_1: u128) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_add(_1: u128, _2: u128) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_mul(_1: u128, _2: u128) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_sub(_1: u128, _2: u128) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shl(_1: u128, _2: u32) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::wrapping_shr(_1: u128, _2: u32) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::rotate_left(_1: u128, _2: u32) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::overflowing_add(_1: u128, _2: u128) -> (u128, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (u128, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:206:9: 206:26>::leading_zeros(_1: u128) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl u128>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::unsigned(_1: i128) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_unsigned(_1: u128) -> i128 {
    debug me => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::abs_diff(_1: i128, _2: i128) -> u128 {
    debug self => _1;
    debug other => _2;
    let mut _0: u128;
    let mut _3: i128;
    let mut _4: i128;

    bb0: {
        _4 = rustc_std_workspace_core::num::<impl i128>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl i128>::wrapping_abs(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = move _3 as u128 (IntToInt);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::BITS: u32 = {
    let mut _0: u32;

    bb0: {
        ConstEvalCounter;
        _0 = rustc_std_workspace_core::num::<impl i128>::count_zeros(const _) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::SIGNED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = Ne(const _, const _);
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ZERO: i128 = {
    let mut _0: i128;

    bb0: {
        _0 = const 0_i128;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::ONE: i128 = {
    let mut _0: i128;

    bb0: {
        _0 = const 1_i128;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MIN: i128 = {
    let mut _0: i128;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::MAX: i128 = {
    let mut _0: i128;

    bb0: {
        _0 = const _;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS: [u8; 20] = {
    let mut _0: [u8; 20];
    let _1: u32;
    let _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let _9: usize;
    let mut _10: usize;
    let mut _11: bool;
    let _14: ();
    let mut _15: ();
    let _16: ();
    let mut _17: bool;
    let mut _18: u8;
    let mut _19: u8;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: u8;
    let mut _25: (u8, bool);
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: (usize, bool);
    let mut _30: u8;
    let _31: usize;
    let mut _32: usize;
    let mut _33: bool;
    let mut _34: (usize, bool);
    let mut _35: (u8, bool);
    let _36: ();
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: (u32, bool);
    let _44: usize;
    let mut _45: usize;
    let mut _46: bool;
    let mut _47: (usize, bool);
    let _50: ();
    let mut _51: u8;
    let mut _52: u8;
    let mut _53: u32;
    let mut _54: u8;
    let _55: usize;
    let mut _56: usize;
    let mut _57: usize;
    let mut _58: (usize, bool);
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: (u8, bool);
    let mut _62: (u8, bool);
    let _63: usize;
    let mut _64: usize;
    let mut _65: bool;
    let _66: ();
    let mut _67: bool;
    let mut _68: usize;
    let mut _69: usize;
    let mut _70: !;
    let mut _71: (usize, bool);
    let mut _72: (usize, bool);
    scope 1 {
        debug bits => _1;
        let mut _2: [u8; 20];
        scope 2 {
            debug v => _2;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let mut _13: u8;
                scope 4 {
                    debug l => _13;
                    let _48: usize;
                    scope 5 {
                        debug mid => _48;
                        let mut _49: usize;
                        scope 6 {
                            debug j => _49;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        StorageLive(_1);
        _1 = const _;
        StorageLive(_2);
        _2 = [const 0_u8; 20];
        StorageLive(_3);
        _3 = const 0_usize;
        _4 = Len(_2);
        _5 = Lt(_3, _4);
        assert(move _5, "index out of bounds: the length is {} but the index is {}", move _4, _3) -> [success: bb1, unwind: bb31];
    }

    bb1: {
        _2[_3] = const 0_u8;
        StorageDead(_3);
        StorageLive(_6);
        _6 = const 1_usize;
        _7 = Len(_2);
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb2, unwind: bb31];
    }

    bb2: {
        _2[_6] = const 1_u8;
        StorageDead(_6);
        StorageLive(_9);
        _9 = const 2_usize;
        _10 = Len(_2);
        _11 = Lt(_9, _10);
        assert(move _11, "index out of bounds: the length is {} but the index is {}", move _10, _9) -> [success: bb3, unwind: bb31];
    }

    bb3: {
        _2[_9] = const 2_u8;
        StorageDead(_9);
        StorageLive(_12);
        _12 = const 3_usize;
        StorageLive(_13);
        _13 = const 8_u8;
        StorageLive(_14);
        goto -> bb4;
    }

    bb4: {
        StorageLive(_16);
        StorageLive(_17);
        StorageLive(_18);
        _18 = _13;
        StorageLive(_19);
        StorageLive(_20);
        StorageLive(_21);
        _21 = _1;
        _22 = Eq(const 2_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb5, unwind: bb31];
    }

    bb5: {
        _20 = Div(move _21, const 2_u32);
        StorageDead(_21);
        _19 = move _20 as u8 (IntToInt);
        StorageDead(_20);
        _17 = Ge(move _18, move _19);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        StorageDead(_19);
        StorageDead(_18);
        _14 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageDead(_14);
        StorageLive(_36);
        StorageLive(_37);
        StorageLive(_38);
        _38 = _1;
        _37 = Ne(move _38, const 8_u32);
        switchInt(move _37) -> [0: bb15, otherwise: bb14];
    }

    bb7: {
        StorageDead(_19);
        StorageDead(_18);
        _16 = const ();
        StorageDead(_17);
        StorageDead(_16);
        StorageLive(_24);
        _24 = _13;
        _25 = CheckedSub(_24, const 1_u8);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u8) -> [success: bb8, unwind: bb31];
    }

    bb8: {
        StorageLive(_26);
        _26 = _12;
        _27 = Len(_2);
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb9, unwind: bb31];
    }

    bb9: {
        _2[_26] = move (_25.0: u8);
        StorageDead(_24);
        StorageDead(_26);
        _29 = CheckedAdd(_12, const 1_usize);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb10, unwind: bb31];
    }

    bb10: {
        _12 = move (_29.0: usize);
        StorageLive(_30);
        _30 = _13;
        StorageLive(_31);
        _31 = _12;
        _32 = Len(_2);
        _33 = Lt(_31, _32);
        assert(move _33, "index out of bounds: the length is {} but the index is {}", move _32, _31) -> [success: bb11, unwind: bb31];
    }

    bb11: {
        _2[_31] = move _30;
        StorageDead(_30);
        StorageDead(_31);
        _34 = CheckedAdd(_12, const 1_usize);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb12, unwind: bb31];
    }

    bb12: {
        _12 = move (_34.0: usize);
        _35 = CheckedMul(_13, const 2_u8);
        assert(!move (_35.1: bool), "attempt to compute `{} * {}`, which would overflow", _13, const 2_u8) -> [success: bb13, unwind: bb31];
    }

    bb13: {
        _13 = move (_35.0: u8);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb4;
    }

    bb14: {
        StorageDead(_38);
        StorageLive(_39);
        StorageLive(_40);
        StorageLive(_41);
        _41 = _1;
        _42 = Eq(const 2_u32, const 0_u32);
        assert(!move _42, "attempt to divide `{}` by zero", _41) -> [success: bb16, unwind: bb31];
    }

    bb15: {
        StorageDead(_38);
        _36 = const ();
        goto -> bb20;
    }

    bb16: {
        _40 = Div(move _41, const 2_u32);
        StorageDead(_41);
        _43 = CheckedSub(_40, const 1_u32);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_u32) -> [success: bb17, unwind: bb31];
    }

    bb17: {
        _39 = move (_43.0: u32);
        StorageDead(_40);
        StorageLive(_44);
        _44 = _12;
        _45 = Len(_2);
        _46 = Lt(_44, _45);
        assert(move _46, "index out of bounds: the length is {} but the index is {}", move _45, _44) -> [success: bb18, unwind: bb31];
    }

    bb18: {
        _2[_44] = move _39 as u8 (IntToInt);
        StorageDead(_39);
        StorageDead(_44);
        _47 = CheckedAdd(_12, const 1_usize);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb19, unwind: bb31];
    }

    bb19: {
        _12 = move (_47.0: usize);
        _36 = const ();
        goto -> bb20;
    }

    bb20: {
        StorageDead(_37);
        StorageDead(_36);
        StorageLive(_48);
        _48 = _12;
        StorageLive(_49);
        _49 = const 1_usize;
        StorageLive(_50);
        goto -> bb21;
    }

    bb21: {
        StorageLive(_51);
        StorageLive(_52);
        StorageLive(_53);
        _53 = _1;
        _52 = move _53 as u8 (IntToInt);
        StorageDead(_53);
        StorageLive(_54);
        StorageLive(_55);
        StorageLive(_56);
        _56 = _48;
        StorageLive(_57);
        _57 = _49;
        _58 = CheckedSub(_56, _57);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _56, move _57) -> [success: bb22, unwind: bb31];
    }

    bb22: {
        _55 = move (_58.0: usize);
        StorageDead(_57);
        StorageDead(_56);
        _59 = Len(_2);
        _60 = Lt(_55, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _55) -> [success: bb23, unwind: bb31];
    }

    bb23: {
        _54 = _2[_55];
        _61 = CheckedSub(_52, _54);
        assert(!move (_61.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, move _54) -> [success: bb24, unwind: bb31];
    }

    bb24: {
        _51 = move (_61.0: u8);
        StorageDead(_54);
        StorageDead(_52);
        _62 = CheckedSub(_51, const 1_u8);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 1_u8) -> [success: bb25, unwind: bb31];
    }

    bb25: {
        StorageLive(_63);
        _63 = _12;
        _64 = Len(_2);
        _65 = Lt(_63, _64);
        assert(move _65, "index out of bounds: the length is {} but the index is {}", move _64, _63) -> [success: bb26, unwind: bb31];
    }

    bb26: {
        _2[_63] = move (_62.0: u8);
        StorageDead(_51);
        StorageDead(_63);
        StorageDead(_55);
        StorageLive(_66);
        StorageLive(_67);
        StorageLive(_68);
        _68 = _49;
        StorageLive(_69);
        _69 = _48;
        _67 = Eq(move _68, move _69);
        switchInt(move _67) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        StorageDead(_69);
        StorageDead(_68);
        _50 = const ();
        StorageDead(_67);
        StorageDead(_66);
        StorageDead(_50);
        _0 = _2;
        StorageDead(_49);
        StorageDead(_48);
        StorageDead(_13);
        StorageDead(_12);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }

    bb28: {
        StorageDead(_69);
        StorageDead(_68);
        _66 = const ();
        StorageDead(_67);
        StorageDead(_66);
        _71 = CheckedAdd(_12, const 1_usize);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _12, const 1_usize) -> [success: bb29, unwind: bb31];
    }

    bb29: {
        _12 = move (_71.0: usize);
        _72 = CheckedAdd(_49, const 1_usize);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", _49, const 1_usize) -> [success: bb30, unwind: bb31];
    }

    bb30: {
        _49 = move (_72.0: usize);
        _15 = const ();
        ConstEvalCounter;
        goto -> bb21;
    }

    bb31 (cleanup): {
        resume;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_LENGTHS::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::FUZZ_NUM: usize = {
    let mut _0: usize;
    let _1: usize;
    let mut _2: u32;
    let mut _3: u32;
    let mut _4: (u32, bool);
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    scope 1 {
        debug log2 => _1;
    }

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _4 = CheckedSub(const _, const 1_u32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, const 1_u32) -> [success: bb1, unwind: bb9];
    }

    bb1: {
        _3 = move (_4.0: u32);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::num::<impl u32>::count_ones(move _3) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        StorageDead(_3);
        _1 = move _2 as usize (IntToInt);
        StorageDead(_2);
        StorageLive(_5);
        StorageLive(_6);
        _6 = _1;
        _5 = Eq(move _6, const 3_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        StorageDead(_6);
        _0 = const 6_usize;
        goto -> bb8;
    }

    bb4: {
        StorageDead(_6);
        StorageLive(_7);
        StorageLive(_8);
        StorageLive(_9);
        _9 = _1;
        _10 = CheckedSub(_9, const 4_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _9, const 4_usize) -> [success: bb5, unwind: bb9];
    }

    bb5: {
        _8 = move (_10.0: usize);
        StorageDead(_9);
        _11 = CheckedMul(const 4_usize, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} * {}`, which would overflow", const 4_usize, move _8) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _7 = move (_11.0: usize);
        StorageDead(_8);
        _12 = CheckedAdd(const 8_usize, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 8_usize, move _7) -> [success: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move (_12.0: usize);
        StorageDead(_7);
        goto -> bb8;
    }

    bb8: {
        StorageDead(_5);
        StorageDead(_1);
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::from_bool(_1: bool) -> i128 {
    debug b => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::logical_shr(_1: i128, _2: u32) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;
    let mut _3: u128;
    let mut _4: u128;

    bb0: {
        _4 = <i128 as Int>::unsigned(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = rustc_std_workspace_core::num::<impl u128>::wrapping_shr(move _4, _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = <i128 as Int>::from_unsigned(move _3) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::is_zero(_1: i128) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = Eq(_1, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_neg(_1: i128) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_neg(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_add(_1: i128, _2: i128) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_mul(_1: i128, _2: i128) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_mul(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_sub(_1: i128, _2: i128) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_sub(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shl(_1: i128, _2: u32) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_shl(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::wrapping_shr(_1: i128, _2: u32) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_shr(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::rotate_left(_1: i128, _2: u32) -> i128 {
    debug self => _1;
    debug other => _2;
    let mut _0: i128;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::rotate_left(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::overflowing_add(_1: i128, _2: i128) -> (i128, bool) {
    debug self => _1;
    debug other => _2;
    let mut _0: (i128, bool);

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::overflowing_add(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:231:9: 231:26>::leading_zeros(_1: i128) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = rustc_std_workspace_core::num::<impl i128>::leading_zeros(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: u16) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: u16) -> u8 {
    debug self => _1;
    let mut _0: u8;
    let mut _2: u16;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 16_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: u16) -> (u8, u8) {
    debug self => _1;
    let mut _0: (u8, u8);
    let mut _2: u8;
    let mut _3: u8;

    bb0: {
        _2 = <u16 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u16 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: u8, _2: u8) -> u16 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: u16;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = <u8 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u8 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: u32) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: u32) -> u16 {
    debug self => _1;
    let mut _0: u16;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 32_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: u32) -> (u16, u16) {
    debug self => _1;
    let mut _0: (u16, u16);
    let mut _2: u16;
    let mut _3: u16;

    bb0: {
        _2 = <u32 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u32 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: u16, _2: u16) -> u32 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: u32;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _3 = <u16 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u16 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: u64) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: u64) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: u64;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 64_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: u64) -> (u32, u32) {
    debug self => _1;
    let mut _0: (u32, u32);
    let mut _2: u32;
    let mut _3: u32;

    bb0: {
        _2 = <u64 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u64 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: u32, _2: u32) -> u64 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = <u32 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u32 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: u128) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: u128) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u128;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 128_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: u128) -> (u64, u64) {
    debug self => _1;
    let mut _0: (u64, u64);
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _2 = <u128 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <u128 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: u64, _2: u64) -> u128 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: u128;
    let mut _3: u128;
    let mut _4: u128;

    bb0: {
        _3 = <u64 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: i16) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: i16) -> i8 {
    debug self => _1;
    let mut _0: i8;
    let mut _2: i16;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 16_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: i16) -> (i8, i8) {
    debug self => _1;
    let mut _0: (i8, i8);
    let mut _2: i8;
    let mut _3: i8;

    bb0: {
        _2 = <i16 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <i16 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: i8, _2: i8) -> i16 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: i16;
    let mut _3: i16;
    let mut _4: i16;

    bb0: {
        _3 = <i8 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i8 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: i32) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: i32) -> i16 {
    debug self => _1;
    let mut _0: i16;
    let mut _2: i32;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 32_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: i32) -> (i16, i16) {
    debug self => _1;
    let mut _0: (i16, i16);
    let mut _2: i16;
    let mut _3: i16;

    bb0: {
        _2 = <i32 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <i32 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: i16, _2: i16) -> i32 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: i32;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _3 = <i16 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i16 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: i64) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: i64) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: i64;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 64_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: i64) -> (i32, i32) {
    debug self => _1;
    let mut _0: (i32, i32);
    let mut _2: i32;
    let mut _3: i32;

    bb0: {
        _2 = <i64 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <i64 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: i32, _2: i32) -> i64 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: i64;
    let mut _3: i64;
    let mut _4: i64;

    bb0: {
        _3 = <i32 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i32 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo(_1: i128) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::hi(_1: i128) -> i64 {
    debug self => _1;
    let mut _0: i64;
    let mut _2: i128;
    let mut _3: bool;

    bb0: {
        _3 = Lt(const _, const 128_u32);
        assert(move _3, "attempt to shift right by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Shr(_1, const _);
        _0 = move _2 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::lo_hi(_1: i128) -> (i64, i64) {
    debug self => _1;
    let mut _0: (i64, i64);
    let mut _2: i64;
    let mut _3: i64;

    bb0: {
        _2 = <i128 as DInt>::lo(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = <i128 as DInt>::hi(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = (move _2, move _3);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:301:13: 301:29>::from_lo_hi(_1: i64, _2: i64) -> i128 {
    debug lo => _1;
    debug hi => _2;
    let mut _0: i128;
    let mut _3: i128;
    let mut _4: i128;

    bb0: {
        _3 = <i64 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i64 as HInt>::widen_hi(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = BitOr(move _3, move _4);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: u8) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: u8) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: u8) -> u16 {
    debug self => _1;
    let mut _0: u16;
    let mut _2: u16;
    let mut _3: bool;

    bb0: {
        _2 = _1 as u16 (IntToInt);
        _3 = Lt(const _, const 16_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: u8, _2: u8) -> u16 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u16;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = <u8 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u8 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: u8, _2: u8) -> u16 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u16;
    let mut _3: u16;
    let mut _4: u16;

    bb0: {
        _3 = <u8 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u8 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u16>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: u16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: u16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: u16) -> u32 {
    debug self => _1;
    let mut _0: u32;
    let mut _2: u32;
    let mut _3: bool;

    bb0: {
        _2 = _1 as u32 (IntToInt);
        _3 = Lt(const _, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: u16, _2: u16) -> u32 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u32;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _3 = <u16 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u16 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: u16, _2: u16) -> u32 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u32;
    let mut _3: u32;
    let mut _4: u32;

    bb0: {
        _3 = <u16 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u16 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u32>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: u32) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: u32) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: u32) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u64;
    let mut _3: bool;

    bb0: {
        _2 = _1 as u64 (IntToInt);
        _3 = Lt(const _, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: u32, _2: u32) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = <u32 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u32 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: u32, _2: u32) -> u64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u64;
    let mut _3: u64;
    let mut _4: u64;

    bb0: {
        _3 = <u32 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u32 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u64>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: u64) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: u64) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: u64) -> u128 {
    debug self => _1;
    let mut _0: u128;
    let mut _2: u128;
    let mut _3: bool;

    bb0: {
        _2 = _1 as u128 (IntToInt);
        _3 = Lt(const _, const 128_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: u64, _2: u64) -> u128 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u128;
    let mut _3: u128;
    let mut _4: u128;

    bb0: {
        _3 = <u64 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: u64, _2: u64) -> u128 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: u128;
    let mut _3: u128;
    let mut _4: u128;

    bb0: {
        _3 = <u64 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <u64 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl u128>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: i8) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: i8) -> i16 {
    debug self => _1;
    let mut _0: i16;
    let mut _2: u8;

    bb0: {
        _2 = _1 as u8 (IntToInt);
        _0 = move _2 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: i8) -> i16 {
    debug self => _1;
    let mut _0: i16;
    let mut _2: i16;
    let mut _3: bool;

    bb0: {
        _2 = _1 as i16 (IntToInt);
        _3 = Lt(const _, const 16_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: i8, _2: i8) -> i16 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i16;
    let mut _3: i16;
    let mut _4: i16;

    bb0: {
        _3 = <i8 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i8 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: i8, _2: i8) -> i16 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i16;
    let mut _3: i16;
    let mut _4: i16;

    bb0: {
        _3 = <i8 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i8 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i16>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: i16) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: i16) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: u16;

    bb0: {
        _2 = _1 as u16 (IntToInt);
        _0 = move _2 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: i16) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: i32;
    let mut _3: bool;

    bb0: {
        _2 = _1 as i32 (IntToInt);
        _3 = Lt(const _, const 32_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: i16, _2: i16) -> i32 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i32;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _3 = <i16 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i16 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: i16, _2: i16) -> i32 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i32;
    let mut _3: i32;
    let mut _4: i32;

    bb0: {
        _3 = <i16 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i16 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i32>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: i32) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: i32) -> i64 {
    debug self => _1;
    let mut _0: i64;
    let mut _2: u32;

    bb0: {
        _2 = _1 as u32 (IntToInt);
        _0 = move _2 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: i32) -> i64 {
    debug self => _1;
    let mut _0: i64;
    let mut _2: i64;
    let mut _3: bool;

    bb0: {
        _2 = _1 as i64 (IntToInt);
        _3 = Lt(const _, const 64_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: i32, _2: i32) -> i64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i64;
    let mut _3: i64;
    let mut _4: i64;

    bb0: {
        _3 = <i32 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i32 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: i32, _2: i32) -> i64 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i64;
    let mut _3: i64;
    let mut _4: i64;

    bb0: {
        _3 = <i32 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i32 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i64>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen(_1: i64) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen(_1: i64) -> i128 {
    debug self => _1;
    let mut _0: i128;
    let mut _2: u64;

    bb0: {
        _2 = _1 as u64 (IntToInt);
        _0 = move _2 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_hi(_1: i64) -> i128 {
    debug self => _1;
    let mut _0: i128;
    let mut _2: i128;
    let mut _3: bool;

    bb0: {
        _2 = _1 as i128 (IntToInt);
        _3 = Lt(const _, const 128_u32);
        assert(move _3, "attempt to shift left by `{}`, which would overflow", const _) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _0 = Shl(move _2, const _);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::zero_widen_mul(_1: i64, _2: i64) -> i128 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i128;
    let mut _3: i128;
    let mut _4: i128;

    bb0: {
        _3 = <i64 as HInt>::zero_widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i64 as HInt>::zero_widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:324:13: 324:29>::widen_mul(_1: i64, _2: i64) -> i128 {
    debug self => _1;
    debug rhs => _2;
    let mut _0: i128;
    let mut _3: i128;
    let mut _4: i128;

    bb0: {
        _3 = <i64 as HInt>::widen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = <i64 as HInt>::widen(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _0 = rustc_std_workspace_core::num::<impl i128>::wrapping_mul(move _3, move _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: usize) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: isize) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u8) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i8) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u16) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i16) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u32) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i32) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u64) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i64) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1;
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: u128) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1 as i128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> usize {
    debug self => _1;
    let mut _0: usize;

    bb0: {
        _0 = _1 as usize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> isize {
    debug self => _1;
    let mut _0: isize;

    bb0: {
        _0 = _1 as isize (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> u8 {
    debug self => _1;
    let mut _0: u8;

    bb0: {
        _0 = _1 as u8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> i8 {
    debug self => _1;
    let mut _0: i8;

    bb0: {
        _0 = _1 as i8 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> u16 {
    debug self => _1;
    let mut _0: u16;

    bb0: {
        _0 = _1 as u16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> i16 {
    debug self => _1;
    let mut _0: i16;

    bb0: {
        _0 = _1 as i16 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> u32 {
    debug self => _1;
    let mut _0: u32;

    bb0: {
        _0 = _1 as u32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = _1 as i32 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> u64 {
    debug self => _1;
    let mut _0: u64;

    bb0: {
        _0 = _1 as u64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> i64 {
    debug self => _1;
    let mut _0: i64;

    bb0: {
        _0 = _1 as i64 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> u128 {
    debug self => _1;
    let mut _0: u128;

    bb0: {
        _0 = _1 as u128 (IntToInt);
        return;
    }
}

fn int::<impl at /Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/int/mod.rs:371:9: 371:37>::cast(_1: i128) -> i128 {
    debug self => _1;
    let mut _0: i128;

    bb0: {
        _0 = _1;
        return;
    }
}

const acos::PIO2_HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5707963267948966f64;
        return;
    }
}

const acos::PIO2_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.123233995736766E-17f64;
        return;
    }
}

const PS0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.16666666666666666f64;
        return;
    }
}

const PS1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.32556581862240092f64;
        return;
    }
}

const acos::PS2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.20121253213486293f64;
        return;
    }
}

const acos::PS3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.040055534500679411f64;
        return;
    }
}

const PS4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.9153499428981453E-4f64;
        return;
    }
}

const acos::PS5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.4793310759602117E-5f64;
        return;
    }
}

const QS1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.4033949117344142f64;
        return;
    }
}

const acos::QS2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.0209457602335057f64;
        return;
    }
}

const acos::QS3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.68828397160545329f64;
        return;
    }
}

const QS4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.077038150555901935f64;
        return;
    }
}

fn acos::r(_1: f64) -> f64 {
    debug z => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    scope 1 {
        debug p => _2;
        let _13: f64;
        scope 2 {
            debug q => _13;
        }
    }

    bb0: {
        _12 = Mul(_1, const _);
        _11 = Add(const _, move _12);
        _10 = Mul(_1, move _11);
        _9 = Add(const _, move _10);
        _8 = Mul(_1, move _9);
        _7 = Add(const _, move _8);
        _6 = Mul(_1, move _7);
        _5 = Add(const _, move _6);
        _4 = Mul(_1, move _5);
        _3 = Add(const _, move _4);
        _2 = Mul(_1, move _3);
        _20 = Mul(_1, const _);
        _19 = Add(const _, move _20);
        _18 = Mul(_1, move _19);
        _17 = Add(const _, move _18);
        _16 = Mul(_1, move _17);
        _15 = Add(const _, move _16);
        _14 = Mul(_1, move _15);
        _13 = Add(const 1f64, move _14);
        _0 = Div(_2, _13);
        return;
    }
}

fn acos(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _15: u64;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: (u32, bool);
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: u32;
    let mut _32: u32;
    let mut _33: bool;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: u64;
    let mut _50: u64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f64;
    scope 1 {
        debug x1p_120f => _2;
        let _3: f64;
        scope 2 {
            debug z => _3;
            let _4: f64;
            scope 3 {
                debug w => _4;
                let _5: f64;
                scope 4 {
                    debug s => _5;
                    let _6: f64;
                    scope 5 {
                        debug c => _6;
                        scope 6 {
                            debug df => _48;
                            let _7: u32;
                            scope 7 {
                                debug hx => _7;
                                let _8: u32;
                                scope 8 {
                                    debug ix => _8;
                                    let _14: u32;
                                    scope 9 {
                                        debug lx => _14;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4066750463515557888_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = const 32_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(move _10, const 32_i32);
        _7 = move _9 as u32 (IntToInt);
        _8 = BitAnd(_7, const 2147483647_u32);
        _13 = Ge(_8, const 1072693248_u32);
        switchInt(move _13) -> [0: bb12, otherwise: bb4];
    }

    bb4: {
        _15 = f64::<impl f64>::to_bits(_1) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = move _15 as u32 (IntToInt);
        _18 = CheckedSub(_8, const 1072693248_u32);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1072693248_u32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _17 = move (_18.0: u32);
        _16 = BitOr(move _17, _14);
        switchInt(move _16) -> [0: bb7, otherwise: bb11];
    }

    bb7: {
        _20 = const 31_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 32_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _19 = Shr(_7, const 31_i32);
        switchInt(move _19) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _22 = Mul(const 2f64, const _);
        _0 = Add(move _22, _2);
        goto -> bb27;
    }

    bb10: {
        _0 = const 0f64;
        goto -> bb27;
    }

    bb11: {
        _23 = Sub(_1, _1);
        _0 = Div(const 0f64, move _23);
        goto -> bb27;
    }

    bb12: {
        _24 = Lt(_8, const 1071644672_u32);
        switchInt(move _24) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _25 = Le(_8, const 1012924416_u32);
        switchInt(move _25) -> [0: bb16, otherwise: bb15];
    }

    bb14: {
        _32 = const 31_i32 as u32 (IntToInt);
        _33 = Lt(move _32, const 32_u32);
        assert(move _33, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb18, unwind unreachable];
    }

    bb15: {
        _0 = Add(const _, _2);
        goto -> bb27;
    }

    bb16: {
        _30 = Mul(_1, _1);
        _29 = acos::r(move _30) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _28 = Mul(_1, move _29);
        _27 = Sub(const _, move _28);
        _26 = Sub(_1, move _27);
        _0 = Sub(const _, move _26);
        goto -> bb27;
    }

    bb18: {
        _31 = Shr(_7, const 31_i32);
        switchInt(move _31) -> [0: bb22, otherwise: bb19];
    }

    bb19: {
        _34 = Add(const 1f64, _1);
        _3 = Mul(move _34, const 0.5f64);
        _36 = _3;
        _35 = sqrt(move _36) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _5 = move _35;
        _39 = _3;
        _38 = acos::r(move _39) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _40 = _5;
        _37 = Mul(move _38, move _40);
        _4 = Sub(move _37, const _);
        _43 = _5;
        _44 = _4;
        _42 = Add(move _43, move _44);
        _41 = Sub(const _, move _42);
        _0 = Mul(const 2f64, move _41);
        goto -> bb27;
    }

    bb22: {
        _45 = Sub(const 1f64, _1);
        _3 = Mul(move _45, const 0.5f64);
        _47 = _3;
        _46 = sqrt(move _47) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _5 = move _46;
        _51 = _5;
        _50 = f64::<impl f64>::to_bits(move _51) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _49 = BitAnd(move _50, const 18446744069414584320_u64);
        _48 = f64::<impl f64>::from_bits(move _49) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _53 = _3;
        _54 = Mul(_48, _48);
        _52 = Sub(move _53, move _54);
        _56 = _5;
        _55 = Add(move _56, _48);
        _6 = Div(move _52, move _55);
        _59 = _3;
        _58 = acos::r(move _59) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _60 = _5;
        _57 = Mul(move _58, move _60);
        _4 = Add(move _57, _6);
        _62 = _4;
        _61 = Add(_48, move _62);
        _0 = Mul(const 2f64, move _61);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

const acosf::PIO2_HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.57079625f32;
        return;
    }
}

const acosf::PIO2_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.54978942E-8f32;
        return;
    }
}

const acosf::P_S0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.166665867f32;
        return;
    }
}

const acosf::P_S1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0427434221f32;
        return;
    }
}

const acosf::P_S2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.008656363f32;
        return;
    }
}

const acosf::Q_S1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.706629634f32;
        return;
    }
}

fn acosf::r(_1: f32) -> f32 {
    debug z => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _3: f32;
    let mut _4: f32;
    let mut _5: f32;
    let mut _6: f32;
    let mut _8: f32;
    scope 1 {
        debug p => _2;
        let _7: f32;
        scope 2 {
            debug q => _7;
        }
    }

    bb0: {
        _6 = Mul(_1, const _);
        _5 = Add(const _, move _6);
        _4 = Mul(_1, move _5);
        _3 = Add(const _, move _4);
        _2 = Mul(_1, move _3);
        _8 = Mul(_1, const _);
        _7 = Add(const 1f32, move _8);
        _0 = Div(_2, _7);
        return;
    }
}

fn acosf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: u32;
    let mut _42: f32;
    let mut _44: u32;
    let mut _45: u32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    scope 1 {
        debug x1p_120 => _2;
        let _3: f32;
        scope 2 {
            debug z => _3;
            let _4: f32;
            scope 3 {
                debug w => _4;
                let _5: f32;
                scope 4 {
                    debug s => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug hx => _6;
                        let _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let _43: f32;
                            scope 7 {
                                debug df => _43;
                                let _46: f32;
                                scope 8 {
                                    debug c => _46;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 58720256_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = _6;
        _7 = BitAnd(move _8, const 2147483647_u32);
        _9 = Ge(_7, const 1065353216_u32);
        switchInt(move _9) -> [0: bb9, otherwise: bb3];
    }

    bb3: {
        switchInt(move _7) -> [1065353216: bb4, otherwise: bb8];
    }

    bb4: {
        _11 = _6;
        _12 = const 31_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _10 = Shr(move _11, const 31_i32);
        switchInt(move _10) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _14 = Mul(const 2f32, const _);
        _0 = Add(move _14, _2);
        goto -> bb24;
    }

    bb7: {
        _0 = const 0f32;
        goto -> bb24;
    }

    bb8: {
        _15 = Sub(_1, _1);
        _0 = Div(const 0f32, move _15);
        goto -> bb24;
    }

    bb9: {
        _16 = Lt(_7, const 1056964608_u32);
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _17 = Le(_7, const 847249408_u32);
        switchInt(move _17) -> [0: bb13, otherwise: bb12];
    }

    bb11: {
        _24 = _6;
        _25 = const 31_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 32_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb15, unwind unreachable];
    }

    bb12: {
        _0 = Add(const _, _2);
        goto -> bb24;
    }

    bb13: {
        _22 = Mul(_1, _1);
        _21 = acosf::r(move _22) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _20 = Mul(_1, move _21);
        _19 = Sub(const _, move _20);
        _18 = Sub(_1, move _19);
        _0 = Sub(const _, move _18);
        goto -> bb24;
    }

    bb15: {
        _23 = Shr(move _24, const 31_i32);
        switchInt(move _23) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _27 = Add(const 1f32, _1);
        _3 = Mul(move _27, const 0.5f32);
        _29 = _3;
        _28 = sqrtf(move _29) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _5 = move _28;
        _32 = _3;
        _31 = acosf::r(move _32) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _33 = _5;
        _30 = Mul(move _31, move _33);
        _4 = Sub(move _30, const _);
        _36 = _5;
        _37 = _4;
        _35 = Add(move _36, move _37);
        _34 = Sub(const _, move _35);
        _0 = Mul(const 2f32, move _34);
        goto -> bb24;
    }

    bb19: {
        _38 = Sub(const 1f32, _1);
        _3 = Mul(move _38, const 0.5f32);
        _40 = _3;
        _39 = sqrtf(move _40) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _5 = move _39;
        _42 = _5;
        _41 = f32::<impl f32>::to_bits(move _42) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _6 = move _41;
        _45 = _6;
        _44 = BitAnd(move _45, const 4294963200_u32);
        _43 = f32::<impl f32>::from_bits(move _44) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _48 = _3;
        _49 = Mul(_43, _43);
        _47 = Sub(move _48, move _49);
        _51 = _5;
        _50 = Add(move _51, _43);
        _46 = Div(move _47, move _50);
        _54 = _3;
        _53 = acosf::r(move _54) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _55 = _5;
        _52 = Mul(move _53, move _55);
        _4 = Add(move _52, _46);
        _57 = _4;
        _56 = Add(_43, move _57);
        _0 = Mul(const 2f32, move _56);
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

const acosh::LN2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718055994529f64;
        return;
    }
}

fn acosh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _4: usize;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: bool;
    let mut _21: usize;
    let mut _22: (usize, bool);
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    scope 1 {
        debug u => _2;
        let _3: usize;
        scope 2 {
            debug e => _3;
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 52_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_2, const 52_i32);
        _4 = move _5 as usize (IntToInt);
        _3 = BitAnd(move _4, const 2047_usize);
        _10 = CheckedAdd(const 1023_usize, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_usize, const 1_usize) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_10.0: usize);
        _8 = Lt(_3, move _9);
        switchInt(move _8) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _12 = Sub(_1, const 1f64);
        _16 = Sub(_1, const 1f64);
        _17 = Sub(_1, const 1f64);
        _15 = Mul(move _16, move _17);
        _19 = Sub(_1, const 1f64);
        _18 = Mul(const 2f64, move _19);
        _14 = Add(move _15, move _18);
        _13 = sqrt(move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = Add(move _12, move _13);
        _0 = log1p(move _11) -> [return: bb12, unwind unreachable];
    }

    bb6: {
        _22 = CheckedAdd(const 1023_usize, const 26_usize);
        assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_usize, const 26_usize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _21 = move (_22.0: usize);
        _20 = Lt(_3, move _21);
        switchInt(move _20) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _24 = Mul(const 2f64, _1);
        _29 = Mul(_1, _1);
        _28 = Sub(move _29, const 1f64);
        _27 = sqrt(move _28) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _26 = Add(_1, move _27);
        _25 = Div(const 1f64, move _26);
        _23 = Sub(move _24, move _25);
        _0 = log(move _23) -> [return: bb12, unwind unreachable];
    }

    bb10: {
        _30 = log(_1) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _0 = Add(move _30, const _);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

const acoshf::LN2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693147182f32;
        return;
    }
}

fn acoshf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: u32;
    let mut _4: bool;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: (u32, bool);
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: f32;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: (u32, bool);
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    scope 1 {
        debug u => _2;
        let _3: u32;
        scope 2 {
            debug a => _3;
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(_2, const 2147483647_u32);
        _7 = const 23_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shl(const 1_u32, const 23_i32);
        _9 = CheckedAdd(const 1065353216_u32, _6);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1065353216_u32, move _6) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move (_9.0: u32);
        _4 = Lt(_3, move _5);
        switchInt(move _4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _11 = Sub(_1, const 1f32);
        _15 = Sub(_1, const 1f32);
        _16 = Sub(_1, const 1f32);
        _14 = Mul(move _15, move _16);
        _18 = Sub(_1, const 1f32);
        _17 = Mul(const 2f32, move _18);
        _13 = Add(move _14, move _17);
        _12 = sqrtf(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = Add(move _11, move _12);
        _0 = log1pf(move _10) -> [return: bb13, unwind unreachable];
    }

    bb6: {
        _22 = const 23_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 32_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _21 = Shl(const 12_u32, const 23_i32);
        _24 = CheckedAdd(const 1065353216_u32, _21);
        assert(!move (_24.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1065353216_u32, move _21) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _20 = move (_24.0: u32);
        _19 = Lt(_3, move _20);
        switchInt(move _19) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _26 = Mul(const 2f32, _1);
        _31 = Mul(_1, _1);
        _30 = Sub(move _31, const 1f32);
        _29 = sqrtf(move _30) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _28 = Add(_1, move _29);
        _27 = Div(const 1f32, move _28);
        _25 = Sub(move _26, move _27);
        _0 = logf(move _25) -> [return: bb13, unwind unreachable];
    }

    bb11: {
        _32 = logf(_1) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _0 = Add(move _32, const _);
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

const asin::PIO2_HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5707963267948966f64;
        return;
    }
}

const asin::PIO2_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.123233995736766E-17f64;
        return;
    }
}

const asin::P_S0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.16666666666666666f64;
        return;
    }
}

const asin::P_S1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.32556581862240092f64;
        return;
    }
}

const asin::P_S2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.20121253213486293f64;
        return;
    }
}

const P_S3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.040055534500679411f64;
        return;
    }
}

const P_S4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.9153499428981453E-4f64;
        return;
    }
}

const P_S5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.4793310759602117E-5f64;
        return;
    }
}

const asin::Q_S1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.4033949117344142f64;
        return;
    }
}

const Q_S2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.0209457602335057f64;
        return;
    }
}

const Q_S3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.68828397160545329f64;
        return;
    }
}

const Q_S4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.077038150555901935f64;
        return;
    }
}

fn comp_r(_1: f64) -> f64 {
    debug z => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    scope 1 {
        debug p => _2;
        let _13: f64;
        scope 2 {
            debug q => _13;
        }
    }

    bb0: {
        _12 = Mul(_1, const _);
        _11 = Add(const _, move _12);
        _10 = Mul(_1, move _11);
        _9 = Add(const _, move _10);
        _8 = Mul(_1, move _9);
        _7 = Add(const _, move _8);
        _6 = Mul(_1, move _7);
        _5 = Add(const _, move _6);
        _4 = Mul(_1, move _5);
        _3 = Add(const _, move _4);
        _2 = Mul(_1, move _3);
        _20 = Mul(_1, const _);
        _19 = Add(const _, move _20);
        _18 = Mul(_1, move _19);
        _17 = Add(const _, move _18);
        _16 = Mul(_1, move _17);
        _15 = Add(const _, move _16);
        _14 = Mul(_1, move _15);
        _13 = Add(const 1f64, move _14);
        _0 = Div(_2, _13);
        return;
    }
}

fn asin(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: u32;
    let mut _5: f64;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: f64;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: (u32, bool);
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: bool;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: u32;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: f64;
    scope 1 {
        debug z => _2;
        scope 2 {
            debug r => _32;
            scope 3 {
                debug s => _31;
                scope 4 {
                    debug hx => _4;
                    let _3: u32;
                    scope 5 {
                        debug ix => _3;
                        scope 6 {
                            debug lx => _7;
                        }
                        scope 7 {
                            debug f => _39;
                            let _38: f64;
                            scope 8 {
                                debug c => _38;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = _1;
        _4 = get_high_word(move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(_4, const 2147483647_u32);
        _6 = Ge(_3, const 1072693248_u32);
        switchInt(move _6) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _8 = _1;
        _7 = get_low_word(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _11 = CheckedSub(_3, const 1072693248_u32);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1072693248_u32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = move (_11.0: u32);
        _9 = BitOr(move _10, _7);
        switchInt(move _9) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _13 = _1;
        _12 = Mul(move _13, const _);
        _14 = f64::<impl f64>::from_bits(const 4066750463515557888_u64) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = Add(move _12, move _14);
        goto -> bb25;
    }

    bb7: {
        _16 = _1;
        _17 = _1;
        _15 = Sub(move _16, move _17);
        _0 = Div(const 0f64, move _15);
        goto -> bb25;
    }

    bb8: {
        _18 = Lt(_3, const 1071644672_u32);
        switchInt(move _18) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _19 = Lt(_3, const 1045430272_u32);
        switchInt(move _19) -> [0: bb13, otherwise: bb11];
    }

    bb10: {
        _30 = _1;
        _29 = fabs(move _30) -> [return: bb15, unwind unreachable];
    }

    bb11: {
        _20 = Ge(_3, const 1048576_u32);
        switchInt(move _20) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = _1;
        goto -> bb25;
    }

    bb13: {
        _21 = _1;
        _23 = _1;
        _26 = _1;
        _27 = _1;
        _25 = Mul(move _26, move _27);
        _24 = comp_r(move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = Mul(move _23, move _24);
        _0 = Add(move _21, move _22);
        goto -> bb25;
    }

    bb15: {
        _28 = Sub(const 1f64, move _29);
        _2 = Mul(move _28, const 0.5f64);
        _31 = sqrt(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _32 = comp_r(_2) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _33 = Ge(_3, const 1072640819_u32);
        switchInt(move _33) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _37 = Mul(_31, _32);
        _36 = Add(_31, move _37);
        _35 = Mul(const 2f64, move _36);
        _34 = Sub(move _35, const _);
        _1 = Sub(const _, move _34);
        goto -> bb21;
    }

    bb19: {
        _39 = with_set_low_word(_31, const 0_u32) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _41 = Mul(_39, _39);
        _40 = Sub(_2, move _41);
        _42 = Add(_31, _39);
        _38 = Div(move _40, move _42);
        _43 = Mul(const 0.5f64, const _);
        _47 = Mul(const 2f64, _31);
        _46 = Mul(move _47, _32);
        _49 = Mul(const 2f64, _38);
        _48 = Sub(const _, move _49);
        _45 = Sub(move _46, move _48);
        _51 = Mul(const 0.5f64, const _);
        _52 = Mul(const 2f64, _39);
        _50 = Sub(move _51, move _52);
        _44 = Sub(move _45, move _50);
        _1 = Sub(move _43, move _44);
        goto -> bb21;
    }

    bb21: {
        _54 = const 31_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 32_u32);
        assert(move _55, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _53 = Shr(_4, const 31_i32);
        switchInt(move _53) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _56 = _1;
        _0 = Neg(move _56);
        goto -> bb25;
    }

    bb24: {
        _0 = _1;
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

const asinf::PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5707963267948966f64;
        return;
    }
}

const asinf::P_S0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.166665867f32;
        return;
    }
}

const asinf::P_S1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0427434221f32;
        return;
    }
}

const asinf::P_S2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.008656363f32;
        return;
    }
}

const asinf::Q_S1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.706629634f32;
        return;
    }
}

fn asinf::r(_1: f32) -> f32 {
    debug z => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _3: f32;
    let mut _4: f32;
    let mut _5: f32;
    let mut _6: f32;
    let mut _8: f32;
    scope 1 {
        debug p => _2;
        let _7: f32;
        scope 2 {
            debug q => _7;
        }
    }

    bb0: {
        _6 = Mul(_1, const _);
        _5 = Add(const _, move _6);
        _4 = Mul(_1, move _5);
        _3 = Add(const _, move _4);
        _2 = Mul(_1, move _3);
        _8 = Mul(_1, const _);
        _7 = Add(const 1f32, move _8);
        _0 = Div(_2, _7);
        return;
    }
}

fn asinf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _4: f32;
    let mut _6: bool;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: f32;
    let mut _13: f32;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f32;
    let mut _36: u32;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: f32;
    scope 1 {
        debug x1p_120 => _2;
        let _3: u32;
        scope 2 {
            debug hx => _3;
            let _5: u32;
            scope 3 {
                debug ix => _5;
                let _24: f32;
                scope 4 {
                    debug z => _24;
                    let _28: f64;
                    scope 5 {
                        debug s => _28;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4066750463515557888_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = BitAnd(_3, const 2147483647_u32);
        _6 = Ge(_5, const 1065353216_u32);
        switchInt(move _6) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        switchInt(move _5) -> [1065353216: bb4, otherwise: bb5];
    }

    bb4: {
        _10 = _1;
        _9 = move _10 as f64 (FloatToFloat);
        _8 = Mul(move _9, const _);
        _7 = Add(move _8, _2);
        _0 = move _7 as f32 (FloatToFloat);
        goto -> bb19;
    }

    bb5: {
        _12 = _1;
        _13 = _1;
        _11 = Sub(move _12, move _13);
        _0 = Div(const 0f32, move _11);
        goto -> bb19;
    }

    bb6: {
        _14 = Lt(_5, const 1056964608_u32);
        switchInt(move _14) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _15 = Lt(_5, const 964689920_u32);
        switchInt(move _15) -> [0: bb11, otherwise: bb9];
    }

    bb8: {
        _27 = _1;
        _26 = fabsf(move _27) -> [return: bb13, unwind unreachable];
    }

    bb9: {
        _16 = Ge(_5, const 8388608_u32);
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = _1;
        goto -> bb19;
    }

    bb11: {
        _17 = _1;
        _19 = _1;
        _22 = _1;
        _23 = _1;
        _21 = Mul(move _22, move _23);
        _20 = asinf::r(move _21) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _18 = Mul(move _19, move _20);
        _0 = Add(move _17, move _18);
        goto -> bb19;
    }

    bb13: {
        _25 = Sub(const 1f32, move _26);
        _24 = Mul(move _25, const 0.5f32);
        _29 = _24 as f64 (FloatToFloat);
        _28 = sqrt(move _29) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _35 = asinf::r(_24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _34 = move _35 as f64 (FloatToFloat);
        _33 = Mul(_28, move _34);
        _32 = Add(_28, move _33);
        _31 = Mul(const 2f64, move _32);
        _30 = Sub(const _, move _31);
        _1 = move _30 as f32 (FloatToFloat);
        _37 = const 31_i32 as u32 (IntToInt);
        _38 = Lt(move _37, const 32_u32);
        assert(move _38, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _36 = Shr(_3, const 31_i32);
        switchInt(move _36) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _39 = _1;
        _0 = Neg(move _39);
        goto -> bb19;
    }

    bb18: {
        _0 = _1;
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

const asinh::LN2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718055994529f64;
        return;
    }
}

fn asinh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: u64;
    let mut _3: f64;
    let mut _5: usize;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: f64;
    let mut _20: u64;
    let mut _21: bool;
    let mut _22: usize;
    let mut _23: (usize, bool);
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: bool;
    let mut _27: usize;
    let mut _28: (usize, bool);
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: bool;
    let mut _42: usize;
    let mut _43: (usize, bool);
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let _58: f64;
    let mut _59: *const f64;
    let _60: &f64;
    let _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    scope 1 {
        debug u => _2;
        let _4: usize;
        scope 2 {
            debug e => _4;
            let _10: bool;
            scope 3 {
                debug sign => _10;
                let _57: f64;
                scope 4 {
                    debug x1p120 => _57;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f64::<impl f64>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _2;
        _8 = const 52_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shr(move _7, const 52_i32);
        _5 = move _6 as usize (IntToInt);
        _4 = BitAnd(move _5, const 2047_usize);
        _12 = _2;
        _13 = const 63_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 64_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _11 = Shr(move _12, const 63_i32);
        _10 = Ne(move _11, const 0_u64);
        _16 = Not(const 0_u64);
        _17 = const 1_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _15 = Shr(move _16, const 1_i32);
        _2 = BitAnd(_2, move _15);
        _20 = _2;
        _19 = f64::<impl f64>::from_bits(move _20) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _1 = move _19;
        _23 = CheckedAdd(const 1023_usize, const 26_usize);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_usize, const 26_usize) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _22 = move (_23.0: usize);
        _21 = Ge(_4, move _22);
        switchInt(move _21) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _25 = _1;
        _24 = log(move _25) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _1 = Add(move _24, const _);
        goto -> bb21;
    }

    bb9: {
        _28 = CheckedAdd(const 1023_usize, const 1_usize);
        assert(!move (_28.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_usize, const 1_usize) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _27 = move (_28.0: usize);
        _26 = Ge(_4, move _27);
        switchInt(move _26) -> [0: bb14, otherwise: bb11];
    }

    bb11: {
        _32 = _1;
        _31 = Mul(const 2f64, move _32);
        _38 = _1;
        _39 = _1;
        _37 = Mul(move _38, move _39);
        _36 = Add(move _37, const 1f64);
        _35 = sqrt(move _36) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _40 = _1;
        _34 = Add(move _35, move _40);
        _33 = Div(const 1f64, move _34);
        _30 = Add(move _31, move _33);
        _29 = log(move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _1 = move _29;
        goto -> bb21;
    }

    bb14: {
        _43 = CheckedSub(const 1023_usize, const 26_usize);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_usize, const 26_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _42 = move (_43.0: usize);
        _41 = Ge(_4, move _42);
        switchInt(move _41) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _46 = _1;
        _49 = _1;
        _50 = _1;
        _48 = Mul(move _49, move _50);
        _55 = _1;
        _56 = _1;
        _54 = Mul(move _55, move _56);
        _53 = Add(move _54, const 1f64);
        _52 = sqrt(move _53) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _51 = Add(move _52, const 1f64);
        _47 = Div(move _48, move _51);
        _45 = Add(move _46, move _47);
        _44 = log1p(move _45) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _1 = move _44;
        goto -> bb21;
    }

    bb19: {
        _57 = f64::<impl f64>::from_bits(const 5147614374084476928_u64) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _62 = _1;
        _61 = Add(move _62, _57);
        _60 = &_61;
        _59 = &raw const (*_60);
        _58 = read_volatile::<f64>(move _59) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        switchInt(_10) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _63 = _1;
        _0 = Neg(move _63);
        goto -> bb24;
    }

    bb23: {
        _0 = _1;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

const asinhf::LN2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693147182f32;
        return;
    }
}

fn asinhf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: u32;
    let mut _3: f32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: f32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: (u32, bool);
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u32, bool);
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: bool;
    let mut _37: u32;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: bool;
    let mut _41: (u32, bool);
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    let mut _54: f32;
    let _56: f32;
    let mut _57: *const f32;
    let _58: &f32;
    let _59: f32;
    let mut _60: f32;
    let mut _61: f32;
    scope 1 {
        debug u => _2;
        let _4: u32;
        scope 2 {
            debug i => _4;
            let _5: bool;
            scope 3 {
                debug sign => _5;
                let _55: f32;
                scope 4 {
                    debug x1p120 => _55;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f32::<impl f32>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = BitAnd(_2, const 2147483647_u32);
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shr(_2, const 31_i32);
        _5 = Ne(move _6, const 0_u32);
        _9 = f32::<impl f32>::from_bits(_4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move _9;
        _13 = const 23_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _12 = Shl(const 12_u32, const 23_i32);
        _15 = CheckedAdd(const 1065353216_u32, _12);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1065353216_u32, move _12) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _11 = move (_15.0: u32);
        _10 = Ge(_4, move _11);
        switchInt(move _10) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _17 = _1;
        _16 = logf(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _1 = Add(move _16, const _);
        goto -> bb22;
    }

    bb8: {
        _21 = const 23_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _20 = Shl(const 1_u32, const 23_i32);
        _23 = CheckedAdd(const 1065353216_u32, _20);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1065353216_u32, move _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _19 = move (_23.0: u32);
        _18 = Ge(_4, move _19);
        switchInt(move _18) -> [0: bb14, otherwise: bb11];
    }

    bb11: {
        _27 = _1;
        _26 = Mul(const 2f32, move _27);
        _33 = _1;
        _34 = _1;
        _32 = Mul(move _33, move _34);
        _31 = Add(move _32, const 1f32);
        _30 = sqrtf(move _31) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _35 = _1;
        _29 = Add(move _30, move _35);
        _28 = Div(const 1f32, move _29);
        _25 = Add(move _26, move _28);
        _24 = logf(move _25) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _1 = move _24;
        goto -> bb22;
    }

    bb14: {
        _39 = const 23_i32 as u32 (IntToInt);
        _40 = Lt(move _39, const 32_u32);
        assert(move _40, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _38 = Shl(const 12_u32, const 23_i32);
        _41 = CheckedSub(const 1065353216_u32, _38);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, move _38) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _37 = move (_41.0: u32);
        _36 = Ge(_4, move _37);
        switchInt(move _36) -> [0: bb20, otherwise: bb17];
    }

    bb17: {
        _44 = _1;
        _47 = _1;
        _48 = _1;
        _46 = Mul(move _47, move _48);
        _53 = _1;
        _54 = _1;
        _52 = Mul(move _53, move _54);
        _51 = Add(move _52, const 1f32);
        _50 = sqrtf(move _51) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _49 = Add(move _50, const 1f32);
        _45 = Div(move _46, move _49);
        _43 = Add(move _44, move _45);
        _42 = log1pf(move _43) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _1 = move _42;
        goto -> bb22;
    }

    bb20: {
        _55 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _60 = _1;
        _59 = Add(move _60, _55);
        _58 = &_59;
        _57 = &raw const (*_58);
        _56 = read_volatile::<f32>(move _57) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        switchInt(_5) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _61 = _1;
        _0 = Neg(move _61);
        goto -> bb25;
    }

    bb24: {
        _0 = _1;
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

const ATANHI: [f64; 4] = {
    let mut _0: [f64; 4];

    bb0: {
        _0 = [const 0.46364760900080609f64, const 0.78539816339744828f64, const 0.98279372324732905f64, const 1.5707963267948966f64];
        return;
    }
}

ATANHI::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 4_usize;
        return;
    }
}

const ATANLO: [f64; 4] = {
    let mut _0: [f64; 4];

    bb0: {
        _0 = [const 2.2698777452961687E-17f64, const 3.061616997868383E-17f64, const 1.3903311031230998E-17f64, const 6.123233995736766E-17f64];
        return;
    }
}

ATANLO::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 4_usize;
        return;
    }
}

const AT: [f64; 11] = {
    let mut _0: [f64; 11];

    bb0: {
        _0 = [const 0.33333333333332932f64, const -0.19999999999876483f64, const 0.14285714272503466f64, const -0.11111110405462356f64, const 0.090908871334365065f64, const -0.0769187620504483f64, const 0.066610731373875312f64, const -0.058335701337905735f64, const 0.049768779946159324f64, const -0.036531572744216916f64, const 0.016285820115365782f64];
        return;
    }
}

AT::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 11_usize;
        return;
    }
}

fn atan(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: f64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: f64;
    let mut _18: f64;
    let mut _19: [f64; 4];
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: f64;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: bool;
    let mut _30: u32;
    let _31: f32;
    let mut _32: *const f32;
    let _33: &f32;
    let _34: f32;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: bool;
    let mut _41: u32;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: bool;
    let mut _52: u32;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: [f64; 11];
    let _67: usize;
    let mut _68: usize;
    let mut _69: bool;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: [f64; 11];
    let _74: usize;
    let mut _75: usize;
    let mut _76: bool;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: [f64; 11];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: [f64; 11];
    let _88: usize;
    let mut _89: usize;
    let mut _90: bool;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: [f64; 11];
    let _95: usize;
    let mut _96: usize;
    let mut _97: bool;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: [f64; 11];
    let _101: usize;
    let mut _102: usize;
    let mut _103: bool;
    let mut _105: f64;
    let mut _106: f64;
    let mut _107: [f64; 11];
    let _108: usize;
    let mut _109: usize;
    let mut _110: bool;
    let mut _111: f64;
    let mut _112: f64;
    let mut _113: f64;
    let mut _114: [f64; 11];
    let _115: usize;
    let mut _116: usize;
    let mut _117: bool;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: f64;
    let mut _121: [f64; 11];
    let _122: usize;
    let mut _123: usize;
    let mut _124: bool;
    let mut _125: f64;
    let mut _126: f64;
    let mut _127: f64;
    let mut _128: [f64; 11];
    let _129: usize;
    let mut _130: usize;
    let mut _131: bool;
    let mut _132: f64;
    let mut _133: f64;
    let mut _134: [f64; 11];
    let _135: usize;
    let mut _136: usize;
    let mut _137: bool;
    let mut _138: bool;
    let mut _139: i32;
    let mut _140: f64;
    let mut _141: f64;
    let mut _142: f64;
    let mut _143: f64;
    let mut _145: f64;
    let mut _146: &f64;
    let mut _147: rustc_std_workspace_core::option::Option<&f64>;
    let mut _148: &[f64];
    let mut _149: usize;
    let mut _150: i32;
    let mut _151: f64;
    let mut _152: f64;
    let mut _153: f64;
    let mut _154: f64;
    let mut _155: f64;
    let mut _156: f64;
    let mut _157: &f64;
    let mut _158: rustc_std_workspace_core::option::Option<&f64>;
    let mut _159: &[f64];
    let mut _160: usize;
    let mut _161: i32;
    let mut _162: f64;
    scope 1 {
        debug x => _2;
        let mut _3: u32;
        scope 2 {
            debug ix => _3;
            let _9: u32;
            scope 3 {
                debug sign => _9;
                let _17: f64;
                let _24: i32;
                scope 4 {
                    debug z => _17;
                }
                scope 5 {
                    debug id => _24;
                    let _59: f64;
                    scope 7 {
                        debug z => _59;
                        let _62: f64;
                        scope 8 {
                            debug w => _62;
                            let _63: f64;
                            scope 9 {
                                debug s1 => _63;
                                let _104: f64;
                                scope 10 {
                                    debug s2 => _104;
                                    let _144: f64;
                                    let mut _163: &[f64; 4];
                                    let mut _164: &[f64; 4];
                                    scope 11 {
                                        debug z => _144;
                                    }
                                }
                            }
                        }
                    }
                }
                scope 6 {
                }
            }
        }
    }

    bb0: {
        _2 = _1;
        _6 = _2;
        _5 = f64::<impl f64>::to_bits(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = const 32_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 32_i32);
        _3 = move _4 as u32 (IntToInt);
        _10 = _3;
        _11 = const 31_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(move _10, const 31_i32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _14 = _3;
        _13 = Ge(move _14, const 1141899264_u32);
        switchInt(move _13) -> [0: bb12, otherwise: bb4];
    }

    bb4: {
        _16 = _2;
        _15 = f64::<impl f64>::is_nan(move _16) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _15) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _2;
        goto -> bb46;
    }

    bb7: {
        _19 = const _;
        _20 = const 3_usize;
        _21 = const 4_usize;
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _18 = _19[_20];
        _23 = f64::<impl f64>::from_bits(const 58720256_u64) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _17 = Add(move _18, move _23);
        switchInt(move _9) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = Neg(_17);
        goto -> bb46;
    }

    bb11: {
        _0 = _17;
        goto -> bb46;
    }

    bb12: {
        _26 = _3;
        _25 = Lt(move _26, const 1071382528_u32);
        switchInt(move _25) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _28 = _3;
        _27 = Lt(move _28, const 1044381696_u32);
        switchInt(move _27) -> [0: bb18, otherwise: bb15];
    }

    bb14: {
        _37 = _2;
        _36 = fabs(move _37) -> [return: bb19, unwind unreachable];
    }

    bb15: {
        _30 = _3;
        _29 = Lt(move _30, const 1048576_u32);
        switchInt(move _29) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _35 = _2;
        _34 = move _35 as f32 (FloatToFloat);
        _33 = &_34;
        _32 = &raw const (*_33);
        _31 = read_volatile::<f32>(move _32) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = _2;
        goto -> bb46;
    }

    bb18: {
        _24 = const -1_i32;
        goto -> bb26;
    }

    bb19: {
        _2 = move _36;
        _39 = _3;
        _38 = Lt(move _39, const 1072889856_u32);
        switchInt(move _38) -> [0: bb23, otherwise: bb20];
    }

    bb20: {
        _41 = _3;
        _40 = Lt(move _41, const 1072037888_u32);
        switchInt(move _40) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _44 = _2;
        _43 = Mul(const 2f64, move _44);
        _42 = Sub(move _43, const 1f64);
        _46 = _2;
        _45 = Add(const 2f64, move _46);
        _2 = Div(move _42, move _45);
        _24 = const 0_i32;
        goto -> bb26;
    }

    bb22: {
        _48 = _2;
        _47 = Sub(move _48, const 1f64);
        _50 = _2;
        _49 = Add(move _50, const 1f64);
        _2 = Div(move _47, move _49);
        _24 = const 1_i32;
        goto -> bb26;
    }

    bb23: {
        _52 = _3;
        _51 = Lt(move _52, const 1073971200_u32);
        switchInt(move _51) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _54 = _2;
        _53 = Sub(move _54, const 1.5f64);
        _57 = _2;
        _56 = Mul(const 1.5f64, move _57);
        _55 = Add(const 1f64, move _56);
        _2 = Div(move _53, move _55);
        _24 = const 2_i32;
        goto -> bb26;
    }

    bb25: {
        _58 = _2;
        _2 = Div(const -1f64, move _58);
        _24 = const 3_i32;
        goto -> bb26;
    }

    bb26: {
        _60 = _2;
        _61 = _2;
        _59 = Mul(move _60, move _61);
        _62 = Mul(_59, _59);
        _66 = const _;
        _67 = const 0_usize;
        _68 = const 11_usize;
        _69 = Lt(_67, _68);
        assert(move _69, "index out of bounds: the length is {} but the index is {}", move _68, _67) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _65 = _66[_67];
        _73 = const _;
        _74 = const 2_usize;
        _75 = const 11_usize;
        _76 = Lt(_74, _75);
        assert(move _76, "index out of bounds: the length is {} but the index is {}", move _75, _74) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _72 = _73[_74];
        _80 = const _;
        _81 = const 4_usize;
        _82 = const 11_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _79 = _80[_81];
        _87 = const _;
        _88 = const 6_usize;
        _89 = const 11_usize;
        _90 = Lt(_88, _89);
        assert(move _90, "index out of bounds: the length is {} but the index is {}", move _89, _88) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _86 = _87[_88];
        _94 = const _;
        _95 = const 8_usize;
        _96 = const 11_usize;
        _97 = Lt(_95, _96);
        assert(move _97, "index out of bounds: the length is {} but the index is {}", move _96, _95) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _93 = _94[_95];
        _100 = const _;
        _101 = const 10_usize;
        _102 = const 11_usize;
        _103 = Lt(_101, _102);
        assert(move _103, "index out of bounds: the length is {} but the index is {}", move _102, _101) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _99 = _100[_101];
        _98 = Mul(_62, move _99);
        _92 = Add(move _93, move _98);
        _91 = Mul(_62, move _92);
        _85 = Add(move _86, move _91);
        _84 = Mul(_62, move _85);
        _78 = Add(move _79, move _84);
        _77 = Mul(_62, move _78);
        _71 = Add(move _72, move _77);
        _70 = Mul(_62, move _71);
        _64 = Add(move _65, move _70);
        _63 = Mul(_59, move _64);
        _107 = const _;
        _108 = const 1_usize;
        _109 = const 11_usize;
        _110 = Lt(_108, _109);
        assert(move _110, "index out of bounds: the length is {} but the index is {}", move _109, _108) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _106 = _107[_108];
        _114 = const _;
        _115 = const 3_usize;
        _116 = const 11_usize;
        _117 = Lt(_115, _116);
        assert(move _117, "index out of bounds: the length is {} but the index is {}", move _116, _115) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _113 = _114[_115];
        _121 = const _;
        _122 = const 5_usize;
        _123 = const 11_usize;
        _124 = Lt(_122, _123);
        assert(move _124, "index out of bounds: the length is {} but the index is {}", move _123, _122) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _120 = _121[_122];
        _128 = const _;
        _129 = const 7_usize;
        _130 = const 11_usize;
        _131 = Lt(_129, _130);
        assert(move _131, "index out of bounds: the length is {} but the index is {}", move _130, _129) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _127 = _128[_129];
        _134 = const _;
        _135 = const 9_usize;
        _136 = const 11_usize;
        _137 = Lt(_135, _136);
        assert(move _137, "index out of bounds: the length is {} but the index is {}", move _136, _135) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _133 = _134[_135];
        _132 = Mul(_62, move _133);
        _126 = Add(move _127, move _132);
        _125 = Mul(_62, move _126);
        _119 = Add(move _120, move _125);
        _118 = Mul(_62, move _119);
        _112 = Add(move _113, move _118);
        _111 = Mul(_62, move _112);
        _105 = Add(move _106, move _111);
        _104 = Mul(_62, move _105);
        _139 = _24;
        _138 = Lt(move _139, const 0_i32);
        switchInt(move _138) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _140 = _2;
        _142 = _2;
        _143 = Add(_63, _104);
        _141 = Mul(move _142, move _143);
        _0 = Sub(move _140, move _141);
        goto -> bb46;
    }

    bb39: {
        _164 = const _;
        _148 = _164 as &[f64] (PointerCoercion(Unsize));
        _150 = _24;
        _149 = move _150 as usize (IntToInt);
        _147 = slice::<impl [f64]>::get::<usize>(move _148, move _149) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _146 = Option::<&f64>::unwrap(move _147) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _145 = (*_146);
        _154 = _2;
        _155 = Add(_63, _104);
        _153 = Mul(move _154, move _155);
        _163 = const _;
        _159 = _163 as &[f64] (PointerCoercion(Unsize));
        _161 = _24;
        _160 = move _161 as usize (IntToInt);
        _158 = slice::<impl [f64]>::get::<usize>(move _159, move _160) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _157 = Option::<&f64>::unwrap(move _158) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _156 = (*_157);
        _152 = Sub(move _153, move _156);
        _162 = _2;
        _151 = Sub(move _152, move _162);
        _144 = Sub(move _145, move _151);
        switchInt(move _9) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _0 = Neg(_144);
        goto -> bb46;
    }

    bb45: {
        _0 = _144;
        goto -> bb46;
    }

    bb46: {
        return;
    }
}

promoted[0] in atan: &[f64; 4] = {
    let mut _0: &[f64; 4];
    let mut _1: [f64; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in atan: &[f64; 4] = {
    let mut _0: &[f64; 4];
    let mut _1: [f64; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const atan2::PI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.1415926535897931f64;
        return;
    }
}

const atan2::PI_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.2246467991473532E-16f64;
        return;
    }
}

fn atan2(_1: f64, _2: f64) -> f64 {
    debug y => _1;
    debug x => _2;
    let mut _0: f64;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u32;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _11: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u32;
    let mut _16: bool;
    let mut _18: u64;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: u32;
    let mut _38: f64;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: bool;
    let mut _45: u32;
    let mut _46: u32;
    let mut _47: u32;
    let mut _48: u32;
    let mut _49: bool;
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: u32;
    let mut _53: f64;
    let mut _55: u32;
    let mut _56: bool;
    let mut _57: u32;
    let mut _58: u32;
    let mut _59: u32;
    let mut _60: u32;
    let mut _61: bool;
    let mut _62: u32;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    scope 1 {
        debug ix => _5;
        let _10: u32;
        scope 2 {
            debug lx => _10;
            let mut _12: u32;
            scope 3 {
                debug iy => _12;
                let _17: u32;
                scope 4 {
                    debug ly => _17;
                    let _22: u32;
                    scope 5 {
                        debug m => _22;
                        let _54: f64;
                        scope 6 {
                            debug z => _54;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::is_nan(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = f64::<impl f64>::is_nan(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Add(_2, _1);
        goto -> bb56;
    }

    bb5: {
        _7 = f64::<impl f64>::to_bits(_2) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _6 = Shr(move _7, const 32_i32);
        _5 = move _6 as u32 (IntToInt);
        _11 = f64::<impl f64>::to_bits(_2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _10 = move _11 as u32 (IntToInt);
        _14 = f64::<impl f64>::to_bits(_1) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _15 = const 32_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 64_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _13 = Shr(move _14, const 32_i32);
        _12 = move _13 as u32 (IntToInt);
        _18 = f64::<impl f64>::to_bits(_1) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _17 = move _18 as u32 (IntToInt);
        _21 = _5;
        _20 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _21, const 1072693248_u32) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _19 = BitOr(move _20, _10);
        switchInt(move _19) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _0 = atan(_1) -> [return: bb56, unwind unreachable];
    }

    bb14: {
        _25 = _12;
        _26 = const 31_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _24 = Shr(move _25, const 31_i32);
        _23 = BitAnd(move _24, const 1_u32);
        _30 = _5;
        _31 = const 30_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 32_u32);
        assert(move _32, "attempt to shift right by `{}`, which would overflow", const 30_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _29 = Shr(move _30, const 30_i32);
        _28 = BitAnd(move _29, const 2_u32);
        _22 = BitOr(move _23, move _28);
        _5 = BitAnd(_5, const 2147483647_u32);
        _12 = BitAnd(_12, const 2147483647_u32);
        _34 = _12;
        _33 = BitOr(move _34, _17);
        switchInt(move _33) -> [0: bb17, otherwise: bb21];
    }

    bb17: {
        switchInt(_22) -> [0: bb19, 1: bb19, 2: bb20, otherwise: bb18];
    }

    bb18: {
        _0 = Neg(const _);
        goto -> bb56;
    }

    bb19: {
        _0 = _1;
        goto -> bb56;
    }

    bb20: {
        _0 = const _;
        goto -> bb56;
    }

    bb21: {
        _36 = _5;
        _35 = BitOr(move _36, _10);
        switchInt(move _35) -> [0: bb22, otherwise: bb23];
    }

    bb22: {
        _37 = BitAnd(_22, const 1_u32);
        switchInt(move _37) -> [0: bb25, otherwise: bb24];
    }

    bb23: {
        _39 = _5;
        switchInt(move _39) -> [2146435072: bb26, otherwise: bb27];
    }

    bb24: {
        _38 = Neg(const _);
        _0 = Div(move _38, const 2f64);
        goto -> bb56;
    }

    bb25: {
        _0 = Div(const _, const 2f64);
        goto -> bb56;
    }

    bb26: {
        _40 = _12;
        switchInt(move _40) -> [2146435072: bb28, otherwise: bb33];
    }

    bb27: {
        _46 = _5;
        _48 = const 20_i32 as u32 (IntToInt);
        _49 = Lt(move _48, const 32_u32);
        assert(move _49, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb38, unwind unreachable];
    }

    bb28: {
        switchInt(_22) -> [0: bb30, 1: bb31, 2: bb32, otherwise: bb29];
    }

    bb29: {
        _43 = Mul(const -3f64, const _);
        _0 = Div(move _43, const 4f64);
        goto -> bb56;
    }

    bb30: {
        _0 = Div(const _, const 4f64);
        goto -> bb56;
    }

    bb31: {
        _41 = Neg(const _);
        _0 = Div(move _41, const 4f64);
        goto -> bb56;
    }

    bb32: {
        _42 = Mul(const 3f64, const _);
        _0 = Div(move _42, const 4f64);
        goto -> bb56;
    }

    bb33: {
        switchInt(_22) -> [0: bb35, 1: bb36, 2: bb37, otherwise: bb34];
    }

    bb34: {
        _0 = Neg(const _);
        goto -> bb56;
    }

    bb35: {
        _0 = const 0f64;
        goto -> bb56;
    }

    bb36: {
        _0 = const -0f64;
        goto -> bb56;
    }

    bb37: {
        _0 = const _;
        goto -> bb56;
    }

    bb38: {
        _47 = Shl(const 64_u32, const 20_i32);
        _45 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _46, move _47) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _50 = _12;
        _44 = Lt(move _45, move _50);
        switchInt(move _44) -> [0: bb40, otherwise: bb41];
    }

    bb40: {
        _51 = _12;
        switchInt(move _51) -> [2146435072: bb41, otherwise: bb44];
    }

    bb41: {
        _52 = BitAnd(_22, const 1_u32);
        switchInt(move _52) -> [0: bb43, otherwise: bb42];
    }

    bb42: {
        _53 = Neg(const _);
        _0 = Div(move _53, const 2f64);
        goto -> bb56;
    }

    bb43: {
        _0 = Div(const _, const 2f64);
        goto -> bb56;
    }

    bb44: {
        _55 = BitAnd(_22, const 2_u32);
        switchInt(move _55) -> [0: bb49, otherwise: bb45];
    }

    bb45: {
        _58 = _12;
        _60 = const 20_i32 as u32 (IntToInt);
        _61 = Lt(move _60, const 32_u32);
        assert(move _61, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _59 = Shl(const 64_u32, const 20_i32);
        _57 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _58, move _59) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _62 = _5;
        _56 = Lt(move _57, move _62);
        switchInt(move _56) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _54 = const 0f64;
        goto -> bb51;
    }

    bb49: {
        _64 = Div(_1, _2);
        _63 = fabs(move _64) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _54 = atan(move _63) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        switchInt(_22) -> [0: bb53, 1: bb54, 2: bb55, otherwise: bb52];
    }

    bb52: {
        _69 = _54;
        _68 = Sub(move _69, const _);
        _0 = Sub(move _68, const _);
        goto -> bb56;
    }

    bb53: {
        _0 = _54;
        goto -> bb56;
    }

    bb54: {
        _65 = _54;
        _0 = Neg(move _65);
        goto -> bb56;
    }

    bb55: {
        _67 = _54;
        _66 = Sub(move _67, const _);
        _0 = Sub(const _, move _66);
        goto -> bb56;
    }

    bb56: {
        return;
    }
}

const atan2f::PI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.14159274f32;
        return;
    }
}

const atan2f::PI_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -8.74227765E-8f32;
        return;
    }
}

fn atan2f(_1: f32, _2: f32) -> f32 {
    debug y => _1;
    debug x => _2;
    let mut _0: f32;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u32;
    let mut _7: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: f32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: u32;
    let mut _33: bool;
    let mut _34: (u32, bool);
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: u32;
    let mut _38: f32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: u32;
    let mut _45: u32;
    let mut _46: bool;
    let mut _47: (u32, bool);
    let mut _48: u32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    scope 1 {
        debug ix => _5;
        let mut _6: u32;
        scope 2 {
            debug iy => _6;
            let _8: u32;
            scope 3 {
                debug m => _8;
                let _39: f32;
                scope 4 {
                    debug z => _39;
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::is_nan(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = f32::<impl f32>::is_nan(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Add(_2, _1);
        goto -> bb51;
    }

    bb5: {
        _5 = f32::<impl f32>::to_bits(_2) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _6 = f32::<impl f32>::to_bits(_1) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _7 = _5;
        switchInt(move _7) -> [1065353216: bb8, otherwise: bb9];
    }

    bb8: {
        _0 = atanf(_1) -> [return: bb51, unwind unreachable];
    }

    bb9: {
        _11 = _6;
        _12 = const 31_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _10 = Shr(move _11, const 31_i32);
        _9 = BitAnd(move _10, const 1_u32);
        _16 = _5;
        _17 = const 30_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 32_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 30_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _15 = Shr(move _16, const 30_i32);
        _14 = BitAnd(move _15, const 2_u32);
        _8 = BitOr(move _9, move _14);
        _5 = BitAnd(_5, const 2147483647_u32);
        _6 = BitAnd(_6, const 2147483647_u32);
        _19 = _6;
        switchInt(move _19) -> [0: bb12, otherwise: bb16];
    }

    bb12: {
        switchInt(_8) -> [0: bb13, 1: bb13, 2: bb14, otherwise: bb15];
    }

    bb13: {
        _0 = _1;
        goto -> bb51;
    }

    bb14: {
        _0 = const _;
        goto -> bb51;
    }

    bb15: {
        _0 = Neg(const _);
        goto -> bb51;
    }

    bb16: {
        _20 = _5;
        switchInt(move _20) -> [0: bb17, otherwise: bb18];
    }

    bb17: {
        _21 = BitAnd(_8, const 1_u32);
        switchInt(move _21) -> [0: bb20, otherwise: bb19];
    }

    bb18: {
        _23 = _5;
        switchInt(move _23) -> [2139095040: bb21, otherwise: bb22];
    }

    bb19: {
        _22 = Neg(const _);
        _0 = Div(move _22, const 2f32);
        goto -> bb51;
    }

    bb20: {
        _0 = Div(const _, const 2f32);
        goto -> bb51;
    }

    bb21: {
        _24 = _6;
        switchInt(move _24) -> [2139095040: bb23, otherwise: bb28];
    }

    bb22: {
        _30 = _5;
        _32 = const 23_i32 as u32 (IntToInt);
        _33 = Lt(move _32, const 32_u32);
        assert(move _33, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb33, unwind unreachable];
    }

    bb23: {
        switchInt(_8) -> [0: bb24, 1: bb25, 2: bb26, otherwise: bb27];
    }

    bb24: {
        _0 = Div(const _, const 4f32);
        goto -> bb51;
    }

    bb25: {
        _25 = Neg(const _);
        _0 = Div(move _25, const 4f32);
        goto -> bb51;
    }

    bb26: {
        _26 = Mul(const 3f32, const _);
        _0 = Div(move _26, const 4f32);
        goto -> bb51;
    }

    bb27: {
        _27 = Mul(const -3f32, const _);
        _0 = Div(move _27, const 4f32);
        goto -> bb51;
    }

    bb28: {
        switchInt(_8) -> [0: bb29, 1: bb30, 2: bb31, otherwise: bb32];
    }

    bb29: {
        _0 = const 0f32;
        goto -> bb51;
    }

    bb30: {
        _0 = const -0f32;
        goto -> bb51;
    }

    bb31: {
        _0 = const _;
        goto -> bb51;
    }

    bb32: {
        _0 = Neg(const _);
        goto -> bb51;
    }

    bb33: {
        _31 = Shl(const 26_u32, const 23_i32);
        _34 = CheckedAdd(_30, _31);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", move _30, move _31) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _29 = move (_34.0: u32);
        _35 = _6;
        _28 = Lt(move _29, move _35);
        switchInt(move _28) -> [0: bb35, otherwise: bb36];
    }

    bb35: {
        _36 = _6;
        switchInt(move _36) -> [2139095040: bb36, otherwise: bb39];
    }

    bb36: {
        _37 = BitAnd(_8, const 1_u32);
        switchInt(move _37) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _38 = Neg(const _);
        _0 = Div(move _38, const 2f32);
        goto -> bb51;
    }

    bb38: {
        _0 = Div(const _, const 2f32);
        goto -> bb51;
    }

    bb39: {
        _40 = BitAnd(_8, const 2_u32);
        switchInt(move _40) -> [0: bb44, otherwise: bb40];
    }

    bb40: {
        _43 = _6;
        _45 = const 23_i32 as u32 (IntToInt);
        _46 = Lt(move _45, const 32_u32);
        assert(move _46, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _44 = Shl(const 26_u32, const 23_i32);
        _47 = CheckedAdd(_43, _44);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", move _43, move _44) -> [success: bb42, unwind unreachable];
    }

    bb42: {
        _42 = move (_47.0: u32);
        _48 = _5;
        _41 = Lt(move _42, move _48);
        switchInt(move _41) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _39 = const 0f32;
        goto -> bb46;
    }

    bb44: {
        _50 = Div(_1, _2);
        _49 = fabsf(move _50) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _39 = atanf(move _49) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        switchInt(_8) -> [0: bb48, 1: bb49, 2: bb50, otherwise: bb47];
    }

    bb47: {
        _55 = _39;
        _54 = Sub(move _55, const _);
        _0 = Sub(move _54, const _);
        goto -> bb51;
    }

    bb48: {
        _0 = _39;
        goto -> bb51;
    }

    bb49: {
        _51 = _39;
        _0 = Neg(move _51);
        goto -> bb51;
    }

    bb50: {
        _53 = _39;
        _52 = Sub(move _53, const _);
        _0 = Sub(const _, move _52);
        goto -> bb51;
    }

    bb51: {
        return;
    }
}

const ATAN_HI: [f32; 4] = {
    let mut _0: [f32; 4];

    bb0: {
        _0 = [const 0.463647604f32, const 0.785398125f32, const 0.982793688f32, const 1.57079625f32];
        return;
    }
}

ATAN_HI::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 4_usize;
        return;
    }
}

const ATAN_LO: [f32; 4] = {
    let mut _0: [f32; 4];

    bb0: {
        _0 = [const 5.01215824E-9f32, const 3.77489471E-8f32, const 3.44732172E-8f32, const 7.54978942E-8f32];
        return;
    }
}

ATAN_LO::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 4_usize;
        return;
    }
}

const A_T: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 0.333333284f32, const -0.199991584f32, const 0.142536357f32, const -0.106480174f32, const 0.0616876073f32];
        return;
    }
}

A_T::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn atanf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: f32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: &f32;
    let mut _17: rustc_std_workspace_core::option::Option<&f32>;
    let mut _18: &[f32];
    let mut _19: f32;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: u32;
    let _27: f32;
    let mut _28: *const f32;
    let _29: &f32;
    let _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: bool;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: bool;
    let mut _49: u32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let mut _59: f32;
    let mut _60: f32;
    let mut _62: f32;
    let mut _63: f32;
    let mut _64: f32;
    let mut _65: &f32;
    let mut _66: rustc_std_workspace_core::option::Option<&f32>;
    let mut _67: &[f32];
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: &f32;
    let mut _72: rustc_std_workspace_core::option::Option<&f32>;
    let mut _73: &[f32];
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: &f32;
    let mut _77: rustc_std_workspace_core::option::Option<&f32>;
    let mut _78: &[f32];
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: &f32;
    let mut _83: rustc_std_workspace_core::option::Option<&f32>;
    let mut _84: &[f32];
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: &f32;
    let mut _88: rustc_std_workspace_core::option::Option<&f32>;
    let mut _89: &[f32];
    let mut _90: bool;
    let mut _91: i32;
    let mut _92: f32;
    let mut _93: f32;
    let mut _94: f32;
    let mut _95: f32;
    let mut _97: i32;
    let mut _99: f32;
    let mut _100: &f32;
    let mut _101: rustc_std_workspace_core::option::Option<&f32>;
    let mut _102: &[f32];
    let mut _103: f32;
    let mut _104: f32;
    let mut _105: f32;
    let mut _106: f32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: &f32;
    let mut _110: rustc_std_workspace_core::option::Option<&f32>;
    let mut _111: &[f32];
    let mut _112: f32;
    scope 1 {
        debug x1p_120 => _2;
        let _3: f32;
        scope 2 {
            debug z => _3;
            let mut _4: u32;
            scope 3 {
                debug ix => _4;
                let _6: bool;
                scope 4 {
                    debug sign => _6;
                    let _20: i32;
                    let mut _113: &[f32; 4];
                    scope 5 {
                        debug id => _20;
                        let _58: f32;
                        scope 7 {
                            debug w => _58;
                            let _61: f32;
                            let mut _118: &[f32; 5];
                            let mut _119: &[f32; 5];
                            let mut _120: &[f32; 5];
                            scope 8 {
                                debug s1 => _61;
                                let _79: f32;
                                let mut _116: &[f32; 5];
                                let mut _117: &[f32; 5];
                                scope 9 {
                                    debug s2 => _79;
                                    let _96: usize;
                                    scope 10 {
                                        debug id => _96;
                                        let _98: f32;
                                        let mut _114: &[f32; 4];
                                        let mut _115: &[f32; 4];
                                        scope 11 {
                                            debug z => _98;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 6 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 58720256_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = _1;
        _4 = f32::<impl f32>::to_bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = _4;
        _9 = const 31_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Shr(move _8, const 31_i32);
        _6 = Ne(move _7, const 0_u32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _12 = _4;
        _11 = Ge(move _12, const 1283457024_u32);
        switchInt(move _11) -> [0: bb12, otherwise: bb4];
    }

    bb4: {
        _14 = _1;
        _13 = f32::<impl f32>::is_nan(move _14) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _1;
        goto -> bb45;
    }

    bb7: {
        _113 = const _;
        _18 = _113 as &[f32] (PointerCoercion(Unsize));
        _17 = slice::<impl [f32]>::get::<usize>(move _18, const 3_usize) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = Option::<&f32>::unwrap(move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _15 = (*_16);
        _3 = Add(move _15, _2);
        switchInt(_6) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _19 = _3;
        _0 = Neg(move _19);
        goto -> bb45;
    }

    bb11: {
        _0 = _3;
        goto -> bb45;
    }

    bb12: {
        _22 = _4;
        _21 = Lt(move _22, const 1054867456_u32);
        switchInt(move _21) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _24 = _4;
        _23 = Lt(move _24, const 964689920_u32);
        switchInt(move _23) -> [0: bb18, otherwise: bb15];
    }

    bb14: {
        _34 = _1;
        _33 = fabsf(move _34) -> [return: bb19, unwind unreachable];
    }

    bb15: {
        _26 = _4;
        _25 = Lt(move _26, const 8388608_u32);
        switchInt(move _25) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _31 = _1;
        _32 = _1;
        _30 = Mul(move _31, move _32);
        _29 = &_30;
        _28 = &raw const (*_29);
        _27 = read_volatile::<f32>(move _28) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = _1;
        goto -> bb45;
    }

    bb18: {
        _20 = const -1_i32;
        goto -> bb26;
    }

    bb19: {
        _1 = move _33;
        _36 = _4;
        _35 = Lt(move _36, const 1066926080_u32);
        switchInt(move _35) -> [0: bb23, otherwise: bb20];
    }

    bb20: {
        _38 = _4;
        _37 = Lt(move _38, const 1060110336_u32);
        switchInt(move _37) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _41 = _1;
        _40 = Mul(const 2f32, move _41);
        _39 = Sub(move _40, const 1f32);
        _43 = _1;
        _42 = Add(const 2f32, move _43);
        _1 = Div(move _39, move _42);
        _20 = const 0_i32;
        goto -> bb26;
    }

    bb22: {
        _45 = _1;
        _44 = Sub(move _45, const 1f32);
        _47 = _1;
        _46 = Add(move _47, const 1f32);
        _1 = Div(move _44, move _46);
        _20 = const 1_i32;
        goto -> bb26;
    }

    bb23: {
        _49 = _4;
        _48 = Lt(move _49, const 1075576832_u32);
        switchInt(move _48) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _51 = _1;
        _50 = Sub(move _51, const 1.5f32);
        _54 = _1;
        _53 = Mul(const 1.5f32, move _54);
        _52 = Add(const 1f32, move _53);
        _1 = Div(move _50, move _52);
        _20 = const 2_i32;
        goto -> bb26;
    }

    bb25: {
        _55 = _1;
        _1 = Div(const -1f32, move _55);
        _20 = const 3_i32;
        goto -> bb26;
    }

    bb26: {
        _56 = _1;
        _57 = _1;
        _3 = Mul(move _56, move _57);
        _59 = _3;
        _60 = _3;
        _58 = Mul(move _59, move _60);
        _62 = _3;
        _120 = const _;
        _67 = _120 as &[f32] (PointerCoercion(Unsize));
        _66 = slice::<impl [f32]>::get::<usize>(move _67, const 0_usize) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _65 = Option::<&f32>::unwrap(move _66) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _64 = (*_65);
        _119 = const _;
        _73 = _119 as &[f32] (PointerCoercion(Unsize));
        _72 = slice::<impl [f32]>::get::<usize>(move _73, const 2_usize) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _71 = Option::<&f32>::unwrap(move _72) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _70 = (*_71);
        _118 = const _;
        _78 = _118 as &[f32] (PointerCoercion(Unsize));
        _77 = slice::<impl [f32]>::get::<usize>(move _78, const 4_usize) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _76 = Option::<&f32>::unwrap(move _77) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _75 = (*_76);
        _74 = Mul(_58, move _75);
        _69 = Add(move _70, move _74);
        _68 = Mul(_58, move _69);
        _63 = Add(move _64, move _68);
        _61 = Mul(move _62, move _63);
        _117 = const _;
        _84 = _117 as &[f32] (PointerCoercion(Unsize));
        _83 = slice::<impl [f32]>::get::<usize>(move _84, const 1_usize) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _82 = Option::<&f32>::unwrap(move _83) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _81 = (*_82);
        _116 = const _;
        _89 = _116 as &[f32] (PointerCoercion(Unsize));
        _88 = slice::<impl [f32]>::get::<usize>(move _89, const 3_usize) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _87 = Option::<&f32>::unwrap(move _88) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _86 = (*_87);
        _85 = Mul(_58, move _86);
        _80 = Add(move _81, move _85);
        _79 = Mul(_58, move _80);
        _91 = _20;
        _90 = Lt(move _91, const 0_i32);
        switchInt(move _90) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _92 = _1;
        _94 = _1;
        _95 = Add(_61, _79);
        _93 = Mul(move _94, move _95);
        _0 = Sub(move _92, move _93);
        goto -> bb45;
    }

    bb38: {
        _97 = _20;
        _96 = move _97 as usize (IntToInt);
        _115 = const _;
        _102 = _115 as &[f32] (PointerCoercion(Unsize));
        _101 = slice::<impl [f32]>::get::<usize>(move _102, _96) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _100 = Option::<&f32>::unwrap(move _101) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _99 = (*_100);
        _106 = _1;
        _107 = Add(_61, _79);
        _105 = Mul(move _106, move _107);
        _114 = const _;
        _111 = _114 as &[f32] (PointerCoercion(Unsize));
        _110 = slice::<impl [f32]>::get::<usize>(move _111, _96) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _109 = Option::<&f32>::unwrap(move _110) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _108 = (*_109);
        _104 = Sub(move _105, move _108);
        _112 = _1;
        _103 = Sub(move _104, move _112);
        _98 = Sub(move _99, move _103);
        switchInt(_6) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _0 = Neg(_98);
        goto -> bb45;
    }

    bb44: {
        _0 = _98;
        goto -> bb45;
    }

    bb45: {
        return;
    }
}

promoted[0] in atanf: &[f32; 4] = {
    let mut _0: &[f32; 4];
    let mut _1: [f32; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in atanf: &[f32; 4] = {
    let mut _0: &[f32; 4];
    let mut _1: [f32; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in atanf: &[f32; 4] = {
    let mut _0: &[f32; 4];
    let mut _1: [f32; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in atanf: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in atanf: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in atanf: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in atanf: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in atanf: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn atanh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _4: usize;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _13: u64;
    let mut _14: bool;
    let mut _15: usize;
    let mut _16: (usize, bool);
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: (usize, bool);
    let _20: f32;
    let mut _21: *const f32;
    let _22: &f32;
    let _23: f32;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    scope 1 {
        debug u => _2;
        let _3: usize;
        scope 2 {
            debug e => _3;
            let _8: bool;
            scope 3 {
                debug sign => _8;
                let mut _12: f64;
                scope 4 {
                    debug y => _12;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 52_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_2, const 52_i32);
        _4 = move _5 as usize (IntToInt);
        _3 = BitAnd(move _4, const 2047_usize);
        _10 = const 63_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(_2, const 63_i32);
        _8 = Ne(move _9, const 0_u64);
        _13 = BitAnd(_2, const 9223372036854775807_u64);
        _12 = f64::<impl f64>::from_bits(move _13) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _16 = CheckedSub(const 1023_usize, const 1_usize);
        assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_usize, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _15 = move (_16.0: usize);
        _14 = Lt(_3, move _15);
        switchInt(move _14) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _19 = CheckedSub(const 1023_usize, const 32_usize);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_usize, const 32_usize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _18 = move (_19.0: usize);
        _17 = Lt(_3, move _18);
        switchInt(move _17) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        switchInt(move _3) -> [0: bb9, otherwise: bb14];
    }

    bb9: {
        _24 = _12;
        _23 = move _24 as f32 (FloatToFloat);
        _22 = &_23;
        _21 = &raw const (*_22);
        _20 = read_volatile::<f32>(move _21) -> [return: bb14, unwind unreachable];
    }

    bb10: {
        _28 = _12;
        _27 = Mul(const 2f64, move _28);
        _32 = _12;
        _31 = Mul(const 2f64, move _32);
        _33 = _12;
        _30 = Mul(move _31, move _33);
        _35 = _12;
        _34 = Sub(const 1f64, move _35);
        _29 = Div(move _30, move _34);
        _26 = Add(move _27, move _29);
        _25 = log1p(move _26) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _12 = Mul(const 0.5f64, move _25);
        goto -> bb14;
    }

    bb12: {
        _39 = _12;
        _41 = _12;
        _40 = Sub(const 1f64, move _41);
        _38 = Div(move _39, move _40);
        _37 = Mul(const 2f64, move _38);
        _36 = log1p(move _37) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _12 = Mul(const 0.5f64, move _36);
        goto -> bb14;
    }

    bb14: {
        switchInt(_8) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _42 = _12;
        _0 = Neg(move _42);
        goto -> bb17;
    }

    bb16: {
        _0 = _12;
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn atanhf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _3: f32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: f32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: (u32, bool);
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: (u32, bool);
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: bool;
    let _30: f32;
    let mut _31: *const f32;
    let _32: &f32;
    let _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    scope 1 {
        debug u => _2;
        let _4: bool;
        scope 2 {
            debug sign => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f32::<impl f32>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 31_i32);
        _4 = Ne(move _5, const 0_u32);
        _2 = BitAnd(_2, const 2147483647_u32);
        _10 = _2;
        _9 = f32::<impl f32>::from_bits(move _10) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move _9;
        _12 = _2;
        _15 = const 23_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 32_u32);
        assert(move _16, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _14 = Shl(const 1_u32, const 23_i32);
        _17 = CheckedSub(const 1065353216_u32, _14);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, move _14) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _13 = move (_17.0: u32);
        _11 = Lt(move _12, move _13);
        switchInt(move _11) -> [0: bb14, otherwise: bb6];
    }

    bb6: {
        _19 = _2;
        _22 = const 23_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 32_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _21 = Shl(const 32_u32, const 23_i32);
        _24 = CheckedSub(const 1065353216_u32, _21);
        assert(!move (_24.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, move _21) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _20 = move (_24.0: u32);
        _18 = Lt(move _19, move _20);
        switchInt(move _18) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _26 = _2;
        _28 = const 23_i32 as u32 (IntToInt);
        _29 = Lt(move _28, const 32_u32);
        assert(move _29, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _27 = Shl(const 1_u32, const 23_i32);
        _25 = Lt(move _26, move _27);
        switchInt(move _25) -> [0: bb16, otherwise: bb11];
    }

    bb11: {
        _34 = _1;
        _35 = _1;
        _33 = Mul(move _34, move _35);
        _32 = &_33;
        _31 = &raw const (*_32);
        _30 = read_volatile::<f32>(move _31) -> [return: bb16, unwind unreachable];
    }

    bb12: {
        _39 = _1;
        _38 = Mul(const 2f32, move _39);
        _43 = _1;
        _42 = Mul(const 2f32, move _43);
        _44 = _1;
        _41 = Mul(move _42, move _44);
        _46 = _1;
        _45 = Sub(const 1f32, move _46);
        _40 = Div(move _41, move _45);
        _37 = Add(move _38, move _40);
        _36 = log1pf(move _37) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _1 = Mul(const 0.5f32, move _36);
        goto -> bb16;
    }

    bb14: {
        _50 = _1;
        _52 = _1;
        _51 = Sub(const 1f32, move _52);
        _49 = Div(move _50, move _51);
        _48 = Mul(const 2f32, move _49);
        _47 = log1pf(move _48) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _1 = Mul(const 0.5f32, move _47);
        goto -> bb16;
    }

    bb16: {
        switchInt(_4) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _53 = _1;
        _0 = Neg(move _53);
        goto -> bb19;
    }

    bb18: {
        _0 = _1;
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

const cbrt::B1: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 715094163_u32;
        return;
    }
}

const cbrt::B2: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 696219795_u32;
        return;
    }
}

const P0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.8759518242717701f64;
        return;
    }
}

const cbrt::P1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.8849797954337717f64;
        return;
    }
}

const cbrt::P2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.6214297201053545f64;
        return;
    }
}

const cbrt::P3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.75839793477876605f64;
        return;
    }
}

const cbrt::P4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14599619288661245f64;
        return;
    }
}

fn cbrt(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _9: u32;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: u32;
    let mut _18: u64;
    let mut _19: f64;
    let mut _20: u32;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: (u32, bool);
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: (u32, bool);
    let mut _34: u64;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: u64;
    let mut _38: u64;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: f64;
    let mut _43: u64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: u64;
    let mut _67: f64;
    let mut _68: u64;
    let mut _69: u64;
    let mut _70: (u64, bool);
    let mut _71: f64;
    let mut _72: u64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    scope 1 {
        debug x1p54 => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let mut _4: f64;
            scope 3 {
                debug r => _4;
                let _5: f64;
                scope 4 {
                    debug s => _5;
                    let mut _6: f64;
                    scope 5 {
                        debug t => _6;
                        let _7: f64;
                        scope 6 {
                            debug w => _7;
                            let mut _8: u32;
                            scope 7 {
                                debug hx => _8;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4850376798678024192_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = _3;
        _12 = const 32_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _10 = Shr(move _11, const 32_i32);
        _9 = move _10 as u32 (IntToInt);
        _8 = BitAnd(move _9, const 2147483647_u32);
        _15 = _8;
        _14 = Ge(move _15, const 2146435072_u32);
        switchInt(move _14) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Add(_1, _1);
        goto -> bb23;
    }

    bb5: {
        _17 = _8;
        _16 = Lt(move _17, const 1048576_u32);
        switchInt(move _16) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _19 = Mul(_1, _2);
        _18 = f64::<impl f64>::to_bits(move _19) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _31 = _8;
        _32 = Eq(const 3_u32, const 0_u32);
        assert(!move _32, "attempt to divide `{}` by zero", _31) -> [success: bb14, unwind unreachable];
    }

    bb8: {
        _3 = move _18;
        _22 = _3;
        _23 = const 32_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 64_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _21 = Shr(move _22, const 32_i32);
        _20 = move _21 as u32 (IntToInt);
        _8 = BitAnd(move _20, const 2147483647_u32);
        _25 = _8;
        switchInt(move _25) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _0 = _1;
        goto -> bb23;
    }

    bb11: {
        _27 = _8;
        _28 = Eq(const 3_u32, const 0_u32);
        assert(!move _28, "attempt to divide `{}` by zero", _27) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _26 = Div(move _27, const 3_u32);
        _29 = CheckedAdd(_26, const _);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", move _26, const _) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _8 = move (_29.0: u32);
        goto -> bb16;
    }

    bb14: {
        _30 = Div(move _31, const 3_u32);
        _33 = CheckedAdd(_30, const _);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _30, const _) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _8 = move (_33.0: u32);
        goto -> bb16;
    }

    bb16: {
        _35 = const 63_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 64_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _34 = Shl(const 1_u64, const 63_i32);
        _3 = BitAnd(_3, move _34);
        _39 = _8;
        _38 = move _39 as u64 (IntToInt);
        _40 = const 32_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 64_u32);
        assert(move _41, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _37 = Shl(move _38, const 32_i32);
        _3 = BitOr(_3, move _37);
        _43 = _3;
        _42 = f64::<impl f64>::from_bits(move _43) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _6 = move _42;
        _45 = _6;
        _46 = _6;
        _44 = Mul(move _45, move _46);
        _48 = _6;
        _47 = Div(move _48, _1);
        _4 = Mul(move _44, move _47);
        _49 = _6;
        _53 = _4;
        _56 = _4;
        _55 = Mul(move _56, const _);
        _54 = Add(const _, move _55);
        _52 = Mul(move _53, move _54);
        _51 = Add(const _, move _52);
        _60 = _4;
        _61 = _4;
        _59 = Mul(move _60, move _61);
        _62 = _4;
        _58 = Mul(move _59, move _62);
        _65 = _4;
        _64 = Mul(move _65, const _);
        _63 = Add(const _, move _64);
        _57 = Mul(move _58, move _63);
        _50 = Add(move _51, move _57);
        _6 = Mul(move _49, move _50);
        _67 = _6;
        _66 = f64::<impl f64>::to_bits(move _67) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _3 = move _66;
        _69 = _3;
        _70 = CheckedAdd(_69, const 2147483648_u64);
        assert(!move (_70.1: bool), "attempt to compute `{} + {}`, which would overflow", move _69, const 2147483648_u64) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _68 = move (_70.0: u64);
        _3 = BitAnd(move _68, const 18446744072635809792_u64);
        _72 = _3;
        _71 = f64::<impl f64>::from_bits(move _72) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _6 = move _71;
        _73 = _6;
        _74 = _6;
        _5 = Mul(move _73, move _74);
        _4 = Div(_1, _5);
        _75 = _6;
        _76 = _6;
        _7 = Add(move _75, move _76);
        _78 = _4;
        _79 = _6;
        _77 = Sub(move _78, move _79);
        _81 = _4;
        _80 = Add(_7, move _81);
        _4 = Div(move _77, move _80);
        _82 = _6;
        _84 = _6;
        _85 = _4;
        _83 = Mul(move _84, move _85);
        _6 = Add(move _82, move _83);
        _0 = _6;
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

const cbrtf::B1: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 709958130_u32;
        return;
    }
}

const cbrtf::B2: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const 642849266_u32;
        return;
    }
}

fn cbrtf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: f32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: (u32, bool);
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: (u32, bool);
    let mut _24: u32;
    let mut _25: f32;
    let mut _26: u32;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    scope 1 {
        debug x1p24 => _2;
        let mut _3: f64;
        scope 2 {
            debug r => _3;
            let mut _4: f64;
            scope 3 {
                debug t => _4;
                let mut _5: u32;
                scope 4 {
                    debug ui => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug hx => _6;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 1266679808_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _5;
        _6 = BitAnd(move _7, const 2147483647_u32);
        _9 = _6;
        _8 = Ge(move _9, const 2139095040_u32);
        switchInt(move _8) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Add(_1, _1);
        goto -> bb16;
    }

    bb4: {
        _11 = _6;
        _10 = Lt(move _11, const 8388608_u32);
        switchInt(move _10) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _12 = _6;
        switchInt(move _12) -> [0: bb7, otherwise: bb8];
    }

    bb6: {
        _21 = _6;
        _22 = Eq(const 3_u32, const 0_u32);
        assert(!move _22, "attempt to divide `{}` by zero", _21) -> [success: bb12, unwind unreachable];
    }

    bb7: {
        _0 = _1;
        goto -> bb16;
    }

    bb8: {
        _14 = Mul(_1, _2);
        _13 = f32::<impl f32>::to_bits(move _14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _5 = move _13;
        _15 = _5;
        _6 = BitAnd(move _15, const 2147483647_u32);
        _17 = _6;
        _18 = Eq(const 3_u32, const 0_u32);
        assert(!move _18, "attempt to divide `{}` by zero", _17) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _16 = Div(move _17, const 3_u32);
        _19 = CheckedAdd(_16, const _);
        assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", move _16, const _) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _6 = move (_19.0: u32);
        goto -> bb14;
    }

    bb12: {
        _20 = Div(move _21, const 3_u32);
        _23 = CheckedAdd(_20, const _);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", move _20, const _) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _6 = move (_23.0: u32);
        goto -> bb14;
    }

    bb14: {
        _5 = BitAnd(_5, const 2147483648_u32);
        _24 = _6;
        _5 = BitOr(_5, move _24);
        _26 = _5;
        _25 = f32::<impl f32>::from_bits(move _26) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _4 = move _25 as f64 (FloatToFloat);
        _28 = _4;
        _29 = _4;
        _27 = Mul(move _28, move _29);
        _30 = _4;
        _3 = Mul(move _27, move _30);
        _32 = _4;
        _35 = _1 as f64 (FloatToFloat);
        _36 = _1 as f64 (FloatToFloat);
        _34 = Add(move _35, move _36);
        _37 = _3;
        _33 = Add(move _34, move _37);
        _31 = Mul(move _32, move _33);
        _40 = _1 as f64 (FloatToFloat);
        _41 = _3;
        _39 = Add(move _40, move _41);
        _42 = _3;
        _38 = Add(move _39, move _42);
        _4 = Div(move _31, move _38);
        _44 = _4;
        _45 = _4;
        _43 = Mul(move _44, move _45);
        _46 = _4;
        _3 = Mul(move _43, move _46);
        _48 = _4;
        _51 = _1 as f64 (FloatToFloat);
        _52 = _1 as f64 (FloatToFloat);
        _50 = Add(move _51, move _52);
        _53 = _3;
        _49 = Add(move _50, move _53);
        _47 = Mul(move _48, move _49);
        _56 = _1 as f64 (FloatToFloat);
        _57 = _3;
        _55 = Add(move _56, move _57);
        _58 = _3;
        _54 = Add(move _55, move _58);
        _4 = Div(move _47, move _54);
        _59 = _4;
        _0 = move _59 as f32 (FloatToFloat);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

const ceil::TOINT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Div(const 1f64, const _);
        return;
    }
}

fn ceil(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: bool;
    let mut _10: i64;
    let mut _11: (i64, bool);
    let mut _12: bool;
    let mut _13: f64;
    let mut _14: u64;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: bool;
    let _22: f64;
    let mut _23: *const f64;
    let _24: &f64;
    let mut _25: u64;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    scope 1 {
        debug u => _2;
        let _3: i64;
        scope 2 {
            debug e => _3;
            let _8: f64;
            scope 3 {
                debug y => _8;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 52_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_2, const 52_i32);
        _4 = BitAnd(move _5, const 2047_u64);
        _3 = move _4 as i64 (IntToInt);
        _11 = CheckedAdd(const 1023_i64, const 52_i64);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i64, const 52_i64) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _10 = move (_11.0: i64);
        _9 = Ge(_3, move _10);
        switchInt(move _9) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _12 = Eq(_1, const 0f64);
        switchInt(move _12) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _1;
        goto -> bb19;
    }

    bb6: {
        _15 = const 63_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 64_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _14 = Shr(_2, const 63_i32);
        switchInt(move _14) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _18 = Sub(_1, const _);
        _17 = Add(move _18, const _);
        _13 = Sub(move _17, _1);
        goto -> bb10;
    }

    bb9: {
        _20 = Add(_1, const _);
        _19 = Sub(move _20, const _);
        _13 = Sub(move _19, _1);
        goto -> bb10;
    }

    bb10: {
        _8 = move _13;
        _21 = Lt(_3, const 1023_i64);
        switchInt(move _21) -> [0: bb16, otherwise: bb11];
    }

    bb11: {
        _24 = &_8;
        _23 = &raw const (*_24);
        _22 = read_volatile::<f64>(move _23) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _26 = const 63_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _25 = Shr(_2, const 63_i32);
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const -0f64;
        goto -> bb19;
    }

    bb15: {
        _0 = const 1f64;
        goto -> bb19;
    }

    bb16: {
        _29 = _8;
        _28 = Lt(move _29, const 0f64);
        switchInt(move _28) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _31 = _8;
        _30 = Add(_1, move _31);
        _0 = Add(move _30, const 1f64);
        goto -> bb19;
    }

    bb18: {
        _32 = _8;
        _0 = Add(_1, move _32);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn ceilf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: u32;
    let _17: f32;
    let mut _18: *const f32;
    let _19: &f32;
    let _20: f32;
    let mut _21: f32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: (u32, bool);
    let mut _27: u32;
    let _28: f32;
    let mut _29: *const f32;
    let _30: &f32;
    let _31: f32;
    let mut _32: f32;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: u32;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: bool;
    let mut _41: u32;
    scope 1 {
        debug ui => _2;
        let _3: i32;
        scope 2 {
            debug e => _3;
            let _12: u32;
            scope 3 {
                debug m => _12;
                scope 4 {
                }
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _2;
        _8 = const 23_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shr(move _7, const 23_i32);
        _5 = BitAnd(move _6, const 255_u32);
        _4 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _5, const 127_u32) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move _4 as i32 (IntToInt);
        _10 = Ge(_3, const 23_i32);
        switchInt(move _10) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = _1;
        goto -> bb25;
    }

    bb5: {
        _11 = Ge(_3, const 0_i32);
        switchInt(move _11) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _13 = _3 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", _3) -> [success: bb8, unwind unreachable];
    }

    bb7: {
        _32 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb17, unwind unreachable];
    }

    bb8: {
        _12 = Shr(const 8388607_u32, _3);
        _16 = _2;
        _15 = BitAnd(move _16, _12);
        switchInt(move _15) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _0 = _1;
        goto -> bb25;
    }

    bb10: {
        _21 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _20 = Add(_1, move _21);
        _19 = &_20;
        _18 = &raw const (*_19);
        _17 = read_volatile::<f32>(move _18) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _23 = _2;
        _24 = const 31_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 32_u32);
        assert(move _25, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _22 = Shr(move _23, const 31_i32);
        switchInt(move _22) -> [0: bb14, otherwise: bb16];
    }

    bb14: {
        _26 = CheckedAdd(_2, _12);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, _12) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move (_26.0: u32);
        goto -> bb16;
    }

    bb16: {
        _27 = Not(_12);
        _2 = BitAnd(_2, move _27);
        goto -> bb24;
    }

    bb17: {
        _31 = Add(_1, move _32);
        _30 = &_31;
        _29 = &raw const (*_30);
        _28 = read_volatile::<f32>(move _29) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _34 = _2;
        _35 = const 31_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _33 = Shr(move _34, const 31_i32);
        switchInt(move _33) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _0 = const -0f32;
        goto -> bb25;
    }

    bb21: {
        _38 = _2;
        _39 = const 1_i32 as u32 (IntToInt);
        _40 = Lt(move _39, const 32_u32);
        assert(move _40, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _37 = Shl(move _38, const 1_i32);
        switchInt(move _37) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _0 = const 1f32;
        goto -> bb25;
    }

    bb24: {
        _41 = _2;
        _0 = f32::<impl f32>::from_bits(move _41) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        return;
    }
}

fn copysign::copysign(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u64;
    scope 1 {
        debug ux => _3;
        let _4: u64;
        scope 2 {
            debug uy => _4;
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f64::<impl f64>::to_bits(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Not(const 0_u64);
        _7 = const 1_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(move _6, const 1_i32);
        _3 = BitAnd(_3, move _5);
        _11 = const 63_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _10 = Shl(const 1_u64, const 63_i32);
        _9 = BitAnd(_4, move _10);
        _3 = BitOr(_3, move _9);
        _13 = _3;
        _0 = f64::<impl f64>::from_bits(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn copysignf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: u32;
    let mut _5: u32;
    let mut _6: u32;
    scope 1 {
        debug ux => _3;
        let _4: u32;
        scope 2 {
            debug uy => _4;
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::to_bits(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = BitAnd(_3, const 2147483647_u32);
        _5 = BitAnd(_4, const 2147483648_u32);
        _3 = BitOr(_3, move _5);
        _6 = _3;
        _0 = f32::<impl f32>::from_bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn cos(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u32;
    let mut _3: u32;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: i32;
    let mut _11: bool;
    let mut _15: (i32, f64, f64);
    let mut _16: i32;
    let mut _17: f64;
    let mut _18: f64;
    scope 1 {
        debug ix => _2;
        let _12: i32;
        let _13: f64;
        let _14: f64;
        scope 2 {
            debug n => _12;
            debug y0 => _13;
            debug y1 => _14;
        }
    }

    bb0: {
        _5 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 32_i32);
        _3 = move _4 as u32 (IntToInt);
        _2 = BitAnd(move _3, const 2147483647_u32);
        _8 = Le(_2, const 1072243195_u32);
        switchInt(move _8) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _9 = Lt(_2, const 1044816030_u32);
        switchInt(move _9) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = _1 as i32 (FloatToInt);
        switchInt(move _10) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = const 1f64;
        goto -> bb17;
    }

    bb6: {
        _0 = k_cos(_1, const 0f64) -> [return: bb17, unwind unreachable];
    }

    bb7: {
        _11 = Ge(_2, const 2146435072_u32);
        switchInt(move _11) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Sub(_1, _1);
        goto -> bb17;
    }

    bb9: {
        _15 = rem_pio2(_1) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _12 = (_15.0: i32);
        _13 = (_15.1: f64);
        _14 = (_15.2: f64);
        _16 = BitAnd(_12, const 3_i32);
        switchInt(_16) -> [0: bb12, 1: bb13, 2: bb15, otherwise: bb11];
    }

    bb11: {
        _0 = k_sin(_13, _14, const 1_i32) -> [return: bb17, unwind unreachable];
    }

    bb12: {
        _0 = k_cos(_13, _14) -> [return: bb17, unwind unreachable];
    }

    bb13: {
        _17 = k_sin(_13, _14, const 1_i32) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _0 = Neg(move _17);
        goto -> bb17;
    }

    bb15: {
        _18 = k_cos(_13, _14) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Neg(move _18);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

const C1_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 1f64, const _);
        return;
    }
}

const C2_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 2f64, const _);
        return;
    }
}

const C3_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 3f64, const _);
        return;
    }
}

const C4_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 4f64, const _);
        return;
    }
}

fn cosf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let _14: f32;
    let mut _15: *const f32;
    let _16: &f32;
    let _17: f32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: f32;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: bool;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: bool;
    let mut _35: u32;
    let mut _38: (i32, f64);
    let mut _39: i32;
    let mut _40: f64;
    let mut _41: f32;
    scope 1 {
        debug x64 => _2;
        let _3: f32;
        scope 2 {
            debug x1p120 => _3;
            let mut _4: u32;
            scope 3 {
                debug ix => _4;
                let _5: bool;
                scope 4 {
                    debug sign => _5;
                    let _36: i32;
                    let _37: f64;
                    scope 5 {
                    }
                    scope 6 {
                        debug n => _36;
                        debug y => _37;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1 as f64 (FloatToFloat);
        _3 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _4;
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 31_i32);
        _5 = Ne(move _6, const 0_u32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _11 = _4;
        _10 = Le(move _11, const 1061752794_u32);
        switchInt(move _10) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _13 = _4;
        _12 = Lt(move _13, const 964689920_u32);
        switchInt(move _12) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        _17 = Add(_1, _3);
        _16 = &_17;
        _15 = &raw const (*_16);
        _14 = read_volatile::<f32>(move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = const 1f32;
        goto -> bb36;
    }

    bb7: {
        _0 = k_cosf(_2) -> [return: bb36, unwind unreachable];
    }

    bb8: {
        _19 = _4;
        _18 = Le(move _19, const 1081824209_u32);
        switchInt(move _18) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _21 = _4;
        _20 = Gt(move _21, const 1075235811_u32);
        switchInt(move _20) -> [0: bb16, otherwise: bb11];
    }

    bb10: {
        _27 = _4;
        _26 = Le(move _27, const 1088565717_u32);
        switchInt(move _26) -> [0: bb20, otherwise: bb19];
    }

    bb11: {
        switchInt(_5) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _23 = Add(_2, const _);
        goto -> bb14;
    }

    bb13: {
        _23 = Sub(_2, const _);
        goto -> bb14;
    }

    bb14: {
        _22 = k_cosf(move _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Neg(move _22);
        goto -> bb36;
    }

    bb16: {
        switchInt(_5) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _24 = Add(_2, const _);
        _0 = k_sinf(move _24) -> [return: bb36, unwind unreachable];
    }

    bb18: {
        _25 = Sub(const _, _2);
        _0 = k_sinf(move _25) -> [return: bb36, unwind unreachable];
    }

    bb19: {
        _29 = _4;
        _28 = Gt(move _29, const 1085271519_u32);
        switchInt(move _28) -> [0: bb25, otherwise: bb21];
    }

    bb20: {
        _35 = _4;
        _34 = Ge(move _35, const 2139095040_u32);
        switchInt(move _34) -> [0: bb29, otherwise: bb28];
    }

    bb21: {
        switchInt(_5) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _30 = Add(_2, const _);
        goto -> bb24;
    }

    bb23: {
        _30 = Sub(_2, const _);
        goto -> bb24;
    }

    bb24: {
        _0 = k_cosf(move _30) -> [return: bb36, unwind unreachable];
    }

    bb25: {
        switchInt(_5) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _32 = Neg(_2);
        _31 = Sub(move _32, const _);
        _0 = k_sinf(move _31) -> [return: bb36, unwind unreachable];
    }

    bb27: {
        _33 = Sub(_2, const _);
        _0 = k_sinf(move _33) -> [return: bb36, unwind unreachable];
    }

    bb28: {
        _0 = Sub(_1, _1);
        goto -> bb36;
    }

    bb29: {
        _38 = rem_pio2f(_1) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _36 = (_38.0: i32);
        _37 = (_38.1: f64);
        _39 = BitAnd(_36, const 3_i32);
        switchInt(_39) -> [0: bb32, 1: bb33, 2: bb34, otherwise: bb31];
    }

    bb31: {
        _0 = k_sinf(_37) -> [return: bb36, unwind unreachable];
    }

    bb32: {
        _0 = k_cosf(_37) -> [return: bb36, unwind unreachable];
    }

    bb33: {
        _40 = Neg(_37);
        _0 = k_sinf(move _40) -> [return: bb36, unwind unreachable];
    }

    bb34: {
        _41 = k_cosf(_37) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _0 = Neg(move _41);
        goto -> bb36;
    }

    bb36: {
        return;
    }
}

fn cosh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: u64;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: (u64, bool);
    let _18: f64;
    let mut _19: *const f64;
    let _20: &f64;
    let _21: f64;
    let mut _22: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: bool;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    scope 1 {
        debug ix => _2;
        let _6: u64;
        scope 2 {
            debug w => _6;
            let _17: f64;
            let _23: f64;
            let _30: f64;
            scope 3 {
                debug x1p120 => _17;
                scope 4 {
                }
            }
            scope 5 {
                debug t => _23;
            }
            scope 6 {
                debug t => _30;
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f64::<impl f64>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(_2, const 9223372036854775807_u64);
        _5 = _2;
        _4 = f64::<impl f64>::from_bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _1 = move _4;
        _7 = _2;
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 32_i32);
        _10 = Lt(_6, const 1072049730_u64);
        switchInt(move _10) -> [0: bb12, otherwise: bb4];
    }

    bb4: {
        _14 = const 20_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Shl(const 26_u64, const 20_i32);
        _16 = CheckedSub(const 1072693248_u64, _13);
        assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u64, move _13) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _12 = move (_16.0: u64);
        _11 = Lt(_6, move _12);
        switchInt(move _11) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _17 = f64::<impl f64>::from_bits(const 5147614374084476928_u64) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _22 = _1;
        _21 = Add(move _22, _17);
        _20 = &_21;
        _19 = &raw const (*_20);
        _18 = read_volatile::<f64>(move _19) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = const 1f64;
        goto -> bb16;
    }

    bb10: {
        _24 = _1;
        _23 = expm1(move _24) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _26 = Mul(_23, _23);
        _28 = Add(const 1f64, _23);
        _27 = Mul(const 2f64, move _28);
        _25 = Div(move _26, move _27);
        _0 = Add(const 1f64, move _25);
        goto -> bb16;
    }

    bb12: {
        _29 = Lt(_6, const 1082535490_u64);
        switchInt(move _29) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _31 = _1;
        _30 = exp(move _31) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _34 = _1;
        _0 = k_expo2(move _34) -> [return: bb16, unwind unreachable];
    }

    bb15: {
        _33 = Div(const 1f64, _30);
        _32 = Add(_30, move _33);
        _0 = Mul(const 0.5f64, move _32);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn coshf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: f32;
    let mut _5: f32;
    let mut _6: u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: (u32, bool);
    let _15: f32;
    let mut _16: *const f32;
    let _17: &f32;
    let _18: f32;
    let mut _19: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: bool;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    scope 1 {
        debug x1p120 => _2;
        let mut _3: u32;
        scope 2 {
            debug ix => _3;
            let _7: u32;
            scope 3 {
                debug w => _7;
                let _20: f32;
                let _27: f32;
                scope 4 {
                }
                scope 5 {
                    debug t => _20;
                }
                scope 6 {
                    debug t => _27;
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _3 = BitAnd(_3, const 2147483647_u32);
        _6 = _3;
        _5 = f32::<impl f32>::from_bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move _5;
        _7 = _3;
        _8 = Lt(_7, const 1060205079_u32);
        switchInt(move _8) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _12 = const 23_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _11 = Shl(const 12_u32, const 23_i32);
        _14 = CheckedSub(const 1065353216_u32, _11);
        assert(!move (_14.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, move _11) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _10 = move (_14.0: u32);
        _9 = Lt(_7, move _10);
        switchInt(move _9) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _19 = _1;
        _18 = Add(move _19, _2);
        _17 = &_18;
        _16 = &raw const (*_17);
        _15 = read_volatile::<f32>(move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = const 1f32;
        goto -> bb15;
    }

    bb9: {
        _21 = _1;
        _20 = expm1f(move _21) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _23 = Mul(_20, _20);
        _25 = Add(const 1f32, _20);
        _24 = Mul(const 2f32, move _25);
        _22 = Div(move _23, move _24);
        _0 = Add(const 1f32, move _22);
        goto -> bb15;
    }

    bb11: {
        _26 = Lt(_7, const 1118925335_u32);
        switchInt(move _26) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _28 = _1;
        _27 = expf(move _28) -> [return: bb14, unwind unreachable];
    }

    bb13: {
        _31 = _1;
        _0 = k_expo2f(move _31) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _30 = Div(const 1f32, _27);
        _29 = Add(_27, move _30);
        _0 = Mul(const 0.5f32, move _29);
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

const erf::ERX: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.84506291151046753f64;
        return;
    }
}

const erf::EFX8: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.0270333367641007f64;
        return;
    }
}

const erf::PP0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.12837916709551256f64;
        return;
    }
}

const erf::PP1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.3250421072470015f64;
        return;
    }
}

const erf::PP2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.02848174957559851f64;
        return;
    }
}

const erf::PP3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0057702702964894416f64;
        return;
    }
}

const erf::PP4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.3763016656650163E-5f64;
        return;
    }
}

const erf::QQ1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.39791722395915535f64;
        return;
    }
}

const erf::QQ2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.065022249988767294f64;
        return;
    }
}

const erf::QQ3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0050813062818757656f64;
        return;
    }
}

const erf::QQ4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.3249473800432164E-4f64;
        return;
    }
}

const erf::QQ5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -3.9602282787753681E-6f64;
        return;
    }
}

const erf::PA0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0023621185607526594f64;
        return;
    }
}

const erf::PA1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.41485611868374833f64;
        return;
    }
}

const erf::PA2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.37220787603570132f64;
        return;
    }
}

const erf::PA3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.31834661990116175f64;
        return;
    }
}

const erf::PA4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.11089469428239668f64;
        return;
    }
}

const erf::PA5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.035478304325618236f64;
        return;
    }
}

const erf::PA6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0021663755948687908f64;
        return;
    }
}

const erf::QA1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.10642088040084423f64;
        return;
    }
}

const erf::QA2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.54039791770217105f64;
        return;
    }
}

const erf::QA3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.071828654414196266f64;
        return;
    }
}

const erf::QA4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.12617121980876164f64;
        return;
    }
}

const erf::QA5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.013637083912029051f64;
        return;
    }
}

const erf::QA6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.011984499846799107f64;
        return;
    }
}

const erf::RA0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0098649440348471482f64;
        return;
    }
}

const erf::RA1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.69385857270718176f64;
        return;
    }
}

const erf::RA2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -10.558626225323291f64;
        return;
    }
}

const erf::RA3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -62.375332450326006f64;
        return;
    }
}

const erf::RA4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -162.39666946257347f64;
        return;
    }
}

const erf::RA5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -184.60509290671104f64;
        return;
    }
}

const erf::RA6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -81.287435506306593f64;
        return;
    }
}

const erf::RA7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -9.8143293441691454f64;
        return;
    }
}

const erf::SA1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 19.651271667439257f64;
        return;
    }
}

const erf::SA2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 137.65775414351904f64;
        return;
    }
}

const erf::SA3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 434.56587747522923f64;
        return;
    }
}

const erf::SA4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 645.38727173326788f64;
        return;
    }
}

const erf::SA5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 429.00814002756783f64;
        return;
    }
}

const erf::SA6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 108.63500554177944f64;
        return;
    }
}

const erf::SA7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.5702497703192817f64;
        return;
    }
}

const erf::SA8: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.060424415214858099f64;
        return;
    }
}

const erf::RB0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0098649429247000992f64;
        return;
    }
}

const erf::RB1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.79928323768052301f64;
        return;
    }
}

const erf::RB2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -17.757954917754752f64;
        return;
    }
}

const erf::RB3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -160.63638485582192f64;
        return;
    }
}

const erf::RB4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -637.56644336838963f64;
        return;
    }
}

const erf::RB5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1025.0951316110772f64;
        return;
    }
}

const erf::RB6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -483.5191916086514f64;
        return;
    }
}

const erf::SB1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 30.338060743482458f64;
        return;
    }
}

const erf::SB2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 325.79251299657392f64;
        return;
    }
}

const erf::SB3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1536.729586084437f64;
        return;
    }
}

const erf::SB4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3199.8582195085955f64;
        return;
    }
}

const erf::SB5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2553.0504064331644f64;
        return;
    }
}

const erf::SB6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 474.52854120695537f64;
        return;
    }
}

const erf::SB7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -22.440952446585818f64;
        return;
    }
}

fn erf::erfc1(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    scope 1 {
        debug s => _2;
        let _3: f64;
        scope 2 {
            debug p => _3;
            let _4: f64;
            scope 3 {
                debug q => _4;
            }
        }
    }

    bb0: {
        _5 = fabs(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Sub(move _5, const 1f64);
        _16 = Mul(_2, const _);
        _15 = Add(const _, move _16);
        _14 = Mul(_2, move _15);
        _13 = Add(const _, move _14);
        _12 = Mul(_2, move _13);
        _11 = Add(const _, move _12);
        _10 = Mul(_2, move _11);
        _9 = Add(const _, move _10);
        _8 = Mul(_2, move _9);
        _7 = Add(const _, move _8);
        _6 = Mul(_2, move _7);
        _3 = Add(const _, move _6);
        _27 = Mul(_2, const _);
        _26 = Add(const _, move _27);
        _25 = Mul(_2, move _26);
        _24 = Add(const _, move _25);
        _23 = Mul(_2, move _24);
        _22 = Add(const _, move _23);
        _21 = Mul(_2, move _22);
        _20 = Add(const _, move _21);
        _19 = Mul(_2, move _20);
        _18 = Add(const _, move _19);
        _17 = Mul(_2, move _18);
        _4 = Add(const 1f64, move _17);
        _28 = Sub(const 1f64, const _);
        _29 = Div(_3, _4);
        _0 = Sub(move _28, move _29);
        return;
    }
}

fn erf::erfc2(_1: u32, _2: f64) -> f64 {
    debug ix => _1;
    debug x => _2;
    let mut _0: f64;
    let _3: f64;
    let mut _6: bool;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: bool;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    scope 1 {
        debug s => _3;
        let _4: f64;
        scope 2 {
            debug r => _4;
            let _5: f64;
            scope 3 {
                debug big_s => _5;
                scope 4 {
                    debug z => _66;
                }
            }
        }
    }

    bb0: {
        _6 = Lt(_1, const 1072955392_u32);
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _7 = _2;
        _0 = erf::erfc1(move _7) -> [return: bb10, unwind unreachable];
    }

    bb2: {
        _9 = _2;
        _8 = fabs(move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move _8;
        _11 = _2;
        _12 = _2;
        _10 = Mul(move _11, move _12);
        _3 = Div(const 1f64, move _10);
        _13 = Lt(_1, const 1074191213_u32);
        switchInt(move _13) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _26 = Mul(_3, const _);
        _25 = Add(const _, move _26);
        _24 = Mul(_3, move _25);
        _23 = Add(const _, move _24);
        _22 = Mul(_3, move _23);
        _21 = Add(const _, move _22);
        _20 = Mul(_3, move _21);
        _19 = Add(const _, move _20);
        _18 = Mul(_3, move _19);
        _17 = Add(const _, move _18);
        _16 = Mul(_3, move _17);
        _15 = Add(const _, move _16);
        _14 = Mul(_3, move _15);
        _4 = Add(const _, move _14);
        _41 = Mul(_3, const _);
        _40 = Add(const _, move _41);
        _39 = Mul(_3, move _40);
        _38 = Add(const _, move _39);
        _37 = Mul(_3, move _38);
        _36 = Add(const _, move _37);
        _35 = Mul(_3, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_3, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_3, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_3, move _30);
        _28 = Add(const _, move _29);
        _27 = Mul(_3, move _28);
        _5 = Add(const 1f64, move _27);
        goto -> bb6;
    }

    bb5: {
        _52 = Mul(_3, const _);
        _51 = Add(const _, move _52);
        _50 = Mul(_3, move _51);
        _49 = Add(const _, move _50);
        _48 = Mul(_3, move _49);
        _47 = Add(const _, move _48);
        _46 = Mul(_3, move _47);
        _45 = Add(const _, move _46);
        _44 = Mul(_3, move _45);
        _43 = Add(const _, move _44);
        _42 = Mul(_3, move _43);
        _4 = Add(const _, move _42);
        _65 = Mul(_3, const _);
        _64 = Add(const _, move _65);
        _63 = Mul(_3, move _64);
        _62 = Add(const _, move _63);
        _61 = Mul(_3, move _62);
        _60 = Add(const _, move _61);
        _59 = Mul(_3, move _60);
        _58 = Add(const _, move _59);
        _57 = Mul(_3, move _58);
        _56 = Add(const _, move _57);
        _55 = Mul(_3, move _56);
        _54 = Add(const _, move _55);
        _53 = Mul(_3, move _54);
        _5 = Add(const 1f64, move _53);
        goto -> bb6;
    }

    bb6: {
        _67 = _2;
        _66 = with_set_low_word(move _67, const 0_u32) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _72 = Neg(_66);
        _71 = Mul(move _72, _66);
        _70 = Sub(move _71, const 0.5625f64);
        _69 = exp(move _70) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _77 = _2;
        _76 = Sub(_66, move _77);
        _79 = _2;
        _78 = Add(_66, move _79);
        _75 = Mul(move _76, move _78);
        _81 = _4;
        _82 = _5;
        _80 = Div(move _81, move _82);
        _74 = Add(move _75, move _80);
        _73 = exp(move _74) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _68 = Mul(move _69, move _73);
        _83 = _2;
        _0 = Div(move _68, move _83);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn erf(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: bool;
    let mut _45: u32;
    let mut _46: f64;
    let mut _47: u32;
    let mut _49: f64;
    scope 1 {
        debug r => _2;
        let _3: f64;
        scope 2 {
            debug s => _3;
            let _4: f64;
            scope 3 {
                debug z => _4;
                let _5: f64;
                scope 4 {
                    debug y => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug ix => _6;
                        let _7: usize;
                        scope 6 {
                            debug sign => _7;
                            let _48: f64;
                            scope 7 {
                                debug x1p_1022 => _48;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _8;
        _10 = _6;
        _11 = const 31_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shr(move _10, const 31_i32);
        _7 = move _9 as usize (IntToInt);
        _6 = BitAnd(_6, const 2147483647_u32);
        _14 = _6;
        _13 = Ge(move _14, const 2146435072_u32);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _17 = _7 as f64 (IntToFloat);
        _16 = Mul(const 2f64, move _17);
        _15 = Sub(const 1f64, move _16);
        _18 = Div(const 1f64, _1);
        _0 = Add(move _15, move _18);
        goto -> bb16;
    }

    bb4: {
        _20 = _6;
        _19 = Lt(move _20, const 1072365568_u32);
        switchInt(move _19) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _22 = _6;
        _21 = Lt(move _22, const 1043333120_u32);
        switchInt(move _21) -> [0: bb8, otherwise: bb7];
    }

    bb6: {
        _45 = _6;
        _44 = Lt(move _45, const 1075314688_u32);
        switchInt(move _44) -> [0: bb10, otherwise: bb9];
    }

    bb7: {
        _24 = Mul(const 8f64, _1);
        _25 = Mul(const _, _1);
        _23 = Add(move _24, move _25);
        _0 = Mul(const 0.125f64, move _23);
        goto -> bb16;
    }

    bb8: {
        _4 = Mul(_1, _1);
        _32 = Mul(_4, const _);
        _31 = Add(const _, move _32);
        _30 = Mul(_4, move _31);
        _29 = Add(const _, move _30);
        _28 = Mul(_4, move _29);
        _27 = Add(const _, move _28);
        _26 = Mul(_4, move _27);
        _2 = Add(const _, move _26);
        _41 = Mul(_4, const _);
        _40 = Add(const _, move _41);
        _39 = Mul(_4, move _40);
        _38 = Add(const _, move _39);
        _37 = Mul(_4, move _38);
        _36 = Add(const _, move _37);
        _35 = Mul(_4, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_4, move _34);
        _3 = Add(const 1f64, move _33);
        _5 = Div(_2, _3);
        _43 = _5;
        _42 = Mul(_1, move _43);
        _0 = Add(_1, move _42);
        goto -> bb16;
    }

    bb9: {
        _47 = _6;
        _46 = erf::erfc2(move _47, _1) -> [return: bb11, unwind unreachable];
    }

    bb10: {
        _48 = f64::<impl f64>::from_bits(const 4503599627370496_u64) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _5 = Sub(const 1f64, move _46);
        goto -> bb13;
    }

    bb12: {
        _5 = Sub(const 1f64, _48);
        goto -> bb13;
    }

    bb13: {
        switchInt(move _7) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _49 = _5;
        _0 = Neg(move _49);
        goto -> bb16;
    }

    bb15: {
        _0 = _5;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn erfc(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: f64;
    let mut _48: u32;
    let mut _49: u32;
    scope 1 {
        debug r => _2;
        let _3: f64;
        scope 2 {
            debug s => _3;
            let _4: f64;
            scope 3 {
                debug z => _4;
                let _5: f64;
                scope 4 {
                    debug y => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug ix => _6;
                        let _7: usize;
                        scope 6 {
                            debug sign => _7;
                            let _50: f64;
                            scope 7 {
                                debug x1p_1022 => _50;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _8;
        _10 = _6;
        _11 = const 31_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shr(move _10, const 31_i32);
        _7 = move _9 as usize (IntToInt);
        _6 = BitAnd(_6, const 2147483647_u32);
        _14 = _6;
        _13 = Ge(move _14, const 2146435072_u32);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _16 = _7 as f64 (IntToFloat);
        _15 = Mul(const 2f64, move _16);
        _17 = Div(const 1f64, _1);
        _0 = Add(move _15, move _17);
        goto -> bb20;
    }

    bb4: {
        _19 = _6;
        _18 = Lt(move _19, const 1072365568_u32);
        switchInt(move _18) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _21 = _6;
        _20 = Lt(move _21, const 1013972992_u32);
        switchInt(move _20) -> [0: bb8, otherwise: bb7];
    }

    bb6: {
        _46 = _6;
        _45 = Lt(move _46, const 1077673984_u32);
        switchInt(move _45) -> [0: bb13, otherwise: bb12];
    }

    bb7: {
        _0 = Sub(const 1f64, _1);
        goto -> bb20;
    }

    bb8: {
        _4 = Mul(_1, _1);
        _28 = Mul(_4, const _);
        _27 = Add(const _, move _28);
        _26 = Mul(_4, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_4, move _25);
        _23 = Add(const _, move _24);
        _22 = Mul(_4, move _23);
        _2 = Add(const _, move _22);
        _37 = Mul(_4, const _);
        _36 = Add(const _, move _37);
        _35 = Mul(_4, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_4, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_4, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_4, move _30);
        _3 = Add(const 1f64, move _29);
        _5 = Div(_2, _3);
        switchInt(move _7) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _39 = _6;
        _38 = Lt(move _39, const 1070596096_u32);
        switchInt(move _38) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _41 = Mul(_1, _5);
        _40 = Add(_1, move _41);
        _0 = Sub(const 1f64, move _40);
        goto -> bb20;
    }

    bb11: {
        _43 = Sub(_1, const 0.5f64);
        _44 = Mul(_1, _5);
        _42 = Add(move _43, move _44);
        _0 = Sub(const 0.5f64, move _42);
        goto -> bb20;
    }

    bb12: {
        switchInt(move _7) -> [0: bb16, otherwise: bb14];
    }

    bb13: {
        _50 = f64::<impl f64>::from_bits(const 4503599627370496_u64) -> [return: bb17, unwind unreachable];
    }

    bb14: {
        _48 = _6;
        _47 = erf::erfc2(move _48, _1) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Sub(const 2f64, move _47);
        goto -> bb20;
    }

    bb16: {
        _49 = _6;
        _0 = erf::erfc2(move _49, _1) -> [return: bb20, unwind unreachable];
    }

    bb17: {
        switchInt(move _7) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _0 = Sub(const 2f64, _50);
        goto -> bb20;
    }

    bb19: {
        _0 = Mul(_50, _50);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

const erff::ERX: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.845062911f32;
        return;
    }
}

const erff::EFX8: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.02703333f32;
        return;
    }
}

const erff::PP0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.128379166f32;
        return;
    }
}

const erff::PP1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.325042099f32;
        return;
    }
}

const erff::PP2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0284817498f32;
        return;
    }
}

const erff::PP3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00577027025f32;
        return;
    }
}

const erff::PP4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -2.37630175E-5f32;
        return;
    }
}

const erff::QQ1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.397917211f32;
        return;
    }
}

const erff::QQ2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0650222525f32;
        return;
    }
}

const erff::QQ3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00508130621f32;
        return;
    }
}

const erff::QQ4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.32494737E-4f32;
        return;
    }
}

const erff::QQ5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -3.96022824E-6f32;
        return;
    }
}

const erff::PA0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00236211857f32;
        return;
    }
}

const erff::PA1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.414856106f32;
        return;
    }
}

const erff::PA2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.37220788f32;
        return;
    }
}

const erff::PA3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.31834662f32;
        return;
    }
}

const erff::PA4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.110894695f32;
        return;
    }
}

const erff::PA5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0354783051f32;
        return;
    }
}

const erff::PA6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00216637552f32;
        return;
    }
}

const erff::QA1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.106420882f32;
        return;
    }
}

const erff::QA2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.540397942f32;
        return;
    }
}

const erff::QA3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0718286559f32;
        return;
    }
}

const erff::QA4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.126171216f32;
        return;
    }
}

const erff::QA5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0136370836f32;
        return;
    }
}

const erff::QA6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0119845001f32;
        return;
    }
}

const erff::RA0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00986494403f32;
        return;
    }
}

const erff::RA1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.693858563f32;
        return;
    }
}

const erff::RA2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -10.5586262f32;
        return;
    }
}

const erff::RA3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -62.3753319f32;
        return;
    }
}

const erff::RA4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -162.396667f32;
        return;
    }
}

const erff::RA5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -184.605087f32;
        return;
    }
}

const erff::RA6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -81.2874374f32;
        return;
    }
}

const erff::RA7: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -9.81432914f32;
        return;
    }
}

const erff::SA1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 19.6512718f32;
        return;
    }
}

const erff::SA2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 137.657761f32;
        return;
    }
}

const erff::SA3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 434.565887f32;
        return;
    }
}

const erff::SA4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 645.387268f32;
        return;
    }
}

const erff::SA5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 429.008148f32;
        return;
    }
}

const erff::SA6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 108.635002f32;
        return;
    }
}

const erff::SA7: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 6.57024956f32;
        return;
    }
}

const erff::SA8: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0604244135f32;
        return;
    }
}

const erff::RB0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0098649431f32;
        return;
    }
}

const erff::RB1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.799283266f32;
        return;
    }
}

const erff::RB2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -17.7579556f32;
        return;
    }
}

const erff::RB3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -160.636383f32;
        return;
    }
}

const erff::RB4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -637.566467f32;
        return;
    }
}

const erff::RB5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1025.09509f32;
        return;
    }
}

const erff::RB6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -483.519196f32;
        return;
    }
}

const erff::SB1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 30.3380604f32;
        return;
    }
}

const erff::SB2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 325.792511f32;
        return;
    }
}

const erff::SB3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1536.72961f32;
        return;
    }
}

const erff::SB4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3199.85815f32;
        return;
    }
}

const erff::SB5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2553.05029f32;
        return;
    }
}

const erff::SB6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 474.528534f32;
        return;
    }
}

const erff::SB7: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -22.4409523f32;
        return;
    }
}

fn erff::erfc1(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: f32;
    let mut _6: f32;
    let mut _7: f32;
    let mut _8: f32;
    let mut _9: f32;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: f32;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    scope 1 {
        debug s => _2;
        let _3: f32;
        scope 2 {
            debug p => _3;
            let _4: f32;
            scope 3 {
                debug q => _4;
            }
        }
    }

    bb0: {
        _5 = fabsf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Sub(move _5, const 1f32);
        _16 = Mul(_2, const _);
        _15 = Add(const _, move _16);
        _14 = Mul(_2, move _15);
        _13 = Add(const _, move _14);
        _12 = Mul(_2, move _13);
        _11 = Add(const _, move _12);
        _10 = Mul(_2, move _11);
        _9 = Add(const _, move _10);
        _8 = Mul(_2, move _9);
        _7 = Add(const _, move _8);
        _6 = Mul(_2, move _7);
        _3 = Add(const _, move _6);
        _27 = Mul(_2, const _);
        _26 = Add(const _, move _27);
        _25 = Mul(_2, move _26);
        _24 = Add(const _, move _25);
        _23 = Mul(_2, move _24);
        _22 = Add(const _, move _23);
        _21 = Mul(_2, move _22);
        _20 = Add(const _, move _21);
        _19 = Mul(_2, move _20);
        _18 = Add(const _, move _19);
        _17 = Mul(_2, move _18);
        _4 = Add(const 1f32, move _17);
        _28 = Sub(const 1f32, const _);
        _29 = Div(_3, _4);
        _0 = Sub(move _28, move _29);
        return;
    }
}

fn erff::erfc2(_1: u32, _2: f32) -> f32 {
    debug ix => _1;
    debug x => _2;
    let mut _0: f32;
    let _3: f32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: f32;
    let mut _9: f32;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: f32;
    let mut _13: f32;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let mut _58: f32;
    let mut _59: f32;
    let mut _60: f32;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let mut _64: f32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: u32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: u32;
    let mut _72: u32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    scope 1 {
        debug s => _3;
        let _4: f32;
        scope 2 {
            debug r => _4;
            let _5: f32;
            scope 3 {
                debug big_s => _5;
                scope 4 {
                    debug z => _70;
                }
            }
        }
    }

    bb0: {
        _7 = _1;
        _6 = Lt(move _7, const 1067450368_u32);
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _8 = _2;
        _0 = erff::erfc1(move _8) -> [return: bb11, unwind unreachable];
    }

    bb2: {
        _10 = _2;
        _9 = fabsf(move _10) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move _9;
        _12 = _2;
        _13 = _2;
        _11 = Mul(move _12, move _13);
        _3 = Div(const 1f32, move _11);
        _15 = _1;
        _14 = Lt(move _15, const 1077336941_u32);
        switchInt(move _14) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _28 = Mul(_3, const _);
        _27 = Add(const _, move _28);
        _26 = Mul(_3, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_3, move _25);
        _23 = Add(const _, move _24);
        _22 = Mul(_3, move _23);
        _21 = Add(const _, move _22);
        _20 = Mul(_3, move _21);
        _19 = Add(const _, move _20);
        _18 = Mul(_3, move _19);
        _17 = Add(const _, move _18);
        _16 = Mul(_3, move _17);
        _4 = Add(const _, move _16);
        _43 = Mul(_3, const _);
        _42 = Add(const _, move _43);
        _41 = Mul(_3, move _42);
        _40 = Add(const _, move _41);
        _39 = Mul(_3, move _40);
        _38 = Add(const _, move _39);
        _37 = Mul(_3, move _38);
        _36 = Add(const _, move _37);
        _35 = Mul(_3, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_3, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_3, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_3, move _30);
        _5 = Add(const 1f32, move _29);
        goto -> bb6;
    }

    bb5: {
        _54 = Mul(_3, const _);
        _53 = Add(const _, move _54);
        _52 = Mul(_3, move _53);
        _51 = Add(const _, move _52);
        _50 = Mul(_3, move _51);
        _49 = Add(const _, move _50);
        _48 = Mul(_3, move _49);
        _47 = Add(const _, move _48);
        _46 = Mul(_3, move _47);
        _45 = Add(const _, move _46);
        _44 = Mul(_3, move _45);
        _4 = Add(const _, move _44);
        _67 = Mul(_3, const _);
        _66 = Add(const _, move _67);
        _65 = Mul(_3, move _66);
        _64 = Add(const _, move _65);
        _63 = Mul(_3, move _64);
        _62 = Add(const _, move _63);
        _61 = Mul(_3, move _62);
        _60 = Add(const _, move _61);
        _59 = Mul(_3, move _60);
        _58 = Add(const _, move _59);
        _57 = Mul(_3, move _58);
        _56 = Add(const _, move _57);
        _55 = Mul(_3, move _56);
        _5 = Add(const 1f32, move _55);
        goto -> bb6;
    }

    bb6: {
        _69 = _2;
        _68 = f32::<impl f32>::to_bits(move _69) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _1 = move _68;
        _72 = _1;
        _71 = BitAnd(move _72, const 4294959104_u32);
        _70 = f32::<impl f32>::from_bits(move _71) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _77 = Neg(_70);
        _76 = Mul(move _77, _70);
        _75 = Sub(move _76, const 0.5625f32);
        _74 = expf(move _75) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _82 = _2;
        _81 = Sub(_70, move _82);
        _84 = _2;
        _83 = Add(_70, move _84);
        _80 = Mul(move _81, move _83);
        _86 = _4;
        _87 = _5;
        _85 = Div(move _86, move _87);
        _79 = Add(move _80, move _85);
        _78 = expf(move _79) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _73 = Mul(move _74, move _78);
        _88 = _2;
        _0 = Div(move _73, move _88);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn erff(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: bool;
    let mut _45: u32;
    let mut _46: f32;
    let mut _47: u32;
    let mut _49: f32;
    scope 1 {
        debug r => _2;
        let _3: f32;
        scope 2 {
            debug s => _3;
            let _4: f32;
            scope 3 {
                debug z => _4;
                let _5: f32;
                scope 4 {
                    debug y => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug ix => _6;
                        let _7: usize;
                        scope 6 {
                            debug sign => _7;
                            let _48: f32;
                            scope 7 {
                                debug x1p_120 => _48;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _8;
        _10 = _6;
        _11 = const 31_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shr(move _10, const 31_i32);
        _7 = move _9 as usize (IntToInt);
        _6 = BitAnd(_6, const 2147483647_u32);
        _14 = _6;
        _13 = Ge(move _14, const 2139095040_u32);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _17 = _7 as f32 (IntToFloat);
        _16 = Mul(const 2f32, move _17);
        _15 = Sub(const 1f32, move _16);
        _18 = Div(const 1f32, _1);
        _0 = Add(move _15, move _18);
        goto -> bb16;
    }

    bb4: {
        _20 = _6;
        _19 = Lt(move _20, const 1062731776_u32);
        switchInt(move _19) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _22 = _6;
        _21 = Lt(move _22, const 830472192_u32);
        switchInt(move _21) -> [0: bb8, otherwise: bb7];
    }

    bb6: {
        _45 = _6;
        _44 = Lt(move _45, const 1086324736_u32);
        switchInt(move _44) -> [0: bb10, otherwise: bb9];
    }

    bb7: {
        _24 = Mul(const 8f32, _1);
        _25 = Mul(const _, _1);
        _23 = Add(move _24, move _25);
        _0 = Mul(const 0.125f32, move _23);
        goto -> bb16;
    }

    bb8: {
        _4 = Mul(_1, _1);
        _32 = Mul(_4, const _);
        _31 = Add(const _, move _32);
        _30 = Mul(_4, move _31);
        _29 = Add(const _, move _30);
        _28 = Mul(_4, move _29);
        _27 = Add(const _, move _28);
        _26 = Mul(_4, move _27);
        _2 = Add(const _, move _26);
        _41 = Mul(_4, const _);
        _40 = Add(const _, move _41);
        _39 = Mul(_4, move _40);
        _38 = Add(const _, move _39);
        _37 = Mul(_4, move _38);
        _36 = Add(const _, move _37);
        _35 = Mul(_4, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_4, move _34);
        _3 = Add(const 1f32, move _33);
        _5 = Div(_2, _3);
        _43 = _5;
        _42 = Mul(_1, move _43);
        _0 = Add(_1, move _42);
        goto -> bb16;
    }

    bb9: {
        _47 = _6;
        _46 = erff::erfc2(move _47, _1) -> [return: bb11, unwind unreachable];
    }

    bb10: {
        _48 = f32::<impl f32>::from_bits(const 58720256_u32) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _5 = Sub(const 1f32, move _46);
        goto -> bb13;
    }

    bb12: {
        _5 = Sub(const 1f32, _48);
        goto -> bb13;
    }

    bb13: {
        switchInt(move _7) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _49 = _5;
        _0 = Neg(move _49);
        goto -> bb16;
    }

    bb15: {
        _0 = _5;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn erfcf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: f32;
    let mut _48: u32;
    let mut _49: u32;
    scope 1 {
        debug r => _2;
        let _3: f32;
        scope 2 {
            debug s => _3;
            let _4: f32;
            scope 3 {
                debug z => _4;
                let _5: f32;
                scope 4 {
                    debug y => _5;
                    let mut _6: u32;
                    scope 5 {
                        debug ix => _6;
                        let _7: usize;
                        scope 6 {
                            debug sign => _7;
                            let _50: f32;
                            scope 7 {
                                debug x1p_120 => _50;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _8;
        _10 = _6;
        _11 = const 31_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 32_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shr(move _10, const 31_i32);
        _7 = move _9 as usize (IntToInt);
        _6 = BitAnd(_6, const 2147483647_u32);
        _14 = _6;
        _13 = Ge(move _14, const 2139095040_u32);
        switchInt(move _13) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _16 = _7 as f32 (IntToFloat);
        _15 = Mul(const 2f32, move _16);
        _17 = Div(const 1f32, _1);
        _0 = Add(move _15, move _17);
        goto -> bb20;
    }

    bb4: {
        _19 = _6;
        _18 = Lt(move _19, const 1062731776_u32);
        switchInt(move _18) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _21 = _6;
        _20 = Lt(move _21, const 595591168_u32);
        switchInt(move _20) -> [0: bb8, otherwise: bb7];
    }

    bb6: {
        _46 = _6;
        _45 = Lt(move _46, const 1105199104_u32);
        switchInt(move _45) -> [0: bb13, otherwise: bb12];
    }

    bb7: {
        _0 = Sub(const 1f32, _1);
        goto -> bb20;
    }

    bb8: {
        _4 = Mul(_1, _1);
        _28 = Mul(_4, const _);
        _27 = Add(const _, move _28);
        _26 = Mul(_4, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_4, move _25);
        _23 = Add(const _, move _24);
        _22 = Mul(_4, move _23);
        _2 = Add(const _, move _22);
        _37 = Mul(_4, const _);
        _36 = Add(const _, move _37);
        _35 = Mul(_4, move _36);
        _34 = Add(const _, move _35);
        _33 = Mul(_4, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_4, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_4, move _30);
        _3 = Add(const 1f32, move _29);
        _5 = Div(_2, _3);
        switchInt(move _7) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _39 = _6;
        _38 = Lt(move _39, const 1048576000_u32);
        switchInt(move _38) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _41 = Mul(_1, _5);
        _40 = Add(_1, move _41);
        _0 = Sub(const 1f32, move _40);
        goto -> bb20;
    }

    bb11: {
        _43 = Sub(_1, const 0.5f32);
        _44 = Mul(_1, _5);
        _42 = Add(move _43, move _44);
        _0 = Sub(const 0.5f32, move _42);
        goto -> bb20;
    }

    bb12: {
        switchInt(move _7) -> [0: bb16, otherwise: bb14];
    }

    bb13: {
        _50 = f32::<impl f32>::from_bits(const 58720256_u32) -> [return: bb17, unwind unreachable];
    }

    bb14: {
        _48 = _6;
        _47 = erff::erfc2(move _48, _1) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Sub(const 2f32, move _47);
        goto -> bb20;
    }

    bb16: {
        _49 = _6;
        _0 = erff::erfc2(move _49, _1) -> [return: bb20, unwind unreachable];
    }

    bb17: {
        switchInt(move _7) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _0 = Sub(const 2f32, _50);
        goto -> bb20;
    }

    bb19: {
        _0 = Mul(_50, _50);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

const exp::HALF: [f64; 2] = {
    let mut _0: [f64; 2];

    bb0: {
        _0 = [const 0.5f64, const -0.5f64];
        return;
    }
}

exp::HALF::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const LN2HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718036912382f64;
        return;
    }
}

const LN2LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9082149292705877E-10f64;
        return;
    }
}

const exp::INVLN2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4426950408889634f64;
        return;
    }
}

const exp::P1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.16666666666666602f64;
        return;
    }
}

const exp::P2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0027777777777015593f64;
        return;
    }
}

const exp::P3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.6137563214379344E-5f64;
        return;
    }
}

const exp::P4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.6533902205465252E-6f64;
        return;
    }
}

const exp::P5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.1381367970572385E-8f64;
        return;
    }
}

fn exp(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: f64;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: f64;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: bool;
    let mut _28: f64;
    let _29: f32;
    let mut _30: *const f32;
    let _31: &f32;
    let _32: f32;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: bool;
    let mut _37: f64;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: bool;
    let mut _41: u32;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: &f64;
    let mut _47: rustc_std_workspace_core::option::Option<&f64>;
    let mut _48: &[f64];
    let mut _49: usize;
    let mut _50: i32;
    let mut _51: (i32, bool);
    let mut _52: (i32, bool);
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: i32;
    let mut _57: f64;
    let mut _58: i32;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: bool;
    let mut _62: u32;
    let mut _63: f64;
    let _64: f64;
    let mut _65: *const f64;
    let _66: &f64;
    let _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: i32;
    let mut _91: i32;
    scope 1 {
        debug x1p1023 => _2;
        let _3: f64;
        scope 2 {
            debug x1p_149 => _3;
            let _4: f64;
            scope 3 {
                debug hi => _4;
                let _5: f64;
                scope 4 {
                    debug lo => _5;
                    let _6: f64;
                    scope 5 {
                        debug c => _6;
                        let _7: f64;
                        scope 6 {
                            debug xx => _7;
                            let _8: f64;
                            scope 7 {
                                debug y => _8;
                                let _9: i32;
                                scope 8 {
                                    debug k => _9;
                                    let _10: i32;
                                    scope 9 {
                                        debug sign => _10;
                                        let mut _11: u32;
                                        scope 10 {
                                            debug hx => _11;
                                            let mut _92: &[f64; 2];
                                            scope 11 {
                                            }
                                            scope 12 {
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f64::<impl f64>::from_bits(const 3936146074321813504_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _14 = _1;
        _13 = f64::<impl f64>::to_bits(move _14) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _15 = const 32_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 64_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _12 = Shr(move _13, const 32_i32);
        _11 = move _12 as u32 (IntToInt);
        _18 = _11;
        _19 = const 31_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 32_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _17 = Shr(move _18, const 31_i32);
        _10 = move _17 as i32 (IntToInt);
        _11 = BitAnd(_11, const 2147483647_u32);
        _22 = _11;
        _21 = Ge(move _22, const 1082532651_u32);
        switchInt(move _21) -> [0: bb15, otherwise: bb6];
    }

    bb6: {
        _24 = _1;
        _23 = f64::<impl f64>::is_nan(move _24) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _23) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = _1;
        goto -> bb31;
    }

    bb9: {
        _26 = _1;
        _25 = Gt(move _26, const 709.78271289338397f64);
        switchInt(move _25) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _1 = Mul(_1, _2);
        _0 = _1;
        goto -> bb31;
    }

    bb11: {
        _28 = _1;
        _27 = Lt(move _28, const -708.39641853226408f64);
        switchInt(move _27) -> [0: bb15, otherwise: bb12];
    }

    bb12: {
        _34 = Neg(_3);
        _35 = _1;
        _33 = Div(move _34, move _35);
        _32 = move _33 as f32 (FloatToFloat);
        _31 = &_32;
        _30 = &raw const (*_31);
        _29 = read_volatile::<f32>(move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _37 = _1;
        _36 = Lt(move _37, const -745.13321910194111f64);
        switchInt(move _36) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const 0f64;
        goto -> bb31;
    }

    bb15: {
        _39 = _11;
        _38 = Gt(move _39, const 1071001154_u32);
        switchInt(move _38) -> [0: bb24, otherwise: bb16];
    }

    bb16: {
        _41 = _11;
        _40 = Ge(move _41, const 1072734898_u32);
        switchInt(move _40) -> [0: bb20, otherwise: bb17];
    }

    bb17: {
        _44 = _1;
        _43 = Mul(const _, move _44);
        _92 = const _;
        _48 = _92 as &[f64] (PointerCoercion(Unsize));
        _49 = _10 as usize (IntToInt);
        _47 = slice::<impl [f64]>::get::<usize>(move _48, move _49) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _46 = Option::<&f64>::unwrap(move _47) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _45 = (*_46);
        _42 = Add(move _43, move _45);
        _9 = move _42 as i32 (FloatToInt);
        goto -> bb23;
    }

    bb20: {
        _51 = CheckedSub(const 1_i32, _10);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1_i32, _10) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _50 = move (_51.0: i32);
        _52 = CheckedSub(_50, _10);
        assert(!move (_52.1: bool), "attempt to compute `{} - {}`, which would overflow", move _50, _10) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _9 = move (_52.0: i32);
        goto -> bb23;
    }

    bb23: {
        _53 = _1;
        _56 = _9;
        _55 = move _56 as f64 (IntToFloat);
        _54 = Mul(move _55, const _);
        _4 = Sub(move _53, move _54);
        _58 = _9;
        _57 = move _58 as f64 (IntToFloat);
        _5 = Mul(move _57, const _);
        _59 = _4;
        _60 = _5;
        _1 = Sub(move _59, move _60);
        goto -> bb28;
    }

    bb24: {
        _62 = _11;
        _61 = Gt(move _62, const 1043333120_u32);
        switchInt(move _61) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _9 = const 0_i32;
        _63 = _1;
        _4 = move _63;
        _5 = const 0f64;
        goto -> bb28;
    }

    bb26: {
        _68 = _1;
        _67 = Add(_2, move _68);
        _66 = &_67;
        _65 = &raw const (*_66);
        _64 = read_volatile::<f64>(move _65) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _69 = _1;
        _0 = Add(const 1f64, move _69);
        goto -> bb31;
    }

    bb28: {
        _70 = _1;
        _71 = _1;
        _7 = Mul(move _70, move _71);
        _72 = _1;
        _81 = Mul(_7, const _);
        _80 = Add(const _, move _81);
        _79 = Mul(_7, move _80);
        _78 = Add(const _, move _79);
        _77 = Mul(_7, move _78);
        _76 = Add(const _, move _77);
        _75 = Mul(_7, move _76);
        _74 = Add(const _, move _75);
        _73 = Mul(_7, move _74);
        _6 = Sub(move _72, move _73);
        _86 = _1;
        _85 = Mul(move _86, _6);
        _87 = Sub(const 2f64, _6);
        _84 = Div(move _85, move _87);
        _88 = _5;
        _83 = Sub(move _84, move _88);
        _89 = _4;
        _82 = Add(move _83, move _89);
        _8 = Add(const 1f64, move _82);
        _90 = _9;
        switchInt(move _90) -> [0: bb29, otherwise: bb30];
    }

    bb29: {
        _0 = _8;
        goto -> bb31;
    }

    bb30: {
        _91 = _9;
        _0 = scalbn(_8, move _91) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        return;
    }
}

promoted[0] in exp: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const LN10: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.3219280948873622f64;
        return;
    }
}

const exp10::P10: &[f64] = {
    let mut _0: &[f64];
    let mut _1: &[f64; 31];
    let _2: &[f64; 31];
    let _3: [f64; 31];
    let mut _4: &[f64; 31];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[f64] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in exp10::P10: &[f64; 31] = {
    let mut _0: &[f64; 31];
    let mut _1: [f64; 31];

    bb0: {
        _1 = [const 1.0000000000000001E-15f64, const 9.9999999999999999E-15f64, const 1.0E-13f64, const 9.9999999999999998E-13f64, const 9.9999999999999993E-12f64, const 1.0E-10f64, const 1.0000000000000001E-9f64, const 1.0E-8f64, const 9.9999999999999995E-8f64, const 9.9999999999999995E-7f64, const 1.0000000000000001E-5f64, const 1.0E-4f64, const 0.001f64, const 0.01f64, const 0.10000000000000001f64, const 1f64, const 10f64, const 100f64, const 1000f64, const 1.0E+4f64, const 1.0E+5f64, const 1.0E+6f64, const 1.0E+7f64, const 1.0E+8f64, const 1.0E+9f64, const 1.0E+10f64, const 1.0E+11f64, const 1.0E+12f64, const 1.0E+13f64, const 1.0E+14f64, const 1.0E+15f64];
        _0 = &_1;
        return;
    }
}

fn exp10(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let _3: f64;
    let mut _4: (f64, f64);
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u64;
    let mut _12: (u64, bool);
    let mut _13: bool;
    let mut _14: f64;
    let mut _15: &f64;
    let mut _16: rustc_std_workspace_core::option::Option<&f64>;
    let _17: &[f64];
    let mut _18: usize;
    let mut _19: isize;
    let mut _20: isize;
    let mut _21: (isize, bool);
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: &f64;
    let mut _28: rustc_std_workspace_core::option::Option<&f64>;
    let _29: &[f64];
    let mut _30: usize;
    let mut _31: isize;
    let mut _32: isize;
    let mut _33: (isize, bool);
    scope 1 {
        debug y => _2;
        debug n => _3;
        let _5: u64;
        scope 2 {
            debug u => _5;
        }
    }

    bb0: {
        _4 = modf(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_4.0: f64);
        _3 = (_4.1: f64);
        _5 = f64::<impl f64>::to_bits(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = const 52_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shr(_5, const 52_i32);
        _7 = BitAnd(move _8, const 2047_u64);
        _12 = CheckedAdd(const 1023_u64, const 4_u64);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_u64, const 4_u64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _11 = move (_12.0: u64);
        _6 = Lt(move _7, move _11);
        switchInt(move _6) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _14 = _2;
        _13 = Eq(move _14, const 0f64);
        switchInt(move _13) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _17 = const _;
        _20 = _3 as isize (FloatToInt);
        _21 = CheckedAdd(_20, const 15_isize);
        assert(!move (_21.1: bool), "attempt to compute `{} + {}`, which would overflow", move _20, const 15_isize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _19 = move (_21.0: isize);
        _18 = move _19 as usize (IntToInt);
        _16 = slice::<impl [f64]>::get::<usize>(_17, move _18) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Option::<&f64>::unwrap(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = (*_15);
        goto -> bb16;
    }

    bb10: {
        _24 = _2;
        _23 = Mul(const _, move _24);
        _22 = exp2(move _23) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _2 = move _22;
        _25 = _2;
        _29 = const _;
        _32 = _3 as isize (FloatToInt);
        _33 = CheckedAdd(_32, const 15_isize);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _32, const 15_isize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _31 = move (_33.0: isize);
        _30 = move _31 as usize (IntToInt);
        _28 = slice::<impl [f64]>::get::<usize>(_29, move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _27 = Option::<&f64>::unwrap(move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _26 = (*_27);
        _0 = Mul(move _25, move _26);
        goto -> bb16;
    }

    bb15: {
        _0 = libm::pow::pow(const 10f64, _1) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        return;
    }
}

const LN10_F32: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.32192802f32;
        return;
    }
}

const LN10_F64: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.3219280948873622f64;
        return;
    }
}

const exp10f::P10: &[f32] = {
    let mut _0: &[f32];
    let mut _1: &[f32; 15];
    let _2: &[f32; 15];
    let _3: [f32; 15];
    let mut _4: &[f32; 15];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[f32] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in exp10f::P10: &[f32; 15] = {
    let mut _0: &[f32; 15];
    let mut _1: [f32; 15];

    bb0: {
        _1 = [const 1.00000001E-7f32, const 9.99999997E-7f32, const 9.99999974E-6f32, const 9.99999974E-5f32, const 0.00100000005f32, const 0.00999999977f32, const 0.100000001f32, const 1f32, const 10f32, const 100f32, const 1000f32, const 1.0E+4f32, const 1.0E+5f32, const 1.0E+6f32, const 1.0E+7f32];
        _0 = &_1;
        return;
    }
}

fn exp10f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f32;
    let _3: f32;
    let mut _4: (f32, f32);
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: (u32, bool);
    let mut _13: bool;
    let mut _14: f32;
    let mut _15: &f32;
    let mut _16: rustc_std_workspace_core::option::Option<&f32>;
    let _17: &[f32];
    let mut _18: usize;
    let mut _19: isize;
    let mut _20: isize;
    let mut _21: (isize, bool);
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: &f32;
    let mut _28: rustc_std_workspace_core::option::Option<&f32>;
    let _29: &[f32];
    let mut _30: usize;
    let mut _31: isize;
    let mut _32: isize;
    let mut _33: (isize, bool);
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    scope 1 {
        debug y => _2;
        debug n => _3;
        let _5: u32;
        scope 2 {
            debug u => _5;
        }
    }

    bb0: {
        _4 = modff(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = (_4.0: f32);
        _3 = (_4.1: f32);
        _5 = f32::<impl f32>::to_bits(_3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = const 23_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shr(_5, const 23_i32);
        _7 = BitAnd(move _8, const 255_u32);
        _12 = CheckedAdd(const 127_u32, const 3_u32);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_u32, const 3_u32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _11 = move (_12.0: u32);
        _6 = Lt(move _7, move _11);
        switchInt(move _6) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _14 = _2;
        _13 = Eq(move _14, const 0f32);
        switchInt(move _13) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _17 = const _;
        _20 = _3 as isize (FloatToInt);
        _21 = CheckedAdd(_20, const 7_isize);
        assert(!move (_21.1: bool), "attempt to compute `{} + {}`, which would overflow", move _20, const 7_isize) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _19 = move (_21.0: isize);
        _18 = move _19 as usize (IntToInt);
        _16 = slice::<impl [f32]>::get::<usize>(_17, move _18) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _15 = Option::<&f32>::unwrap(move _16) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = (*_15);
        goto -> bb17;
    }

    bb10: {
        _24 = _2;
        _23 = Mul(const _, move _24);
        _22 = exp2f(move _23) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _2 = move _22;
        _25 = _2;
        _29 = const _;
        _32 = _3 as isize (FloatToInt);
        _33 = CheckedAdd(_32, const 7_isize);
        assert(!move (_33.1: bool), "attempt to compute `{} + {}`, which would overflow", move _32, const 7_isize) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _31 = move (_33.0: isize);
        _30 = move _31 as usize (IntToInt);
        _28 = slice::<impl [f32]>::get::<usize>(_29, move _30) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _27 = Option::<&f32>::unwrap(move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _26 = (*_27);
        _0 = Mul(move _25, move _26);
        goto -> bb17;
    }

    bb15: {
        _36 = _1 as f64 (FloatToFloat);
        _35 = Mul(const _, move _36);
        _34 = exp2(move _35) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = move _34 as f32 (FloatToFloat);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

const exp2::TBLSIZE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 256_usize;
        return;
    }
}

static TBL: [u64; 512] = {
    let mut _0: [u64; 512];

    bb0: {
        _0 = [const 4604544271217802589_u64, const 4411706843567489024_u64, const 4604561539468695364_u64, const 4384254237245177856_u64, const 4604578854538566142_u64, const 13630276213632139264_u64, const 4604596216554354367_u64, const 4404168591847456768_u64, const 4604613625643342377_u64, const 13607626274099953664_u64, const 4604631081933159139_u64, const 13599744974752055296_u64, const 4604648585551778694_u64, const 13632352091585380352_u64, const 4604666136627522979_u64, const 13631419705725026304_u64, const 4604683735289061315_u64, const 4401072367103639552_u64, const 4604701381665410821_u64, const 13634700648422309888_u64, const 4604719075885941074_u64, const 13619096379400912896_u64, const 4604736818080369916_u64, const 4408892093800382464_u64, const 4604754608378767345_u64, const 4396603951848357888_u64, const 4604772446911556936_u64, const 13630091495678672896_u64, const 4604790333809515832_u64, const 13609033648983506944_u64, const 4604808269203774720_u64, const 4387350461988995072_u64, const 4604826253225820536_u64, const 13613537248610877440_u64, const 4604844286007496800_u64, const 4404590804312522752_u64, const 4604862367681003827_u64, const 4368491638549381120_u64, const 4604880498378901046_u64, const 13629739651957784576_u64, const 4604898678234107451_u64, const 13619694513726423040_u64, const 4604916907379901416_u64, const 13629115129353207808_u64, const 4604935185949924174_u64, const 4409868460125847552_u64, const 4604953514078177050_u64, const 4399735360964263936_u64, const 4604971891899026814_u64, const 13628385053632364544_u64, const 4604990319547204304_u64, const 4407282408777318400_u64, const 4605008797157804725_u64, const 4415515551846105088_u64, const 4605027324866288572_u64, const 4405188938638032896_u64, const 4605045902808486319_u64, const 13633174526282956800_u64, const 4605064531120595861_u64, const 13628736897353252864_u64, const 4605083209939183032_u64, const 13630847959678582784_u64, const 4605101939401185280_u64, const 13613537248610877440_u64, const 4605120719643910691_u64, const 4409912440590958592_u64, const 4605139550805039610_u64, const 4414288496869507072_u64, const 4605158433022624643_u64, const 13632061820515647488_u64, const 4605177366435096140_u64, const 13627980433353342976_u64, const 4605196351181256711_u64, const 4406816215847141376_u64, const 4605215387400285198_u64, const 13626960086562766848_u64, const 4605234475231739798_u64, const 13620538938656555008_u64, const 4605253614815555577_u64, const 4392487380313964544_u64, const 4605272806292047434_u64, const 4402022345150038016_u64, const 4605292049801910446_u64, const 13621418547958775808_u64, const 4605311345486222027_u64, const 4406042159661187072_u64, const 4605330693486440225_u64, const 13634313620329332736_u64, const 4605350093944409642_u64, const 13619166748145090560_u64, const 4605369547002356643_u64, const 4408179610265583616_u64, const 4605389052802893316_u64, const 13634828191771131904_u64, const 4605408611489021833_u64, const 4410532565149024256_u64, const 4605428223204127067_u64, const 4406411595568119808_u64, const 4605447888091986117_u64, const 13613255773634166784_u64, const 4605467606296765326_u64, const 4402215859196526592_u64, const 4605487377963021058_u64, const 4401776054545416192_u64, const 4605507203235702093_u64, const 13615789048424562688_u64, const 4605527082260150518_u64, const 4398292801708621824_u64, const 4605547015182102055_u64, const 4407572679847051264_u64, const 4605567002147687005_u64, const 13626467505353523200_u64, const 4605587043303433627_u64, const 4398715014173687808_u64, const 4605607138796266003_u64, const 4411425368590778368_u64, const 4605627288773505959_u64, const 4400333495289774080_u64, const 4605647493382876813_u64, const 4397413192406401024_u64, const 4605667752772500690_u64, const 13630628057353027584_u64, const 4605688067090902968_u64, const 4407739805614473216_u64, const 4605708436487009153_u64, const 4384535712221888512_u64, const 4605728861110151040_u64, const 4387631936965705728_u64, const 4605749341110063779_u64, const 13631428501818048512_u64, const 4605769876636889959_u64, const 4401793646731460608_u64, const 4605790467841177488_u64, const 4408975656684093440_u64, const 4605811114873883049_u64, const 4400702931196706816_u64, const 4605831817886374475_u64, const 4417264874845896704_u64, const 4605852577030424551_u64, const 13634709444515332096_u64, const 4605873392458225978_u64, const 4366239838735695872_u64, const 4605894264322377066_u64, const 4398556684499288064_u64, const 4605915192775892560_u64, const 4386083824593797120_u64, const 4605936177972201906_u64, const 13620222279307755520_u64, const 4605957220065150467_u64, const 13622667593167929344_u64, const 4605978319209000806_u64, const 4399330740685242368_u64, const 4605999475558433279_u64, const 4396252108127469568_u64, const 4606020689268547951_u64, const 13627742938841743360_u64, const 4606041960494865848_u64, const 13623564794656194560_u64, const 4606063289393328873_u64, const 13623740716516638720_u64, const 4606084676120302304_u64, const 4398855751662043136_u64, const 4606106120832574702_u64, const 13621488916702953472_u64, const 4606127623687360559_u64, const 13623054621260906496_u64, const 4606149184842300693_u64, const 4411669460172144640_u64, const 4606170804455461067_u64, const 13626221214748901376_u64, const 4606192482685338038_u64, const 13643731487177048064_u64, const 4606214219690862387_u64, const 13626282787400056832_u64, const 4606236015631385823_u64, const 4380595062547939328_u64, const 4606257870666698900_u64, const 4395865080034492416_u64, const 4606279784957023881_u64, const 4391044821058322432_u64, const 4606301758663017490_u64, const 4391959614732632064_u64, const 4606323791945771835_u64, const 13620732452703043584_u64, const 4606345884966816188_u64, const 4398222432964444160_u64, const 4606368037888116986_u64, const 13625042538283925504_u64, const 4606390250872081029_u64, const 4403719991103324160_u64, const 4606412524081553923_u64, const 4395970633150758912_u64, const 4606434857679824017_u64, const 4386224562082152448_u64, const 4606457251830621857_u64, const 13619905619958956032_u64, const 4606479706698122062_u64, const 13622500467400507392_u64, const 4606502222446944400_u64, const 4392346642825609216_u64, const 4606524799242154670_u64, const 4395390091011293184_u64, const 4606547437249266469_u64, const 4389180049337614336_u64, const 4606570136634242117_u64, const 13615824232796651520_u64, const 4606592897563493823_u64, const 13627171192795299840_u64, const 4606615720203885292_u64, const 13625099712888569856_u64, const 4606638604722732382_u64, const 4398688625894621184_u64, const 4606661551287804903_u64, const 4413754134218407936_u64, const 4606684560067325532_u64, const 4399005285243420672_u64, const 4606707631229976500_u64, const 13621471324516909056_u64, const 4606730764944895336_u64, const 13611285448797192192_u64, const 4606753961381678148_u64, const 13621128276889042944_u64, const 4606777220710381350_u64, const 13615349243773452288_u64, const 4606800543101522152_u64, const 4388142110360993792_u64, const 4606823928726080228_u64, const 4401734273103560704_u64, const 4606847377755498509_u64, const 4392504972500008960_u64, const 4606870890361685268_u64, const 4379258056408563712_u64, const 4606894466717014547_u64, const 13613959461075943424_u64, const 4606918106994327814_u64, const 13617345956889493504_u64, const 4606941811366934883_u64, const 13631428501818048512_u64, const 4606965580008616565_u64, const 4371306388316487680_u64, const 4606989413093623076_u64, const 13615771456238518272_u64, const 4607013310796678397_u64, const 4380454325059584000_u64, const 4607037273292979768_u64, const 4394031094639362048_u64, const 4607061300758199426_u64, const 13606605927309377536_u64, const 4607085393368486030_u64, const 13621994692051730432_u64, const 4607109551300465937_u64, const 13601117165263519744_u64, const 4607133774731243924_u64, const 13623633514132930560_u64, const 4607158063838405614_u64, const 4390520354011873280_u64, const 4607182418800017408_u64, const 0_u64, const 4607194629297323198_u64, const 13597282068705837056_u64, const 4607206872900645635_u64, const 13623977111516610560_u64, const 4607219149699744386_u64, const 4375880356688035840_u64, const 4607231459784622188_u64, const 4390895287476944896_u64, const 4607243803245525962_u64, const 13602911568240050176_u64, const 4607256180172947337_u64, const 4384307013803311104_u64, const 4607268590657623143_u64, const 13626272891795406848_u64, const 4607281034790536538_u64, const 13619593358656667648_u64, const 4607293512662917013_u64, const 4391396664779210752_u64, const 4607306024366241562_u64, const 4401463793243127808_u64, const 4607318569992235053_u64, const 13612587270564478976_u64, const 4607331149632871376_u64, const 4388265255663304704_u64, const 4607343763380373448_u64, const 13619017214563713024_u64, const 4607356411327214467_u64, const 13589611875590471680_u64, const 4607369093566118192_u64, const 4395407683197337600_u64, const 4607381810190059772_u64, const 13617416325633671168_u64, const 4607394561292266634_u64, const 4384746818454421504_u64, const 4607407346966218774_u64, const 4396955795569246208_u64, const 4607420167305649624_u64, const 13617425121726693376_u64, const 4607433022404547059_u64, const 4403302176684769280_u64, const 4607445912357153190_u64, const 13620266259772866560_u64, const 4607458837257966320_u64, const 13622597224423751680_u64, const 4607471797201740619_u64, const 4391379072593166336_u64, const 4607484792283487067_u64, const 4389883736779390976_u64, const 4607497822598474489_u64, const 4401912393987260416_u64, const 4607510888242229717_u64, const 4388828205616726016_u64, const 4607523989310538877_u64, const 13623054621260906496_u64, const 4607537125899447785_u64, const 4389004127477170176_u64, const 4607550298105262392_u64, const 4389672630546857984_u64, const 4607563506024550001_u64, const 4396973387755290624_u64, const 4607576749754139615_u64, const 4396419233894891520_u64, const 4607590029391122961_u64, const 4407005331847118848_u64, const 4607603345032854431_u64, const 13620521346470510592_u64, const 4607616696776953235_u64, const 13626916106097655808_u64, const 4607630084721302886_u64, const 4400562193708351488_u64, const 4607643508964051879_u64, const 4400096000778174464_u64, const 4607656969603614691_u64, const 13638932668677619712_u64, const 4607670466738675028_u64, const 4405897024126320640_u64, const 4607684000468180035_u64, const 13621735207307575296_u64, const 4607697570891348402_u64, const 4387491199477350400_u64, const 4607711178107666481_u64, const 4389531893058502656_u64, const 4607724822216890680_u64, const 4395953040964714496_u64, const 4607738503319047671_u64, const 13626617038934900736_u64, const 4607752221514435983_u64, const 4408342337986494464_u64, const 4607765976903624734_u64, const 4384254237245177856_u64, const 4607779769587457345_u64, const 4407673834916806656_u64, const 4607793599667049251_u64, const 4402822789615058944_u64, const 4607807467243790823_u64, const 13626142049911701504_u64, const 4607821372419347495_u64, const 4396128962825158656_u64, const 4607835315295659522_u64, const 13624312462563082240_u64, const 4607849295974944432_u64, const 4400702931196706816_u64, const 4607863314559696150_u64, const 4400527009336262656_u64, const 4607877371152687119_u64, const 4409567193939836928_u64, const 4607891465856967486_u64, const 13624725878935126016_u64, const 4607905598775868208_u64, const 13624470792237481984_u64, const 4607919770012999433_u64, const 4397958550173777920_u64, const 4607933979672252059_u64, const 13628591761818386432_u64, const 4607948227857799738_u64, const 4407392359940096000_u64, const 4607962514674096889_u64, const 13623529610284105728_u64, const 4607976840225882841_u64, const 13623054621260906496_u64, const 4607991204618179961_u64, const 13615542757819940864_u64, const 4608005607956295375_u64, const 13629185498097385472_u64, const 4608020050345822242_u64, const 13625130499214147584_u64, const 4608034531892639269_u64, const 13633018395631812608_u64, const 4608049052702909707_u64, const 13650656211408781312_u64, const 4608063612883097528_u64, const 13628534587213742080_u64, const 4608078212539935138_u64, const 13629466973074096128_u64, const 4608092851780458342_u64, const 4404186184033501184_u64, const 4608107530711988775_u64, const 13608752174006796288_u64, const 4608122249442139919_u64, const 13632633566562091008_u64, const 4608137008078817465_u64, const 4405303287847321600_u64, const 4608151806730218041_u64, const 4404625988684611584_u64, const 4608166645504832766_u64, const 13625183275772280832_u64, const 4608181524511447096_u64, const 13621946313540108288_u64, const 4608196443859140291_u64, const 13638150915910270976_u64, const 4608211403657289760_u64, const 4397800220499378176_u64, const 4608226404015566485_u64, const 4413105422358020096_u64, const 4608241445043939570_u64, const 4390868899197878272_u64, const 4608256526852677922_u64, const 13625535119493169152_u64, const 4608271649552348347_u64, const 4406262061986742272_u64, const 4608286813253816012_u64, const 13639333990421757952_u64, const 4608302018068250252_u64, const 13636015664329129984_u64, const 4608317264107118779_u64, const 4406130120591409152_u64, const 4608332551482191509_u64, const 4404168591847456768_u64, const 4608347880305542726_u64, const 13624338850842148864_u64, const 4608363250689550624_u64, const 4405531986265899008_u64, const 4608378662746896875_u64, const 4393824386453340160_u64, const 4608394116590569753_u64, const 13616281629633806336_u64, const 4608409612333863425_u64, const 13622192604144730112_u64, const 4608425150090379286_u64, const 13624092560237527040_u64, const 4608440729974027046_u64, const 4409270325800337408_u64, const 4608456352099023872_u64, const 13631622015864537088_u64, const 4608472016579899140_u64, const 4398926120406220800_u64, const 4608487723531490162_u64, const 13627417483399921664_u64, const 4608503473068947457_u64, const 4397624298638934016_u64, const 4608519265307732449_u64, const 13624374035214237696_u64, const 4608535100363620658_u64, const 4395653973801959424_u64, const 4608550978352700891_u64, const 4408021280591183872_u64, const 4608566899391376278_u64, const 13627012863120900096_u64, const 4608582863596367106_u64, const 4402585295103459328_u64, const 4608598871084708289_u64, const 13621348179214598144_u64, const 4608614921973753386_u64, const 13617196423308115968_u64, const 4608631016381174250_u64, const 4416351180683214848_u64, const 4608647154424958682_u64, const 13629818816794984448_u64, const 4608663336223419418_u64, const 13633033788794601472_u64, const 4608679561895187675_u64, const 4415845405334437888_u64, const 4608695831559213419_u64, const 4405839849521676288_u64, const 4608712145334774238_u64, const 4413908065846296576_u64, const 4608728503341466638_u64, const 13630672037818138624_u64, const 4608744905699215215_u64, const 13628745693446275072_u64, const 4608761352528268108_u64, const 4417446294264479744_u64, const 4608777843949196327_u64, const 13601996774565740544_u64, const 4608794380082903796_u64, const 4409032831288737792_u64, const 4608810961050617355_u64, const 13629801224608940032_u64, const 4608827586973896255_u64, const 4415385809474027520_u64, const 4608844257974624481_u64, const 13626555466283745280_u64, const 4608860974175022026_u64, const 4402110306080260096_u64, const 4608877735697636536_u64, const 4406481964312297472_u64, const 4608894542665348885_u64, const 4395794711290314752_u64, const 4608911395201373489_u64, const 13625024946097881088_u64, const 4608928293429258677_u64, const 13624180521167749120_u64, const 4608945237472887571_u64, const 13612833561169100800_u64, const 4608962227456478970_u64, const 13630249825353072640_u64, const 4608979263504593815_u64, const 4427599184635363328_u64, const 4608996345742111374_u64, const 13634401581259554816_u64, const 4609013474294278526_u64, const 4388335624407482368_u64, const 4609030649286661233_u64, const 13630557688608849920_u64];
        return;
    }
}

TBL::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedMul(const _, const 2_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 2_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

fn exp2(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _3: f64;
    let mut _4: f64;
    let mut _14: f64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: u64;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: f64;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: f64;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let _36: f32;
    let mut _37: *const f32;
    let _38: &f32;
    let _39: f32;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: bool;
    let mut _43: f64;
    let mut _44: bool;
    let mut _45: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: u32;
    let mut _53: u32;
    let mut _54: bool;
    let mut _56: u32;
    let mut _57: u32;
    let mut _58: u32;
    let mut _59: bool;
    let mut _60: u32;
    let mut _61: (u32, bool);
    let mut _63: i32;
    let mut _64: i32;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: u32;
    let mut _70: bool;
    let mut _72: f64;
    let mut _74: f64;
    let mut _76: u64;
    let mut _77: &u64;
    let mut _78: rustc_std_workspace_core::option::Option<&u64>;
    let mut _79: &[u64];
    let _80: &[u64; 512];
    let mut _81: usize;
    let mut _82: usize;
    let mut _83: u32;
    let mut _84: (usize, bool);
    let mut _85: f64;
    let mut _86: u64;
    let mut _87: &u64;
    let mut _88: rustc_std_workspace_core::option::Option<&u64>;
    let mut _89: &[u64];
    let _90: &[u64; 512];
    let mut _91: usize;
    let mut _92: usize;
    let mut _93: usize;
    let mut _94: u32;
    let mut _95: (usize, bool);
    let mut _96: (usize, bool);
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: f64;
    let mut _102: f64;
    let mut _103: f64;
    let mut _104: f64;
    let mut _105: f64;
    let mut _106: f64;
    let mut _107: f64;
    let mut _108: f64;
    let mut _109: f64;
    let mut _110: f64;
    let mut _111: f64;
    let mut _112: f64;
    scope 1 {
        debug redux => _2;
        let _5: f64;
        scope 2 {
            debug p1 => _5;
            let _6: f64;
            scope 3 {
                debug p2 => _6;
                let _7: f64;
                scope 4 {
                    debug p3 => _7;
                    let _8: f64;
                    scope 5 {
                        debug p4 => _8;
                        let _9: f64;
                        scope 6 {
                            debug p5 => _9;
                            let _10: f64;
                            scope 7 {
                                debug x1p1023 => _10;
                                let _11: f64;
                                scope 8 {
                                    debug x1p52 => _11;
                                    let _12: f64;
                                    scope 9 {
                                        debug _0x1p_149 => _12;
                                        let _13: u64;
                                        scope 10 {
                                            debug ui => _13;
                                            let _15: u64;
                                            scope 11 {
                                                debug ix => _15;
                                                let _46: u64;
                                                scope 12 {
                                                }
                                                scope 13 {
                                                    debug ui => _46;
                                                    let mut _49: u32;
                                                    scope 14 {
                                                        debug i0 => _49;
                                                        let _55: u32;
                                                        scope 15 {
                                                            debug ku => _55;
                                                            let _62: i32;
                                                            scope 16 {
                                                                debug ki => _62;
                                                                let _71: f64;
                                                                scope 17 {
                                                                    debug uf => _71;
                                                                    let mut _73: f64;
                                                                    scope 18 {
                                                                        debug z => _73;
                                                                        let _75: f64;
                                                                        scope 19 {
                                                                            debug t => _75;
                                                                            let _97: f64;
                                                                            scope 20 {
                                                                                debug r => _97;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::from_bits(const 4843621399236968448_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const _ as f64 (IntToFloat);
        _2 = Div(move _3, move _4);
        _5 = f64::<impl f64>::from_bits(const 4604418534313441775_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = f64::<impl f64>::from_bits(const 4597823092348339573_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = f64::<impl f64>::from_bits(const 4588159806095007910_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = f64::<impl f64>::from_bits(const 4576698096145597440_u64) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = f64::<impl f64>::from_bits(const 4563791841736481908_u64) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _10 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = f64::<impl f64>::from_bits(const 4841369599423283200_u64) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _12 = f64::<impl f64>::from_bits(const 13159518111176589312_u64) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _14 = _1;
        _13 = f64::<impl f64>::to_bits(move _14) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _17 = const 32_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _16 = Shr(_13, const 32_i32);
        _15 = BitAnd(move _16, const 2147483647_u64);
        _19 = Ge(_15, const 1083174912_u64);
        switchInt(move _19) -> [0: bb25, otherwise: bb12];
    }

    bb12: {
        _20 = Ge(_15, const 1083179008_u64);
        switchInt(move _20) -> [0: bb16, otherwise: bb13];
    }

    bb13: {
        _22 = const 63_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 64_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _21 = Shr(_13, const 63_i32);
        switchInt(move _21) -> [0: bb15, otherwise: bb16];
    }

    bb15: {
        _1 = Mul(_1, _10);
        _0 = _1;
        goto -> bb46;
    }

    bb16: {
        _24 = Ge(_15, const 2146435072_u64);
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _25 = _1;
        _0 = Div(const -1f64, move _25);
        goto -> bb46;
    }

    bb18: {
        _27 = const 63_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _26 = Shr(_13, const 63_i32);
        switchInt(move _26) -> [0: bb27, otherwise: bb20];
    }

    bb20: {
        _30 = _1;
        _29 = Le(move _30, const -1075f64);
        switchInt(move _29) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _34 = _1;
        _33 = Sub(move _34, _11);
        _32 = Add(move _33, _11);
        _35 = _1;
        _31 = Ne(move _32, move _35);
        switchInt(move _31) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _41 = _1;
        _40 = Div(_12, move _41);
        _39 = move _40 as f32 (FloatToFloat);
        _38 = &_39;
        _37 = &raw const (*_38);
        _36 = read_volatile::<f32>(move _37) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _43 = _1;
        _42 = Le(move _43, const -1075f64);
        switchInt(move _42) -> [0: bb27, otherwise: bb24];
    }

    bb24: {
        _0 = const 0f64;
        goto -> bb46;
    }

    bb25: {
        _44 = Lt(_15, const 1016070144_u64);
        switchInt(move _44) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _45 = _1;
        _0 = Add(const 1f64, move _45);
        goto -> bb46;
    }

    bb27: {
        _48 = _1;
        _47 = Add(move _48, _2);
        _46 = f64::<impl f64>::to_bits(move _47) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _49 = _46 as u32 (IntToInt);
        _51 = _49;
        _53 = const _ as u32 (IntToInt);
        _54 = Eq(const 2_u32, const 0_u32);
        assert(!move _54, "attempt to divide `{}` by zero", _53) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _52 = Div(move _53, const 2_u32);
        _50 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _51, move _52) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _49 = move _50;
        _57 = _49;
        _58 = const _ as u32 (IntToInt);
        _59 = Eq(_58, const 0_u32);
        assert(!move _59, "attempt to divide `{}` by zero", _57) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _56 = Div(move _57, move _58);
        _60 = const _ as u32 (IntToInt);
        _61 = CheckedMul(_56, _60);
        assert(!move (_61.1: bool), "attempt to compute `{} * {}`, which would overflow", move _56, move _60) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _55 = move (_61.0: u32);
        _63 = _55 as i32 (IntToInt);
        _64 = const _ as i32 (IntToInt);
        _65 = Eq(_64, const 0_i32);
        assert(!move _65, "attempt to divide `{}` by zero", _63) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _66 = Eq(_64, const -1_i32);
        _67 = Eq(_63, const i32::MIN);
        _68 = BitAnd(move _66, move _67);
        assert(!move _68, "attempt to compute `{} / {}`, which would overflow", _63, _64) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _62 = Div(move _63, move _64);
        _69 = const _ as u32 (IntToInt);
        _70 = Eq(_69, const 0_u32);
        assert(!move _70, "attempt to calculate the remainder of `{}` with a divisor of zero", _49) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _49 = Rem(_49, move _69);
        _72 = f64::<impl f64>::from_bits(_46) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _71 = Sub(move _72, _2);
        _74 = _1;
        _73 = Sub(move _74, _71);
        _80 = const {alloc8: &[u64; 512]};
        _79 = _80 as &[u64] (PointerCoercion(Unsize));
        _83 = _49;
        _82 = move _83 as usize (IntToInt);
        _84 = CheckedMul(const 2_usize, _82);
        assert(!move (_84.1: bool), "attempt to compute `{} * {}`, which would overflow", const 2_usize, move _82) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _81 = move (_84.0: usize);
        _78 = slice::<impl [u64]>::get::<usize>(move _79, move _81) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _77 = Option::<&u64>::unwrap(move _78) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _76 = (*_77);
        _75 = f64::<impl f64>::from_bits(move _76) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _90 = const {alloc8: &[u64; 512]};
        _89 = _90 as &[u64] (PointerCoercion(Unsize));
        _94 = _49;
        _93 = move _94 as usize (IntToInt);
        _95 = CheckedMul(const 2_usize, _93);
        assert(!move (_95.1: bool), "attempt to compute `{} * {}`, which would overflow", const 2_usize, move _93) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _92 = move (_95.0: usize);
        _96 = CheckedAdd(_92, const 1_usize);
        assert(!move (_96.1: bool), "attempt to compute `{} + {}`, which would overflow", move _92, const 1_usize) -> [success: bb42, unwind unreachable];
    }

    bb42: {
        _91 = move (_96.0: usize);
        _88 = slice::<impl [u64]>::get::<usize>(move _89, move _91) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _87 = Option::<&u64>::unwrap(move _88) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _86 = (*_87);
        _85 = f64::<impl f64>::from_bits(move _86) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _73 = Sub(_73, move _85);
        _100 = _73;
        _99 = Mul(_75, move _100);
        _103 = _73;
        _106 = _73;
        _109 = _73;
        _112 = _73;
        _111 = Mul(move _112, _9);
        _110 = Add(_8, move _111);
        _108 = Mul(move _109, move _110);
        _107 = Add(_7, move _108);
        _105 = Mul(move _106, move _107);
        _104 = Add(_6, move _105);
        _102 = Mul(move _103, move _104);
        _101 = Add(_5, move _102);
        _98 = Mul(move _99, move _101);
        _97 = Add(_75, move _98);
        _0 = scalbn(_97, _62) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        return;
    }
}

alloc8 (static: TBL, size: 4096, align: 8) {
    0x0000  5d 3d 7f 66 9e a0 e6 3f 00 00 00 00 00 88 39 3d  ]=.f...?......9=
    0x0010  44 17 75 fa 52 b0 e6 3f 00 00 00 00 00 00 d8 3c  D.u.R..?.......<
    0x0020  fe d9 0b 75 12 c0 e6 3f 00 00 00 00 00 78 28 bd  ...u...?.....x(.
    0x0030  bf 76 d4 dd dc cf e6 3f 00 00 00 00 00 c0 1e 3d  .v.....?.......=
    0x0040  29 1a 65 3c b2 df e6 3f 00 00 00 00 00 00 d8 bc  ).e<...?........
    0x0050  e3 3a 59 98 92 ef e6 3f 00 00 00 00 00 00 bc bc  .:Y....?........
    0x0060  86 93 51 f9 7d ff e6 3f 00 00 00 00 00 d8 2f bd  ..Q.}..?....../.
    0x0070  a3 2d f4 66 74 0f e7 3f 00 00 00 00 00 88 2c bd  .-.ft..?......,.
    0x0080  c3 5f ec e8 75 1f e7 3f 00 00 00 00 00 c0 13 3d  ._..u..?.......=
    0x0090  05 cf ea 86 82 2f e7 3f 00 00 00 00 00 30 38 bd  ...../.?.....08.
    0x00a0  52 81 a5 48 9a 3f e7 3f 00 00 00 00 00 c0 00 bd  R..H.?.?........
    0x00b0  fc cc d7 35 bd 4f e7 3f 00 00 00 00 00 88 2f 3d  ...5.O.?....../=
    0x00c0  f1 67 42 56 eb 5f e7 3f 00 00 00 00 00 e0 03 3d  .gBV._.?.......=
    0x00d0  48 6d ab b1 24 70 e7 3f 00 00 00 00 00 d0 27 bd  Hm..$p.?......'.
    0x00e0  38 5d de 4f 69 80 e7 3f 00 00 00 00 00 00 dd bc  8].Oi..?........
    0x00f0  00 1d ac 38 b9 90 e7 3f 00 00 00 00 00 00 e3 3c  ...8...?.......<
    0x0100  78 01 eb 73 14 a1 e7 3f 00 00 00 00 00 00 ed bc  x..s...?........
    0x0110  60 d0 76 09 7b b1 e7 3f 00 00 00 00 00 40 20 3d  `.v.{..?.....@ =
    0x0120  33 c1 30 01 ed c1 e7 3f 00 00 00 00 00 00 a0 3c  3.0....?.......<
    0x0130  36 86 ff 62 6a d2 e7 3f 00 00 00 00 00 90 26 bd  6..bj..?......&.
    0x0140  3b 4e cf 36 f3 e2 e7 3f 00 00 00 00 00 e0 02 bd  ;N.6...?........
    0x0150  e8 c3 91 84 87 f3 e7 3f 00 00 00 00 00 58 24 bd  .......?.....X$.
    0x0160  4e 1b 3e 54 27 04 e8 3f 00 00 00 00 00 00 33 3d  N.>T'..?......3=
    0x0170  1a 07 d1 ad d2 14 e8 3f 00 00 00 00 00 00 0f 3d  .......?.......=
    0x0180  7e cd 4c 99 89 25 e8 3f 00 00 00 00 00 c0 21 bd  ~.L..%.?......!.
    0x0190  d0 42 b9 1e 4c 36 e8 3f 00 00 00 00 00 d0 29 3d  .B..L6.?......)=
    0x01a0  b5 ca 23 46 1a 47 e8 3f 00 00 00 00 00 10 47 3d  ..#F.G.?......G=
    0x01b0  bc 5b 9f 17 f4 57 e8 3f 00 00 00 00 00 60 22 3d  .[...W.?.....`"=
    0x01c0  af 91 44 9b d9 68 e8 3f 00 00 00 00 00 c4 32 bd  ..D..h.?......2.
    0x01d0  95 a3 31 d9 ca 79 e8 3f 00 00 00 00 00 00 23 bd  ..1..y.?......#.
    0x01e0  b8 65 8a d9 c7 8a e8 3f 00 00 00 00 00 80 2a bd  .e.....?......*.
    0x01f0  00 58 78 a4 d0 9b e8 3f 00 00 00 00 00 00 ed bc  .Xx....?........
    0x0200  23 a2 2a 42 e5 ac e8 3f 00 00 00 00 00 28 33 3d  #.*B...?.....(3=
    0x0210  fa 19 d6 ba 05 be e8 3f 00 00 00 00 00 b4 42 3d  .......?......B=
    0x0220  83 43 b5 16 32 cf e8 3f 00 00 00 00 00 d0 2e bd  .C..2..?........
    0x0230  4c 66 08 5e 6a e0 e8 3f 00 00 00 00 00 50 20 bd  Lf.^j..?.....P .
    0x0240  07 78 15 99 ae f1 e8 3f 00 00 00 00 00 28 28 3d  .x.....?.....((=
    0x0250  0e 2c 28 d0 fe 02 e9 3f 00 00 00 00 00 b0 1c bd  .,(....?........
    0x0260  96 ff 91 0b 5b 14 e9 3f 00 00 00 00 00 e0 05 bd  ....[..?........
    0x0270  f9 2f aa 53 c3 25 e9 3f 00 00 00 00 00 40 f5 3c  ./.S.%.?.....@.<
    0x0280  4a c6 cd b0 37 37 e9 3f 00 00 00 00 00 20 17 3d  J...77.?..... .=
    0x0290  ae 98 5f 2b b8 48 e9 3f 00 00 00 00 00 00 09 bd  .._+.H.?........
    0x02a0  cb 52 c8 cb 44 5a e9 3f 00 00 00 00 00 68 25 3d  .R..DZ.?.....h%=
    0x02b0  21 6f 76 9a dd 6b e9 3f 00 00 00 00 00 d0 36 bd  !ov..k.?......6.
    0x02c0  2a 4e de 9f 82 7d e9 3f 00 00 00 00 00 00 01 bd  *N...}.?........
    0x02d0  a3 23 7a e4 33 8f e9 3f 00 00 00 00 00 00 2d 3d  .#z.3..?......-=
    0x02e0  04 06 ca 70 f1 a0 e9 3f 00 00 00 00 00 a4 38 bd  ...p...?......8.
    0x02f0  89 ff 53 4d bb b2 e9 3f 00 00 00 00 00 5c 35 3d  ..SM...?.....\5=
    0x0300  5b f1 a3 82 91 c4 e9 3f 00 00 00 00 00 b8 26 3d  [......?......&=
    0x0310  c5 b8 4b 19 74 d6 e9 3f 00 00 00 00 00 00 ec bc  ..K.t..?........
    0x0320  8e 23 e3 19 63 e8 e9 3f 00 00 00 00 00 d0 17 3d  .#..c..?.......=
    0x0330  02 f3 07 8d 5e fa e9 3f 00 00 00 00 00 40 16 3d  ....^..?.....@.=
    0x0340  4d e5 5d 7b 66 0c ea 3f 00 00 00 00 00 00 f5 bc  M.]{f..?........
    0x0350  f6 b8 8e ed 7a 1e ea 3f 00 00 00 00 00 e0 09 3d  ....z..?.......=
    0x0360  27 2e 4a ec 9b 30 ea 3f 00 00 00 00 00 d8 2a 3d  '.J..0.?......*=
    0x0370  5d 0a 46 80 c9 42 ea 3f 00 00 00 00 00 f0 1a bd  ].F..B.?........
    0x0380  9b 25 3e b2 03 55 ea 3f 00 00 00 00 00 60 0b 3d  .%>..U.?.....`.=
    0x0390  13 62 f4 8a 4a 67 ea 3f 00 00 00 00 00 88 38 3d  .b..Jg.?......8=
    0x03a0  a7 b3 30 13 9e 79 ea 3f 00 00 00 00 00 20 11 3d  ..0..y.?..... .=
    0x03b0  8d 2e c1 53 fe 8b ea 3f 00 00 00 00 00 c0 06 3d  ...S...?.......=
    0x03c0  d2 fc 79 55 6b 9e ea 3f 00 00 00 00 00 b8 29 bd  ..yUk..?......).
    0x03d0  b8 6f 35 21 e5 b0 ea 3f 00 00 00 00 00 70 2b 3d  .o5!...?.....p+=
    0x03e0  81 f3 d3 bf 6b c3 ea 3f 00 00 00 00 00 00 d9 3c  ....k..?.......<
    0x03f0  80 27 3c 3a ff d5 ea 3f 00 00 00 00 00 00 e4 3c  .'<:...?.......<
    0x0400  a3 d2 5a 99 9f e8 ea 3f 00 00 00 00 00 90 2c bd  ..Z....?......,.
    0x0410  67 f3 22 e6 4c fb ea 3f 00 00 00 00 00 50 16 3d  g.".L..?.....P.=
    0x0420  90 b7 8d 29 07 0e eb 3f 00 00 00 00 00 d4 2f 3d  ...)...?....../=
    0x0430  a9 89 9a 6c ce 20 eb 3f 00 00 00 00 00 70 12 3d  ...l. .?.....p.=
    0x0440  4b 1a 4f b8 a2 33 eb 3f 00 00 00 00 00 47 4d 3d  K.O..3.?.....GM=
    0x0450  e7 47 b7 15 84 46 eb 3f 00 00 00 00 00 38 38 bd  .G...F.?.....88.
    0x0460  3a 59 e5 8d 72 59 eb 3f 00 00 00 00 00 00 98 3c  :Y..rY.?.......<
    0x0470  6a c5 f1 29 6e 6c eb 3f 00 00 00 00 00 d0 0a 3d  j..)nl.?.......=
    0x0480  50 5e fb f2 76 7f eb 3f 00 00 00 00 00 80 de 3c  P^..v..?.......<
    0x0490  b2 49 27 f2 8c 92 eb 3f 00 00 00 00 00 c0 04 bd  .I'....?........
    0x04a0  03 06 a1 30 b0 a5 eb 3f 00 00 00 00 00 70 0d bd  ...0...?.....p..
    0x04b0  66 6f 9a b7 e0 b8 eb 3f 00 00 00 00 00 90 0d 3d  fo.....?.......=
    0x04c0  ff c1 4b 90 1e cc eb 3f 00 00 00 00 00 a0 02 3d  ..K....?.......=
    0x04d0  6f a1 f3 c3 69 df eb 3f 00 00 00 00 00 78 1f bd  o...i..?.....x..
    0x04e0  b8 1d d7 5b c2 f2 eb 3f 00 00 00 00 00 a0 10 bd  ...[...?........
    0x04f0  e9 b2 41 61 28 06 ec 3f 00 00 00 00 00 40 11 bd  ..Aa(..?.....@..
    0x0500  e0 52 85 dd 9b 19 ec 3f 00 00 00 00 00 e0 0b 3d  .R.....?.......=
    0x0510  ee 64 fa d9 1c 2d ec 3f 00 00 00 00 00 40 09 bd  .d...-.?.....@..
    0x0520  2f d0 ff 5f ab 40 ec 3f 00 00 00 00 00 d0 0e bd  /.._.@.?........
    0x0530  15 fd fa 78 47 54 ec 3f 00 00 00 00 00 66 39 3d  ...xGT.?.....f9=
    0x0540  cb d0 57 2e f1 67 ec 3f 00 00 00 00 00 10 1a bd  ..W..g.?........
    0x0550  b6 c1 88 89 a8 7b ec 3f 00 00 00 00 80 45 58 bd  .....{.?.....EX.
    0x0560  33 e7 06 94 6d 8f ec 3f 00 00 00 00 00 48 1a bd  3...m..?.....H..
    0x0570  df c4 51 57 40 a3 ec 3f 00 00 00 00 00 00 cb 3c  ..QW@..?.......<
    0x0580  94 90 ef dc 20 b7 ec 3f 00 00 00 00 00 40 01 3d  .... ..?.....@.=
    0x0590  89 16 6d 2e 0f cb ec 3f 00 00 00 00 00 20 f0 3c  ..m....?..... .<
    0x05a0  12 c4 5d 55 0b df ec 3f 00 00 00 00 00 60 f3 3c  ..]U...?.....`.<
    0x05b0  3b ab 5b 5b 15 f3 ec 3f 00 00 00 00 00 90 06 bd  ;.[[...?........
    0x05c0  bc 89 07 4a 2d 07 ed 3f 00 00 00 00 00 a0 09 3d  ...J-..?.......=
    0x05d0  fa c8 08 2b 53 1b ed 3f 00 00 00 00 00 e0 15 bd  ...+S..?........
    0x05e0  85 8a 0d 08 87 2f ed 3f 00 00 00 00 00 28 1d 3d  ...../.?.....(.=
    0x05f0  03 a2 ca ea c8 43 ed 3f 00 00 00 00 00 a0 01 3d  .....C.?.......=
    0x0600  91 a4 fb dc 18 58 ed 3f 00 00 00 00 00 00 df 3c  .....X.?.......<
    0x0610  a1 e6 62 e8 76 6c ed 3f 00 00 00 00 00 a0 03 bd  ..b.vl.?........
    0x0620  4e 83 c9 16 e3 80 ed 3f 00 00 00 00 00 d8 0c bd  N......?........
    0x0630  90 60 ff 71 5d 95 ed 3f 00 00 00 00 00 c0 f4 3c  .`.q]..?.......<
    0x0640  ae 32 db 03 e6 a9 ed 3f 00 00 00 00 00 90 ff 3c  .2.....?.......<
    0x0650  25 83 3a d6 7c be ed 3f 00 00 00 00 00 80 e9 3c  %.:.|..?.......<
    0x0660  45 b4 01 f3 21 d3 ed 3f 00 00 00 00 00 20 f5 bc  E...!..?..... ..
    0x0670  bf 05 1c 64 d5 e7 ed 3f 00 00 00 00 00 70 1d bd  ...d...?.....p..
    0x0680  ec 9a 7b 33 97 fc ed 3f 00 00 00 00 00 14 16 bd  ..{3...?........
    0x0690  5e 7d 19 6b 67 11 ee 3f 00 00 00 00 00 48 0b 3d  ^}.kg..?.....H.=
    0x06a0  e7 a3 f5 14 46 26 ee 3f 00 00 00 00 00 ce 40 3d  ....F&.?......@=
    0x06b0  5c ee 16 3b 33 3b ee 3f 00 00 00 00 00 68 0c 3d  \..;3;.?.....h.=
    0x06c0  b4 3f 8b e7 2e 50 ee 3f 00 00 00 00 00 30 09 bd  .?...P.?.....0..
    0x06d0  68 6d 67 24 39 65 ee 3f 00 00 00 00 00 00 e5 bc  hmg$9e.?........
    0x06e0  44 4c c7 fb 51 7a ee 3f 00 00 00 00 00 f8 07 bd  DL..Qz.?........
    0x06f0  26 b7 cd 77 79 8f ee 3f 00 00 00 00 00 70 f3 bc  &..wy..?.....p..
    0x0700  e8 90 a4 a2 af a4 ee 3f 00 00 00 00 00 d0 e5 3c  .......?.......<
    0x0710  e4 ca 7c 86 f4 b9 ee 3f 00 00 00 00 00 1a 16 3d  ..|....?.......=
    0x0720  0d 68 8e 2d 48 cf ee 3f 00 00 00 00 00 50 f5 3c  .h.-H..?.....P.<
    0x0730  14 85 18 a2 aa e4 ee 3f 00 00 00 00 00 40 c6 3c  .......?.....@.<
    0x0740  13 5a 61 ee 1b fa ee 3f 00 00 00 00 00 80 ee bc  .Za....?........
    0x0750  06 41 b6 1c 9c 0f ef 3f 00 00 00 00 00 88 fa bc  .A.....?........
    0x0760  63 b9 6b 37 2b 25 ef 3f 00 00 00 00 00 90 2c bd  c.k7+%.?......,.
    0x0770  75 72 dd 48 c9 3a ef 3f 00 00 00 00 00 00 aa 3c  ur.H.:.?.......<
    0x0780  24 45 6e 5b 76 50 ef 3f 00 00 00 00 00 f0 f4 bc  $En[vP.?........
    0x0790  fd 44 88 79 32 66 ef 3f 00 00 00 00 00 80 ca 3c  .D.y2f.?.......<
    0x07a0  38 be 9c ad fd 7b ef 3f 00 00 00 00 00 bc fa 3c  8....{.?.......<
    0x07b0  82 3c 24 02 d8 91 ef 3f 00 00 00 00 00 60 d4 bc  .<$....?.....`..
    0x07c0  8e 90 9e 81 c1 a7 ef 3f 00 00 00 00 00 0c 0b bd  .......?........
    0x07d0  11 d5 92 36 ba bd ef 3f 00 00 00 00 00 e0 c0 bc  ...6...?........
    0x07e0  94 71 8f 2b c2 d3 ef 3f 00 00 00 00 80 de 10 bd  .q.+...?........
    0x07f0  ee 23 2a 6b d9 e9 ef 3f 00 00 00 00 00 43 ee 3c  .#*k...?.....C.<
    0x0800  00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 00 00  .......?........
    0x0810  be bc 5a fa 1a 0b f0 3f 00 00 00 00 00 40 b3 bc  ..Z....?.....@..
    0x0820  03 33 fb a9 3d 16 f0 3f 00 00 00 00 00 17 12 bd  .3..=..?........
    0x0830  82 02 3b 14 68 21 f0 3f 00 00 00 00 00 40 ba 3c  ..;.h!.?.....@.<
    0x0840  6c 80 77 3e 9a 2c f0 3f 00 00 00 00 00 98 ef 3c  l.w>.,.?.......<
    0x0850  ca bb 11 2e d4 37 f0 3f 00 00 00 00 00 40 c7 bc  .....7.?.....@..
    0x0860  89 7f 6e e8 15 43 f0 3f 00 00 00 00 00 30 d8 3c  ..n..C.?.....0.<
    0x0870  67 54 f6 72 5f 4e f0 3f 00 00 00 00 00 3f 1a bd  gT.r_N.?.....?..
    0x0880  5a 85 15 d3 b0 59 f0 3f 00 00 00 00 00 84 02 bd  Z....Y.?........
    0x0890  95 1f 3c 0e 0a 65 f0 3f 00 00 00 00 00 60 f1 3c  ..<..e.?.....`.<
    0x08a0  1a f7 dd 29 6b 70 f0 3f 00 00 00 00 00 24 15 3d  ...)kp.?.....$.=
    0x08b0  2d a8 72 2b d4 7b f0 3f 00 00 00 00 00 a0 e9 bc  -.r+.{.?........
    0x08c0  d0 9b 75 18 45 87 f0 3f 00 00 00 00 00 40 e6 3c  ..u.E..?.....@.<
    0x08d0  c8 07 66 f6 bd 92 f0 3f 00 00 00 00 00 78 00 bd  ..f....?.....x..
    0x08e0  83 f3 c6 ca 3e 9e f0 3f 00 00 00 00 00 00 98 bc  ....>..?........
    0x08f0  30 39 1f 9b c7 a9 f0 3f 00 00 00 00 00 a0 ff 3c  09.....?.......<
    0x0900  fc 88 f9 6c 58 b5 f0 3f 00 00 00 00 00 c8 fa bc  ...lX..?........
    0x0910  8a 6c e4 45 f1 c0 f0 3f 00 00 00 00 00 c0 d9 3c  .l.E...?.......<
    0x0920  16 48 72 2b 92 cc f0 3f 00 00 00 00 00 20 05 3d  .Hr+...?..... .=
    0x0930  d8 5d 39 23 3b d8 f0 3f 00 00 00 00 00 d0 fa bc  .]9#;..?........
    0x0940  f3 d1 d3 32 ec e3 f0 3f 00 00 00 00 00 ac 1b 3d  ...2...?.......=
    0x0950  a6 a9 df 5f a5 ef f0 3f 00 00 00 00 00 e8 04 bd  ..._...?........
    0x0960  f0 d2 fe af 66 fb f0 3f 00 00 00 00 00 30 0d bd  ....f..?.....0..
    0x0970  4b 23 d7 28 30 07 f1 3f 00 00 00 00 00 50 f1 3c  K#.(0..?.....P.<
    0x0980  5b 5b 12 d0 01 13 f1 3f 00 00 00 00 00 00 ec 3c  [[.....?.......<
    0x0990  f9 2a 5e ab db 1e f1 3f 00 00 00 00 00 bc 16 3d  .*^....?.......=
    0x09a0  d5 31 6c c0 bd 2a f1 3f 00 00 00 00 00 40 e8 3c  .1l..*.?.....@.<
    0x09b0  7d 04 f2 14 a8 36 f1 3f 00 00 00 00 00 d0 0e bd  }....6.?........
    0x09c0  e9 2d a9 ae 9a 42 f1 3f 00 00 00 00 00 e0 e8 3c  .-...B.?.......<
    0x09d0  38 31 4f 93 95 4e f1 3f 00 00 00 00 00 40 eb 3c  81O..N.?.....@.<
    0x09e0  71 8e a5 c8 98 5a f1 3f 00 00 00 00 00 30 05 3d  q....Z.?.....0.=
    0x09f0  df c3 71 54 a4 66 f1 3f 00 00 00 00 00 38 03 3d  ..qT.f.?.....8.=
    0x0a00  11 52 7d 3c b8 72 f1 3f 00 00 00 00 00 d4 28 3d  .R}<.r.?......(=
    0x0a10  9f bb 95 86 d4 7e f1 3f 00 00 00 00 00 d0 05 bd  .....~.?........
    0x0a20  93 8d 8c 38 f9 8a f1 3f 00 00 00 00 00 88 1c bd  ...8...?........
    0x0a30  66 5d 37 58 26 97 f1 3f 00 00 00 00 00 f0 11 3d  f]7X&..?.......=
    0x0a40  a7 cb 6f eb 5b a3 f1 3f 00 00 00 00 00 48 10 3d  ..o.[..?.....H.=
    0x0a50  e3 87 13 f8 99 af f1 3f 00 00 00 00 00 39 47 bd  .......?.....9G.
    0x0a60  54 5d 04 84 e0 bb f1 3f 00 00 00 00 00 e4 24 3d  T].....?......$=
    0x0a70  43 1c 28 95 2f c8 f1 3f 00 00 00 00 00 20 0a bd  C.(./..?..... ..
    0x0a80  b2 b9 68 31 87 d4 f1 3f 00 00 00 00 00 80 e3 3c  ..h1...?.......<
    0x0a90  31 40 b4 5e e7 e0 f1 3f 00 00 00 00 00 c0 ea 3c  1@.^...?.......<
    0x0aa0  38 d9 fc 22 50 ed f1 3f 00 00 00 00 00 90 01 3d  8.."P..?.......=
    0x0ab0  f7 cd 38 84 c1 f9 f1 3f 00 00 00 00 00 78 1b bd  ..8....?.....x..
    0x0ac0  8f 8d 62 88 3b 06 f2 3f 00 00 00 00 00 94 2d 3d  ..b.;..?......-=
    0x0ad0  1e a8 78 35 be 12 f2 3f 00 00 00 00 00 00 d8 3c  ..x5...?.......<
    0x0ae0  41 dd 7d 91 49 1f f2 3f 00 00 00 00 00 34 2b 3d  A.}.I..?.....4+=
    0x0af0  23 13 79 a2 dd 2b f2 3f 00 00 00 00 00 f8 19 3d  #.y..+.?.......=
    0x0b00  e7 61 75 6e 7a 38 f2 3f 00 00 00 00 00 c8 19 bd  .aunz8.?........
    0x0b10  27 14 82 fb 1f 45 f2 3f 00 00 00 00 00 30 02 3d  '....E.?.....0.=
    0x0b20  02 a6 b2 4f ce 51 f2 3f 00 00 00 00 00 48 13 bd  ...O.Q.?.....H..
    0x0b30  b0 ce 1e 71 85 5e f2 3f 00 00 00 00 00 70 12 3d  ...q.^.?.....p.=
    0x0b40  16 7d e2 65 45 6b f2 3f 00 00 00 00 00 d0 11 3d  .}.eEk.?.......=
    0x0b50  0f e0 1d 34 0e 78 f2 3f 00 00 00 00 00 ee 31 3d  ...4.x.?......1=
    0x0b60  3e 63 f5 e1 df 84 f2 3f 00 00 00 00 00 c0 14 bd  >c.....?........
    0x0b70  30 bb 91 75 ba 91 f2 3f 00 00 00 00 00 d8 13 bd  0..u...?........
    0x0b80  09 df 1f f5 9d 9e f2 3f 00 00 00 00 00 b0 08 3d  .......?.......=
    0x0b90  9b 0e d1 66 8a ab f2 3f 00 00 00 00 00 7c 22 bd  ...f...?.....|".
    0x0ba0  3a da da d0 7f b8 f2 3f 00 00 00 00 00 34 2a 3d  :......?.....4*=
    0x0bb0  f9 1a 77 39 7e c5 f2 3f 00 00 00 00 00 80 10 bd  ..w9~..?........
    0x0bc0  d9 02 e4 a6 85 d2 f2 3f 00 00 00 00 00 d0 0e bd  .......?........
    0x0bd0  79 15 64 1f 96 df f2 3f 00 00 00 00 00 20 f4 bc  y.d....?..... ..
    0x0be0  cf 2e 3e a9 af ec f2 3f 00 00 00 00 00 98 24 bd  ..>....?......$.
    0x0bf0  22 88 bd 4a d2 f9 f2 3f 00 00 00 00 00 30 16 bd  "..J...?.....0..
    0x0c00  25 b6 31 0a fe 06 f3 3f 00 00 00 00 00 36 32 bd  %.1....?.....62.
    0x0c10  0b a5 ee ed 32 14 f3 3f 00 00 00 00 80 df 70 bd  ....2..?......p.
    0x0c20  b8 d7 4c fc 70 21 f3 3f 00 00 00 00 00 48 22 bd  ..L.p!.?.....H".
    0x0c30  a2 e9 a8 3b b8 2e f3 3f 00 00 00 00 00 98 25 bd  ...;...?......%.
    0x0c40  66 17 64 b2 08 3c f3 3f 00 00 00 00 00 d0 1e 3d  f.d..<.?.......=
    0x0c50  27 fa e3 66 62 49 f3 3f 00 00 00 00 00 00 dc bc  '..fbI.?........
    0x0c60  0f 9f 92 5f c5 56 f3 3f 00 00 00 00 00 d8 30 bd  ..._.V.?......0.
    0x0c70  b9 88 de a2 31 64 f3 3f 00 00 00 00 00 c8 22 3d  ....1d.?......"=
    0x0c80  39 aa 3a 37 a7 71 f3 3f 00 00 00 00 00 60 20 3d  9.:7.q.?.....` =
    0x0c90  fe 74 1e 23 26 7f f3 3f 00 00 00 00 00 60 16 bd  .t.#&..?.....`..
    0x0ca0  38 d8 05 6d ae 8c f3 3f 00 00 00 00 00 e0 0a bd  8..m...?........
    0x0cb0  c3 3e 71 1b 40 9a f3 3f 00 00 00 00 00 72 44 bd  .>q.@..?.....rD.
    0x0cc0  20 a0 e5 34 db a7 f3 3f 00 00 00 00 00 20 08 3d   ..4...?..... .=
    0x0cd0  95 6e ec bf 7f b5 f3 3f 00 00 00 00 00 80 3e 3d  .n.....?......>=
    0x0ce0  f2 a8 13 c3 2d c3 f3 3f 00 00 00 00 00 80 ef 3c  ....-..?.......<
    0x0cf0  22 e1 ed 44 e5 d0 f3 3f 00 00 00 00 00 a0 17 bd  "..D...?........
    0x0d00  bb 34 12 4c a6 de f3 3f 00 00 00 00 00 30 26 3d  .4.L...?.....0&=
    0x0d10  cc 4e 1c df 70 ec f3 3f 00 00 00 00 00 a6 48 bd  .N..p..?......H.
    0x0d20  8c 7e ac 04 45 fa f3 3f 00 00 00 00 00 dc 3c bd  .~..E..?......<.
    0x0d30  bb a0 67 c3 22 08 f4 3f 00 00 00 00 00 b8 25 3d  ..g."..?......%=
    0x0d40  95 2e f7 21 0a 16 f4 3f 00 00 00 00 00 c0 1e 3d  ...!...?.......=
    0x0d50  46 46 09 27 fb 23 f4 3f 00 00 00 00 00 60 13 bd  FF.'.#.?.....`..
    0x0d60  20 a9 50 d9 f5 31 f4 3f 00 00 00 00 00 98 23 3d   .P..1.?......#=
    0x0d70  eb b9 84 3f fa 3f f4 3f 00 00 00 00 00 00 fa 3c  ...?.?.?.......<
    0x0d80  19 89 61 60 08 4e f4 3f 00 00 00 00 00 c0 f6 bc  ..a`.N.?........
    0x0d90  01 d2 a7 42 20 5c f4 3f 00 00 00 00 00 c0 0b bd  ...B \.?........
    0x0da0  16 00 1d ed 41 6a f4 3f 00 00 00 00 00 80 12 bd  ....Aj.?........
    0x0db0  26 33 8b 66 6d 78 f4 3f 00 00 00 00 00 e0 30 3d  &3.fmx.?......0=
    0x0dc0  00 3c c1 b5 a2 86 f4 3f 00 00 00 00 00 40 2d bd  .<.....?.....@-.
    0x0dd0  04 af 92 e1 e1 94 f4 3f 00 00 00 00 00 20 0c 3d  .......?..... .=
    0x0de0  72 d3 d7 f0 2a a3 f4 3f 00 00 00 00 00 50 1e bd  r...*..?.....P..
    0x0df0  01 b8 6d ea 7d b1 f4 3f 00 00 00 00 00 80 07 3d  ..m.}..?.......=
    0x0e00  e1 29 36 d5 da bf f4 3f 00 00 00 00 00 80 13 bd  .)6....?........
    0x0e10  32 c1 17 b8 41 ce f4 3f 00 00 00 00 00 80 00 3d  2...A..?.......=
    0x0e20  db dd fd 99 b2 dc f4 3f 00 00 00 00 00 70 2c 3d  .......?.....p,=
    0x0e30  96 ab d8 81 2d eb f4 3f 00 00 00 00 00 e0 1c bd  ....-..?........
    0x0e40  02 2d 9d 76 b2 f9 f4 3f 00 00 00 00 00 20 19 3d  .-.v...?..... .=
    0x0e50  c1 31 45 7f 41 08 f5 3f 00 00 00 00 00 c0 08 bd  .1E.A..?........
    0x0e60  2a 66 cf a2 da 16 f5 3f 00 00 00 00 00 00 fa bc  *f.....?........
    0x0e70  ea 51 3f e8 7d 25 f5 3f 00 00 00 00 00 08 4a 3d  .Q?.}%.?......J=
    0x0e80  da 4e 9d 56 2b 34 f5 3f 00 00 00 00 00 d8 26 bd  .N.V+4.?......&.
    0x0e90  1a ac f6 f4 e2 42 f5 3f 00 00 00 00 00 44 32 bd  .....B.?.....D2.
    0x0ea0  db 94 5d ca a4 51 f5 3f 00 00 00 00 00 3c 48 3d  ..]..Q.?.....<H=
    0x0eb0  6b 11 e9 dd 70 60 f5 3f 00 00 00 00 00 b0 24 3d  k...p`.?......$=
    0x0ec0  de 29 b5 36 47 6f f5 3f 00 00 00 00 00 5a 41 3d  .).6Go.?.....ZA=
    0x0ed0  0e c4 e2 db 27 7e f5 3f 00 00 00 00 00 e0 29 bd  ....'~.?......).
    0x0ee0  6f c7 97 d4 12 8d f5 3f 00 00 00 00 00 08 23 bd  o......?......#.
    0x0ef0  4c 0b ff 27 08 9c f5 3f 00 00 00 00 00 ec 4d 3d  L..'...?......M=
    0x0f00  27 54 48 dd 07 ab f5 3f 00 00 00 00 00 00 c4 bc  'TH....?........
    0x0f10  f4 7a a8 fb 11 ba f5 3f 00 00 00 00 00 08 30 3d  .z.....?......0=
    0x0f20  0b 46 59 8a 26 c9 f5 3f 00 00 00 00 00 c8 26 bd  .FY.&..?......&.
    0x0f30  3f 8e 99 90 45 d8 f5 3f 00 00 00 00 00 9a 46 3d  ?...E..?......F=
    0x0f40  e1 20 ad 15 6f e7 f5 3f 00 00 00 00 00 40 1b bd  . ..o..?.....@..
    0x0f50  ca eb dc 20 a3 f6 f5 3f 00 00 00 00 00 70 17 3d  ... ...?.....p.=
    0x0f60  b8 dc 76 b9 e1 05 f6 3f 00 00 00 00 00 f8 26 3d  ..v....?......&=
    0x0f70  15 f7 cd e6 2a 15 f6 3f 00 00 00 00 00 00 01 3d  ....*..?.......=
    0x0f80  31 55 3a b0 7e 24 f6 3f 00 00 00 00 00 d0 15 bd  1U:.~$.?........
    0x0f90  b5 29 19 1d dd 33 f6 3f 00 00 00 00 00 d0 12 bd  .)...3.?........
    0x0fa0  13 c3 cc 34 46 43 f6 3f 00 00 00 00 00 80 ea bc  ...4FC.?........
    0x0fb0  fa 8e bc fe b9 52 f6 3f 00 00 00 00 00 60 28 bd  .....R.?.....`(.
    0x0fc0  97 33 55 82 38 62 f6 3f 00 00 00 00 00 fe 71 3d  .3U.8b.?......q=
    0x0fd0  8e 32 08 c7 c1 71 f6 3f 00 00 00 00 00 20 37 bd  .2...q.?..... 7.
    0x0fe0  7e a9 4c d4 55 81 f6 3f 00 00 00 00 00 80 e6 3c  ~.L.U..?.......<
    0x0ff0  71 94 9e b1 f4 90 f6 3f 00 00 00 00 00 78 29 bd  q......?.....x).
}

const exp2f::TBLSIZE: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 16_usize;
        return;
    }
}

static EXP2FT: [u64; 16] = {
    let mut _0: [u64; 16];

    bb0: {
        _0 = [const 4604544271217802189_u64, const 4604826253225820551_u64, const 4605120719643910363_u64, const 4605428223204126864_u64, const 4605749341110064045_u64, const 4606084676120302236_u64, const 4606434857679824007_u64, const 4606800543101522138_u64, const 4607182418800017408_u64, const 4607381810190059791_u64, const 4607590029391122811_u64, const 4607807467243790904_u64, const 4608034531892639509_u64, const 4608271649552348194_u64, const 4608519265307732519_u64, const 4608777843949196329_u64];
        return;
    }
}

EXP2FT::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const _;
        return;
    }
}

fn exp2f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _3: f32;
    let mut _4: f32;
    let mut _11: f32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: u32;
    let _20: f32;
    let mut _21: *const f32;
    let _22: &f32;
    let _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: (u32, bool);
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: bool;
    let mut _42: u64;
    let mut _43: u64;
    let mut _44: u32;
    let mut _45: (u32, bool);
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: u32;
    let mut _49: u32;
    let mut _50: (u32, bool);
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _57: u64;
    let mut _58: &u64;
    let mut _59: rustc_std_workspace_core::option::Option<&u64>;
    let mut _60: &[u64];
    let _61: &[u64; 16];
    let mut _62: usize;
    let mut _63: u32;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    scope 1 {
        debug redux => _2;
        let _5: f32;
        scope 2 {
            debug p1 => _5;
            let _6: f32;
            scope 3 {
                debug p2 => _6;
                let _7: f32;
                scope 4 {
                    debug p3 => _7;
                    let _8: f32;
                    scope 5 {
                        debug p4 => _8;
                        let _9: f32;
                        scope 6 {
                            debug x1p127 => _9;
                            let _10: u32;
                            scope 7 {
                                debug ui => _10;
                                let _12: u32;
                                scope 8 {
                                    debug ix => _12;
                                    let _29: u32;
                                    scope 9 {
                                    }
                                    scope 10 {
                                        debug ui => _29;
                                        let mut _32: u32;
                                        scope 11 {
                                            debug i0 => _32;
                                            let _37: u32;
                                            scope 12 {
                                                debug k => _37;
                                                let _41: f64;
                                                scope 13 {
                                                    debug ukf => _41;
                                                    let mut _51: f32;
                                                    scope 14 {
                                                        debug uf => _51;
                                                        let _52: f64;
                                                        scope 15 {
                                                            debug z => _52;
                                                            let _56: f64;
                                                            scope 16 {
                                                                debug r => _56;
                                                                let _64: f64;
                                                                scope 17 {
                                                                    debug t => _64;
                                                                    let _65: f64;
                                                                    scope 18 {
                                                                        debug r => _65;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::from_bits(const 1262485504_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const _ as f32 (IntToFloat);
        _2 = Div(move _3, move _4);
        _5 = f32::<impl f32>::from_bits(const 1060205080_u32) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = f32::<impl f32>::from_bits(const 1047920112_u32) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = f32::<impl f32>::from_bits(const 1029921188_u32) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = f32::<impl f32>::from_bits(const 1008571982_u32) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _9 = f32::<impl f32>::from_bits(const 2130706432_u32) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = _1;
        _10 = f32::<impl f32>::to_bits(move _11) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _12 = BitAnd(_10, const 2147483647_u32);
        _13 = Gt(_12, const 1123811328_u32);
        switchInt(move _13) -> [0: bb20, otherwise: bb8];
    }

    bb8: {
        _14 = Gt(_12, const 2139095040_u32);
        switchInt(move _14) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = _1;
        goto -> bb35;
    }

    bb10: {
        _15 = Ge(_10, const 1124073472_u32);
        switchInt(move _15) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _16 = Lt(_10, const 2147483648_u32);
        switchInt(move _16) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _1 = Mul(_1, _9);
        _0 = _1;
        goto -> bb35;
    }

    bb13: {
        _17 = Ge(_10, const 2147483648_u32);
        switchInt(move _17) -> [0: bb22, otherwise: bb14];
    }

    bb14: {
        _18 = Ge(_10, const 3272998912_u32);
        switchInt(move _18) -> [0: bb15, otherwise: bb16];
    }

    bb15: {
        _19 = BitAnd(_10, const 65535_u32);
        switchInt(move _19) -> [0: bb18, otherwise: bb16];
    }

    bb16: {
        _24 = f32::<impl f32>::from_bits(const 2147483649_u32) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _25 = _1;
        _23 = Div(move _24, move _25);
        _22 = &_23;
        _21 = &raw const (*_22);
        _20 = read_volatile::<f32>(move _21) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _26 = Ge(_10, const 3272998912_u32);
        switchInt(move _26) -> [0: bb22, otherwise: bb19];
    }

    bb19: {
        _0 = const 0f32;
        goto -> bb35;
    }

    bb20: {
        _27 = Le(_12, const 855638016_u32);
        switchInt(move _27) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _28 = _1;
        _0 = Add(const 1f32, move _28);
        goto -> bb35;
    }

    bb22: {
        _31 = _1;
        _30 = Add(move _31, _2);
        _29 = f32::<impl f32>::to_bits(move _30) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _32 = _29;
        _34 = const _ as u32 (IntToInt);
        _35 = Eq(const 2_u32, const 0_u32);
        assert(!move _35, "attempt to divide `{}` by zero", _34) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _33 = Div(move _34, const 2_u32);
        _36 = CheckedAdd(_32, _33);
        assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", _32, move _33) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _32 = move (_36.0: u32);
        _38 = _32;
        _39 = const _ as u32 (IntToInt);
        _40 = Eq(_39, const 0_u32);
        assert(!move _40, "attempt to divide `{}` by zero", _38) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _37 = Div(move _38, move _39);
        _45 = CheckedAdd(const 1023_u32, _37);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_u32, _37) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _44 = move (_45.0: u32);
        _43 = move _44 as u64 (IntToInt);
        _46 = const 52_i32 as u32 (IntToInt);
        _47 = Lt(move _46, const 64_u32);
        assert(move _47, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _42 = Shl(move _43, const 52_i32);
        _41 = f64::<impl f64>::from_bits(move _42) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _49 = const _ as u32 (IntToInt);
        _50 = CheckedSub(_49, const 1_u32);
        assert(!move (_50.1: bool), "attempt to compute `{} - {}`, which would overflow", move _49, const 1_u32) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _48 = move (_50.0: u32);
        _32 = BitAnd(_32, move _48);
        _51 = f32::<impl f32>::from_bits(_29) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _51 = Sub(_51, _2);
        _54 = _1;
        _55 = _51;
        _53 = Sub(move _54, move _55);
        _52 = move _53 as f64 (FloatToFloat);
        _61 = const {alloc9: &[u64; 16]};
        _60 = _61 as &[u64] (PointerCoercion(Unsize));
        _63 = _32;
        _62 = move _63 as usize (IntToInt);
        _59 = slice::<impl [u64]>::get::<usize>(move _60, move _62) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _58 = Option::<&u64>::unwrap(move _59) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _57 = (*_58);
        _56 = f64::<impl f64>::from_bits(move _57) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _64 = Mul(_56, _52);
        _69 = _5 as f64 (FloatToFloat);
        _71 = _6 as f64 (FloatToFloat);
        _70 = Mul(_52, move _71);
        _68 = Add(move _69, move _70);
        _67 = Mul(_64, move _68);
        _66 = Add(_56, move _67);
        _74 = Mul(_52, _52);
        _73 = Mul(_64, move _74);
        _76 = _7 as f64 (FloatToFloat);
        _78 = _8 as f64 (FloatToFloat);
        _77 = Mul(_52, move _78);
        _75 = Add(move _76, move _77);
        _72 = Mul(move _73, move _75);
        _65 = Add(move _66, move _72);
        _79 = Mul(_65, _41);
        _0 = move _79 as f32 (FloatToFloat);
        goto -> bb35;
    }

    bb35: {
        return;
    }
}

alloc9 (static: EXP2FT, size: 128, align: 8) {
    0x00  cd 3b 7f 66 9e a0 e6 3f 87 01 eb 73 14 a1 e7 3f  .;.f...?...s...?
    0x10  db a0 2a 42 e5 ac e8 3f 90 f0 a3 82 91 c4 e9 3f  ..*B...?.......?
    0x20  ad d3 5a 99 9f e8 ea 3f 9c 52 85 dd 9b 19 ec 3f  ..Z....?.R.....?
    0x30  87 a4 fb dc 18 58 ed 3f da 90 a4 a2 af a4 ee 3f  .....X.?.......?
    0x40  00 00 00 00 00 00 f0 3f 0f 89 f9 6c 58 b5 f0 3f  .......?...lX..?
    0x50  7b 51 7d 3c b8 72 f1 3f 38 62 75 6e 7a 38 f2 3f  {Q}<.r.?8bunz8.?
    0x60  15 b7 31 0a fe 06 f3 3f 22 34 12 4c a6 de f3 3f  ..1....?"4.L...?
    0x70  27 2a 36 d5 da bf f4 3f 29 54 48 dd 07 ab f5 3f  '*6....?)TH....?
}

const expf::HALF: [f32; 2] = {
    let mut _0: [f32; 2];

    bb0: {
        _0 = [const 0.5f32, const -0.5f32];
        return;
    }
}

expf::HALF::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const expf::LN2_HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693145751f32;
        return;
    }
}

const expf::LN2_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.42860677E-6f32;
        return;
    }
}

const expf::INV_LN2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.44269502f32;
        return;
    }
}

const expf::P1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.166666254f32;
        return;
    }
}

const expf::P2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00276673329f32;
        return;
    }
}

fn expf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: f32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: u32;
    let _18: f32;
    let mut _19: *const f32;
    let _20: &f32;
    let _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _29: bool;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: u32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: &f32;
    let mut _38: rustc_std_workspace_core::option::Option<&f32>;
    let mut _39: &[f32];
    let mut _40: usize;
    let mut _41: i32;
    let mut _42: (i32, bool);
    let mut _43: (i32, bool);
    let mut _45: i32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: bool;
    let mut _51: u32;
    let mut _52: f32;
    let _53: f32;
    let mut _54: *const f32;
    let _55: &f32;
    let _56: f32;
    let mut _57: f32;
    let mut _58: f32;
    let mut _60: f32;
    let mut _61: f32;
    let mut _63: f32;
    let mut _64: f32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f32;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: i32;
    let mut _77: i32;
    scope 1 {
        debug x1p127 => _2;
        let _3: f32;
        scope 2 {
            debug x1p_126 => _3;
            let mut _4: u32;
            scope 3 {
                debug hx => _4;
                let _6: i32;
                scope 4 {
                    debug sign => _6;
                    let _11: bool;
                    scope 5 {
                        debug signb => _11;
                        let _26: i32;
                        scope 6 {
                        }
                        scope 7 {
                            debug k => _26;
                            let _27: f32;
                            scope 8 {
                                debug hi => _27;
                                let _28: f32;
                                scope 9 {
                                    debug lo => _28;
                                    let _44: f32;
                                    let _59: f32;
                                    let mut _78: &[f32; 2];
                                    scope 10 {
                                        debug kf => _44;
                                    }
                                    scope 11 {
                                    }
                                    scope 12 {
                                        debug xx => _59;
                                        let _62: f32;
                                        scope 13 {
                                            debug c => _62;
                                            let _67: f32;
                                            scope 14 {
                                                debug y => _67;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 2130706432_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f32::<impl f32>::from_bits(const 8388608_u32) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = _1;
        _4 = f32::<impl f32>::to_bits(move _5) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = _4;
        _9 = const 31_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _7 = Shr(move _8, const 31_i32);
        _6 = move _7 as i32 (IntToInt);
        _11 = Ne(_6, const 0_i32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _13 = _4;
        _12 = Ge(move _13, const 1118743632_u32);
        switchInt(move _12) -> [0: bb14, otherwise: bb5];
    }

    bb5: {
        _15 = _4;
        _14 = Gt(move _15, const 2139095040_u32);
        switchInt(move _14) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _1;
        goto -> bb30;
    }

    bb7: {
        _17 = _4;
        _16 = Ge(move _17, const 1118925336_u32);
        switchInt(move _16) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        switchInt(_11) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _1 = Mul(_1, _2);
        _0 = _1;
        goto -> bb30;
    }

    bb10: {
        switchInt(_11) -> [0: bb14, otherwise: bb11];
    }

    bb11: {
        _22 = Neg(_3);
        _23 = _1;
        _21 = Div(move _22, move _23);
        _20 = &_21;
        _19 = &raw const (*_20);
        _18 = read_volatile::<f32>(move _19) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _25 = _4;
        _24 = Ge(move _25, const 1120924085_u32);
        switchInt(move _24) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _0 = const 0f32;
        goto -> bb30;
    }

    bb14: {
        _30 = _4;
        _29 = Gt(move _30, const 1051816472_u32);
        switchInt(move _29) -> [0: bb23, otherwise: bb15];
    }

    bb15: {
        _32 = _4;
        _31 = Gt(move _32, const 1065686418_u32);
        switchInt(move _31) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _35 = _1;
        _34 = Mul(const _, move _35);
        _78 = const _;
        _39 = _78 as &[f32] (PointerCoercion(Unsize));
        _40 = _6 as usize (IntToInt);
        _38 = slice::<impl [f32]>::get::<usize>(move _39, move _40) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _37 = Option::<&f32>::unwrap(move _38) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _36 = (*_37);
        _33 = Add(move _34, move _36);
        _26 = move _33 as i32 (FloatToInt);
        goto -> bb22;
    }

    bb19: {
        _42 = CheckedSub(const 1_i32, _6);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1_i32, _6) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _41 = move (_42.0: i32);
        _43 = CheckedSub(_41, _6);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _41, _6) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _26 = move (_43.0: i32);
        goto -> bb22;
    }

    bb22: {
        _45 = _26;
        _44 = move _45 as f32 (IntToFloat);
        _46 = _1;
        _47 = Mul(_44, const _);
        _27 = Sub(move _46, move _47);
        _28 = Mul(_44, const _);
        _48 = _27;
        _49 = _28;
        _1 = Sub(move _48, move _49);
        goto -> bb27;
    }

    bb23: {
        _51 = _4;
        _50 = Gt(move _51, const 956301312_u32);
        switchInt(move _50) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _26 = const 0_i32;
        _52 = _1;
        _27 = move _52;
        _28 = const 0f32;
        goto -> bb27;
    }

    bb25: {
        _57 = _1;
        _56 = Add(_2, move _57);
        _55 = &_56;
        _54 = &raw const (*_55);
        _53 = read_volatile::<f32>(move _54) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _58 = _1;
        _0 = Add(const 1f32, move _58);
        goto -> bb30;
    }

    bb27: {
        _60 = _1;
        _61 = _1;
        _59 = Mul(move _60, move _61);
        _63 = _1;
        _66 = Mul(_59, const _);
        _65 = Add(const _, move _66);
        _64 = Mul(_59, move _65);
        _62 = Sub(move _63, move _64);
        _72 = _1;
        _71 = Mul(move _72, _62);
        _73 = Sub(const 2f32, _62);
        _70 = Div(move _71, move _73);
        _74 = _28;
        _69 = Sub(move _70, move _74);
        _75 = _27;
        _68 = Add(move _69, move _75);
        _67 = Add(const 1f32, move _68);
        _76 = _26;
        switchInt(move _76) -> [0: bb28, otherwise: bb29];
    }

    bb28: {
        _0 = _67;
        goto -> bb30;
    }

    bb29: {
        _77 = _26;
        _0 = scalbnf(_67, move _77) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        return;
    }
}

promoted[0] in expf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const expm1::O_THRESHOLD: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 709.78271289338397f64;
        return;
    }
}

const expm1::LN2_HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718036912382f64;
        return;
    }
}

const expm1::LN2_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9082149292705877E-10f64;
        return;
    }
}

const expm1::INVLN2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4426950408889634f64;
        return;
    }
}

const expm1::Q1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.033333333333333132f64;
        return;
    }
}

const expm1::Q2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0015873015872548146f64;
        return;
    }
}

const Q3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -7.9365075786748794E-5f64;
        return;
    }
}

const Q4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.0082178273293624E-6f64;
        return;
    }
}

const Q5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.0109921818362437E-7f64;
        return;
    }
}

fn expm1(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _9: f64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: f64;
    let mut _24: bool;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: i32;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: bool;
    let mut _47: bool;
    let _48: f64;
    let mut _49: *const f64;
    let _50: &f64;
    let mut _52: f64;
    let mut _54: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: i32;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: i32;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: i32;
    let mut _92: bool;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: f64;
    let mut _102: u64;
    let mut _103: i32;
    let mut _104: i32;
    let mut _105: (i32, bool);
    let mut _106: u32;
    let mut _107: bool;
    let mut _109: u64;
    let mut _110: bool;
    let mut _111: i32;
    let mut _112: bool;
    let mut _113: i32;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: f64;
    let mut _117: i32;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: f64;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: u64;
    let mut _124: i32;
    let mut _125: i32;
    let mut _126: (i32, bool);
    let mut _127: u32;
    let mut _128: bool;
    let mut _130: u64;
    let mut _131: bool;
    let mut _132: i32;
    let mut _133: f64;
    let mut _134: f64;
    let mut _135: f64;
    let mut _136: f64;
    let mut _137: f64;
    let mut _138: f64;
    let mut _139: f64;
    let mut _140: f64;
    let mut _141: f64;
    let mut _142: f64;
    scope 1 {
        debug hi => _2;
        let _3: f64;
        scope 2 {
            debug lo => _3;
            let _4: i32;
            scope 3 {
                debug k => _4;
                let _5: f64;
                scope 4 {
                    debug c => _5;
                    let mut _6: f64;
                    scope 5 {
                        debug t => _6;
                        let mut _7: f64;
                        scope 6 {
                            debug y => _7;
                            let mut _8: u64;
                            scope 7 {
                                debug ui => _8;
                                let _10: u32;
                                scope 8 {
                                    debug hx => _10;
                                    let _16: i32;
                                    scope 9 {
                                        debug sign => _16;
                                        let _51: f64;
                                        scope 10 {
                                        }
                                        scope 11 {
                                            debug hfx => _51;
                                            let _53: f64;
                                            scope 12 {
                                                debug hxs => _53;
                                                let _55: f64;
                                                scope 13 {
                                                    debug r1 => _55;
                                                    let mut _66: f64;
                                                    scope 14 {
                                                        debug e => _66;
                                                        let _108: f64;
                                                        scope 15 {
                                                            debug twopk => _108;
                                                            let _129: f64;
                                                            scope 16 {
                                                                debug uf => _129;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _9 = _1;
        _8 = f64::<impl f64>::to_bits(move _9) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _13 = _8;
        _14 = const 32_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _12 = Shr(move _13, const 32_i32);
        _11 = BitAnd(move _12, const 2147483647_u64);
        _10 = move _11 as u32 (IntToInt);
        _18 = _8;
        _19 = const 63_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 64_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _17 = Shr(move _18, const 63_i32);
        _16 = move _17 as i32 (IntToInt);
        _21 = Ge(_10, const 1078159482_u32);
        switchInt(move _21) -> [0: bb12, otherwise: bb4];
    }

    bb4: {
        _23 = _1;
        _22 = f64::<impl f64>::is_nan(move _23) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        switchInt(move _22) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _1;
        goto -> bb52;
    }

    bb7: {
        switchInt(move _16) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = const -1f64;
        goto -> bb52;
    }

    bb9: {
        _25 = _1;
        _24 = Gt(move _25, const _);
        switchInt(move _24) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _26 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _1 = Mul(_1, move _26);
        _0 = _1;
        goto -> bb52;
    }

    bb12: {
        _27 = Gt(_10, const 1071001154_u32);
        switchInt(move _27) -> [0: bb22, otherwise: bb13];
    }

    bb13: {
        _28 = Lt(_10, const 1072734898_u32);
        switchInt(move _28) -> [0: bb17, otherwise: bb14];
    }

    bb14: {
        switchInt(move _16) -> [0: bb15, otherwise: bb16];
    }

    bb15: {
        _29 = _1;
        _2 = Sub(move _29, const _);
        _3 = const _;
        _4 = const 1_i32;
        goto -> bb21;
    }

    bb16: {
        _30 = _1;
        _2 = Add(move _30, const _);
        _3 = Neg(const _);
        _4 = const -1_i32;
        goto -> bb21;
    }

    bb17: {
        _33 = _1;
        _32 = Mul(const _, move _33);
        switchInt(move _16) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _34 = const -0.5f64;
        goto -> bb20;
    }

    bb19: {
        _34 = const 0.5f64;
        goto -> bb20;
    }

    bb20: {
        _31 = Add(move _32, move _34);
        _4 = move _31 as i32 (FloatToInt);
        _35 = _4;
        _6 = move _35 as f64 (IntToFloat);
        _36 = _1;
        _38 = _6;
        _37 = Mul(move _38, const _);
        _2 = Sub(move _36, move _37);
        _39 = _6;
        _3 = Mul(move _39, const _);
        goto -> bb21;
    }

    bb21: {
        _40 = _2;
        _41 = _3;
        _1 = Sub(move _40, move _41);
        _43 = _2;
        _44 = _1;
        _42 = Sub(move _43, move _44);
        _45 = _3;
        _5 = Sub(move _42, move _45);
        goto -> bb27;
    }

    bb22: {
        _46 = Lt(_10, const 1016070144_u32);
        switchInt(move _46) -> [0: bb26, otherwise: bb23];
    }

    bb23: {
        _47 = Lt(_10, const 1048576_u32);
        switchInt(move _47) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _50 = &_1;
        _49 = &raw const (*_50);
        _48 = read_volatile::<f64>(move _49) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _0 = _1;
        goto -> bb52;
    }

    bb26: {
        _5 = const 0f64;
        _4 = const 0_i32;
        goto -> bb27;
    }

    bb27: {
        _52 = _1;
        _51 = Mul(const 0.5f64, move _52);
        _54 = _1;
        _53 = Mul(move _54, _51);
        _64 = Mul(_53, const _);
        _63 = Add(const _, move _64);
        _62 = Mul(_53, move _63);
        _61 = Add(const _, move _62);
        _60 = Mul(_53, move _61);
        _59 = Add(const _, move _60);
        _58 = Mul(_53, move _59);
        _57 = Add(const _, move _58);
        _56 = Mul(_53, move _57);
        _55 = Add(const 1f64, move _56);
        _65 = Mul(_55, _51);
        _6 = Sub(const 3f64, move _65);
        _69 = _6;
        _68 = Sub(_55, move _69);
        _72 = _1;
        _73 = _6;
        _71 = Mul(move _72, move _73);
        _70 = Sub(const 6f64, move _71);
        _67 = Div(move _68, move _70);
        _66 = Mul(_53, move _67);
        _74 = _4;
        switchInt(move _74) -> [0: bb28, otherwise: bb29];
    }

    bb28: {
        _75 = _1;
        _78 = _1;
        _79 = _66;
        _77 = Mul(move _78, move _79);
        _76 = Sub(move _77, _53);
        _0 = Sub(move _75, move _76);
        goto -> bb52;
    }

    bb29: {
        _81 = _1;
        _83 = _66;
        _84 = _5;
        _82 = Sub(move _83, move _84);
        _80 = Mul(move _81, move _82);
        _85 = _5;
        _66 = Sub(move _80, move _85);
        _66 = Sub(_66, _53);
        _86 = _4;
        switchInt(move _86) -> [4294967295: bb30, otherwise: bb31];
    }

    bb30: {
        _89 = _1;
        _90 = _66;
        _88 = Sub(move _89, move _90);
        _87 = Mul(const 0.5f64, move _88);
        _0 = Sub(move _87, const 0.5f64);
        goto -> bb52;
    }

    bb31: {
        _91 = _4;
        switchInt(move _91) -> [1: bb32, otherwise: bb33];
    }

    bb32: {
        _93 = _1;
        _92 = Lt(move _93, const -0.25f64);
        switchInt(move _92) -> [0: bb35, otherwise: bb34];
    }

    bb33: {
        _104 = _4;
        _105 = CheckedAdd(const 1023_i32, _104);
        assert(!move (_105.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, move _104) -> [success: bb36, unwind unreachable];
    }

    bb34: {
        _95 = _66;
        _97 = _1;
        _96 = Add(move _97, const 0.5f64);
        _94 = Sub(move _95, move _96);
        _0 = Mul(const -2f64, move _94);
        goto -> bb52;
    }

    bb35: {
        _100 = _1;
        _101 = _66;
        _99 = Sub(move _100, move _101);
        _98 = Mul(const 2f64, move _99);
        _0 = Add(const 1f64, move _98);
        goto -> bb52;
    }

    bb36: {
        _103 = move (_105.0: i32);
        _102 = move _103 as u64 (IntToInt);
        _106 = const 52_i32 as u32 (IntToInt);
        _107 = Lt(move _106, const 64_u32);
        assert(move _107, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _8 = Shl(move _102, const 52_i32);
        _109 = _8;
        _108 = f64::<impl f64>::from_bits(move _109) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _111 = _4;
        _110 = Lt(move _111, const 0_i32);
        switchInt(move _110) -> [0: bb39, otherwise: bb40];
    }

    bb39: {
        _113 = _4;
        _112 = Gt(move _113, const 56_i32);
        switchInt(move _112) -> [0: bb45, otherwise: bb40];
    }

    bb40: {
        _115 = _1;
        _116 = _66;
        _114 = Sub(move _115, move _116);
        _7 = Add(move _114, const 1f64);
        _117 = _4;
        switchInt(move _117) -> [1024: bb41, otherwise: bb43];
    }

    bb41: {
        _119 = _7;
        _118 = Mul(move _119, const 2f64);
        _120 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _7 = Mul(move _118, move _120);
        goto -> bb44;
    }

    bb43: {
        _121 = _7;
        _7 = Mul(move _121, _108);
        goto -> bb44;
    }

    bb44: {
        _122 = _7;
        _0 = Sub(move _122, const 1f64);
        goto -> bb52;
    }

    bb45: {
        _125 = _4;
        _126 = CheckedSub(const 1023_i32, _125);
        assert(!move (_126.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_i32, move _125) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _124 = move (_126.0: i32);
        _123 = move _124 as u64 (IntToInt);
        _127 = const 52_i32 as u32 (IntToInt);
        _128 = Lt(move _127, const 64_u32);
        assert(move _128, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _8 = Shl(move _123, const 52_i32);
        _130 = _8;
        _129 = f64::<impl f64>::from_bits(move _130) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        _132 = _4;
        _131 = Lt(move _132, const 20_i32);
        switchInt(move _131) -> [0: bb50, otherwise: bb49];
    }

    bb49: {
        _135 = _1;
        _136 = _66;
        _134 = Sub(move _135, move _136);
        _137 = Sub(const 1f64, _129);
        _133 = Add(move _134, move _137);
        _7 = Mul(move _133, _108);
        goto -> bb51;
    }

    bb50: {
        _140 = _1;
        _142 = _66;
        _141 = Add(move _142, _129);
        _139 = Sub(move _140, move _141);
        _138 = Add(move _139, const 1f64);
        _7 = Mul(move _138, _108);
        goto -> bb51;
    }

    bb51: {
        _0 = _7;
        goto -> bb52;
    }

    bb52: {
        return;
    }
}

const expm1f::O_THRESHOLD: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 88.7216796f32;
        return;
    }
}

const expm1f::LN2_HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693138123f32;
        return;
    }
}

const expm1f::LN2_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 9.05800061E-6f32;
        return;
    }
}

const expm1f::INV_LN2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.44269502f32;
        return;
    }
}

const expm1f::Q1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0333332121f32;
        return;
    }
}

const expm1f::Q2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00158071704f32;
        return;
    }
}

fn expm1f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: f32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: f32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: u32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _31: i32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: bool;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: u32;
    let _44: f32;
    let mut _45: *const f32;
    let _46: &f32;
    let _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _51: f32;
    let mut _53: f32;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let mut _59: f32;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let mut _64: f32;
    let mut _65: f32;
    let mut _66: i32;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f32;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: i32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: i32;
    let mut _84: bool;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: f32;
    let mut _91: f32;
    let mut _92: f32;
    let mut _93: f32;
    let mut _95: u32;
    let mut _96: i32;
    let mut _97: i32;
    let mut _98: i32;
    let mut _99: (i32, bool);
    let mut _100: u32;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: i32;
    let mut _104: bool;
    let mut _105: i32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: f32;
    let mut _110: i32;
    let mut _111: f32;
    let mut _112: f32;
    let mut _113: f32;
    let mut _114: f32;
    let mut _116: u32;
    let mut _117: i32;
    let mut _118: i32;
    let mut _119: i32;
    let mut _120: (i32, bool);
    let mut _121: u32;
    let mut _122: bool;
    let mut _123: bool;
    let mut _124: i32;
    let mut _125: f32;
    let mut _126: f32;
    let mut _127: f32;
    let mut _128: f32;
    let mut _129: f32;
    let mut _130: f32;
    let mut _131: f32;
    let mut _132: f32;
    let mut _133: f32;
    let mut _134: f32;
    scope 1 {
        debug x1p127 => _2;
        let mut _3: u32;
        scope 2 {
            debug hx => _3;
            let _5: bool;
            scope 3 {
                debug sign => _5;
                let _16: i32;
                scope 4 {
                    debug k => _16;
                    let _17: f32;
                    scope 5 {
                        debug hi => _17;
                        let _18: f32;
                        scope 6 {
                            debug lo => _18;
                            let mut _19: f32;
                            scope 7 {
                                debug c => _19;
                                let _30: f32;
                                let _50: f32;
                                scope 8 {
                                    debug t => _30;
                                }
                                scope 9 {
                                }
                                scope 10 {
                                    debug hfx => _50;
                                    let _52: f32;
                                    scope 11 {
                                        debug hxs => _52;
                                        let _54: f32;
                                        scope 12 {
                                            debug r1 => _54;
                                            let _58: f32;
                                            scope 13 {
                                                debug t => _58;
                                                let mut _60: f32;
                                                scope 14 {
                                                    debug e => _60;
                                                    let _94: f32;
                                                    scope 15 {
                                                        debug twopk => _94;
                                                        let mut _106: f32;
                                                        let _115: f32;
                                                        scope 16 {
                                                            debug y => _106;
                                                        }
                                                        scope 17 {
                                                            debug uf => _115;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 2130706432_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _3;
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 31_i32);
        _5 = Ne(move _6, const 0_u32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _11 = _3;
        _10 = Ge(move _11, const 1100331076_u32);
        switchInt(move _10) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _13 = _3;
        _12 = Gt(move _13, const 2139095040_u32);
        switchInt(move _12) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _1;
        goto -> bb48;
    }

    bb6: {
        switchInt(_5) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = const -1f32;
        goto -> bb48;
    }

    bb8: {
        _15 = _1;
        _14 = Gt(move _15, const _);
        switchInt(move _14) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _1 = Mul(_1, _2);
        _0 = _1;
        goto -> bb48;
    }

    bb10: {
        _19 = const 0f32;
        _21 = _3;
        _20 = Gt(move _21, const 1051816472_u32);
        switchInt(move _20) -> [0: bb20, otherwise: bb11];
    }

    bb11: {
        _23 = _3;
        _22 = Lt(move _23, const 1065686418_u32);
        switchInt(move _22) -> [0: bb15, otherwise: bb12];
    }

    bb12: {
        switchInt(_5) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _24 = _1;
        _17 = Sub(move _24, const _);
        _18 = const _;
        _16 = const 1_i32;
        goto -> bb19;
    }

    bb14: {
        _25 = _1;
        _17 = Add(move _25, const _);
        _18 = Neg(const _);
        _16 = const -1_i32;
        goto -> bb19;
    }

    bb15: {
        _28 = _1;
        _27 = Mul(const _, move _28);
        switchInt(_5) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _29 = const -0.5f32;
        goto -> bb18;
    }

    bb17: {
        _29 = const 0.5f32;
        goto -> bb18;
    }

    bb18: {
        _26 = Add(move _27, move _29);
        _16 = move _26 as i32 (FloatToInt);
        _31 = _16;
        _30 = move _31 as f32 (IntToFloat);
        _32 = _1;
        _33 = Mul(_30, const _);
        _17 = Sub(move _32, move _33);
        _18 = Mul(_30, const _);
        goto -> bb19;
    }

    bb19: {
        _34 = _17;
        _35 = _18;
        _1 = Sub(move _34, move _35);
        _37 = _17;
        _38 = _1;
        _36 = Sub(move _37, move _38);
        _39 = _18;
        _19 = Sub(move _36, move _39);
        goto -> bb25;
    }

    bb20: {
        _41 = _3;
        _40 = Lt(move _41, const 855638016_u32);
        switchInt(move _40) -> [0: bb24, otherwise: bb21];
    }

    bb21: {
        _43 = _3;
        _42 = Lt(move _43, const 8388608_u32);
        switchInt(move _42) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _48 = _1;
        _49 = _1;
        _47 = Mul(move _48, move _49);
        _46 = &_47;
        _45 = &raw const (*_46);
        _44 = read_volatile::<f32>(move _45) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = _1;
        goto -> bb48;
    }

    bb24: {
        _16 = const 0_i32;
        goto -> bb25;
    }

    bb25: {
        _51 = _1;
        _50 = Mul(const 0.5f32, move _51);
        _53 = _1;
        _52 = Mul(move _53, _50);
        _57 = Mul(_52, const _);
        _56 = Add(const _, move _57);
        _55 = Mul(_52, move _56);
        _54 = Add(const 1f32, move _55);
        _59 = Mul(_54, _50);
        _58 = Sub(const 3f32, move _59);
        _62 = Sub(_54, _58);
        _65 = _1;
        _64 = Mul(move _65, _58);
        _63 = Sub(const 6f32, move _64);
        _61 = Div(move _62, move _63);
        _60 = Mul(_52, move _61);
        _66 = _16;
        switchInt(move _66) -> [0: bb26, otherwise: bb27];
    }

    bb26: {
        _67 = _1;
        _70 = _1;
        _71 = _60;
        _69 = Mul(move _70, move _71);
        _68 = Sub(move _69, _52);
        _0 = Sub(move _67, move _68);
        goto -> bb48;
    }

    bb27: {
        _73 = _1;
        _75 = _60;
        _76 = _19;
        _74 = Sub(move _75, move _76);
        _72 = Mul(move _73, move _74);
        _77 = _19;
        _60 = Sub(move _72, move _77);
        _60 = Sub(_60, _52);
        _78 = _16;
        switchInt(move _78) -> [4294967295: bb28, otherwise: bb29];
    }

    bb28: {
        _81 = _1;
        _82 = _60;
        _80 = Sub(move _81, move _82);
        _79 = Mul(const 0.5f32, move _80);
        _0 = Sub(move _79, const 0.5f32);
        goto -> bb48;
    }

    bb29: {
        _83 = _16;
        switchInt(move _83) -> [1: bb30, otherwise: bb31];
    }

    bb30: {
        _85 = _1;
        _84 = Lt(move _85, const -0.25f32);
        switchInt(move _84) -> [0: bb33, otherwise: bb32];
    }

    bb31: {
        _98 = _16;
        _99 = CheckedAdd(const 127_i32, _98);
        assert(!move (_99.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_i32, move _98) -> [success: bb34, unwind unreachable];
    }

    bb32: {
        _87 = _60;
        _89 = _1;
        _88 = Add(move _89, const 0.5f32);
        _86 = Sub(move _87, move _88);
        _0 = Mul(const -2f32, move _86);
        goto -> bb48;
    }

    bb33: {
        _92 = _1;
        _93 = _60;
        _91 = Sub(move _92, move _93);
        _90 = Mul(const 2f32, move _91);
        _0 = Add(const 1f32, move _90);
        goto -> bb48;
    }

    bb34: {
        _97 = move (_99.0: i32);
        _100 = const 23_i32 as u32 (IntToInt);
        _101 = Lt(move _100, const 32_u32);
        assert(move _101, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _96 = Shl(move _97, const 23_i32);
        _95 = move _96 as u32 (IntToInt);
        _94 = f32::<impl f32>::from_bits(move _95) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _103 = _16;
        _102 = Lt(move _103, const 0_i32);
        switchInt(move _102) -> [0: bb37, otherwise: bb38];
    }

    bb37: {
        _105 = _16;
        _104 = Gt(move _105, const 56_i32);
        switchInt(move _104) -> [0: bb42, otherwise: bb38];
    }

    bb38: {
        _108 = _1;
        _109 = _60;
        _107 = Sub(move _108, move _109);
        _106 = Add(move _107, const 1f32);
        _110 = _16;
        switchInt(move _110) -> [128: bb39, otherwise: bb40];
    }

    bb39: {
        _112 = _106;
        _111 = Mul(move _112, const 2f32);
        _106 = Mul(move _111, _2);
        goto -> bb41;
    }

    bb40: {
        _113 = _106;
        _106 = Mul(move _113, _94);
        goto -> bb41;
    }

    bb41: {
        _114 = _106;
        _0 = Sub(move _114, const 1f32);
        goto -> bb48;
    }

    bb42: {
        _119 = _16;
        _120 = CheckedSub(const 127_i32, _119);
        assert(!move (_120.1: bool), "attempt to compute `{} - {}`, which would overflow", const 127_i32, move _119) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _118 = move (_120.0: i32);
        _121 = const 23_i32 as u32 (IntToInt);
        _122 = Lt(move _121, const 32_u32);
        assert(move _122, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _117 = Shl(move _118, const 23_i32);
        _116 = move _117 as u32 (IntToInt);
        _115 = f32::<impl f32>::from_bits(move _116) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _124 = _16;
        _123 = Lt(move _124, const 23_i32);
        switchInt(move _123) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _127 = _1;
        _128 = _60;
        _126 = Sub(move _127, move _128);
        _129 = Sub(const 1f32, _115);
        _125 = Add(move _126, move _129);
        _0 = Mul(move _125, _94);
        goto -> bb48;
    }

    bb47: {
        _132 = _1;
        _134 = _60;
        _133 = Add(move _134, _115);
        _131 = Sub(move _132, move _133);
        _130 = Add(move _131, const 1f32);
        _0 = Mul(move _130, _94);
        goto -> bb48;
    }

    bb48: {
        return;
    }
}

fn fabs(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: bool;

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = Eq(const 2_u64, const 0_u64);
        assert(!move _5, "attempt to divide `{}` by zero", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Div(const _, const 2_u64);
        _2 = BitAnd(move _3, move _4);
        _0 = f64::<impl f64>::from_bits(move _2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn fabsf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _3: u32;

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, const 2147483647_u32);
        _0 = f32::<impl f32>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn fdim(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _3 = f64::<impl f64>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _1;
        goto -> bb9;
    }

    bb3: {
        _4 = f64::<impl f64>::is_nan(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _2;
        goto -> bb9;
    }

    bb6: {
        _5 = Gt(_1, _2);
        switchInt(move _5) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Sub(_1, _2);
        goto -> bb9;
    }

    bb8: {
        _0 = const 0f64;
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn fdimf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _3 = f32::<impl f32>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _1;
        goto -> bb9;
    }

    bb3: {
        _4 = f32::<impl f32>::is_nan(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _2;
        goto -> bb9;
    }

    bb6: {
        _5 = Gt(_1, _2);
        switchInt(move _5) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Sub(_1, _2);
        goto -> bb9;
    }

    bb8: {
        _0 = const 0f32;
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

const floor::TOINT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Div(const 1f64, const _);
        return;
    }
}

fn floor(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: i32;
    let mut _10: (i32, bool);
    let mut _11: bool;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: bool;
    let _21: f64;
    let mut _22: *const f64;
    let _23: &f64;
    let mut _24: u64;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    scope 1 {
        debug ui => _2;
        let _3: i32;
        scope 2 {
            debug e => _3;
            let _12: f64;
            scope 3 {
                debug y => _12;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 52_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_2, const 52_i32);
        _4 = BitAnd(move _5, const 2047_u64);
        _3 = move _4 as i32 (IntToInt);
        _10 = CheckedAdd(const 1023_i32, const 52_i32);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = move (_10.0: i32);
        _8 = Ge(_3, move _9);
        switchInt(move _8) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _11 = Eq(_1, const 0f64);
        switchInt(move _11) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _1;
        goto -> bb19;
    }

    bb6: {
        _14 = const 63_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _13 = Shr(_2, const 63_i32);
        switchInt(move _13) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _17 = Sub(_1, const _);
        _16 = Add(move _17, const _);
        _12 = Sub(move _16, _1);
        goto -> bb10;
    }

    bb9: {
        _19 = Add(_1, const _);
        _18 = Sub(move _19, const _);
        _12 = Sub(move _18, _1);
        goto -> bb10;
    }

    bb10: {
        _20 = Lt(_3, const 1023_i32);
        switchInt(move _20) -> [0: bb16, otherwise: bb11];
    }

    bb11: {
        _23 = &_12;
        _22 = &raw const (*_23);
        _21 = read_volatile::<f64>(move _22) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _25 = const 63_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 64_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _24 = Shr(_2, const 63_i32);
        switchInt(move _24) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = const -1f64;
        goto -> bb19;
    }

    bb15: {
        _0 = const 0f64;
        goto -> bb19;
    }

    bb16: {
        _28 = _12;
        _27 = Gt(move _28, const 0f64);
        switchInt(move _27) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _30 = _12;
        _29 = Add(_1, move _30);
        _0 = Sub(move _29, const 1f64);
        goto -> bb19;
    }

    bb18: {
        _31 = _12;
        _0 = Add(_1, move _31);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn floorf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _4: i32;
    let mut _5: i32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: (i32, bool);
    let mut _11: bool;
    let mut _12: bool;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let _18: f32;
    let mut _19: *const f32;
    let _20: &f32;
    let _21: f32;
    let mut _22: f32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: (u32, bool);
    let mut _28: u32;
    let _29: f32;
    let mut _30: *const f32;
    let _31: &f32;
    let _32: f32;
    let mut _33: f32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: u32;
    scope 1 {
        debug ui => _2;
        let _3: i32;
        scope 2 {
            debug e => _3;
            let _13: u32;
            scope 3 {
                debug m => _13;
                scope 4 {
                }
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = _2;
        _8 = const 23_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _6 = Shr(move _7, const 23_i32);
        _5 = move _6 as i32 (IntToInt);
        _4 = BitAnd(move _5, const 255_i32);
        _10 = CheckedSub(_4, const 127_i32);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", move _4, const 127_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _3 = move (_10.0: i32);
        _11 = Ge(_3, const 23_i32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = _1;
        goto -> bb25;
    }

    bb5: {
        _12 = Ge(_3, const 0_i32);
        switchInt(move _12) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _14 = _3 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", _3) -> [success: bb8, unwind unreachable];
    }

    bb7: {
        _33 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb17, unwind unreachable];
    }

    bb8: {
        _13 = Shr(const 8388607_u32, _3);
        _17 = _2;
        _16 = BitAnd(move _17, _13);
        switchInt(move _16) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _0 = _1;
        goto -> bb25;
    }

    bb10: {
        _22 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = Add(_1, move _22);
        _20 = &_21;
        _19 = &raw const (*_20);
        _18 = read_volatile::<f32>(move _19) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _24 = _2;
        _25 = const 31_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 32_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _23 = Shr(move _24, const 31_i32);
        switchInt(move _23) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _27 = CheckedAdd(_2, _13);
        assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, _13) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move (_27.0: u32);
        goto -> bb16;
    }

    bb16: {
        _28 = Not(_13);
        _2 = BitAnd(_2, move _28);
        goto -> bb24;
    }

    bb17: {
        _32 = Add(_1, move _33);
        _31 = &_32;
        _30 = &raw const (*_31);
        _29 = read_volatile::<f32>(move _30) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _35 = _2;
        _36 = const 31_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 32_u32);
        assert(move _37, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _34 = Shr(move _35, const 31_i32);
        switchInt(move _34) -> [0: bb20, otherwise: bb21];
    }

    bb20: {
        _2 = const 0_u32;
        goto -> bb24;
    }

    bb21: {
        _39 = _2;
        _40 = const 1_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 32_u32);
        assert(move _41, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _38 = Shl(move _39, const 1_i32);
        switchInt(move _38) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _0 = const -1f32;
        goto -> bb25;
    }

    bb24: {
        _42 = _2;
        _0 = f32::<impl f32>::from_bits(move _42) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        return;
    }
}

const ZEROINFNAN: i32 = {
    let mut _0: i32;
    let mut _1: i32;
    let mut _2: i32;
    let mut _3: (i32, bool);
    let mut _4: (i32, bool);
    let mut _5: (i32, bool);

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _3 = CheckedSub(const 2047_i32, const 1023_i32);
        assert(!move (_3.1: bool), "attempt to compute `{} - {}`, which would overflow", const 2047_i32, const 1023_i32) -> [success: bb1, unwind: bb4];
    }

    bb1: {
        _2 = move (_3.0: i32);
        _4 = CheckedSub(_2, const 52_i32);
        assert(!move (_4.1: bool), "attempt to compute `{} - {}`, which would overflow", move _2, const 52_i32) -> [success: bb2, unwind: bb4];
    }

    bb2: {
        _1 = move (_4.0: i32);
        StorageDead(_2);
        _5 = CheckedSub(_1, const 1_i32);
        assert(!move (_5.1: bool), "attempt to compute `{} - {}`, which would overflow", move _1, const 1_i32) -> [success: bb3, unwind: bb4];
    }

    bb3: {
        _0 = move (_5.0: i32);
        StorageDead(_1);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}

fn normalize(_1: f64) -> fma::Num {
    debug x => _1;
    let mut _0: math::libm::fma::Num;
    let _2: f64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _10: i32;
    let mut _11: i32;
    let mut _12: u64;
    let mut _13: f64;
    let mut _14: i32;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: i32;
    let mut _20: i32;
    let mut _21: i32;
    let mut _22: (i32, bool);
    let mut _23: u64;
    let mut _24: u64;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: (u64, bool);
    let mut _28: u64;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: i32;
    let mut _34: i32;
    let mut _35: (i32, bool);
    let mut _36: (i32, bool);
    let mut _37: (i32, bool);
    let mut _38: u64;
    let mut _39: i32;
    scope 1 {
        debug x1p63 => _2;
        let mut _3: u64;
        scope 2 {
            debug ix => _3;
            let mut _4: i32;
            scope 3 {
                debug e => _4;
                let _9: i32;
                scope 4 {
                    debug sign => _9;
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4890909195324358656_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = _3;
        _7 = const 52_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(move _6, const 52_i32);
        _4 = move _5 as i32 (IntToInt);
        _10 = _4;
        _9 = BitAnd(move _10, const 2048_i32);
        _4 = BitAnd(_4, const 2047_i32);
        _11 = _4;
        switchInt(move _11) -> [0: bb4, otherwise: bb11];
    }

    bb4: {
        _13 = Mul(_1, _2);
        _12 = f64::<impl f64>::to_bits(move _13) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _3 = move _12;
        _16 = _3;
        _17 = const 52_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _15 = Shr(move _16, const 52_i32);
        _14 = move _15 as i32 (IntToInt);
        _4 = BitAnd(move _14, const 2047_i32);
        _20 = _4;
        switchInt(move _20) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _21 = _4;
        _22 = CheckedSub(_21, const 63_i32);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", move _21, const 63_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _19 = move (_22.0: i32);
        goto -> bb10;
    }

    bb9: {
        _19 = const 2048_i32;
        goto -> bb10;
    }

    bb10: {
        _4 = move _19;
        goto -> bb11;
    }

    bb11: {
        _25 = const 52_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 64_u32);
        assert(move _26, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _24 = Shl(const 1_u64, const 52_i32);
        _27 = CheckedSub(_24, const 1_u64);
        assert(!move (_27.1: bool), "attempt to compute `{} - {}`, which would overflow", move _24, const 1_u64) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _23 = move (_27.0: u64);
        _3 = BitAnd(_3, move _23);
        _29 = const 52_i32 as u32 (IntToInt);
        _30 = Lt(move _29, const 64_u32);
        assert(move _30, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _28 = Shl(const 1_u64, const 52_i32);
        _3 = BitOr(_3, move _28);
        _31 = const 1_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 64_u32);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _3 = Shl(_3, const 1_i32);
        _35 = CheckedAdd(const 1023_i32, const 52_i32);
        assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, const 52_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _34 = move (_35.0: i32);
        _36 = CheckedAdd(_34, const 1_i32);
        assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", move _34, const 1_i32) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _33 = move (_36.0: i32);
        _37 = CheckedSub(_4, _33);
        assert(!move (_37.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, move _33) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _4 = move (_37.0: i32);
        _38 = _3;
        _39 = _4;
        _0 = fma::Num { m: move _38, e: move _39, sign: _9 };
        return;
    }
}

fn fma::mul(_1: u64, _2: u64) -> (u64, u64) {
    debug x => _1;
    debug y => _2;
    let mut _0: (u64, u64);
    let _3: u128;
    let mut _4: u128;
    let mut _5: u128;
    let mut _6: u64;
    let mut _7: u128;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u64;
    scope 1 {
        debug t => _3;
    }

    bb0: {
        _4 = _1 as u128 (IntToInt);
        _5 = _2 as u128 (IntToInt);
        _3 = rustc_std_workspace_core::num::<impl u128>::wrapping_mul(move _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = const 64_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 128_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 64_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Shr(_3, const 64_i32);
        _6 = move _7 as u64 (IntToInt);
        _10 = _3 as u64 (IntToInt);
        _0 = (move _6, move _10);
        return;
    }
}

fn fma(_1: f64, _2: f64, _3: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    debug z => _3;
    let mut _0: f64;
    let _4: f64;
    let mut _9: bool;
    let mut _10: i32;
    let mut _11: bool;
    let mut _12: i32;
    let mut _13: f64;
    let mut _14: bool;
    let mut _15: i32;
    let mut _16: bool;
    let mut _17: i32;
    let mut _18: f64;
    let mut _23: (u64, u64);
    let mut _24: u64;
    let mut _25: u64;
    let mut _27: i32;
    let mut _28: i32;
    let mut _29: (i32, bool);
    let mut _31: i32;
    let mut _32: i32;
    let mut _33: (i32, bool);
    let mut _34: bool;
    let mut _35: i32;
    let mut _36: bool;
    let mut _37: i32;
    let mut _38: u64;
    let mut _39: i32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: u64;
    let mut _43: i32;
    let mut _44: i32;
    let mut _45: (i32, bool);
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: u64;
    let mut _49: i32;
    let mut _50: (i32, bool);
    let mut _51: (i32, bool);
    let mut _52: i32;
    let mut _53: bool;
    let mut _54: i32;
    let mut _55: u64;
    let mut _56: u64;
    let mut _57: u64;
    let mut _58: i32;
    let mut _59: i32;
    let mut _60: (i32, bool);
    let mut _61: u32;
    let mut _62: bool;
    let mut _63: u64;
    let mut _64: u64;
    let mut _65: i32;
    let mut _66: u32;
    let mut _67: bool;
    let mut _68: u64;
    let mut _69: bool;
    let mut _70: u64;
    let mut _71: u64;
    let mut _72: i32;
    let mut _73: i32;
    let mut _74: (i32, bool);
    let mut _75: u32;
    let mut _76: bool;
    let mut _77: u64;
    let mut _78: i32;
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: i32;
    let mut _82: bool;
    let mut _83: i32;
    let mut _84: u64;
    let mut _85: bool;
    let mut _86: i32;
    let mut _87: u64;
    let mut _88: u64;
    let mut _89: i32;
    let mut _90: u32;
    let mut _91: bool;
    let mut _92: u64;
    let mut _93: bool;
    let mut _94: u64;
    let mut _95: u64;
    let mut _96: i32;
    let mut _97: i32;
    let mut _98: (i32, bool);
    let mut _99: u32;
    let mut _100: bool;
    let mut _102: i32;
    let mut _103: i32;
    let mut _105: i32;
    let mut _106: i32;
    let mut _107: i32;
    let mut _109: u64;
    let mut _110: u64;
    let mut _111: u64;
    let mut _112: u64;
    let mut _113: u64;
    let mut _114: u64;
    let mut _115: bool;
    let mut _116: u64;
    let mut _117: u64;
    let mut _118: (u64, bool);
    let mut _119: (u64, bool);
    let mut _122: (u64, bool);
    let mut _123: u64;
    let mut _124: u64;
    let mut _125: u64;
    let mut _126: u64;
    let mut _127: u64;
    let mut _128: u64;
    let mut _129: u64;
    let mut _130: u64;
    let mut _131: u64;
    let mut _132: u32;
    let mut _133: bool;
    let mut _134: i64;
    let mut _135: i64;
    let mut _136: u64;
    let mut _137: u64;
    let mut _138: i64;
    let mut _139: i64;
    let mut _140: u64;
    let mut _141: u64;
    let mut _142: bool;
    let mut _143: u64;
    let mut _144: (u64, bool);
    let mut _145: bool;
    let mut _146: i32;
    let mut _147: bool;
    let mut _148: u64;
    let mut _149: i32;
    let mut _150: (i32, bool);
    let mut _151: i32;
    let mut _152: u32;
    let mut _153: u64;
    let mut _154: (i32, bool);
    let mut _155: u64;
    let mut _156: u64;
    let mut _157: u64;
    let mut _158: i32;
    let mut _159: u32;
    let mut _160: bool;
    let mut _161: u64;
    let mut _162: u64;
    let mut _163: i32;
    let mut _164: i32;
    let mut _165: (i32, bool);
    let mut _166: u32;
    let mut _167: bool;
    let mut _168: u64;
    let mut _169: bool;
    let mut _170: u64;
    let mut _171: u64;
    let mut _172: i32;
    let mut _173: u32;
    let mut _174: bool;
    let mut _175: u64;
    let mut _176: i32;
    let mut _177: u32;
    let mut _178: u64;
    let mut _179: (i32, bool);
    let mut _180: bool;
    let mut _181: i32;
    let mut _182: u64;
    let mut _183: u64;
    let mut _184: u32;
    let mut _185: bool;
    let mut _186: u64;
    let mut _187: u64;
    let mut _188: u64;
    let mut _189: i32;
    let mut _190: u32;
    let mut _191: bool;
    let mut _192: f64;
    let mut _193: i32;
    let mut _194: (i32, bool);
    let mut _196: u64;
    let mut _197: i32;
    let mut _198: i64;
    let mut _199: bool;
    let mut _201: i64;
    let mut _202: bool;
    let mut _203: i32;
    let mut _204: i32;
    let mut _205: (i32, bool);
    let mut _206: bool;
    let mut _207: i32;
    let mut _208: i32;
    let mut _209: (i32, bool);
    let mut _211: i32;
    let mut _212: f64;
    let mut _213: bool;
    let mut _214: f64;
    let mut _215: f64;
    let mut _217: f64;
    let mut _218: f64;
    let mut _219: f64;
    let mut _220: f64;
    let mut _221: f64;
    let mut _222: f64;
    let mut _223: f64;
    let mut _224: u64;
    let mut _225: u64;
    let mut _226: u32;
    let mut _227: bool;
    let mut _228: u64;
    let mut _229: u64;
    let mut _230: u64;
    let mut _231: u64;
    let mut _232: u32;
    let mut _233: bool;
    let mut _234: u64;
    let mut _235: u64;
    let mut _236: u64;
    let mut _237: u32;
    let mut _238: bool;
    let mut _239: i32;
    let mut _240: i64;
    let mut _241: bool;
    let mut _242: i64;
    let mut _243: f64;
    let mut _244: f64;
    let mut _245: f64;
    let mut _247: f64;
    let mut _248: f64;
    let mut _249: f64;
    let mut _250: f64;
    let mut _251: f64;
    let mut _252: f64;
    let mut _253: f64;
    let mut _254: f64;
    let mut _255: u64;
    let mut _256: u64;
    let mut _257: u64;
    let mut _258: u64;
    let mut _259: i32;
    let mut _260: u32;
    let mut _261: bool;
    let mut _262: u64;
    let mut _263: bool;
    let mut _264: u64;
    let mut _265: u64;
    let mut _266: i32;
    let mut _267: i32;
    let mut _268: (i32, bool);
    let mut _269: u32;
    let mut _270: bool;
    let mut _271: i32;
    let mut _272: u32;
    let mut _273: bool;
    let mut _274: i32;
    let mut _275: i64;
    let mut _276: bool;
    let mut _277: i64;
    let mut _278: f64;
    let mut _279: i32;
    scope 1 {
        debug x1p63 => _4;
        let _5: f64;
        scope 2 {
            debug x0_ffffff8p_63 => _5;
            let _6: math::libm::fma::Num;
            scope 3 {
                debug nx => _6;
                let _7: math::libm::fma::Num;
                scope 4 {
                    debug ny => _7;
                    let _8: math::libm::fma::Num;
                    scope 5 {
                        debug nz => _8;
                        let _19: u64;
                        scope 6 {
                            debug zhi => _19;
                            let _20: u64;
                            scope 7 {
                                debug zlo => _20;
                                let mut _21: u64;
                                let mut _22: u64;
                                scope 8 {
                                    debug rhi => _21;
                                    debug rlo => _22;
                                    let mut _26: i32;
                                    scope 9 {
                                        debug e => _26;
                                        let mut _30: i32;
                                        scope 10 {
                                            debug d => _30;
                                            let mut _101: i32;
                                            scope 11 {
                                                debug sign => _101;
                                                let _104: bool;
                                                scope 12 {
                                                    debug samesign => _104;
                                                    let mut _108: i32;
                                                    scope 13 {
                                                        debug nonzero => _108;
                                                        let _120: u64;
                                                        let _121: bool;
                                                        let mut _195: i64;
                                                        scope 14 {
                                                            debug res => _120;
                                                            debug borrow => _121;
                                                        }
                                                        scope 15 {
                                                            debug i => _195;
                                                            let mut _200: f64;
                                                            scope 16 {
                                                                debug r => _200;
                                                                let mut _210: f64;
                                                                scope 17 {
                                                                    debug c => _210;
                                                                    let _216: f32;
                                                                    let _246: f64;
                                                                    scope 18 {
                                                                        debug fltmin => _216;
                                                                    }
                                                                    scope 19 {
                                                                        debug tiny => _246;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = f64::<impl f64>::from_bits(const 4890909195324358656_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = f64::<impl f64>::from_bits(const 4323455642007240704_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = normalize(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = normalize(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = normalize(_3) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _10 = (_6.1: i32);
        _9 = Ge(move _10, const _);
        switchInt(move _9) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        _12 = (_7.1: i32);
        _11 = Ge(move _12, const _);
        switchInt(move _11) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _13 = Mul(_1, _2);
        _0 = Add(move _13, _3);
        goto -> bb104;
    }

    bb8: {
        _15 = (_8.1: i32);
        _14 = Ge(move _15, const _);
        switchInt(move _14) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _17 = (_8.1: i32);
        _16 = Gt(move _17, const _);
        switchInt(move _16) -> [0: bb12, otherwise: bb11];
    }

    bb10: {
        _24 = (_6.0: u64);
        _25 = (_7.0: u64);
        _23 = fma::mul(move _24, move _25) -> [return: bb13, unwind unreachable];
    }

    bb11: {
        _18 = Mul(_1, _2);
        _0 = Add(move _18, _3);
        goto -> bb104;
    }

    bb12: {
        _0 = _3;
        goto -> bb104;
    }

    bb13: {
        _21 = (_23.0: u64);
        _22 = (_23.1: u64);
        _27 = (_6.1: i32);
        _28 = (_7.1: i32);
        _29 = CheckedAdd(_27, _28);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", move _27, move _28) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _26 = move (_29.0: i32);
        _31 = (_8.1: i32);
        _32 = _26;
        _33 = CheckedSub(_31, _32);
        assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", move _31, move _32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _30 = move (_33.0: i32);
        _35 = _30;
        _34 = Gt(move _35, const 0_i32);
        switchInt(move _34) -> [0: bb33, otherwise: bb16];
    }

    bb16: {
        _37 = _30;
        _36 = Lt(move _37, const 64_i32);
        switchInt(move _36) -> [0: bb21, otherwise: bb17];
    }

    bb17: {
        _38 = (_8.0: u64);
        _39 = _30;
        _40 = _39 as u32 (IntToInt);
        _41 = Lt(move _40, const 64_u32);
        assert(move _41, "attempt to shift left by `{}`, which would overflow", _39) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _20 = Shl(move _38, move _39);
        _42 = (_8.0: u64);
        _44 = _30;
        _45 = CheckedSub(const 64_i32, _44);
        assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _44) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _43 = move (_45.0: i32);
        _46 = _43 as u32 (IntToInt);
        _47 = Lt(move _46, const 64_u32);
        assert(move _47, "attempt to shift right by `{}`, which would overflow", _43) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _19 = Shr(move _42, move _43);
        goto -> bb42;
    }

    bb21: {
        _20 = const 0_u64;
        _48 = (_8.0: u64);
        _19 = move _48;
        _49 = (_8.1: i32);
        _50 = CheckedSub(_49, const 64_i32);
        assert(!move (_50.1: bool), "attempt to compute `{} - {}`, which would overflow", move _49, const 64_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _26 = move (_50.0: i32);
        _51 = CheckedSub(_30, const 64_i32);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", _30, const 64_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _30 = move (_51.0: i32);
        _52 = _30;
        switchInt(move _52) -> [0: bb42, otherwise: bb24];
    }

    bb24: {
        _54 = _30;
        _53 = Lt(move _54, const 64_i32);
        switchInt(move _53) -> [0: bb32, otherwise: bb25];
    }

    bb25: {
        _57 = _21;
        _59 = _30;
        _60 = CheckedSub(const 64_i32, _59);
        assert(!move (_60.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _59) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _58 = move (_60.0: i32);
        _61 = _58 as u32 (IntToInt);
        _62 = Lt(move _61, const 64_u32);
        assert(move _62, "attempt to shift left by `{}`, which would overflow", _58) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _56 = Shl(move _57, move _58);
        _64 = _22;
        _65 = _30;
        _66 = _65 as u32 (IntToInt);
        _67 = Lt(move _66, const 64_u32);
        assert(move _67, "attempt to shift right by `{}`, which would overflow", _65) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _63 = Shr(move _64, move _65);
        _55 = BitOr(move _56, move _63);
        _71 = _22;
        _73 = _30;
        _74 = CheckedSub(const 64_i32, _73);
        assert(!move (_74.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _73) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _72 = move (_74.0: i32);
        _75 = _72 as u32 (IntToInt);
        _76 = Lt(move _75, const 64_u32);
        assert(move _76, "attempt to shift left by `{}`, which would overflow", _72) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _70 = Shl(move _71, move _72);
        _69 = Ne(move _70, const 0_u64);
        _68 = move _69 as u64 (IntToInt);
        _22 = BitOr(move _55, move _68);
        _77 = _21;
        _78 = _30;
        _79 = _78 as u32 (IntToInt);
        _80 = Lt(move _79, const 64_u32);
        assert(move _80, "attempt to shift right by `{}`, which would overflow", _78) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _21 = Shr(move _77, move _78);
        goto -> bb42;
    }

    bb32: {
        _22 = const 1_u64;
        _21 = const 0_u64;
        goto -> bb42;
    }

    bb33: {
        _19 = const 0_u64;
        _81 = _30;
        _82 = Eq(_81, const i32::MIN);
        assert(!move _82, "attempt to negate `{}`, which would overflow", _81) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _30 = Neg(move _81);
        _83 = _30;
        switchInt(move _83) -> [0: bb35, otherwise: bb36];
    }

    bb35: {
        _84 = (_8.0: u64);
        _20 = move _84;
        goto -> bb42;
    }

    bb36: {
        _86 = _30;
        _85 = Lt(move _86, const 64_i32);
        switchInt(move _85) -> [0: bb41, otherwise: bb37];
    }

    bb37: {
        _88 = (_8.0: u64);
        _89 = _30;
        _90 = _89 as u32 (IntToInt);
        _91 = Lt(move _90, const 64_u32);
        assert(move _91, "attempt to shift right by `{}`, which would overflow", _89) -> [success: bb38, unwind unreachable];
    }

    bb38: {
        _87 = Shr(move _88, move _89);
        _95 = (_8.0: u64);
        _97 = _30;
        _98 = CheckedSub(const 64_i32, _97);
        assert(!move (_98.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _97) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _96 = move (_98.0: i32);
        _99 = _96 as u32 (IntToInt);
        _100 = Lt(move _99, const 64_u32);
        assert(move _100, "attempt to shift left by `{}`, which would overflow", _96) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _94 = Shl(move _95, move _96);
        _93 = Ne(move _94, const 0_u64);
        _92 = move _93 as u64 (IntToInt);
        _20 = BitOr(move _87, move _92);
        goto -> bb42;
    }

    bb41: {
        _20 = const 1_u64;
        goto -> bb42;
    }

    bb42: {
        _102 = (_6.2: i32);
        _103 = (_7.2: i32);
        _101 = BitXor(move _102, move _103);
        _106 = _101;
        _107 = (_8.2: i32);
        _105 = BitXor(move _106, move _107);
        _104 = Eq(_105, const 0_i32);
        _108 = const 1_i32;
        switchInt(move _105) -> [0: bb43, otherwise: bb47];
    }

    bb43: {
        _110 = _22;
        _111 = _20;
        _109 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(move _110, move _111) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _22 = move _109;
        _113 = _19;
        _116 = _22;
        _117 = _20;
        _115 = Lt(move _116, move _117);
        _114 = move _115 as u64 (IntToInt);
        _118 = CheckedAdd(_113, _114);
        assert(!move (_118.1: bool), "attempt to compute `{} + {}`, which would overflow", move _113, move _114) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _112 = move (_118.0: u64);
        _119 = CheckedAdd(_21, _112);
        assert(!move (_119.1: bool), "attempt to compute `{} + {}`, which would overflow", _21, move _112) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _21 = move (_119.0: u64);
        goto -> bb57;
    }

    bb47: {
        _123 = _22;
        _124 = _20;
        _122 = rustc_std_workspace_core::num::<impl u64>::overflowing_sub(move _123, move _124) -> [return: bb48, unwind unreachable];
    }

    bb48: {
        _120 = (_122.0: u64);
        _121 = (_122.1: bool);
        _22 = _120;
        _126 = _21;
        _128 = _19;
        _129 = _121 as u64 (IntToInt);
        _127 = rustc_std_workspace_core::num::<impl u64>::wrapping_add(move _128, move _129) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _125 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _126, move _127) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _21 = move _125;
        _131 = _21;
        _132 = const 63_i32 as u32 (IntToInt);
        _133 = Lt(move _132, const 64_u32);
        assert(move _133, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb51, unwind unreachable];
    }

    bb51: {
        _130 = Shr(move _131, const 63_i32);
        switchInt(move _130) -> [0: bb56, otherwise: bb52];
    }

    bb52: {
        _136 = _22;
        _135 = move _136 as i64 (IntToInt);
        _134 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _135) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _22 = move _134 as u64 (IntToInt);
        _140 = _21;
        _139 = move _140 as i64 (IntToInt);
        _138 = rustc_std_workspace_core::num::<impl i64>::wrapping_neg(move _139) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _137 = move _138 as u64 (IntToInt);
        _143 = _22;
        _142 = Ne(move _143, const 0_u64);
        _141 = move _142 as u64 (IntToInt);
        _144 = CheckedSub(_137, _141);
        assert(!move (_144.1: bool), "attempt to compute `{} - {}`, which would overflow", move _137, move _141) -> [success: bb55, unwind unreachable];
    }

    bb55: {
        _21 = move (_144.0: u64);
        _146 = _101;
        _145 = Eq(move _146, const 0_i32);
        _101 = move _145 as i32 (IntToInt);
        goto -> bb56;
    }

    bb56: {
        _148 = _21;
        _147 = Ne(move _148, const 0_u64);
        _108 = move _147 as i32 (IntToInt);
        goto -> bb57;
    }

    bb57: {
        _149 = _108;
        switchInt(move _149) -> [0: bb66, otherwise: bb58];
    }

    bb58: {
        _150 = CheckedAdd(_26, const 64_i32);
        assert(!move (_150.1: bool), "attempt to compute `{} + {}`, which would overflow", _26, const 64_i32) -> [success: bb59, unwind unreachable];
    }

    bb59: {
        _26 = move (_150.0: i32);
        _153 = _21;
        _152 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(move _153) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _151 = move _152 as i32 (IntToInt);
        _154 = CheckedSub(_151, const 1_i32);
        assert(!move (_154.1: bool), "attempt to compute `{} - {}`, which would overflow", move _151, const 1_i32) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _30 = move (_154.0: i32);
        _157 = _21;
        _158 = _30;
        _159 = _158 as u32 (IntToInt);
        _160 = Lt(move _159, const 64_u32);
        assert(move _160, "attempt to shift left by `{}`, which would overflow", _158) -> [success: bb62, unwind unreachable];
    }

    bb62: {
        _156 = Shl(move _157, move _158);
        _162 = _22;
        _164 = _30;
        _165 = CheckedSub(const 64_i32, _164);
        assert(!move (_165.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _164) -> [success: bb63, unwind unreachable];
    }

    bb63: {
        _163 = move (_165.0: i32);
        _166 = _163 as u32 (IntToInt);
        _167 = Lt(move _166, const 64_u32);
        assert(move _167, "attempt to shift right by `{}`, which would overflow", _163) -> [success: bb64, unwind unreachable];
    }

    bb64: {
        _161 = Shr(move _162, move _163);
        _155 = BitOr(move _156, move _161);
        _171 = _22;
        _172 = _30;
        _173 = _172 as u32 (IntToInt);
        _174 = Lt(move _173, const 64_u32);
        assert(move _174, "attempt to shift left by `{}`, which would overflow", _172) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _170 = Shl(move _171, move _172);
        _169 = Ne(move _170, const 0_u64);
        _168 = move _169 as u64 (IntToInt);
        _21 = BitOr(move _155, move _168);
        goto -> bb75;
    }

    bb66: {
        _175 = _22;
        switchInt(move _175) -> [0: bb74, otherwise: bb67];
    }

    bb67: {
        _178 = _22;
        _177 = rustc_std_workspace_core::num::<impl u64>::leading_zeros(move _178) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _176 = move _177 as i32 (IntToInt);
        _179 = CheckedSub(_176, const 1_i32);
        assert(!move (_179.1: bool), "attempt to compute `{} - {}`, which would overflow", move _176, const 1_i32) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _30 = move (_179.0: i32);
        _181 = _30;
        _180 = Lt(move _181, const 0_i32);
        switchInt(move _180) -> [0: bb72, otherwise: bb70];
    }

    bb70: {
        _183 = _22;
        _184 = const 1_i32 as u32 (IntToInt);
        _185 = Lt(move _184, const 64_u32);
        assert(move _185, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb71, unwind unreachable];
    }

    bb71: {
        _182 = Shr(move _183, const 1_i32);
        _187 = _22;
        _186 = BitAnd(move _187, const 1_u64);
        _21 = BitOr(move _182, move _186);
        goto -> bb75;
    }

    bb72: {
        _188 = _22;
        _189 = _30;
        _190 = _189 as u32 (IntToInt);
        _191 = Lt(move _190, const 64_u32);
        assert(move _191, "attempt to shift left by `{}`, which would overflow", _189) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _21 = Shl(move _188, move _189);
        goto -> bb75;
    }

    bb74: {
        _192 = Mul(_1, _2);
        _0 = Add(move _192, _3);
        goto -> bb104;
    }

    bb75: {
        _193 = _30;
        _194 = CheckedSub(_26, _193);
        assert(!move (_194.1: bool), "attempt to compute `{} - {}`, which would overflow", _26, move _193) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _26 = move (_194.0: i32);
        _196 = _21;
        _195 = move _196 as i64 (IntToInt);
        _197 = _101;
        switchInt(move _197) -> [0: bb79, otherwise: bb77];
    }

    bb77: {
        _198 = _195;
        _199 = Eq(_198, const i64::MIN);
        assert(!move _199, "attempt to negate `{}`, which would overflow", _198) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _195 = Neg(move _198);
        goto -> bb79;
    }

    bb79: {
        _201 = _195;
        _200 = move _201 as f64 (IntToFloat);
        _203 = _26;
        _205 = CheckedSub(const -1022_i32, const 62_i32);
        assert(!move (_205.1: bool), "attempt to compute `{} - {}`, which would overflow", const -1022_i32, const 62_i32) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _204 = move (_205.0: i32);
        _202 = Lt(move _203, move _204);
        switchInt(move _202) -> [0: bb103, otherwise: bb81];
    }

    bb81: {
        _207 = _26;
        _209 = CheckedSub(const -1022_i32, const 63_i32);
        assert(!move (_209.1: bool), "attempt to compute `{} - {}`, which would overflow", const -1022_i32, const 63_i32) -> [success: bb82, unwind unreachable];
    }

    bb82: {
        _208 = move (_209.0: i32);
        _206 = Eq(move _207, move _208);
        switchInt(move _206) -> [0: bb95, otherwise: bb83];
    }

    bb83: {
        _210 = _4;
        _211 = _101;
        switchInt(move _211) -> [0: bb85, otherwise: bb84];
    }

    bb84: {
        _212 = _210;
        _210 = Neg(move _212);
        goto -> bb85;
    }

    bb85: {
        _214 = _200;
        _215 = _210;
        _213 = Eq(move _214, move _215);
        switchInt(move _213) -> [0: bb87, otherwise: bb86];
    }

    bb86: {
        _219 = const _ as f64 (FloatToFloat);
        _218 = Mul(_5, move _219);
        _220 = _200;
        _217 = Mul(move _218, move _220);
        _216 = move _217 as f32 (FloatToFloat);
        _222 = const _ as f64 (FloatToFloat);
        _221 = Div(const _, move _222);
        _223 = _216 as f64 (FloatToFloat);
        _0 = Mul(move _221, move _223);
        goto -> bb104;
    }

    bb87: {
        _225 = _21;
        _226 = const 53_i32 as u32 (IntToInt);
        _227 = Lt(move _226, const 64_u32);
        assert(move _227, "attempt to shift left by `{}`, which would overflow", const 53_i32) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _224 = Shl(move _225, const 53_i32);
        switchInt(move _224) -> [0: bb103, otherwise: bb89];
    }

    bb89: {
        _231 = _21;
        _232 = const 1_i32 as u32 (IntToInt);
        _233 = Lt(move _232, const 64_u32);
        assert(move _233, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb90, unwind unreachable];
    }

    bb90: {
        _230 = Shr(move _231, const 1_i32);
        _235 = _21;
        _234 = BitAnd(move _235, const 1_u64);
        _229 = BitOr(move _230, move _234);
        _237 = const 62_i32 as u32 (IntToInt);
        _238 = Lt(move _237, const 64_u32);
        assert(move _238, "attempt to shift left by `{}`, which would overflow", const 62_i32) -> [success: bb91, unwind unreachable];
    }

    bb91: {
        _236 = Shl(const 1_u64, const 62_i32);
        _228 = BitOr(move _229, move _236);
        _195 = move _228 as i64 (IntToInt);
        _239 = _101;
        switchInt(move _239) -> [0: bb94, otherwise: bb92];
    }

    bb92: {
        _240 = _195;
        _241 = Eq(_240, const i64::MIN);
        assert(!move _241, "attempt to negate `{}`, which would overflow", _240) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _195 = Neg(move _240);
        goto -> bb94;
    }

    bb94: {
        _242 = _195;
        _200 = move _242 as f64 (IntToFloat);
        _244 = _200;
        _243 = Mul(const 2f64, move _244);
        _245 = _210;
        _200 = Sub(move _243, move _245);
        _248 = const _ as f64 (FloatToFloat);
        _247 = Div(const _, move _248);
        _249 = _200;
        _246 = Mul(move _247, move _249);
        _251 = Mul(_246, _246);
        _253 = _200;
        _254 = _200;
        _252 = Sub(move _253, move _254);
        _250 = Mul(move _251, move _252);
        _200 = Add(_200, move _250);
        goto -> bb103;
    }

    bb95: {
        _30 = const 10_i32;
        _258 = _21;
        _259 = _30;
        _260 = _259 as u32 (IntToInt);
        _261 = Lt(move _260, const 64_u32);
        assert(move _261, "attempt to shift right by `{}`, which would overflow", _259) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _257 = Shr(move _258, move _259);
        _265 = _21;
        _267 = _30;
        _268 = CheckedSub(const 64_i32, _267);
        assert(!move (_268.1: bool), "attempt to compute `{} - {}`, which would overflow", const 64_i32, move _267) -> [success: bb97, unwind unreachable];
    }

    bb97: {
        _266 = move (_268.0: i32);
        _269 = _266 as u32 (IntToInt);
        _270 = Lt(move _269, const 64_u32);
        assert(move _270, "attempt to shift left by `{}`, which would overflow", _266) -> [success: bb98, unwind unreachable];
    }

    bb98: {
        _264 = Shl(move _265, move _266);
        _263 = Ne(move _264, const 0_u64);
        _262 = move _263 as u64 (IntToInt);
        _256 = BitOr(move _257, move _262);
        _271 = _30;
        _272 = _271 as u32 (IntToInt);
        _273 = Lt(move _272, const 64_u32);
        assert(move _273, "attempt to shift left by `{}`, which would overflow", _271) -> [success: bb99, unwind unreachable];
    }

    bb99: {
        _255 = Shl(move _256, move _271);
        _195 = move _255 as i64 (IntToInt);
        _274 = _101;
        switchInt(move _274) -> [0: bb102, otherwise: bb100];
    }

    bb100: {
        _275 = _195;
        _276 = Eq(_275, const i64::MIN);
        assert(!move _276, "attempt to negate `{}`, which would overflow", _275) -> [success: bb101, unwind unreachable];
    }

    bb101: {
        _195 = Neg(move _275);
        goto -> bb102;
    }

    bb102: {
        _277 = _195;
        _200 = move _277 as f64 (IntToFloat);
        goto -> bb103;
    }

    bb103: {
        _278 = _200;
        _279 = _26;
        _0 = scalbn(move _278, move _279) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        return;
    }
}

fn fmaf(_1: f32, _2: f32, _3: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    debug z => _3;
    let mut _0: f32;
    let _4: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f32;
    let mut _12: u64;
    let mut _13: f64;
    let mut _14: i32;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: bool;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f32;
    let mut _26: bool;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f32;
    let mut _31: bool;
    let mut _32: i32;
    let mut _33: bool;
    let mut _34: i32;
    let mut _35: (i32, bool);
    let mut _36: bool;
    let mut _37: i32;
    let mut _38: (i32, bool);
    let mut _39: i32;
    let _40: i32;
    let mut _42: *const f32;
    let _43: &f32;
    let mut _44: f64;
    let mut _45: i32;
    let _46: i32;
    let _47: i32;
    let mut _48: f64;
    let mut _50: u64;
    let mut _51: u64;
    let mut _52: u32;
    let mut _53: bool;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: f64;
    let mut _58: f32;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f32;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f32;
    let mut _66: f64;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: f64;
    let mut _70: (u64, bool);
    let mut _71: (u64, bool);
    let mut _72: f64;
    let mut _73: u64;
    scope 1 {
        debug xy => _4;
        let mut _5: f64;
        scope 2 {
            debug result => _5;
            let mut _6: u64;
            scope 3 {
                debug ui => _6;
                let _7: i32;
                scope 4 {
                    debug e => _7;
                    let _41: f32;
                    let _49: bool;
                    scope 5 {
                        debug vz => _41;
                    }
                    scope 6 {
                    }
                    scope 7 {
                        debug neg => _49;
                        let _54: f64;
                        scope 8 {
                            debug err => _54;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = _1 as f64 (FloatToFloat);
        _9 = _2 as f64 (FloatToFloat);
        _4 = Mul(move _8, move _9);
        _11 = _3;
        _10 = move _11 as f64 (FloatToFloat);
        _5 = Add(_4, move _10);
        _13 = _5;
        _12 = f64::<impl f64>::to_bits(move _13) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _12;
        _16 = _6;
        _17 = const 52_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _15 = Shr(move _16, const 52_i32);
        _14 = move _15 as i32 (IntToInt);
        _7 = BitAnd(move _14, const 2047_i32);
        _20 = _6;
        _19 = BitAnd(move _20, const 536870911_u64);
        switchInt(move _19) -> [268435456: bb3, otherwise: bb8];
    }

    bb3: {
        switchInt(move _7) -> [2047: bb8, otherwise: bb4];
    }

    bb4: {
        _23 = _5;
        _22 = Sub(move _23, _4);
        _25 = _3;
        _24 = move _25 as f64 (FloatToFloat);
        _21 = Eq(move _22, move _24);
        switchInt(move _21) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _28 = _5;
        _30 = _3;
        _29 = move _30 as f64 (FloatToFloat);
        _27 = Sub(move _28, move _29);
        _26 = Eq(move _27, _4);
        switchInt(move _26) -> [0: bb6, otherwise: bb8];
    }

    bb6: {
        _32 = fegetround() -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _31 = Ne(move _32, const _);
        switchInt(move _31) -> [0: bb21, otherwise: bb8];
    }

    bb8: {
        _35 = CheckedSub(const 1023_i32, const 126_i32);
        assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_i32, const 126_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _34 = move (_35.0: i32);
        _33 = Lt(_7, move _34);
        switchInt(move _33) -> [0: bb20, otherwise: bb10];
    }

    bb10: {
        _38 = CheckedSub(const 1023_i32, const 149_i32);
        assert(!move (_38.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_i32, const 149_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _37 = move (_38.0: i32);
        _36 = Ge(_7, move _37);
        switchInt(move _36) -> [0: bb20, otherwise: bb12];
    }

    bb12: {
        _39 = fetestexcept(const _) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        switchInt(move _39) -> [0: bb20, otherwise: bb14];
    }

    bb14: {
        _40 = feclearexcept(const _) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _43 = &_3;
        _42 = &raw const (*_43);
        _41 = read_volatile::<f32>(move _42) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _44 = _41 as f64 (FloatToFloat);
        _5 = Add(_4, move _44);
        _45 = fetestexcept(const _) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        switchInt(move _45) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _46 = feraiseexcept(const _) -> [return: bb20, unwind unreachable];
    }

    bb19: {
        _47 = feraiseexcept(const _) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _48 = _5;
        _3 = move _48 as f32 (FloatToFloat);
        _0 = _3;
        goto -> bb32;
    }

    bb21: {
        _51 = _6;
        _52 = const 63_i32 as u32 (IntToInt);
        _53 = Lt(move _52, const 64_u32);
        assert(move _53, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _50 = Shr(move _51, const 63_i32);
        _49 = Ne(move _50, const 0_u64);
        _58 = _3;
        _57 = move _58 as f64 (FloatToFloat);
        _56 = Gt(move _57, _4);
        _55 = Eq(_49, move _56);
        switchInt(move _55) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _60 = _5;
        _59 = Sub(_4, move _60);
        _62 = _3;
        _61 = move _62 as f64 (FloatToFloat);
        _54 = Add(move _59, move _61);
        goto -> bb25;
    }

    bb24: {
        _65 = _3;
        _64 = move _65 as f64 (FloatToFloat);
        _66 = _5;
        _63 = Sub(move _64, move _66);
        _54 = Add(move _63, _4);
        goto -> bb25;
    }

    bb25: {
        _69 = _54;
        _68 = Lt(move _69, const 0f64);
        _67 = Eq(_49, move _68);
        switchInt(move _67) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _70 = CheckedAdd(_6, const 1_u64);
        assert(!move (_70.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_u64) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _6 = move (_70.0: u64);
        goto -> bb30;
    }

    bb28: {
        _71 = CheckedSub(_6, const 1_u64);
        assert(!move (_71.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_u64) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _6 = move (_71.0: u64);
        goto -> bb30;
    }

    bb30: {
        _73 = _6;
        _72 = f64::<impl f64>::from_bits(move _73) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _0 = move _72 as f32 (FloatToFloat);
        goto -> bb32;
    }

    bb32: {
        return;
    }
}

fn libm::fmax::fmax(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: f64;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _4 = f64::<impl f64>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = Lt(_1, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = _2;
        goto -> bb5;
    }

    bb4: {
        _3 = _1;
        goto -> bb5;
    }

    bb5: {
        _0 = Mul(move _3, const 1f64);
        return;
    }
}

fn libm::fmaxf::fmaxf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: f32;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _4 = f32::<impl f32>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = Lt(_1, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = _2;
        goto -> bb5;
    }

    bb4: {
        _3 = _1;
        goto -> bb5;
    }

    bb5: {
        _0 = Mul(move _3, const 1f32);
        return;
    }
}

fn libm::fmin::fmin(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: f64;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _4 = f64::<impl f64>::is_nan(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = Lt(_1, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = _1;
        goto -> bb5;
    }

    bb4: {
        _3 = _2;
        goto -> bb5;
    }

    bb5: {
        _0 = Mul(move _3, const 1f64);
        return;
    }
}

fn libm::fminf::fminf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: f32;
    let mut _4: bool;
    let mut _5: bool;

    bb0: {
        _4 = f32::<impl f32>::is_nan(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _4) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = Lt(_1, _2);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = _1;
        goto -> bb5;
    }

    bb4: {
        _3 = _2;
        goto -> bb5;
    }

    bb5: {
        _0 = Mul(move _3, const 1f32);
        return;
    }
}

fn libm::fmod::fmod(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: u64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u32;
    let mut _16: bool;
    let mut _18: u64;
    let mut _19: u32;
    let mut _20: bool;
    let mut _22: u64;
    let mut _23: u64;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: i64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: bool;
    let mut _31: u64;
    let mut _32: u64;
    let mut _33: u32;
    let mut _34: bool;
    let mut _35: u64;
    let mut _36: u64;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: bool;
    let mut _40: u64;
    let mut _41: u64;
    let mut _42: u32;
    let mut _43: bool;
    let mut _44: u64;
    let mut _45: u64;
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: i64;
    let mut _49: u64;
    let mut _50: u32;
    let mut _51: bool;
    let mut _52: u64;
    let mut _53: u64;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: (i64, bool);
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: i64;
    let mut _60: i64;
    let mut _61: i64;
    let mut _62: bool;
    let mut _63: (i64, bool);
    let mut _64: u64;
    let mut _65: bool;
    let mut _66: u64;
    let mut _67: u32;
    let mut _68: bool;
    let mut _69: u64;
    let mut _70: u32;
    let mut _71: bool;
    let mut _72: i64;
    let mut _73: u64;
    let mut _74: u32;
    let mut _75: bool;
    let mut _76: u64;
    let mut _77: u64;
    let mut _78: u32;
    let mut _79: bool;
    let mut _80: (i64, bool);
    let mut _81: u32;
    let mut _82: bool;
    let mut _83: i64;
    let mut _84: i64;
    let mut _85: i64;
    let mut _86: bool;
    let mut _87: (i64, bool);
    let mut _88: u64;
    let mut _89: bool;
    let mut _90: u64;
    let mut _91: u32;
    let mut _92: bool;
    let mut _93: u64;
    let mut _94: u32;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: i64;
    let mut _98: i64;
    let mut _99: u64;
    let mut _100: u64;
    let mut _101: u64;
    let mut _102: u64;
    let mut _103: u64;
    let mut _104: u32;
    let mut _105: bool;
    let mut _106: u64;
    let mut _107: u64;
    let mut _108: u32;
    let mut _109: bool;
    let mut _110: (i64, bool);
    let mut _111: u64;
    let mut _112: u64;
    let mut _113: u64;
    let mut _114: u64;
    let mut _115: u64;
    let mut _116: u32;
    let mut _117: bool;
    let mut _118: u64;
    let mut _119: u64;
    let mut _120: u64;
    let mut _121: u64;
    let mut _122: u32;
    let mut _123: bool;
    let mut _124: u32;
    let mut _125: bool;
    let mut _126: (i64, bool);
    let mut _127: bool;
    let mut _128: i64;
    let mut _129: u64;
    let mut _130: u32;
    let mut _131: bool;
    let mut _132: (u64, bool);
    let mut _133: u64;
    let mut _134: u64;
    let mut _135: i64;
    let mut _136: u32;
    let mut _137: bool;
    let mut _138: i64;
    let mut _139: i64;
    let mut _140: i64;
    let mut _141: bool;
    let mut _142: (i64, bool);
    let mut _143: u64;
    let mut _144: bool;
    let mut _145: u64;
    let mut _146: u32;
    let mut _147: bool;
    let mut _148: u64;
    scope 1 {
        debug uxi => _3;
        let mut _4: u64;
        scope 2 {
            debug uyi => _4;
            let mut _5: i64;
            scope 3 {
                debug ex => _5;
                let mut _11: i64;
                scope 4 {
                    debug ey => _11;
                    let _17: u64;
                    scope 5 {
                        debug sx => _17;
                        let mut _21: u64;
                        scope 6 {
                            debug i => _21;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f64::<impl f64>::to_bits(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = _3;
        _9 = const 52_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Shr(move _8, const 52_i32);
        _6 = BitAnd(move _7, const 2047_u64);
        _5 = move _6 as i64 (IntToInt);
        _14 = _4;
        _15 = const 52_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 64_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = Shr(move _14, const 52_i32);
        _12 = BitAnd(move _13, const 2047_u64);
        _11 = move _12 as i64 (IntToInt);
        _18 = _3;
        _19 = const 63_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 64_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _17 = Shr(move _18, const 63_i32);
        _23 = _4;
        _24 = const 1_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 64_u32);
        assert(move _25, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _22 = Shl(move _23, const 1_i32);
        switchInt(move _22) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _26 = f64::<impl f64>::is_nan(_2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        switchInt(move _26) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _27 = _5;
        switchInt(move _27) -> [2047: bb10, otherwise: bb11];
    }

    bb10: {
        _28 = Mul(_1, _2);
        _29 = Mul(_1, _2);
        _0 = Div(move _28, move _29);
        goto -> bb81;
    }

    bb11: {
        _32 = _3;
        _33 = const 1_i32 as u32 (IntToInt);
        _34 = Lt(move _33, const 64_u32);
        assert(move _34, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _31 = Shl(move _32, const 1_i32);
        _36 = _4;
        _37 = const 1_i32 as u32 (IntToInt);
        _38 = Lt(move _37, const 64_u32);
        assert(move _38, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _35 = Shl(move _36, const 1_i32);
        _30 = Le(move _31, move _35);
        switchInt(move _30) -> [0: bb19, otherwise: bb14];
    }

    bb14: {
        _41 = _3;
        _42 = const 1_i32 as u32 (IntToInt);
        _43 = Lt(move _42, const 64_u32);
        assert(move _43, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _40 = Shl(move _41, const 1_i32);
        _45 = _4;
        _46 = const 1_i32 as u32 (IntToInt);
        _47 = Lt(move _46, const 64_u32);
        assert(move _47, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _44 = Shl(move _45, const 1_i32);
        _39 = Eq(move _40, move _44);
        switchInt(move _39) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = Mul(const 0f64, _1);
        goto -> bb81;
    }

    bb18: {
        _0 = _1;
        goto -> bb81;
    }

    bb19: {
        _48 = _5;
        switchInt(move _48) -> [0: bb20, otherwise: bb21];
    }

    bb20: {
        _49 = _3;
        _50 = const 12_i32 as u32 (IntToInt);
        _51 = Lt(move _50, const 64_u32);
        assert(move _51, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb22, unwind unreachable];
    }

    bb21: {
        _67 = const 12_i32 as u32 (IntToInt);
        _68 = Lt(move _67, const 64_u32);
        assert(move _68, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb32, unwind unreachable];
    }

    bb22: {
        _21 = Shl(move _49, const 12_i32);
        goto -> bb23;
    }

    bb23: {
        _53 = _21;
        _54 = const 63_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 64_u32);
        assert(move _55, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _52 = Shr(move _53, const 63_i32);
        switchInt(move _52) -> [0: bb25, otherwise: bb28];
    }

    bb25: {
        _56 = CheckedSub(_5, const 1_i64);
        assert(!move (_56.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i64) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _5 = move (_56.0: i64);
        _57 = const 1_i32 as u32 (IntToInt);
        _58 = Lt(move _57, const 64_u32);
        assert(move _58, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _21 = Shl(_21, const 1_i32);
        goto -> bb23;
    }

    bb28: {
        _61 = _5;
        _62 = Eq(_61, const i64::MIN);
        assert(!move _62, "attempt to negate `{}`, which would overflow", _61) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _60 = Neg(move _61);
        _63 = CheckedAdd(_60, const 1_i64);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", move _60, const 1_i64) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _59 = move (_63.0: i64);
        _64 = _59 as u64 (IntToInt);
        _65 = Lt(move _64, const 64_u64);
        assert(move _65, "attempt to shift left by `{}`, which would overflow", _59) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _3 = Shl(_3, move _59);
        goto -> bb34;
    }

    bb32: {
        _66 = Shr(const _, const 12_i32);
        _3 = BitAnd(_3, move _66);
        _70 = const 52_i32 as u32 (IntToInt);
        _71 = Lt(move _70, const 64_u32);
        assert(move _71, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _69 = Shl(const 1_u64, const 52_i32);
        _3 = BitOr(_3, move _69);
        goto -> bb34;
    }

    bb34: {
        _72 = _11;
        switchInt(move _72) -> [0: bb35, otherwise: bb46];
    }

    bb35: {
        _73 = _4;
        _74 = const 12_i32 as u32 (IntToInt);
        _75 = Lt(move _74, const 64_u32);
        assert(move _75, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _21 = Shl(move _73, const 12_i32);
        goto -> bb37;
    }

    bb37: {
        _77 = _21;
        _78 = const 63_i32 as u32 (IntToInt);
        _79 = Lt(move _78, const 64_u32);
        assert(move _79, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb38, unwind unreachable];
    }

    bb38: {
        _76 = Shr(move _77, const 63_i32);
        switchInt(move _76) -> [0: bb39, otherwise: bb42];
    }

    bb39: {
        _80 = CheckedSub(_11, const 1_i64);
        assert(!move (_80.1: bool), "attempt to compute `{} - {}`, which would overflow", _11, const 1_i64) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _11 = move (_80.0: i64);
        _81 = const 1_i32 as u32 (IntToInt);
        _82 = Lt(move _81, const 64_u32);
        assert(move _82, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _21 = Shl(_21, const 1_i32);
        goto -> bb37;
    }

    bb42: {
        _85 = _11;
        _86 = Eq(_85, const i64::MIN);
        assert(!move _86, "attempt to negate `{}`, which would overflow", _85) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _84 = Neg(move _85);
        _87 = CheckedAdd(_84, const 1_i64);
        assert(!move (_87.1: bool), "attempt to compute `{} + {}`, which would overflow", move _84, const 1_i64) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _83 = move (_87.0: i64);
        _88 = _83 as u64 (IntToInt);
        _89 = Lt(move _88, const 64_u64);
        assert(move _89, "attempt to shift left by `{}`, which would overflow", _83) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _4 = Shl(_4, move _83);
        goto -> bb49;
    }

    bb46: {
        _91 = const 12_i32 as u32 (IntToInt);
        _92 = Lt(move _91, const 64_u32);
        assert(move _92, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _90 = Shr(const _, const 12_i32);
        _4 = BitAnd(_4, move _90);
        _94 = const 52_i32 as u32 (IntToInt);
        _95 = Lt(move _94, const 64_u32);
        assert(move _95, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _93 = Shl(const 1_u64, const 52_i32);
        _4 = BitOr(_4, move _93);
        goto -> bb49;
    }

    bb49: {
        _97 = _5;
        _98 = _11;
        _96 = Gt(move _97, move _98);
        switchInt(move _96) -> [0: bb59, otherwise: bb50];
    }

    bb50: {
        _100 = _3;
        _101 = _4;
        _99 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _100, move _101) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _21 = move _99;
        _103 = _21;
        _104 = const 63_i32 as u32 (IntToInt);
        _105 = Lt(move _104, const 64_u32);
        assert(move _105, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _102 = Shr(move _103, const 63_i32);
        switchInt(move _102) -> [0: bb53, otherwise: bb56];
    }

    bb53: {
        _106 = _21;
        switchInt(move _106) -> [0: bb54, otherwise: bb55];
    }

    bb54: {
        _0 = Mul(const 0f64, _1);
        goto -> bb81;
    }

    bb55: {
        _107 = _21;
        _3 = move _107;
        goto -> bb56;
    }

    bb56: {
        _108 = const 1_i32 as u32 (IntToInt);
        _109 = Lt(move _108, const 64_u32);
        assert(move _109, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _3 = Shl(_3, const 1_i32);
        _110 = CheckedSub(_5, const 1_i64);
        assert(!move (_110.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i64) -> [success: bb58, unwind unreachable];
    }

    bb58: {
        _5 = move (_110.0: i64);
        goto -> bb49;
    }

    bb59: {
        _112 = _3;
        _113 = _4;
        _111 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _112, move _113) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _21 = move _111;
        _115 = _21;
        _116 = const 63_i32 as u32 (IntToInt);
        _117 = Lt(move _116, const 64_u32);
        assert(move _117, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _114 = Shr(move _115, const 63_i32);
        switchInt(move _114) -> [0: bb62, otherwise: bb65];
    }

    bb62: {
        _118 = _21;
        switchInt(move _118) -> [0: bb63, otherwise: bb64];
    }

    bb63: {
        _0 = Mul(const 0f64, _1);
        goto -> bb81;
    }

    bb64: {
        _119 = _21;
        _3 = move _119;
        goto -> bb65;
    }

    bb65: {
        _121 = _3;
        _122 = const 52_i32 as u32 (IntToInt);
        _123 = Lt(move _122, const 64_u32);
        assert(move _123, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb66, unwind unreachable];
    }

    bb66: {
        _120 = Shr(move _121, const 52_i32);
        switchInt(move _120) -> [0: bb67, otherwise: bb70];
    }

    bb67: {
        _124 = const 1_i32 as u32 (IntToInt);
        _125 = Lt(move _124, const 64_u32);
        assert(move _125, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _3 = Shl(_3, const 1_i32);
        _126 = CheckedSub(_5, const 1_i64);
        assert(!move (_126.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i64) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _5 = move (_126.0: i64);
        goto -> bb65;
    }

    bb70: {
        _128 = _5;
        _127 = Gt(move _128, const 0_i64);
        switchInt(move _127) -> [0: bb72, otherwise: bb71];
    }

    bb71: {
        _130 = const 52_i32 as u32 (IntToInt);
        _131 = Lt(move _130, const 64_u32);
        assert(move _131, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb73, unwind unreachable];
    }

    bb72: {
        _140 = _5;
        _141 = Eq(_140, const i64::MIN);
        assert(!move _141, "attempt to negate `{}`, which would overflow", _140) -> [success: bb76, unwind unreachable];
    }

    bb73: {
        _129 = Shl(const 1_u64, const 52_i32);
        _132 = CheckedSub(_3, _129);
        assert(!move (_132.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _129) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _3 = move (_132.0: u64);
        _135 = _5;
        _134 = move _135 as u64 (IntToInt);
        _136 = const 52_i32 as u32 (IntToInt);
        _137 = Lt(move _136, const 64_u32);
        assert(move _137, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _133 = Shl(move _134, const 52_i32);
        _3 = BitOr(_3, move _133);
        goto -> bb79;
    }

    bb76: {
        _139 = Neg(move _140);
        _142 = CheckedAdd(_139, const 1_i64);
        assert(!move (_142.1: bool), "attempt to compute `{} + {}`, which would overflow", move _139, const 1_i64) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _138 = move (_142.0: i64);
        _143 = _138 as u64 (IntToInt);
        _144 = Lt(move _143, const 64_u64);
        assert(move _144, "attempt to shift right by `{}`, which would overflow", _138) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _3 = Shr(_3, move _138);
        goto -> bb79;
    }

    bb79: {
        _146 = const 63_i32 as u32 (IntToInt);
        _147 = Lt(move _146, const 64_u32);
        assert(move _147, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        _145 = Shl(_17, const 63_i32);
        _3 = BitOr(_3, move _145);
        _148 = _3;
        _0 = f64::<impl f64>::from_bits(move _148) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        return;
    }
}

fn libm::fmodf::fmodf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: bool;
    let mut _18: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: i32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: u32;
    let mut _45: bool;
    let mut _46: i32;
    let mut _47: u32;
    let mut _48: u32;
    let mut _49: bool;
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: u32;
    let mut _53: bool;
    let mut _54: (i32, bool);
    let mut _55: u32;
    let mut _56: bool;
    let mut _57: i32;
    let mut _58: i32;
    let mut _59: i32;
    let mut _60: bool;
    let mut _61: (i32, bool);
    let mut _62: u32;
    let mut _63: bool;
    let mut _64: u32;
    let mut _65: u32;
    let mut _66: bool;
    let mut _67: u32;
    let mut _68: u32;
    let mut _69: bool;
    let mut _70: i32;
    let mut _71: u32;
    let mut _72: u32;
    let mut _73: bool;
    let mut _74: u32;
    let mut _75: u32;
    let mut _76: u32;
    let mut _77: bool;
    let mut _78: (i32, bool);
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: i32;
    let mut _82: i32;
    let mut _83: i32;
    let mut _84: bool;
    let mut _85: (i32, bool);
    let mut _86: u32;
    let mut _87: bool;
    let mut _88: u32;
    let mut _89: u32;
    let mut _90: bool;
    let mut _91: u32;
    let mut _92: u32;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: i32;
    let mut _96: i32;
    let mut _97: u32;
    let mut _98: u32;
    let mut _99: u32;
    let mut _100: u32;
    let mut _101: u32;
    let mut _102: u32;
    let mut _103: bool;
    let mut _104: u32;
    let mut _105: u32;
    let mut _106: u32;
    let mut _107: bool;
    let mut _108: (i32, bool);
    let mut _109: u32;
    let mut _110: u32;
    let mut _111: u32;
    let mut _112: u32;
    let mut _113: u32;
    let mut _114: u32;
    let mut _115: bool;
    let mut _116: u32;
    let mut _117: u32;
    let mut _118: u32;
    let mut _119: u32;
    let mut _120: u32;
    let mut _121: bool;
    let mut _122: u32;
    let mut _123: bool;
    let mut _124: (i32, bool);
    let mut _125: bool;
    let mut _126: i32;
    let mut _127: u32;
    let mut _128: u32;
    let mut _129: bool;
    let mut _130: (u32, bool);
    let mut _131: u32;
    let mut _132: u32;
    let mut _133: i32;
    let mut _134: u32;
    let mut _135: bool;
    let mut _136: i32;
    let mut _137: i32;
    let mut _138: i32;
    let mut _139: bool;
    let mut _140: (i32, bool);
    let mut _141: u32;
    let mut _142: bool;
    let mut _143: u32;
    scope 1 {
        debug uxi => _3;
        let mut _4: u32;
        scope 2 {
            debug uyi => _4;
            let mut _5: i32;
            scope 3 {
                debug ex => _5;
                let mut _11: i32;
                scope 4 {
                    debug ey => _11;
                    let _17: u32;
                    scope 5 {
                        debug sx => _17;
                        let mut _19: u32;
                        scope 6 {
                            debug i => _19;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::to_bits(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _8 = _3;
        _9 = const 23_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Shr(move _8, const 23_i32);
        _6 = BitAnd(move _7, const 255_u32);
        _5 = move _6 as i32 (IntToInt);
        _14 = _4;
        _15 = const 23_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 32_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = Shr(move _14, const 23_i32);
        _12 = BitAnd(move _13, const 255_u32);
        _11 = move _12 as i32 (IntToInt);
        _18 = _3;
        _17 = BitAnd(move _18, const 2147483648_u32);
        _21 = _4;
        _22 = const 1_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 32_u32);
        assert(move _23, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _20 = Shl(move _21, const 1_i32);
        switchInt(move _20) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _24 = f32::<impl f32>::is_nan(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        switchInt(move _24) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _25 = _5;
        switchInt(move _25) -> [255: bb9, otherwise: bb10];
    }

    bb9: {
        _26 = Mul(_1, _2);
        _27 = Mul(_1, _2);
        _0 = Div(move _26, move _27);
        goto -> bb79;
    }

    bb10: {
        _30 = _3;
        _31 = const 1_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 32_u32);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _29 = Shl(move _30, const 1_i32);
        _34 = _4;
        _35 = const 1_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _33 = Shl(move _34, const 1_i32);
        _28 = Le(move _29, move _33);
        switchInt(move _28) -> [0: bb18, otherwise: bb13];
    }

    bb13: {
        _39 = _3;
        _40 = const 1_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 32_u32);
        assert(move _41, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _38 = Shl(move _39, const 1_i32);
        _43 = _4;
        _44 = const 1_i32 as u32 (IntToInt);
        _45 = Lt(move _44, const 32_u32);
        assert(move _45, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _42 = Shl(move _43, const 1_i32);
        _37 = Eq(move _38, move _42);
        switchInt(move _37) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _0 = Mul(const 0f32, _1);
        goto -> bb79;
    }

    bb17: {
        _0 = _1;
        goto -> bb79;
    }

    bb18: {
        _46 = _5;
        switchInt(move _46) -> [0: bb19, otherwise: bb20];
    }

    bb19: {
        _47 = _3;
        _48 = const 9_i32 as u32 (IntToInt);
        _49 = Lt(move _48, const 32_u32);
        assert(move _49, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb21, unwind unreachable];
    }

    bb20: {
        _65 = const 9_i32 as u32 (IntToInt);
        _66 = Lt(move _65, const 32_u32);
        assert(move _66, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb31, unwind unreachable];
    }

    bb21: {
        _19 = Shl(move _47, const 9_i32);
        goto -> bb22;
    }

    bb22: {
        _51 = _19;
        _52 = const 31_i32 as u32 (IntToInt);
        _53 = Lt(move _52, const 32_u32);
        assert(move _53, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _50 = Shr(move _51, const 31_i32);
        switchInt(move _50) -> [0: bb24, otherwise: bb27];
    }

    bb24: {
        _54 = CheckedSub(_5, const 1_i32);
        assert(!move (_54.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _5 = move (_54.0: i32);
        _55 = const 1_i32 as u32 (IntToInt);
        _56 = Lt(move _55, const 32_u32);
        assert(move _56, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _19 = Shl(_19, const 1_i32);
        goto -> bb22;
    }

    bb27: {
        _59 = _5;
        _60 = Eq(_59, const i32::MIN);
        assert(!move _60, "attempt to negate `{}`, which would overflow", _59) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _58 = Neg(move _59);
        _61 = CheckedAdd(_58, const 1_i32);
        assert(!move (_61.1: bool), "attempt to compute `{} + {}`, which would overflow", move _58, const 1_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _57 = move (_61.0: i32);
        _62 = _57 as u32 (IntToInt);
        _63 = Lt(move _62, const 32_u32);
        assert(move _63, "attempt to shift left by `{}`, which would overflow", _57) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _3 = Shl(_3, move _57);
        goto -> bb33;
    }

    bb31: {
        _64 = Shr(const _, const 9_i32);
        _3 = BitAnd(_3, move _64);
        _68 = const 23_i32 as u32 (IntToInt);
        _69 = Lt(move _68, const 32_u32);
        assert(move _69, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _67 = Shl(const 1_u32, const 23_i32);
        _3 = BitOr(_3, move _67);
        goto -> bb33;
    }

    bb33: {
        _70 = _11;
        switchInt(move _70) -> [0: bb34, otherwise: bb45];
    }

    bb34: {
        _71 = _4;
        _72 = const 9_i32 as u32 (IntToInt);
        _73 = Lt(move _72, const 32_u32);
        assert(move _73, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _19 = Shl(move _71, const 9_i32);
        goto -> bb36;
    }

    bb36: {
        _75 = _19;
        _76 = const 31_i32 as u32 (IntToInt);
        _77 = Lt(move _76, const 32_u32);
        assert(move _77, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _74 = Shr(move _75, const 31_i32);
        switchInt(move _74) -> [0: bb38, otherwise: bb41];
    }

    bb38: {
        _78 = CheckedSub(_11, const 1_i32);
        assert(!move (_78.1: bool), "attempt to compute `{} - {}`, which would overflow", _11, const 1_i32) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _11 = move (_78.0: i32);
        _79 = const 1_i32 as u32 (IntToInt);
        _80 = Lt(move _79, const 32_u32);
        assert(move _80, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _19 = Shl(_19, const 1_i32);
        goto -> bb36;
    }

    bb41: {
        _83 = _11;
        _84 = Eq(_83, const i32::MIN);
        assert(!move _84, "attempt to negate `{}`, which would overflow", _83) -> [success: bb42, unwind unreachable];
    }

    bb42: {
        _82 = Neg(move _83);
        _85 = CheckedAdd(_82, const 1_i32);
        assert(!move (_85.1: bool), "attempt to compute `{} + {}`, which would overflow", move _82, const 1_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _81 = move (_85.0: i32);
        _86 = _81 as u32 (IntToInt);
        _87 = Lt(move _86, const 32_u32);
        assert(move _87, "attempt to shift left by `{}`, which would overflow", _81) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _4 = Shl(_4, move _81);
        goto -> bb48;
    }

    bb45: {
        _89 = const 9_i32 as u32 (IntToInt);
        _90 = Lt(move _89, const 32_u32);
        assert(move _90, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _88 = Shr(const _, const 9_i32);
        _4 = BitAnd(_4, move _88);
        _92 = const 23_i32 as u32 (IntToInt);
        _93 = Lt(move _92, const 32_u32);
        assert(move _93, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _91 = Shl(const 1_u32, const 23_i32);
        _4 = BitOr(_4, move _91);
        goto -> bb48;
    }

    bb48: {
        _95 = _5;
        _96 = _11;
        _94 = Gt(move _95, move _96);
        switchInt(move _94) -> [0: bb58, otherwise: bb49];
    }

    bb49: {
        _98 = _3;
        _99 = _4;
        _97 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _98, move _99) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _19 = move _97;
        _101 = _19;
        _102 = const 31_i32 as u32 (IntToInt);
        _103 = Lt(move _102, const 32_u32);
        assert(move _103, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb51, unwind unreachable];
    }

    bb51: {
        _100 = Shr(move _101, const 31_i32);
        switchInt(move _100) -> [0: bb52, otherwise: bb55];
    }

    bb52: {
        _104 = _19;
        switchInt(move _104) -> [0: bb53, otherwise: bb54];
    }

    bb53: {
        _0 = Mul(const 0f32, _1);
        goto -> bb79;
    }

    bb54: {
        _105 = _19;
        _3 = move _105;
        goto -> bb55;
    }

    bb55: {
        _106 = const 1_i32 as u32 (IntToInt);
        _107 = Lt(move _106, const 32_u32);
        assert(move _107, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _3 = Shl(_3, const 1_i32);
        _108 = CheckedSub(_5, const 1_i32);
        assert(!move (_108.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _5 = move (_108.0: i32);
        goto -> bb48;
    }

    bb58: {
        _110 = _3;
        _111 = _4;
        _109 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _110, move _111) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _19 = move _109;
        _113 = _19;
        _114 = const 31_i32 as u32 (IntToInt);
        _115 = Lt(move _114, const 32_u32);
        assert(move _115, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _112 = Shr(move _113, const 31_i32);
        switchInt(move _112) -> [0: bb61, otherwise: bb64];
    }

    bb61: {
        _116 = _19;
        switchInt(move _116) -> [0: bb62, otherwise: bb63];
    }

    bb62: {
        _0 = Mul(const 0f32, _1);
        goto -> bb79;
    }

    bb63: {
        _117 = _19;
        _3 = move _117;
        goto -> bb64;
    }

    bb64: {
        _119 = _3;
        _120 = const 23_i32 as u32 (IntToInt);
        _121 = Lt(move _120, const 32_u32);
        assert(move _121, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _118 = Shr(move _119, const 23_i32);
        switchInt(move _118) -> [0: bb66, otherwise: bb69];
    }

    bb66: {
        _122 = const 1_i32 as u32 (IntToInt);
        _123 = Lt(move _122, const 32_u32);
        assert(move _123, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb67, unwind unreachable];
    }

    bb67: {
        _3 = Shl(_3, const 1_i32);
        _124 = CheckedSub(_5, const 1_i32);
        assert(!move (_124.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb68, unwind unreachable];
    }

    bb68: {
        _5 = move (_124.0: i32);
        goto -> bb64;
    }

    bb69: {
        _126 = _5;
        _125 = Gt(move _126, const 0_i32);
        switchInt(move _125) -> [0: bb71, otherwise: bb70];
    }

    bb70: {
        _128 = const 23_i32 as u32 (IntToInt);
        _129 = Lt(move _128, const 32_u32);
        assert(move _129, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb72, unwind unreachable];
    }

    bb71: {
        _138 = _5;
        _139 = Eq(_138, const i32::MIN);
        assert(!move _139, "attempt to negate `{}`, which would overflow", _138) -> [success: bb75, unwind unreachable];
    }

    bb72: {
        _127 = Shl(const 1_u32, const 23_i32);
        _130 = CheckedSub(_3, _127);
        assert(!move (_130.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _127) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _3 = move (_130.0: u32);
        _133 = _5;
        _132 = move _133 as u32 (IntToInt);
        _134 = const 23_i32 as u32 (IntToInt);
        _135 = Lt(move _134, const 32_u32);
        assert(move _135, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _131 = Shl(move _132, const 23_i32);
        _3 = BitOr(_3, move _131);
        goto -> bb78;
    }

    bb75: {
        _137 = Neg(move _138);
        _140 = CheckedAdd(_137, const 1_i32);
        assert(!move (_140.1: bool), "attempt to compute `{} + {}`, which would overflow", move _137, const 1_i32) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _136 = move (_140.0: i32);
        _141 = _136 as u32 (IntToInt);
        _142 = Lt(move _141, const 32_u32);
        assert(move _142, "attempt to shift right by `{}`, which would overflow", _136) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _3 = Shr(_3, move _136);
        goto -> bb78;
    }

    bb78: {
        _3 = BitOr(_3, _17);
        _143 = _3;
        _0 = f32::<impl f32>::from_bits(move _143) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        return;
    }
}

fn frexp(_1: f64) -> (f64, i32) {
    debug x => _1;
    let mut _0: (f64, i32);
    let mut _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _13: (f64, i32);
    let mut _14: f64;
    let mut _15: i32;
    let mut _16: (i32, bool);
    let mut _18: (i32, bool);
    let mut _19: f64;
    let mut _20: u64;
    scope 1 {
        debug y => _2;
        let _3: i32;
        scope 2 {
            debug ee => _3;
            let _10: f64;
            let _17: i32;
            scope 3 {
                debug x1p64 => _10;
                let _11: f64;
                let _12: i32;
                scope 4 {
                    debug x => _11;
                    debug e => _12;
                }
            }
            scope 5 {
                debug e => _17;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 52_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 52_i32);
        _4 = BitAnd(move _5, const 2047_u64);
        _3 = move _4 as i32 (IntToInt);
        switchInt(move _3) -> [0: bb3, otherwise: bb9];
    }

    bb3: {
        _9 = Ne(_1, const 0f64);
        switchInt(move _9) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _10 = f64::<impl f64>::from_bits(const 4895412794951729152_u64) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = Mul(_1, _10);
        _13 = frexp(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = (_13.0: f64);
        _12 = (_13.1: i32);
        _16 = CheckedSub(_12, const 64_i32);
        assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 64_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _15 = move (_16.0: i32);
        _0 = (_11, move _15);
        goto -> bb14;
    }

    bb8: {
        _0 = (_1, const 0_i32);
        goto -> bb14;
    }

    bb9: {
        switchInt(move _3) -> [2047: bb10, otherwise: bb11];
    }

    bb10: {
        _0 = (_1, const 0_i32);
        goto -> bb14;
    }

    bb11: {
        _18 = CheckedSub(_3, const 1022_i32);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1022_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _17 = move (_18.0: i32);
        _2 = BitAnd(_2, const 9227875636482146303_u64);
        _2 = BitOr(_2, const 4602678819172646912_u64);
        _20 = _2;
        _19 = f64::<impl f64>::from_bits(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = (move _19, _17);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn frexpf(_1: f32) -> (f32, i32) {
    debug x => _1;
    let mut _0: (f32, i32);
    let mut _2: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _13: (f32, i32);
    let mut _14: f32;
    let mut _15: i32;
    let mut _16: (i32, bool);
    let mut _18: (i32, bool);
    let mut _19: f32;
    let mut _20: u32;
    scope 1 {
        debug y => _2;
        let _3: i32;
        scope 2 {
            debug ee => _3;
            let _10: f32;
            let _17: i32;
            scope 3 {
                debug x1p64 => _10;
                let _11: f32;
                let _12: i32;
                scope 4 {
                    debug x => _11;
                    debug e => _12;
                }
            }
            scope 5 {
                debug e => _17;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 23_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 23_i32);
        _4 = BitAnd(move _5, const 255_u32);
        _3 = move _4 as i32 (IntToInt);
        switchInt(move _3) -> [0: bb3, otherwise: bb9];
    }

    bb3: {
        _9 = Ne(_1, const 0f32);
        switchInt(move _9) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _10 = f32::<impl f32>::from_bits(const 1602224128_u32) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = Mul(_1, _10);
        _13 = frexpf(move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = (_13.0: f32);
        _12 = (_13.1: i32);
        _16 = CheckedSub(_12, const 64_i32);
        assert(!move (_16.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 64_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _15 = move (_16.0: i32);
        _0 = (_11, move _15);
        goto -> bb14;
    }

    bb8: {
        _0 = (_1, const 0_i32);
        goto -> bb14;
    }

    bb9: {
        switchInt(move _3) -> [255: bb10, otherwise: bb11];
    }

    bb10: {
        _0 = (_1, const 0_i32);
        goto -> bb14;
    }

    bb11: {
        _18 = CheckedSub(_3, const 126_i32);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 126_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _17 = move (_18.0: i32);
        _2 = BitAnd(_2, const 2155872255_u32);
        _2 = BitOr(_2, const 1056964608_u32);
        _20 = _2;
        _19 = f32::<impl f32>::from_bits(move _20) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = (move _19, _17);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

const SPLIT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Add(const 134217728f64, const 1f64);
        return;
    }
}

fn sq(_1: f64) -> (f64, f64) {
    debug x => _1;
    let mut _0: (f64, f64);
    let _2: f64;
    let mut _5: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    scope 1 {
        debug xh => _2;
        let _3: f64;
        scope 2 {
            debug xl => _3;
            let _4: f64;
            scope 3 {
                debug xc => _4;
                let _6: f64;
                scope 4 {
                    debug hi => _6;
                    let _7: f64;
                    scope 5 {
                        debug lo => _7;
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Mul(_1, const _);
        _5 = Sub(_1, _4);
        _2 = Add(move _5, _4);
        _3 = Sub(_1, _2);
        _6 = Mul(_1, _1);
        _10 = Mul(_2, _2);
        _9 = Sub(move _10, _6);
        _12 = Mul(const 2f64, _2);
        _11 = Mul(move _12, _3);
        _8 = Add(move _9, move _11);
        _13 = Mul(_3, _3);
        _7 = Add(move _8, move _13);
        _0 = (_6, _7);
        return;
    }
}

fn hypot(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let _3: f64;
    let mut _6: f64;
    let mut _8: f64;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u64;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: u64;
    let mut _30: u64;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: f64;
    let mut _34: u64;
    let mut _35: f64;
    let mut _36: u64;
    let mut _37: u64;
    let mut _38: bool;
    let mut _39: i64;
    let mut _40: (i64, bool);
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: bool;
    let mut _44: i64;
    let mut _45: (i64, bool);
    let mut _46: bool;
    let mut _47: i64;
    let mut _48: (i64, bool);
    let mut _51: (f64, f64);
    let mut _52: f64;
    let mut _55: (f64, f64);
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    scope 1 {
        debug x1p700 => _3;
        let _4: f64;
        scope 2 {
            debug x1p_700 => _4;
            let mut _5: u64;
            scope 3 {
                debug uxi => _5;
                let mut _7: u64;
                scope 4 {
                    debug uyi => _7;
                    scope 5 {
                        debug uti => _23;
                        let _9: i64;
                        scope 6 {
                            debug ex => _9;
                            let _10: i64;
                            scope 7 {
                                debug ey => _10;
                                let mut _11: f64;
                                scope 8 {
                                    debug z => _11;
                                    let _49: f64;
                                    let _50: f64;
                                    scope 9 {
                                        debug hx => _49;
                                        debug lx => _50;
                                        let _53: f64;
                                        let _54: f64;
                                        scope 10 {
                                            debug hy => _53;
                                            debug ly => _54;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::from_bits(const 7759702157959364608_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f64::<impl f64>::from_bits(const 1454662679640670208_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = _1;
        _5 = f64::<impl f64>::to_bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = _2;
        _7 = f64::<impl f64>::to_bits(move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _13 = const -1_i64 as u64 (IntToInt);
        _14 = const 1_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 64_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _12 = Shr(move _13, const 1_i32);
        _5 = BitAnd(_5, move _12);
        _17 = const -1_i64 as u64 (IntToInt);
        _18 = const 1_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _16 = Shr(move _17, const 1_i32);
        _7 = BitAnd(_7, move _16);
        _21 = _5;
        _22 = _7;
        _20 = Lt(move _21, move _22);
        switchInt(move _20) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _23 = _5;
        _24 = _7;
        _5 = move _24;
        _7 = _23;
        goto -> bb8;
    }

    bb8: {
        _26 = _5;
        _27 = const 52_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _25 = Shr(move _26, const 52_i32);
        _9 = move _25 as i64 (IntToInt);
        _30 = _7;
        _31 = const 52_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 64_u32);
        assert(move _32, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _29 = Shr(move _30, const 52_i32);
        _10 = move _29 as i64 (IntToInt);
        _34 = _5;
        _33 = f64::<impl f64>::from_bits(move _34) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _1 = move _33;
        _36 = _7;
        _35 = f64::<impl f64>::from_bits(move _36) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move _35;
        switchInt(move _10) -> [2047: bb13, otherwise: bb14];
    }

    bb13: {
        _0 = _2;
        goto -> bb30;
    }

    bb14: {
        switchInt(move _9) -> [2047: bb16, otherwise: bb15];
    }

    bb15: {
        _37 = _7;
        switchInt(move _37) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        _0 = _1;
        goto -> bb30;
    }

    bb17: {
        _40 = CheckedSub(_9, _10);
        assert(!move (_40.1: bool), "attempt to compute `{} - {}`, which would overflow", _9, _10) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _39 = move (_40.0: i64);
        _38 = Gt(move _39, const 64_i64);
        switchInt(move _38) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _41 = _1;
        _42 = _2;
        _0 = Add(move _41, move _42);
        goto -> bb30;
    }

    bb20: {
        _11 = const 1f64;
        _45 = CheckedAdd(const 1023_i64, const 510_i64);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i64, const 510_i64) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _44 = move (_45.0: i64);
        _43 = Gt(_9, move _44);
        switchInt(move _43) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _11 = _3;
        _1 = Mul(_1, _4);
        _2 = Mul(_2, _4);
        goto -> bb26;
    }

    bb23: {
        _48 = CheckedSub(const 1023_i64, const 450_i64);
        assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_i64, const 450_i64) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _47 = move (_48.0: i64);
        _46 = Lt(_10, move _47);
        switchInt(move _46) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _11 = _4;
        _1 = Mul(_1, _3);
        _2 = Mul(_2, _3);
        goto -> bb26;
    }

    bb26: {
        _52 = _1;
        _51 = sq(move _52) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _49 = (_51.0: f64);
        _50 = (_51.1: f64);
        _56 = _2;
        _55 = sq(move _56) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _53 = (_55.0: f64);
        _54 = (_55.1: f64);
        _57 = _11;
        _61 = Add(_54, _50);
        _60 = Add(move _61, _53);
        _59 = Add(move _60, _49);
        _58 = sqrt(move _59) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _0 = Mul(move _57, move _58);
        goto -> bb30;
    }

    bb30: {
        return;
    }
}

fn hypotf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let _3: f32;
    let mut _6: f32;
    let mut _8: f32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: f32;
    let mut _24: u32;
    let mut _25: f32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: (u32, bool);
    let mut _43: u32;
    let mut _44: u32;
    let mut _45: bool;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: bool;
    let mut _49: u32;
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: (u32, bool);
    let mut _53: u32;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: u32;
    let mut _57: u32;
    let mut _58: u32;
    let mut _59: (u32, bool);
    let mut _60: u32;
    let mut _61: bool;
    let mut _62: f32;
    let mut _63: f32;
    let mut _64: f32;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f32;
    let mut _69: f64;
    let mut _70: f32;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f32;
    let mut _74: f64;
    let mut _75: f32;
    scope 1 {
        debug x1p90 => _3;
        let _4: f32;
        scope 2 {
            debug x1p_90 => _4;
            let mut _5: u32;
            scope 3 {
                debug uxi => _5;
                let mut _7: u32;
                scope 4 {
                    debug uyi => _7;
                    scope 5 {
                        debug uti => _21;
                        let mut _9: f32;
                        scope 6 {
                            debug z => _9;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::from_bits(const 1820327936_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::from_bits(const 310378496_u32) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = _1;
        _5 = f32::<impl f32>::to_bits(move _6) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _8 = _2;
        _7 = f32::<impl f32>::to_bits(move _8) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = const -1_i32 as u32 (IntToInt);
        _12 = const 1_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _10 = Shr(move _11, const 1_i32);
        _5 = BitAnd(_5, move _10);
        _15 = const -1_i32 as u32 (IntToInt);
        _16 = const 1_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 32_u32);
        assert(move _17, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _14 = Shr(move _15, const 1_i32);
        _7 = BitAnd(_7, move _14);
        _19 = _5;
        _20 = _7;
        _18 = Lt(move _19, move _20);
        switchInt(move _18) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _21 = _5;
        _22 = _7;
        _5 = move _22;
        _7 = _21;
        goto -> bb8;
    }

    bb8: {
        _24 = _5;
        _23 = f32::<impl f32>::from_bits(move _24) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _1 = move _23;
        _26 = _7;
        _25 = f32::<impl f32>::from_bits(move _26) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _2 = move _25;
        _28 = _7;
        _30 = const 23_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 32_u32);
        assert(move _31, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _29 = Shl(const 255_u32, const 23_i32);
        _27 = Eq(move _28, move _29);
        switchInt(move _27) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = _2;
        goto -> bb30;
    }

    bb13: {
        _33 = _5;
        _35 = const 23_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _34 = Shl(const 255_u32, const 23_i32);
        _32 = Ge(move _33, move _34);
        switchInt(move _32) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _37 = _7;
        switchInt(move _37) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _40 = _5;
        _41 = _7;
        _42 = CheckedSub(_40, _41);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, move _41) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _39 = move (_42.0: u32);
        _44 = const 23_i32 as u32 (IntToInt);
        _45 = Lt(move _44, const 32_u32);
        assert(move _45, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _43 = Shl(const 25_u32, const 23_i32);
        _38 = Ge(move _39, move _43);
        switchInt(move _38) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _46 = _1;
        _47 = _2;
        _0 = Add(move _46, move _47);
        goto -> bb30;
    }

    bb20: {
        _9 = const 1f32;
        _49 = _5;
        _52 = CheckedAdd(const 127_u32, const 60_u32);
        assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_u32, const 60_u32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _51 = move (_52.0: u32);
        _53 = const 23_i32 as u32 (IntToInt);
        _54 = Lt(move _53, const 32_u32);
        assert(move _54, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _50 = Shl(move _51, const 23_i32);
        _48 = Ge(move _49, move _50);
        switchInt(move _48) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _9 = _3;
        _1 = Mul(_1, _4);
        _2 = Mul(_2, _4);
        goto -> bb28;
    }

    bb24: {
        _56 = _7;
        _59 = CheckedSub(const 127_u32, const 60_u32);
        assert(!move (_59.1: bool), "attempt to compute `{} - {}`, which would overflow", const 127_u32, const 60_u32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _58 = move (_59.0: u32);
        _60 = const 23_i32 as u32 (IntToInt);
        _61 = Lt(move _60, const 32_u32);
        assert(move _61, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _57 = Shl(move _58, const 23_i32);
        _55 = Lt(move _56, move _57);
        switchInt(move _55) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _9 = _4;
        _1 = Mul(_1, _3);
        _2 = Mul(_2, _3);
        goto -> bb28;
    }

    bb28: {
        _62 = _9;
        _68 = _1;
        _67 = move _68 as f64 (FloatToFloat);
        _70 = _1;
        _69 = move _70 as f64 (FloatToFloat);
        _66 = Mul(move _67, move _69);
        _73 = _2;
        _72 = move _73 as f64 (FloatToFloat);
        _75 = _2;
        _74 = move _75 as f64 (FloatToFloat);
        _71 = Mul(move _72, move _74);
        _65 = Add(move _66, move _71);
        _64 = move _65 as f32 (FloatToFloat);
        _63 = sqrtf(move _64) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _0 = Mul(move _62, move _63);
        goto -> bb30;
    }

    bb30: {
        return;
    }
}

const ilogb::FP_ILOGBNAN: i32 = {
    let mut _0: i32;
    let mut _1: (i32, bool);

    bb0: {
        _1 = CheckedSub(const -1_i32, const i32::MAX);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const -1_i32, const i32::MAX) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const ilogb::FP_ILOGB0: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const _;
        return;
    }
}

fn ilogb(_1: f64) -> i32 {
    debug x => _1;
    let mut _0: i32;
    let mut _2: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u64;
    let _12: f64;
    let mut _13: *const f64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: (i32, bool);
    let mut _20: u32;
    let mut _21: bool;
    let _22: f64;
    let mut _23: *const f64;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (i32, bool);
    scope 1 {
        debug i => _2;
        let _3: i32;
        scope 2 {
            debug e => _3;
            let mut _14: i32;
            scope 3 {
                let mut _29: &f64;
            }
            scope 4 {
                debug e => _14;
            }
            scope 5 {
                let mut _30: &f64;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 52_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 52_i32);
        _4 = BitAnd(move _5, const 2047_u64);
        _3 = move _4 as i32 (IntToInt);
        switchInt(move _3) -> [0: bb3, otherwise: bb14];
    }

    bb3: {
        _9 = const 12_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 64_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = Shl(_2, const 12_i32);
        _11 = _2;
        switchInt(move _11) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _29 = const _;
        _13 = &raw const (*_29);
        _12 = read_volatile::<f64>(move _13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = const _;
        goto -> bb22;
    }

    bb7: {
        _14 = const -1023_i32;
        goto -> bb8;
    }

    bb8: {
        _16 = _2;
        _17 = const 63_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _15 = Shr(move _16, const 63_i32);
        switchInt(move _15) -> [0: bb10, otherwise: bb13];
    }

    bb10: {
        _19 = CheckedSub(_14, const 1_i32);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", _14, const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _14 = move (_19.0: i32);
        _20 = const 1_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = Shl(_2, const 1_i32);
        goto -> bb8;
    }

    bb13: {
        _0 = _14;
        goto -> bb22;
    }

    bb14: {
        switchInt(move _3) -> [2047: bb15, otherwise: bb20];
    }

    bb15: {
        _30 = const _;
        _23 = &raw const (*_30);
        _22 = read_volatile::<f64>(move _23) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _25 = _2;
        _26 = const 12_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 64_u32);
        assert(move _27, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _24 = Shl(move _25, const 12_i32);
        switchInt(move _24) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _0 = const _;
        goto -> bb22;
    }

    bb19: {
        _0 = rustc_std_workspace_core::num::<impl i32>::max_value() -> [return: bb22, unwind unreachable];
    }

    bb20: {
        _28 = CheckedSub(_3, const 1023_i32);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1023_i32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _0 = move (_28.0: i32);
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

promoted[0] in ilogb: &f64 = {
    let mut _0: &f64;
    let mut _1: f64;

    bb0: {
        _1 = Div(const 0f64, const 0f64);
        _0 = &_1;
        return;
    }
}

promoted[1] in ilogb: &f64 = {
    let mut _0: &f64;
    let mut _1: f64;

    bb0: {
        _1 = Div(const 0f64, const 0f64);
        _0 = &_1;
        return;
    }
}

const ilogbf::FP_ILOGBNAN: i32 = {
    let mut _0: i32;
    let mut _1: (i32, bool);

    bb0: {
        _1 = CheckedSub(const -1_i32, const i32::MAX);
        assert(!move (_1.1: bool), "attempt to compute `{} - {}`, which would overflow", const -1_i32, const i32::MAX) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: i32);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const ilogbf::FP_ILOGB0: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const _;
        return;
    }
}

fn ilogbf(_1: f32) -> i32 {
    debug x => _1;
    let mut _0: i32;
    let mut _2: u32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let _12: f64;
    let mut _13: *const f64;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: (i32, bool);
    let mut _20: u32;
    let mut _21: bool;
    let _22: f64;
    let mut _23: *const f64;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: (i32, bool);
    scope 1 {
        debug i => _2;
        let _3: i32;
        scope 2 {
            debug e => _3;
            let mut _14: i32;
            scope 3 {
                let mut _29: &f64;
            }
            scope 4 {
                debug e => _14;
            }
            scope 5 {
                let mut _30: &f64;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 23_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 23_i32);
        _4 = BitAnd(move _5, const 255_u32);
        _3 = move _4 as i32 (IntToInt);
        switchInt(move _3) -> [0: bb3, otherwise: bb14];
    }

    bb3: {
        _9 = const 9_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = Shl(_2, const 9_i32);
        _11 = _2;
        switchInt(move _11) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _29 = const _;
        _13 = &raw const (*_29);
        _12 = read_volatile::<f64>(move _13) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _0 = const _;
        goto -> bb22;
    }

    bb7: {
        _14 = const -127_i32;
        goto -> bb8;
    }

    bb8: {
        _16 = _2;
        _17 = const 31_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 32_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _15 = Shr(move _16, const 31_i32);
        switchInt(move _15) -> [0: bb10, otherwise: bb13];
    }

    bb10: {
        _19 = CheckedSub(_14, const 1_i32);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", _14, const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _14 = move (_19.0: i32);
        _20 = const 1_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 32_u32);
        assert(move _21, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = Shl(_2, const 1_i32);
        goto -> bb8;
    }

    bb13: {
        _0 = _14;
        goto -> bb22;
    }

    bb14: {
        switchInt(move _3) -> [255: bb15, otherwise: bb20];
    }

    bb15: {
        _30 = const _;
        _23 = &raw const (*_30);
        _22 = read_volatile::<f64>(move _23) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _25 = _2;
        _26 = const 9_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _24 = Shl(move _25, const 9_i32);
        switchInt(move _24) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _0 = const _;
        goto -> bb22;
    }

    bb19: {
        _0 = rustc_std_workspace_core::num::<impl i32>::max_value() -> [return: bb22, unwind unreachable];
    }

    bb20: {
        _28 = CheckedSub(_3, const 127_i32);
        assert(!move (_28.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 127_i32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _0 = move (_28.0: i32);
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

promoted[0] in ilogbf: &f64 = {
    let mut _0: &f64;
    let mut _1: f64;

    bb0: {
        _1 = Div(const 0f64, const 0f64);
        _0 = &_1;
        return;
    }
}

promoted[1] in ilogbf: &f64 = {
    let mut _0: &f64;
    let mut _1: f64;

    bb0: {
        _1 = Div(const 0f64, const 0f64);
        _0 = &_1;
        return;
    }
}

const j0::INVSQRTPI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.56418958354775628f64;
        return;
    }
}

const j0::TPI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.63661977236758138f64;
        return;
    }
}

fn j0::common(_1: u32, _2: f64, _3: bool) -> f64 {
    debug ix => _1;
    debug x => _2;
    debug y0 => _3;
    let mut _0: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: bool;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: bool;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: bool;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    scope 1 {
        debug s => _8;
        let mut _4: f64;
        scope 2 {
            debug c => _4;
            let mut _5: f64;
            scope 3 {
                debug ss => _5;
                let mut _6: f64;
                scope 4 {
                    debug cc => _6;
                    let _7: f64;
                    scope 5 {
                        debug z => _7;
                    }
                }
            }
        }
    }

    bb0: {
        _8 = sin(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = cos(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _4 = move _9;
        switchInt(_3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _10 = _4;
        _4 = Neg(move _10);
        goto -> bb4;
    }

    bb4: {
        _11 = _4;
        _6 = Add(_8, move _11);
        _12 = Lt(_1, const 2145386496_u32);
        switchInt(move _12) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _13 = _4;
        _5 = Sub(_8, move _13);
        _15 = Mul(const 2f64, _2);
        _14 = cos(move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _7 = Neg(move _14);
        _18 = _4;
        _17 = Mul(_8, move _18);
        _16 = Lt(move _17, const 0f64);
        switchInt(move _16) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _19 = _5;
        _6 = Div(_7, move _19);
        goto -> bb9;
    }

    bb8: {
        _20 = _6;
        _5 = Div(_7, move _20);
        goto -> bb9;
    }

    bb9: {
        _21 = Lt(_1, const 1207959552_u32);
        switchInt(move _21) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        switchInt(_3) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _22 = _5;
        _5 = Neg(move _22);
        goto -> bb12;
    }

    bb12: {
        _24 = pzero(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = _6;
        _23 = Mul(move _24, move _25);
        _27 = qzero(_2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _28 = _5;
        _26 = Mul(move _27, move _28);
        _6 = Sub(move _23, move _26);
        goto -> bb15;
    }

    bb15: {
        _30 = _6;
        _29 = Mul(const _, move _30);
        _31 = sqrt(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Div(move _29, move _31);
        return;
    }
}

const j0::R02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.015624999999999995f64;
        return;
    }
}

const j0::R03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.8997929423885472E-4f64;
        return;
    }
}

const j0::R04: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.8295404953270067E-6f64;
        return;
    }
}

const j0::R05: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -4.6183268853210319E-9f64;
        return;
    }
}

const j0::S01: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.015619102946489001f64;
        return;
    }
}

const j0::S02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.1692678466333745E-4f64;
        return;
    }
}

const j0::S03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 5.1354655020731811E-7f64;
        return;
    }
}

const j0::S04: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.1661400333379E-9f64;
        return;
    }
}

fn j0(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _6: u32;
    let mut _7: f64;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: f64;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug r => _3;
            let _4: f64;
            scope 3 {
                debug s => _4;
                let mut _5: u32;
                scope 4 {
                    debug ix => _5;
                }
            }
        }
    }

    bb0: {
        _7 = _1;
        _6 = get_high_word(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move _6;
        _5 = BitAnd(_5, const 2147483647_u32);
        _9 = _5;
        _8 = Ge(move _9, const 2146435072_u32);
        switchInt(move _8) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _11 = _1;
        _12 = _1;
        _10 = Mul(move _11, move _12);
        _0 = Div(const 1f64, move _10);
        goto -> bb11;
    }

    bb3: {
        _14 = _1;
        _13 = fabs(move _14) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _1 = move _13;
        _16 = _5;
        _15 = Ge(move _16, const 1073741824_u32);
        switchInt(move _15) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _17 = _5;
        _18 = _1;
        _0 = j0::common(move _17, move _18, const false) -> [return: bb11, unwind unreachable];
    }

    bb6: {
        _20 = _5;
        _19 = Ge(move _20, const 1059061760_u32);
        switchInt(move _19) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _21 = _1;
        _22 = _1;
        _2 = Mul(move _21, move _22);
        _28 = Mul(_2, const _);
        _27 = Add(const _, move _28);
        _26 = Mul(_2, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_2, move _25);
        _23 = Add(const _, move _24);
        _3 = Mul(_2, move _23);
        _35 = Mul(_2, const _);
        _34 = Add(const _, move _35);
        _33 = Mul(_2, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_2, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_2, move _30);
        _4 = Add(const 1f64, move _29);
        _39 = _1;
        _38 = Div(move _39, const 2f64);
        _37 = Add(const 1f64, move _38);
        _42 = _1;
        _41 = Div(move _42, const 2f64);
        _40 = Sub(const 1f64, move _41);
        _36 = Mul(move _37, move _40);
        _44 = Div(_3, _4);
        _43 = Mul(_2, move _44);
        _0 = Add(move _36, move _43);
        goto -> bb11;
    }

    bb8: {
        _46 = _5;
        _45 = Ge(move _46, const 939524096_u32);
        switchInt(move _45) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _48 = _1;
        _47 = Mul(const 0.25f64, move _48);
        _49 = _1;
        _1 = Mul(move _47, move _49);
        goto -> bb10;
    }

    bb10: {
        _50 = _1;
        _0 = Sub(const 1f64, move _50);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

const j0::U00: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.073804295108687232f64;
        return;
    }
}

const j0::U01: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.17666645250918112f64;
        return;
    }
}

const j0::U02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.01381856719455969f64;
        return;
    }
}

const j0::U03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.4745343209368365E-4f64;
        return;
    }
}

const j0::U04: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -3.8140705372436416E-6f64;
        return;
    }
}

const j0::U05: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9559013703502292E-8f64;
        return;
    }
}

const j0::U06: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -3.982051941321034E-11f64;
        return;
    }
}

const j0::V01: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.01273048348341237f64;
        return;
    }
}

const j0::V02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.6006862735035325E-5f64;
        return;
    }
}

const j0::V03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.5915085184045781E-7f64;
        return;
    }
}

const j0::V04: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.4111031133267547E-10f64;
        return;
    }
}

fn y0(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug u => _3;
            let _4: f64;
            scope 3 {
                debug v => _4;
                scope 4 {
                    debug ix => _5;
                    scope 5 {
                        debug lx => _6;
                    }
                }
            }
        }
    }

    bb0: {
        _5 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = get_low_word(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = const 1_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shl(_5, const 1_i32);
        _7 = BitOr(move _8, _6);
        switchInt(move _7) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _0 = Div(const -1f64, const 0f64);
        goto -> bb18;
    }

    bb5: {
        _12 = const 31_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = Shr(_5, const 31_i32);
        switchInt(move _11) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Div(const 0f64, const 0f64);
        goto -> bb18;
    }

    bb8: {
        _14 = Ge(_5, const 2146435072_u32);
        switchInt(move _14) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = Div(const 1f64, _1);
        goto -> bb18;
    }

    bb10: {
        _15 = Ge(_5, const 1073741824_u32);
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = j0::common(_5, _1, const true) -> [return: bb18, unwind unreachable];
    }

    bb12: {
        _16 = Ge(_5, const 1044381696_u32);
        switchInt(move _16) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _2 = Mul(_1, _1);
        _27 = Mul(_2, const _);
        _26 = Add(const _, move _27);
        _25 = Mul(_2, move _26);
        _24 = Add(const _, move _25);
        _23 = Mul(_2, move _24);
        _22 = Add(const _, move _23);
        _21 = Mul(_2, move _22);
        _20 = Add(const _, move _21);
        _19 = Mul(_2, move _20);
        _18 = Add(const _, move _19);
        _17 = Mul(_2, move _18);
        _3 = Add(const _, move _17);
        _34 = Mul(_2, const _);
        _33 = Add(const _, move _34);
        _32 = Mul(_2, move _33);
        _31 = Add(const _, move _32);
        _30 = Mul(_2, move _31);
        _29 = Add(const _, move _30);
        _28 = Mul(_2, move _29);
        _4 = Add(const 1f64, move _28);
        _35 = Div(_3, _4);
        _38 = j0(_1) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _41 = log(_1) -> [return: bb17, unwind unreachable];
    }

    bb15: {
        _39 = log(_1) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _37 = Mul(move _38, move _39);
        _36 = Mul(const _, move _37);
        _0 = Add(move _35, move _36);
        goto -> bb18;
    }

    bb17: {
        _40 = Mul(const _, move _41);
        _0 = Add(const _, move _40);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

const j0::PR8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 0f64, const -0.070312499999990036f64, const -8.081670412753498f64, const -257.06310567970485f64, const -2485.2164100942882f64, const -5253.0438049072955f64];
        return;
    }
}

j0::PR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::PS8: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 116.53436461966818f64, const 3833.7447536412183f64, const 40597.857264847255f64, const 116752.97256437592f64, const 47627.728414673096f64];
        return;
    }
}

j0::PS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0::PR5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -1.141254646918945E-11f64, const -0.070312494087359928f64, const -4.1596106447058778f64, const -67.674765226516726f64, const -331.23129964917297f64, const -346.43338836560491f64];
        return;
    }
}

j0::PR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::PS5: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 60.753938269230034f64, const 1051.2523059570458f64, const 5978.9709433385578f64, const 9625.4451435777446f64, const 2406.0581592293911f64];
        return;
    }
}

j0::PS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0::PR3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -2.5470460177195192E-9f64, const -0.070311961638148165f64, const -2.4090322154952961f64, const -21.965977473488309f64, const -58.079170470173757f64, const -31.44794705948885f64];
        return;
    }
}

j0::PR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::PS3: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 35.856033805520973f64, const 361.51398305030386f64, const 1193.6078379211153f64, const 1127.9967985690741f64, const 173.58093081333575f64];
        return;
    }
}

j0::PS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0::PR2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -8.8753433303252641E-8f64, const -0.070303099548362474f64, const -1.4507384678095299f64, const -7.6356961382352777f64, const -11.193166886035675f64, const -3.2336457935133534f64];
        return;
    }
}

j0::PR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::PS2: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 22.220299753208881f64, const 136.20679421821521f64, const 270.47027865808349f64, const 153.87539420832033f64, const 14.657617694825619f64];
        return;
    }
}

j0::PS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn pzero(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: &[f64; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f64;
    let mut _74: f64;
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: f64;
    scope 1 {
        debug p => _2;
        let _3: &[f64; 5];
        scope 2 {
            debug q => _3;
            let _4: f64;
            scope 3 {
                debug z => _4;
                let _5: f64;
                scope 4 {
                    debug r => _5;
                    let _6: f64;
                    scope 5 {
                        debug s => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _79: &[f64; 5];
                            let mut _80: &[f64; 6];
                            let mut _81: &[f64; 5];
                            let mut _82: &[f64; 6];
                            let mut _83: &[f64; 5];
                            let mut _84: &[f64; 6];
                            let mut _85: &[f64; 5];
                            let mut _86: &[f64; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1075838976_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _80 = const _;
        _2 = _80;
        _79 = const _;
        _3 = _79;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1074933387_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _82 = const _;
        _2 = _82;
        _81 = const _;
        _3 = _81;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1074191213_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _84 = const _;
        _2 = _84;
        _83 = const _;
        _3 = _83;
        goto -> bb8;
    }

    bb7: {
        _86 = const _;
        _2 = _86;
        _85 = const _;
        _3 = _85;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _4 = Div(const 1f64, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_4, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_4, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_4, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_4, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_4, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 5_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 5_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 5_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 5_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _75 = const 4_usize;
        _76 = const 5_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _74 = (*_3)[_75];
        _73 = Mul(_4, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_4, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_4, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_4, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_4, move _50);
        _6 = Add(const 1f64, move _49);
        _78 = Div(_5, _6);
        _0 = Add(const 1f64, move _78);
        return;
    }
}

promoted[0] in pzero: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in pzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in pzero: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in pzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in pzero: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in pzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in pzero: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in pzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

pzero::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

pzero::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0::QR8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 0f64, const 0.073242187499993505f64, const 11.768206468225269f64, const 557.67338025640186f64, const 8859.1972075646863f64, const 37014.626777688783f64];
        return;
    }
}

j0::QR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QS8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 163.77602689568982f64, const 8098.3449465644981f64, const 142538.29141912048f64, const 803309.2571195144f64, const 840501.57981906051f64, const -343899.29353786662f64];
        return;
    }
}

j0::QS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QR5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 1.8408596359451553E-11f64, const 0.073242176661268477f64, const 5.8356350896205695f64, const 135.11157728644983f64, const 1027.243765961641f64, const 1989.9778586460538f64];
        return;
    }
}

j0::QR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QS5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 82.776610223653776f64, const 2077.8141642139299f64, const 18847.288778571809f64, const 56751.112289494733f64, const 35976.753842511447f64, const -5354.3427560194477f64];
        return;
    }
}

j0::QS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QR3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 4.3774101408973862E-9f64, const 0.073241118004291145f64, const 3.3442313751617072f64, const 42.621844074541265f64, const 170.8080913405656f64, const 166.73394869665117f64];
        return;
    }
}

j0::QR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QS3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 48.758872972458718f64, const 709.68922105660602f64, const 3704.1482262011136f64, const 6460.4251675256892f64, const 2516.3336892036896f64, const -149.24745183615639f64];
        return;
    }
}

j0::QS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QR2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 1.5044444488698327E-7f64, const 0.073223426596307928f64, const 1.99819174093816f64, const 14.495602934788574f64, const 31.666231750478154f64, const 16.252707571092927f64];
        return;
    }
}

j0::QR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0::QS2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 30.365584835521918f64, const 269.34811860804984f64, const 844.78375759532014f64, const 882.93584511248855f64, const 212.66638851179883f64, const -5.3109549388266695f64];
        return;
    }
}

j0::QS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

fn qzero(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: &[f64; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let _76: usize;
    let mut _77: usize;
    let mut _78: bool;
    let mut _79: f64;
    let mut _80: f64;
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f64;
    let mut _85: f64;
    scope 1 {
        debug p => _2;
        let _3: &[f64; 6];
        scope 2 {
            debug q => _3;
            let _4: f64;
            scope 3 {
                debug s => _4;
                let _5: f64;
                scope 4 {
                    debug r => _5;
                    let _6: f64;
                    scope 5 {
                        debug z => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _86: &[f64; 6];
                            let mut _87: &[f64; 6];
                            let mut _88: &[f64; 6];
                            let mut _89: &[f64; 6];
                            let mut _90: &[f64; 6];
                            let mut _91: &[f64; 6];
                            let mut _92: &[f64; 6];
                            let mut _93: &[f64; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1075838976_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _87 = const _;
        _2 = _87;
        _86 = const _;
        _3 = _86;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1074933387_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _89 = const _;
        _2 = _89;
        _88 = const _;
        _3 = _88;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1074191213_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _91 = const _;
        _2 = _91;
        _90 = const _;
        _3 = _90;
        goto -> bb8;
    }

    bb7: {
        _93 = const _;
        _2 = _93;
        _92 = const _;
        _3 = _92;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _6 = Div(const 1f64, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_6, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_6, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_6, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_6, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_6, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 6_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 6_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 6_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 6_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _76 = const 4_usize;
        _77 = const 6_usize;
        _78 = Lt(_76, _77);
        assert(move _78, "index out of bounds: the length is {} but the index is {}", move _77, _76) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _75 = (*_3)[_76];
        _81 = const 5_usize;
        _82 = const 6_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _80 = (*_3)[_81];
        _79 = Mul(_6, move _80);
        _74 = Add(move _75, move _79);
        _73 = Mul(_6, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_6, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_6, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_6, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_6, move _50);
        _4 = Add(const 1f64, move _49);
        _85 = Div(_5, _4);
        _84 = Add(const -0.125f64, move _85);
        _0 = Div(move _84, _1);
        return;
    }
}

promoted[0] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in qzero: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

qzero::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

qzero::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::INVSQRTPI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.564189613f32;
        return;
    }
}

const j0f::TPI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.636619746f32;
        return;
    }
}

fn j0f::common(_1: u32, _2: f32, _3: bool) -> f32 {
    debug ix => _1;
    debug x => _2;
    debug y0 => _3;
    let mut _0: f32;
    let _4: f32;
    let mut _8: f32;
    let mut _9: f32;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: bool;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: bool;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: bool;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    scope 1 {
        debug z => _4;
        scope 2 {
            debug s => _8;
            let mut _5: f32;
            scope 3 {
                debug c => _5;
                let mut _6: f32;
                scope 4 {
                    debug ss => _6;
                    let mut _7: f32;
                    scope 5 {
                        debug cc => _7;
                    }
                }
            }
        }
    }

    bb0: {
        _8 = sinf(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = cosf(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = move _9;
        switchInt(_3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _10 = _5;
        _5 = Neg(move _10);
        goto -> bb4;
    }

    bb4: {
        _11 = _5;
        _7 = Add(_8, move _11);
        _12 = Lt(_1, const 2130706432_u32);
        switchInt(move _12) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _13 = _5;
        _6 = Sub(_8, move _13);
        _15 = Mul(const 2f32, _2);
        _14 = cosf(move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _4 = Neg(move _14);
        _18 = _5;
        _17 = Mul(_8, move _18);
        _16 = Lt(move _17, const 0f32);
        switchInt(move _16) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _19 = _6;
        _7 = Div(_4, move _19);
        goto -> bb9;
    }

    bb8: {
        _20 = _7;
        _6 = Div(_4, move _20);
        goto -> bb9;
    }

    bb9: {
        _21 = Lt(_1, const 1484783616_u32);
        switchInt(move _21) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        switchInt(_3) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _22 = _6;
        _6 = Neg(move _22);
        goto -> bb12;
    }

    bb12: {
        _24 = pzerof(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = _7;
        _23 = Mul(move _24, move _25);
        _27 = qzerof(_2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _28 = _6;
        _26 = Mul(move _27, move _28);
        _7 = Sub(move _23, move _26);
        goto -> bb15;
    }

    bb15: {
        _30 = _7;
        _29 = Mul(const _, move _30);
        _31 = sqrtf(_2) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Div(move _29, move _31);
        return;
    }
}

const j0f::R02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.015625f32;
        return;
    }
}

const j0f::R03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1.89979299E-4f32;
        return;
    }
}

const j0f::R04: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.82954045E-6f32;
        return;
    }
}

const j0f::R05: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -4.61832705E-9f32;
        return;
    }
}

const j0f::S01: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0156191029f32;
        return;
    }
}

const j0f::S02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.16926785E-4f32;
        return;
    }
}

const j0f::S03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 5.13546524E-7f32;
        return;
    }
}

const j0f::S04: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.16614007E-9f32;
        return;
    }
}

fn j0f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _6: u32;
    let mut _7: f32;
    let mut _8: bool;
    let mut _9: u32;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: f32;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    scope 1 {
        debug z => _2;
        let _3: f32;
        scope 2 {
            debug r => _3;
            let _4: f32;
            scope 3 {
                debug s => _4;
                let mut _5: u32;
                scope 4 {
                    debug ix => _5;
                }
            }
        }
    }

    bb0: {
        _7 = _1;
        _6 = f32::<impl f32>::to_bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move _6;
        _5 = BitAnd(_5, const 2147483647_u32);
        _9 = _5;
        _8 = Ge(move _9, const 2139095040_u32);
        switchInt(move _8) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _11 = _1;
        _12 = _1;
        _10 = Mul(move _11, move _12);
        _0 = Div(const 1f32, move _10);
        goto -> bb11;
    }

    bb3: {
        _14 = _1;
        _13 = fabsf(move _14) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _1 = move _13;
        _16 = _5;
        _15 = Ge(move _16, const 1073741824_u32);
        switchInt(move _15) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _17 = _5;
        _18 = _1;
        _0 = j0f::common(move _17, move _18, const false) -> [return: bb11, unwind unreachable];
    }

    bb6: {
        _20 = _5;
        _19 = Ge(move _20, const 973078528_u32);
        switchInt(move _19) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _21 = _1;
        _22 = _1;
        _2 = Mul(move _21, move _22);
        _28 = Mul(_2, const _);
        _27 = Add(const _, move _28);
        _26 = Mul(_2, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_2, move _25);
        _23 = Add(const _, move _24);
        _3 = Mul(_2, move _23);
        _35 = Mul(_2, const _);
        _34 = Add(const _, move _35);
        _33 = Mul(_2, move _34);
        _32 = Add(const _, move _33);
        _31 = Mul(_2, move _32);
        _30 = Add(const _, move _31);
        _29 = Mul(_2, move _30);
        _4 = Add(const 1f32, move _29);
        _39 = _1;
        _38 = Div(move _39, const 2f32);
        _37 = Add(const 1f32, move _38);
        _42 = _1;
        _41 = Div(move _42, const 2f32);
        _40 = Sub(const 1f32, move _41);
        _36 = Mul(move _37, move _40);
        _44 = Div(_3, _4);
        _43 = Mul(_2, move _44);
        _0 = Add(move _36, move _43);
        goto -> bb11;
    }

    bb8: {
        _46 = _5;
        _45 = Ge(move _46, const 562036736_u32);
        switchInt(move _45) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _48 = _1;
        _47 = Mul(const 0.25f32, move _48);
        _49 = _1;
        _1 = Mul(move _47, move _49);
        goto -> bb10;
    }

    bb10: {
        _50 = _1;
        _0 = Sub(const 1f32, move _50);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

const j0f::U00: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0738042966f32;
        return;
    }
}

const j0f::U01: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.176666453f32;
        return;
    }
}

const j0f::U02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0138185676f32;
        return;
    }
}

const j0f::U03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.47453431E-4f32;
        return;
    }
}

const j0f::U04: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -3.81407062E-6f32;
        return;
    }
}

const j0f::U05: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.9559014E-8f32;
        return;
    }
}

const j0f::U06: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -3.98205184E-11f32;
        return;
    }
}

const j0f::V01: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0127304839f32;
        return;
    }
}

const j0f::V02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.60068651E-5f32;
        return;
    }
}

const j0f::V03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2.59150852E-7f32;
        return;
    }
}

const j0f::V04: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 4.41110315E-10f32;
        return;
    }
}

fn y0f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    scope 1 {
        debug z => _2;
        let _3: f32;
        scope 2 {
            debug u => _3;
            let _4: f32;
            scope 3 {
                debug v => _4;
                scope 4 {
                    debug ix => _5;
                }
            }
        }
    }

    bb0: {
        _5 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = BitAnd(_5, const 2147483647_u32);
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = Div(const -1f32, const 0f32);
        goto -> bb16;
    }

    bb3: {
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _7 = Shr(_5, const 31_i32);
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = Div(const 0f32, const 0f32);
        goto -> bb16;
    }

    bb6: {
        _10 = Ge(_5, const 2139095040_u32);
        switchInt(move _10) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Div(const 1f32, _1);
        goto -> bb16;
    }

    bb8: {
        _11 = Ge(_5, const 1073741824_u32);
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = j0f::common(_5, _1, const true) -> [return: bb16, unwind unreachable];
    }

    bb10: {
        _12 = Ge(_5, const 956301312_u32);
        switchInt(move _12) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _2 = Mul(_1, _1);
        _23 = Mul(_2, const _);
        _22 = Add(const _, move _23);
        _21 = Mul(_2, move _22);
        _20 = Add(const _, move _21);
        _19 = Mul(_2, move _20);
        _18 = Add(const _, move _19);
        _17 = Mul(_2, move _18);
        _16 = Add(const _, move _17);
        _15 = Mul(_2, move _16);
        _14 = Add(const _, move _15);
        _13 = Mul(_2, move _14);
        _3 = Add(const _, move _13);
        _30 = Mul(_2, const _);
        _29 = Add(const _, move _30);
        _28 = Mul(_2, move _29);
        _27 = Add(const _, move _28);
        _26 = Mul(_2, move _27);
        _25 = Add(const _, move _26);
        _24 = Mul(_2, move _25);
        _4 = Add(const 1f32, move _24);
        _31 = Div(_3, _4);
        _34 = j0f(_1) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _37 = logf(_1) -> [return: bb15, unwind unreachable];
    }

    bb13: {
        _35 = logf(_1) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _33 = Mul(move _34, move _35);
        _32 = Mul(const _, move _33);
        _0 = Add(move _31, move _32);
        goto -> bb16;
    }

    bb15: {
        _36 = Mul(const _, move _37);
        _0 = Add(const _, move _36);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

const j0f::PR8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 0f32, const -0.0703125f32, const -8.08167076f32, const -257.06311f32, const -2485.21631f32, const -5253.04395f32];
        return;
    }
}

j0f::PR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::PS8: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 116.534363f32, const 3833.74487f32, const 40597.8555f32, const 116752.969f32, const 47627.7266f32];
        return;
    }
}

j0f::PS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0f::PR5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -1.14125463E-11f32, const -0.0703124925f32, const -4.15961075f32, const -67.6747665f32, const -331.231293f32, const -346.43338f32];
        return;
    }
}

j0f::PR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::PS5: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 60.7539368f32, const 1051.25232f32, const 5978.9707f32, const 9625.44531f32, const 2406.05811f32];
        return;
    }
}

j0f::PS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0f::PR3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -2.54704591E-9f32, const -0.0703119636f32, const -2.40903211f32, const -21.9659767f32, const -58.0791702f32, const -31.4479465f32];
        return;
    }
}

j0f::PR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::PS3: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 35.8560333f32, const 361.513977f32, const 1193.60779f32, const 1127.99683f32, const 173.580933f32];
        return;
    }
}

j0f::PS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0f::PR2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -8.87534312E-8f32, const -0.0703030974f32, const -1.45073843f32, const -7.63569593f32, const -11.1931667f32, const -3.23364568f32];
        return;
    }
}

j0f::PR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::PS2: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 22.2203007f32, const 136.206787f32, const 270.470276f32, const 153.875397f32, const 14.6576176f32];
        return;
    }
}

j0f::PS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn pzerof(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: &[f32; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f32;
    let mut _45: f32;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f32;
    let mut _74: f32;
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: f32;
    scope 1 {
        debug p => _2;
        let _3: &[f32; 5];
        scope 2 {
            debug q => _3;
            let _4: f32;
            scope 3 {
                debug z => _4;
                let _5: f32;
                scope 4 {
                    debug r => _5;
                    let _6: f32;
                    scope 5 {
                        debug s => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _79: &[f32; 5];
                            let mut _80: &[f32; 6];
                            let mut _81: &[f32; 5];
                            let mut _82: &[f32; 6];
                            let mut _83: &[f32; 5];
                            let mut _84: &[f32; 6];
                            let mut _85: &[f32; 5];
                            let mut _86: &[f32; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1090519040_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _80 = const _;
        _2 = _80;
        _79 = const _;
        _3 = _79;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1083274219_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _82 = const _;
        _2 = _82;
        _81 = const _;
        _3 = _81;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1077336343_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _84 = const _;
        _2 = _84;
        _83 = const _;
        _3 = _83;
        goto -> bb8;
    }

    bb7: {
        _86 = const _;
        _2 = _86;
        _85 = const _;
        _3 = _85;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _4 = Div(const 1f32, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_4, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_4, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_4, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_4, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_4, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 5_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 5_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 5_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 5_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _75 = const 4_usize;
        _76 = const 5_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _74 = (*_3)[_75];
        _73 = Mul(_4, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_4, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_4, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_4, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_4, move _50);
        _6 = Add(const 1f32, move _49);
        _78 = Div(_5, _6);
        _0 = Add(const 1f32, move _78);
        return;
    }
}

promoted[0] in pzerof: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in pzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in pzerof: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in pzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in pzerof: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in pzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in pzerof: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in pzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

pzerof::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

pzerof::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j0f::QR8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 0f32, const 0.0732421875f32, const 11.7682066f32, const 557.673401f32, const 8859.19726f32, const 37014.625f32];
        return;
    }
}

j0f::QR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QS8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 163.776031f32, const 8098.34472f32, const 142538.297f32, const 803309.25f32, const 840501.563f32, const -343899.281f32];
        return;
    }
}

j0f::QS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QR5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 1.84085958E-11f32, const 0.07324218f32, const 5.83563519f32, const 135.111572f32, const 1027.24377f32, const 1989.97791f32];
        return;
    }
}

j0f::QR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QS5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 82.7766113f32, const 2077.81421f32, const 18847.2891f32, const 56751.1133f32, const 35976.7539f32, const -5354.34277f32];
        return;
    }
}

j0f::QS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QR3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 4.37740999E-9f32, const 0.0732411146f32, const 3.34423137f32, const 42.6218452f32, const 170.80809f32, const 166.733948f32];
        return;
    }
}

j0f::QR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QS3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 48.758873f32, const 709.689208f32, const 3704.14819f32, const 6460.42529f32, const 2516.33374f32, const -149.247452f32];
        return;
    }
}

j0f::QS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QR2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 1.5044445E-7f32, const 0.0732234269f32, const 1.99819171f32, const 14.4956026f32, const 31.6662312f32, const 16.2527084f32];
        return;
    }
}

j0f::QR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j0f::QS2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 30.3655853f32, const 269.348114f32, const 844.783752f32, const 882.935852f32, const 212.666382f32, const -5.31095505f32];
        return;
    }
}

j0f::QS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

fn qzerof(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: &[f32; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f32;
    let mut _45: f32;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let _76: usize;
    let mut _77: usize;
    let mut _78: bool;
    let mut _79: f32;
    let mut _80: f32;
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f32;
    let mut _85: f32;
    scope 1 {
        debug p => _2;
        let _3: &[f32; 6];
        scope 2 {
            debug q => _3;
            let _4: f32;
            scope 3 {
                debug s => _4;
                let _5: f32;
                scope 4 {
                    debug r => _5;
                    let _6: f32;
                    scope 5 {
                        debug z => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _86: &[f32; 6];
                            let mut _87: &[f32; 6];
                            let mut _88: &[f32; 6];
                            let mut _89: &[f32; 6];
                            let mut _90: &[f32; 6];
                            let mut _91: &[f32; 6];
                            let mut _92: &[f32; 6];
                            let mut _93: &[f32; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1090519040_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _87 = const _;
        _2 = _87;
        _86 = const _;
        _3 = _86;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1083274219_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _89 = const _;
        _2 = _89;
        _88 = const _;
        _3 = _88;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1077336343_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _91 = const _;
        _2 = _91;
        _90 = const _;
        _3 = _90;
        goto -> bb8;
    }

    bb7: {
        _93 = const _;
        _2 = _93;
        _92 = const _;
        _3 = _92;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _6 = Div(const 1f32, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_6, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_6, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_6, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_6, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_6, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 6_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 6_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 6_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 6_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _76 = const 4_usize;
        _77 = const 6_usize;
        _78 = Lt(_76, _77);
        assert(move _78, "index out of bounds: the length is {} but the index is {}", move _77, _76) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _75 = (*_3)[_76];
        _81 = const 5_usize;
        _82 = const 6_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _80 = (*_3)[_81];
        _79 = Mul(_6, move _80);
        _74 = Add(move _75, move _79);
        _73 = Mul(_6, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_6, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_6, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_6, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_6, move _50);
        _4 = Add(const 1f32, move _49);
        _85 = Div(_5, _4);
        _84 = Add(const -0.125f32, move _85);
        _0 = Div(move _84, _1);
        return;
    }
}

promoted[0] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in qzerof: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

qzerof::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

qzerof::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::INVSQRTPI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.56418958354775628f64;
        return;
    }
}

const j1::TPI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.63661977236758138f64;
        return;
    }
}

fn j1::common(_1: u32, _2: f64, _3: bool, _4: bool) -> f64 {
    debug ix => _1;
    debug x => _2;
    debug y1 => _3;
    debug sign => _4;
    let mut _0: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: bool;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: bool;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: bool;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    scope 1 {
        debug z => _15;
        let mut _5: f64;
        scope 2 {
            debug s => _5;
            scope 3 {
                debug c => _10;
                let mut _6: f64;
                scope 4 {
                    debug ss => _6;
                    let mut _7: f64;
                    scope 5 {
                        debug cc => _7;
                    }
                }
            }
        }
    }

    bb0: {
        _8 = sin(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move _8;
        switchInt(_3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _9 = _5;
        _5 = Neg(move _9);
        goto -> bb3;
    }

    bb3: {
        _10 = cos(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _11 = _5;
        _7 = Sub(move _11, _10);
        _12 = Lt(_1, const 2145386496_u32);
        switchInt(move _12) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _14 = _5;
        _13 = Neg(move _14);
        _6 = Sub(move _13, _10);
        _16 = Mul(const 2f64, _2);
        _15 = cos(move _16) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _19 = _5;
        _18 = Mul(move _19, _10);
        _17 = Gt(move _18, const 0f64);
        switchInt(move _17) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _20 = _6;
        _7 = Div(_15, move _20);
        goto -> bb9;
    }

    bb8: {
        _21 = _7;
        _6 = Div(_15, move _21);
        goto -> bb9;
    }

    bb9: {
        _22 = Lt(_1, const 1207959552_u32);
        switchInt(move _22) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        switchInt(_3) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _23 = _6;
        _6 = Neg(move _23);
        goto -> bb12;
    }

    bb12: {
        _25 = pone(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _26 = _7;
        _24 = Mul(move _25, move _26);
        _28 = qone(_2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _29 = _6;
        _27 = Mul(move _28, move _29);
        _7 = Sub(move _24, move _27);
        goto -> bb15;
    }

    bb15: {
        switchInt(_4) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _30 = _7;
        _7 = Neg(move _30);
        goto -> bb17;
    }

    bb17: {
        _32 = _7;
        _31 = Mul(const _, move _32);
        _33 = sqrt(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = Div(move _31, move _33);
        return;
    }
}

const j1::R00: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0625f64;
        return;
    }
}

const j1::R01: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0014070566695518971f64;
        return;
    }
}

const j1::R02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.599556310840356E-5f64;
        return;
    }
}

const j1::R03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.9672799960958445E-8f64;
        return;
    }
}

const j1::S01: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.019153759953836346f64;
        return;
    }
}

const j1::S02: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.8594678558863092E-4f64;
        return;
    }
}

const j1::S03: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.1771846404262368E-6f64;
        return;
    }
}

const j1::S04: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 5.0463625707621704E-9f64;
        return;
    }
}

const j1::S05: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.2354227442613791E-11f64;
        return;
    }
}

fn j1(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: f64;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: f64;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug r => _3;
            let _4: f64;
            scope 3 {
                debug s => _4;
                let mut _5: u32;
                scope 4 {
                    debug ix => _5;
                    let _6: bool;
                    scope 5 {
                        debug sign => _6;
                    }
                }
            }
        }
    }

    bb0: {
        _7 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move _7;
        _9 = _5;
        _10 = const 31_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 31_i32);
        _6 = Ne(move _8, const 0_u32);
        _5 = BitAnd(_5, const 2147483647_u32);
        _13 = _5;
        _12 = Ge(move _13, const 2146435072_u32);
        switchInt(move _12) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _14 = Mul(_1, _1);
        _0 = Div(const 1f64, move _14);
        goto -> bb11;
    }

    bb4: {
        _16 = _5;
        _15 = Ge(move _16, const 1073741824_u32);
        switchInt(move _15) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _17 = _5;
        _18 = fabs(_1) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _20 = _5;
        _19 = Ge(move _20, const 939524096_u32);
        switchInt(move _19) -> [0: bb9, otherwise: bb8];
    }

    bb7: {
        _0 = j1::common(move _17, move _18, const false, _6) -> [return: bb11, unwind unreachable];
    }

    bb8: {
        _2 = Mul(_1, _1);
        _21 = _2;
        _24 = _2;
        _27 = _2;
        _30 = _2;
        _29 = Mul(move _30, const _);
        _28 = Add(const _, move _29);
        _26 = Mul(move _27, move _28);
        _25 = Add(const _, move _26);
        _23 = Mul(move _24, move _25);
        _22 = Add(const _, move _23);
        _3 = Mul(move _21, move _22);
        _32 = _2;
        _35 = _2;
        _38 = _2;
        _41 = _2;
        _44 = _2;
        _43 = Mul(move _44, const _);
        _42 = Add(const _, move _43);
        _40 = Mul(move _41, move _42);
        _39 = Add(const _, move _40);
        _37 = Mul(move _38, move _39);
        _36 = Add(const _, move _37);
        _34 = Mul(move _35, move _36);
        _33 = Add(const _, move _34);
        _31 = Mul(move _32, move _33);
        _4 = Add(const 1f64, move _31);
        _2 = Div(_3, _4);
        goto -> bb10;
    }

    bb9: {
        _2 = _1;
        goto -> bb10;
    }

    bb10: {
        _46 = _2;
        _45 = Add(const 0.5f64, move _46);
        _0 = Mul(move _45, _1);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

const j1::U0: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const -0.19605709064623894f64, const 0.050443871663981128f64, const -0.0019125689587576355f64, const 2.352526005616105E-5f64, const -9.1909915803987887E-8f64];
        return;
    }
}

j1::U0::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1::V0: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 0.01991673182366499f64, const 2.0255258102513517E-4f64, const 1.3560880109751623E-6f64, const 6.227414523646215E-9f64, const 1.6655924620799208E-11f64];
        return;
    }
}

j1::V0::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn y1(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: [f64; 5];
    let _20: usize;
    let mut _21: usize;
    let mut _22: bool;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: [f64; 5];
    let _27: usize;
    let mut _28: usize;
    let mut _29: bool;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: [f64; 5];
    let _34: usize;
    let mut _35: usize;
    let mut _36: bool;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: [f64; 5];
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: [f64; 5];
    let _47: usize;
    let mut _48: usize;
    let mut _49: bool;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: [f64; 5];
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: [f64; 5];
    let _61: usize;
    let mut _62: usize;
    let mut _63: bool;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: [f64; 5];
    let _68: usize;
    let mut _69: usize;
    let mut _70: bool;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: [f64; 5];
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: [f64; 5];
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug u => _3;
            let _4: f64;
            scope 3 {
                debug v => _4;
                scope 4 {
                    debug ix => _5;
                    scope 5 {
                        debug lx => _6;
                    }
                }
            }
        }
    }

    bb0: {
        _5 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = get_low_word(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = const 1_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shl(_5, const 1_i32);
        _7 = BitOr(move _8, _6);
        switchInt(move _7) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _0 = Div(const -1f64, const 0f64);
        goto -> bb27;
    }

    bb5: {
        _12 = const 31_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 32_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _11 = Shr(_5, const 31_i32);
        switchInt(move _11) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Div(const 0f64, const 0f64);
        goto -> bb27;
    }

    bb8: {
        _14 = Ge(_5, const 2146435072_u32);
        switchInt(move _14) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = Div(const 1f64, _1);
        goto -> bb27;
    }

    bb10: {
        _15 = Ge(_5, const 1073741824_u32);
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = j1::common(_5, _1, const true, const false) -> [return: bb27, unwind unreachable];
    }

    bb12: {
        _16 = Lt(_5, const 1016070144_u32);
        switchInt(move _16) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _17 = Neg(const _);
        _0 = Div(move _17, _1);
        goto -> bb27;
    }

    bb14: {
        _2 = Mul(_1, _1);
        _19 = const _;
        _20 = const 0_usize;
        _21 = const 5_usize;
        _22 = Lt(_20, _21);
        assert(move _22, "index out of bounds: the length is {} but the index is {}", move _21, _20) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _18 = _19[_20];
        _26 = const _;
        _27 = const 1_usize;
        _28 = const 5_usize;
        _29 = Lt(_27, _28);
        assert(move _29, "index out of bounds: the length is {} but the index is {}", move _28, _27) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _25 = _26[_27];
        _33 = const _;
        _34 = const 2_usize;
        _35 = const 5_usize;
        _36 = Lt(_34, _35);
        assert(move _36, "index out of bounds: the length is {} but the index is {}", move _35, _34) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _32 = _33[_34];
        _40 = const _;
        _41 = const 3_usize;
        _42 = const 5_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _39 = _40[_41];
        _46 = const _;
        _47 = const 4_usize;
        _48 = const 5_usize;
        _49 = Lt(_47, _48);
        assert(move _49, "index out of bounds: the length is {} but the index is {}", move _48, _47) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _45 = _46[_47];
        _44 = Mul(_2, move _45);
        _38 = Add(move _39, move _44);
        _37 = Mul(_2, move _38);
        _31 = Add(move _32, move _37);
        _30 = Mul(_2, move _31);
        _24 = Add(move _25, move _30);
        _23 = Mul(_2, move _24);
        _3 = Add(move _18, move _23);
        _53 = const _;
        _54 = const 0_usize;
        _55 = const 5_usize;
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _52 = _53[_54];
        _60 = const _;
        _61 = const 1_usize;
        _62 = const 5_usize;
        _63 = Lt(_61, _62);
        assert(move _63, "index out of bounds: the length is {} but the index is {}", move _62, _61) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _59 = _60[_61];
        _67 = const _;
        _68 = const 2_usize;
        _69 = const 5_usize;
        _70 = Lt(_68, _69);
        assert(move _70, "index out of bounds: the length is {} but the index is {}", move _69, _68) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _66 = _67[_68];
        _74 = const _;
        _75 = const 3_usize;
        _76 = const 5_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _73 = _74[_75];
        _80 = const _;
        _81 = const 4_usize;
        _82 = const 5_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _79 = _80[_81];
        _78 = Mul(_2, move _79);
        _72 = Add(move _73, move _78);
        _71 = Mul(_2, move _72);
        _65 = Add(move _66, move _71);
        _64 = Mul(_2, move _65);
        _58 = Add(move _59, move _64);
        _57 = Mul(_2, move _58);
        _51 = Add(move _52, move _57);
        _50 = Mul(_2, move _51);
        _4 = Add(const 1f64, move _50);
        _85 = Div(_3, _4);
        _84 = Mul(_1, move _85);
        _89 = j1(_1) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _90 = log(_1) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _88 = Mul(move _89, move _90);
        _91 = Div(const 1f64, _1);
        _87 = Sub(move _88, move _91);
        _86 = Mul(const _, move _87);
        _0 = Add(move _84, move _86);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

const j1::PR8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 0f64, const 0.11718749999998865f64, const 13.239480659307358f64, const 412.05185430737856f64, const 3874.7453891396053f64, const 7914.4795403189173f64];
        return;
    }
}

j1::PR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::PS8: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 114.20737037567841f64, const 3650.9308342085346f64, const 36956.206026903346f64, const 97602.79359349508f64, const 30804.272062788881f64];
        return;
    }
}

j1::PS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1::PR5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 1.3199051955624352E-11f64, const 0.1171874931906141f64, const 6.8027512786843287f64, const 108.30818299018911f64, const 517.63613953319975f64, const 528.71520136333754f64];
        return;
    }
}

j1::PR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::PS5: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 59.280598722113133f64, const 991.40141873361438f64, const 5353.2669529148798f64, const 7844.6903174955123f64, const 1504.0468881036106f64];
        return;
    }
}

j1::PS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1::PR3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 3.0250391613737362E-9f64, const 0.11718686556725359f64, const 3.9329775003331564f64, const 35.119403559163693f64, const 91.055011075078127f64, const 48.559068519736492f64];
        return;
    }
}

j1::PR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::PS3: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 34.791309500125152f64, const 336.76245874782575f64, const 1046.8713997577513f64, const 890.81134639825643f64, const 103.78793243963928f64];
        return;
    }
}

j1::PS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1::PR2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 1.0771083010687374E-7f64, const 0.11717621946268335f64, const 2.3685149666760879f64, const 12.242610914826123f64, const 17.693971127168773f64, const 5.073523125888185f64];
        return;
    }
}

j1::PR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::PS2: [f64; 5] = {
    let mut _0: [f64; 5];

    bb0: {
        _0 = [const 21.436485936382141f64, const 125.29022716840275f64, const 232.27646905716281f64, const 117.6793732871471f64, const 8.3646389337161828f64];
        return;
    }
}

j1::PS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn pone(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: &[f64; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f64;
    let mut _74: f64;
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: f64;
    scope 1 {
        debug p => _2;
        let _3: &[f64; 5];
        scope 2 {
            debug q => _3;
            let _4: f64;
            scope 3 {
                debug z => _4;
                let _5: f64;
                scope 4 {
                    debug r => _5;
                    let _6: f64;
                    scope 5 {
                        debug s => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _79: &[f64; 5];
                            let mut _80: &[f64; 6];
                            let mut _81: &[f64; 5];
                            let mut _82: &[f64; 6];
                            let mut _83: &[f64; 5];
                            let mut _84: &[f64; 6];
                            let mut _85: &[f64; 5];
                            let mut _86: &[f64; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1075838976_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _80 = const _;
        _2 = _80;
        _79 = const _;
        _3 = _79;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1074933387_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _82 = const _;
        _2 = _82;
        _81 = const _;
        _3 = _81;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1074191213_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _84 = const _;
        _2 = _84;
        _83 = const _;
        _3 = _83;
        goto -> bb8;
    }

    bb7: {
        _86 = const _;
        _2 = _86;
        _85 = const _;
        _3 = _85;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _4 = Div(const 1f64, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_4, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_4, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_4, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_4, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_4, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 5_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 5_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 5_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 5_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _75 = const 4_usize;
        _76 = const 5_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _74 = (*_3)[_75];
        _73 = Mul(_4, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_4, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_4, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_4, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_4, move _50);
        _6 = Add(const 1f64, move _49);
        _78 = Div(_5, _6);
        _0 = Add(const 1f64, move _78);
        return;
    }
}

promoted[0] in pone: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in pone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in pone: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in pone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in pone: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in pone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in pone: &[f64; 5] = {
    let mut _0: &[f64; 5];
    let mut _1: [f64; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in pone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

pone::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

pone::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1::QR8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 0f64, const -0.10253906249999271f64, const -16.271753454458999f64, const -759.60172251395011f64, const -11849.806670242959f64, const -48438.512428575035f64];
        return;
    }
}

j1::QR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QS8: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 161.39536970072291f64, const 7825.3859992334847f64, const 133875.33628724958f64, const 719657.72368324094f64, const 666601.23261777638f64, const -294490.26430383464f64];
        return;
    }
}

j1::QS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QR5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -2.089799311417641E-11f64, const -0.10253905024137543f64, const -8.0564482812393603f64, const -183.66960747488838f64, const -1373.1937606550816f64, const -2612.4444045321566f64];
        return;
    }
}

j1::QR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QS5: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 81.276550138433578f64, const 1991.7987346048596f64, const 17468.485192490891f64, const 49851.427091035228f64, const 27948.075163891812f64, const -4719.1835479512847f64];
        return;
    }
}

j1::QS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QR3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -5.0783122646176656E-9f64, const -0.10253782982083709f64, const -4.610115811394734f64, const -57.847221656278364f64, const -228.2445407376317f64, const -219.21012847890933f64];
        return;
    }
}

j1::QR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QS3: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 47.665155032372951f64, const 673.86511267669971f64, const 3380.1528667952634f64, const 5547.7290972072278f64, const 1903.119193388108f64, const -135.20119144430734f64];
        return;
    }
}

j1::QS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QR2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const -1.7838172751095887E-7f64, const -0.10251704260798555f64, const -2.7522056827818746f64, const -19.663616264370372f64, const -42.325313337283049f64, const -21.371921170370406f64];
        return;
    }
}

j1::QR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1::QS2: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 29.533362906052385f64, const 252.98154998219053f64, const 757.50283486864544f64, const 739.39320532046725f64, const 155.94900333666612f64, const -4.9594989882262821f64];
        return;
    }
}

j1::QS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

fn qone(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: &[f64; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f64;
    let mut _16: f64;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let _76: usize;
    let mut _77: usize;
    let mut _78: bool;
    let mut _79: f64;
    let mut _80: f64;
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f64;
    let mut _85: f64;
    scope 1 {
        debug p => _2;
        let _3: &[f64; 6];
        scope 2 {
            debug q => _3;
            let _4: f64;
            scope 3 {
                debug s => _4;
                let _5: f64;
                scope 4 {
                    debug r => _5;
                    let _6: f64;
                    scope 5 {
                        debug z => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _86: &[f64; 6];
                            let mut _87: &[f64; 6];
                            let mut _88: &[f64; 6];
                            let mut _89: &[f64; 6];
                            let mut _90: &[f64; 6];
                            let mut _91: &[f64; 6];
                            let mut _92: &[f64; 6];
                            let mut _93: &[f64; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1075838976_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _87 = const _;
        _2 = _87;
        _86 = const _;
        _3 = _86;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1074933387_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _89 = const _;
        _2 = _89;
        _88 = const _;
        _3 = _88;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1074191213_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _91 = const _;
        _2 = _91;
        _90 = const _;
        _3 = _90;
        goto -> bb8;
    }

    bb7: {
        _93 = const _;
        _2 = _93;
        _92 = const _;
        _3 = _92;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _6 = Div(const 1f64, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_6, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_6, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_6, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_6, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_6, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 6_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 6_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 6_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 6_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _76 = const 4_usize;
        _77 = const 6_usize;
        _78 = Lt(_76, _77);
        assert(move _78, "index out of bounds: the length is {} but the index is {}", move _77, _76) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _75 = (*_3)[_76];
        _81 = const 5_usize;
        _82 = const 6_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _80 = (*_3)[_81];
        _79 = Mul(_6, move _80);
        _74 = Add(move _75, move _79);
        _73 = Mul(_6, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_6, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_6, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_6, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_6, move _50);
        _4 = Add(const 1f64, move _49);
        _85 = Div(_5, _4);
        _84 = Add(const 0.375f64, move _85);
        _0 = Div(move _84, _1);
        return;
    }
}

promoted[0] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in qone: &[f64; 6] = {
    let mut _0: &[f64; 6];
    let mut _1: [f64; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

qone::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

qone::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::INVSQRTPI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.564189613f32;
        return;
    }
}

const j1f::TPI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.636619746f32;
        return;
    }
}

fn j1f::common(_1: u32, _2: f32, _3: bool, _4: bool) -> f32 {
    debug ix => _1;
    debug x => _2;
    debug y1 => _3;
    debug sign => _4;
    let mut _0: f32;
    let _5: f64;
    let mut _10: f32;
    let mut _11: f64;
    let mut _12: f32;
    let mut _13: f64;
    let mut _14: bool;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: bool;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f32;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f32;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f32;
    scope 1 {
        debug z => _5;
        let mut _6: f64;
        scope 2 {
            debug s => _6;
            let _7: f64;
            scope 3 {
                debug c => _7;
                let mut _8: f64;
                scope 4 {
                    debug ss => _8;
                    let mut _9: f64;
                    scope 5 {
                        debug cc => _9;
                    }
                }
            }
        }
    }

    bb0: {
        _10 = sinf(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = move _10 as f64 (FloatToFloat);
        switchInt(_3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _11 = _6;
        _6 = Neg(move _11);
        goto -> bb3;
    }

    bb3: {
        _12 = cosf(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _7 = move _12 as f64 (FloatToFloat);
        _13 = _6;
        _9 = Sub(move _13, _7);
        _14 = Lt(_1, const 2130706432_u32);
        switchInt(move _14) -> [0: bb15, otherwise: bb5];
    }

    bb5: {
        _16 = _6;
        _15 = Neg(move _16);
        _8 = Sub(move _15, _7);
        _18 = Mul(const 2f32, _2);
        _17 = cosf(move _18) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _5 = move _17 as f64 (FloatToFloat);
        _21 = _6;
        _20 = Mul(move _21, _7);
        _19 = Gt(move _20, const 0f64);
        switchInt(move _19) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _22 = _8;
        _9 = Div(_5, move _22);
        goto -> bb9;
    }

    bb8: {
        _23 = _9;
        _8 = Div(_5, move _23);
        goto -> bb9;
    }

    bb9: {
        _24 = Lt(_1, const 1484783616_u32);
        switchInt(move _24) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        switchInt(_3) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _25 = _8;
        _8 = Neg(move _25);
        goto -> bb12;
    }

    bb12: {
        _28 = ponef(_2) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _27 = move _28 as f64 (FloatToFloat);
        _29 = _9;
        _26 = Mul(move _27, move _29);
        _32 = qonef(_2) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _31 = move _32 as f64 (FloatToFloat);
        _33 = _8;
        _30 = Mul(move _31, move _33);
        _9 = Sub(move _26, move _30);
        goto -> bb15;
    }

    bb15: {
        switchInt(_4) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _34 = _9;
        _9 = Neg(move _34);
        goto -> bb17;
    }

    bb17: {
        _37 = const _ as f64 (FloatToFloat);
        _38 = _9;
        _36 = Mul(move _37, move _38);
        _40 = sqrtf(_2) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _39 = move _40 as f64 (FloatToFloat);
        _35 = Div(move _36, move _39);
        _0 = move _35 as f32 (FloatToFloat);
        return;
    }
}

const j1f::R00: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0625f32;
        return;
    }
}

const j1f::R01: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0014070567f32;
        return;
    }
}

const j1f::R02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1.59955634E-5f32;
        return;
    }
}

const j1f::R03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 4.96727992E-8f32;
        return;
    }
}

const j1f::S01: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0191537607f32;
        return;
    }
}

const j1f::S02: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.85946788E-4f32;
        return;
    }
}

const j1f::S03: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.17718469E-6f32;
        return;
    }
}

const j1f::S04: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 5.04636244E-9f32;
        return;
    }
}

const j1f::S05: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.2354227E-11f32;
        return;
    }
}

fn j1f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: f32;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    scope 1 {
        debug z => _2;
        let _3: f32;
        scope 2 {
            debug r => _3;
            let _4: f32;
            scope 3 {
                debug s => _4;
                let mut _5: u32;
                scope 4 {
                    debug ix => _5;
                    let _6: bool;
                    scope 5 {
                        debug sign => _6;
                    }
                }
            }
        }
    }

    bb0: {
        _7 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move _7;
        _9 = _5;
        _10 = const 31_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 31_i32);
        _6 = Ne(move _8, const 0_u32);
        _5 = BitAnd(_5, const 2147483647_u32);
        _13 = _5;
        _12 = Ge(move _13, const 2139095040_u32);
        switchInt(move _12) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _14 = Mul(_1, _1);
        _0 = Div(const 1f32, move _14);
        goto -> bb11;
    }

    bb4: {
        _16 = _5;
        _15 = Ge(move _16, const 1073741824_u32);
        switchInt(move _15) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _17 = _5;
        _18 = fabsf(_1) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _20 = _5;
        _19 = Ge(move _20, const 956301312_u32);
        switchInt(move _19) -> [0: bb9, otherwise: bb8];
    }

    bb7: {
        _0 = j1f::common(move _17, move _18, const false, _6) -> [return: bb11, unwind unreachable];
    }

    bb8: {
        _2 = Mul(_1, _1);
        _21 = _2;
        _24 = _2;
        _27 = _2;
        _30 = _2;
        _29 = Mul(move _30, const _);
        _28 = Add(const _, move _29);
        _26 = Mul(move _27, move _28);
        _25 = Add(const _, move _26);
        _23 = Mul(move _24, move _25);
        _22 = Add(const _, move _23);
        _3 = Mul(move _21, move _22);
        _32 = _2;
        _35 = _2;
        _38 = _2;
        _41 = _2;
        _44 = _2;
        _43 = Mul(move _44, const _);
        _42 = Add(const _, move _43);
        _40 = Mul(move _41, move _42);
        _39 = Add(const _, move _40);
        _37 = Mul(move _38, move _39);
        _36 = Add(const _, move _37);
        _34 = Mul(move _35, move _36);
        _33 = Add(const _, move _34);
        _31 = Mul(move _32, move _33);
        _4 = Add(const 1f32, move _31);
        _45 = Div(_3, _4);
        _2 = Add(const 0.5f32, move _45);
        goto -> bb10;
    }

    bb9: {
        _2 = const 0.5f32;
        goto -> bb10;
    }

    bb10: {
        _46 = _2;
        _0 = Mul(move _46, _1);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

const j1f::U0: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const -0.196057096f32, const 0.0504438728f32, const -0.00191256893f32, const 2.35252592E-5f32, const -9.19099178E-8f32];
        return;
    }
}

j1f::U0::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1f::V0: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 0.0199167319f32, const 2.02552576E-4f32, const 1.35608798E-6f32, const 6.22741458E-9f32, const 1.66559249E-11f32];
        return;
    }
}

j1f::V0::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn y1f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: f32;
    let mut _14: f32;
    let mut _15: [f32; 5];
    let _16: usize;
    let mut _17: usize;
    let mut _18: bool;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: [f32; 5];
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: [f32; 5];
    let _30: usize;
    let mut _31: usize;
    let mut _32: bool;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: [f32; 5];
    let _37: usize;
    let mut _38: usize;
    let mut _39: bool;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: [f32; 5];
    let _43: usize;
    let mut _44: usize;
    let mut _45: bool;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: [f32; 5];
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: [f32; 5];
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let mut _60: f32;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: [f32; 5];
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: [f32; 5];
    let _71: usize;
    let mut _72: usize;
    let mut _73: bool;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: [f32; 5];
    let _77: usize;
    let mut _78: usize;
    let mut _79: bool;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    scope 1 {
        debug z => _2;
        let _3: f32;
        scope 2 {
            debug u => _3;
            let _4: f32;
            scope 3 {
                debug v => _4;
                scope 4 {
                    debug ix => _5;
                }
            }
        }
    }

    bb0: {
        _5 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = BitAnd(_5, const 2147483647_u32);
        switchInt(move _6) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = Div(const -1f32, const 0f32);
        goto -> bb25;
    }

    bb3: {
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _7 = Shr(_5, const 31_i32);
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = Div(const 0f32, const 0f32);
        goto -> bb25;
    }

    bb6: {
        _10 = Ge(_5, const 2139095040_u32);
        switchInt(move _10) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Div(const 1f32, _1);
        goto -> bb25;
    }

    bb8: {
        _11 = Ge(_5, const 1073741824_u32);
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = j1f::common(_5, _1, const true, const false) -> [return: bb25, unwind unreachable];
    }

    bb10: {
        _12 = Lt(_5, const 855638016_u32);
        switchInt(move _12) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _13 = Neg(const _);
        _0 = Div(move _13, _1);
        goto -> bb25;
    }

    bb12: {
        _2 = Mul(_1, _1);
        _15 = const _;
        _16 = const 0_usize;
        _17 = const 5_usize;
        _18 = Lt(_16, _17);
        assert(move _18, "index out of bounds: the length is {} but the index is {}", move _17, _16) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _14 = _15[_16];
        _22 = const _;
        _23 = const 1_usize;
        _24 = const 5_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _21 = _22[_23];
        _29 = const _;
        _30 = const 2_usize;
        _31 = const 5_usize;
        _32 = Lt(_30, _31);
        assert(move _32, "index out of bounds: the length is {} but the index is {}", move _31, _30) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _28 = _29[_30];
        _36 = const _;
        _37 = const 3_usize;
        _38 = const 5_usize;
        _39 = Lt(_37, _38);
        assert(move _39, "index out of bounds: the length is {} but the index is {}", move _38, _37) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _35 = _36[_37];
        _42 = const _;
        _43 = const 4_usize;
        _44 = const 5_usize;
        _45 = Lt(_43, _44);
        assert(move _45, "index out of bounds: the length is {} but the index is {}", move _44, _43) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _41 = _42[_43];
        _40 = Mul(_2, move _41);
        _34 = Add(move _35, move _40);
        _33 = Mul(_2, move _34);
        _27 = Add(move _28, move _33);
        _26 = Mul(_2, move _27);
        _20 = Add(move _21, move _26);
        _19 = Mul(_2, move _20);
        _3 = Add(move _14, move _19);
        _49 = const _;
        _50 = const 0_usize;
        _51 = const 5_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _48 = _49[_50];
        _56 = const _;
        _57 = const 1_usize;
        _58 = const 5_usize;
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _55 = _56[_57];
        _63 = const _;
        _64 = const 2_usize;
        _65 = const 5_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _62 = _63[_64];
        _70 = const _;
        _71 = const 3_usize;
        _72 = const 5_usize;
        _73 = Lt(_71, _72);
        assert(move _73, "index out of bounds: the length is {} but the index is {}", move _72, _71) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _69 = _70[_71];
        _76 = const _;
        _77 = const 4_usize;
        _78 = const 5_usize;
        _79 = Lt(_77, _78);
        assert(move _79, "index out of bounds: the length is {} but the index is {}", move _78, _77) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _75 = _76[_77];
        _74 = Mul(_2, move _75);
        _68 = Add(move _69, move _74);
        _67 = Mul(_2, move _68);
        _61 = Add(move _62, move _67);
        _60 = Mul(_2, move _61);
        _54 = Add(move _55, move _60);
        _53 = Mul(_2, move _54);
        _47 = Add(move _48, move _53);
        _46 = Mul(_2, move _47);
        _4 = Add(const 1f32, move _46);
        _81 = Div(_3, _4);
        _80 = Mul(_1, move _81);
        _85 = j1f(_1) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _86 = logf(_1) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _84 = Mul(move _85, move _86);
        _87 = Div(const 1f32, _1);
        _83 = Sub(move _84, move _87);
        _82 = Mul(const _, move _83);
        _0 = Add(move _80, move _82);
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

const j1f::PR8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 0f32, const 0.1171875f32, const 13.239481f32, const 412.051849f32, const 3874.74536f32, const 7914.47949f32];
        return;
    }
}

j1f::PR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::PS8: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 114.207367f32, const 3650.93091f32, const 36956.207f32, const 97602.7968f32, const 30804.2715f32];
        return;
    }
}

j1f::PS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1f::PR5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 1.31990521E-11f32, const 0.117187493f32, const 6.80275106f32, const 108.308182f32, const 517.636169f32, const 528.71521f32];
        return;
    }
}

j1f::PR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::PS5: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 59.2805977f32, const 991.401428f32, const 5353.26709f32, const 7844.69042f32, const 1504.04688f32];
        return;
    }
}

j1f::PS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1f::PR3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 3.02503911E-9f32, const 0.117186867f32, const 3.93297744f32, const 35.1194038f32, const 91.0550079f32, const 48.5590668f32];
        return;
    }
}

j1f::PR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::PS3: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 34.7913094f32, const 336.762451f32, const 1046.87146f32, const 890.81134f32, const 103.787933f32];
        return;
    }
}

j1f::PS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1f::PR2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 1.07710832E-7f32, const 0.11717622f32, const 2.36851501f32, const 12.2426109f32, const 17.6939716f32, const 5.07352304f32];
        return;
    }
}

j1f::PR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::PS2: [f32; 5] = {
    let mut _0: [f32; 5];

    bb0: {
        _0 = [const 21.4364853f32, const 125.29023f32, const 232.276474f32, const 117.679375f32, const 8.36463928f32];
        return;
    }
}

j1f::PS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

fn ponef(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: &[f32; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f32;
    let mut _45: f32;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f32;
    let mut _74: f32;
    let _75: usize;
    let mut _76: usize;
    let mut _77: bool;
    let mut _78: f32;
    scope 1 {
        debug p => _2;
        let _3: &[f32; 5];
        scope 2 {
            debug q => _3;
            let _4: f32;
            scope 3 {
                debug z => _4;
                let _5: f32;
                scope 4 {
                    debug r => _5;
                    let _6: f32;
                    scope 5 {
                        debug s => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _79: &[f32; 5];
                            let mut _80: &[f32; 6];
                            let mut _81: &[f32; 5];
                            let mut _82: &[f32; 6];
                            let mut _83: &[f32; 5];
                            let mut _84: &[f32; 6];
                            let mut _85: &[f32; 5];
                            let mut _86: &[f32; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1090519040_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _80 = const _;
        _2 = _80;
        _79 = const _;
        _3 = _79;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1083274219_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _82 = const _;
        _2 = _82;
        _81 = const _;
        _3 = _81;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1077336343_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _84 = const _;
        _2 = _84;
        _83 = const _;
        _3 = _83;
        goto -> bb8;
    }

    bb7: {
        _86 = const _;
        _2 = _86;
        _85 = const _;
        _3 = _85;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _4 = Div(const 1f32, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_4, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_4, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_4, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_4, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_4, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 5_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 5_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 5_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 5_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _75 = const 4_usize;
        _76 = const 5_usize;
        _77 = Lt(_75, _76);
        assert(move _77, "index out of bounds: the length is {} but the index is {}", move _76, _75) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _74 = (*_3)[_75];
        _73 = Mul(_4, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_4, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_4, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_4, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_4, move _50);
        _6 = Add(const 1f32, move _49);
        _78 = Div(_5, _6);
        _0 = Add(const 1f32, move _78);
        return;
    }
}

promoted[0] in ponef: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in ponef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in ponef: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in ponef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in ponef: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in ponef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in ponef: &[f32; 5] = {
    let mut _0: &[f32; 5];
    let mut _1: [f32; 5];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in ponef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

ponef::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

ponef::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 5_usize;
        return;
    }
}

const j1f::QR8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 0f32, const -0.102539063f32, const -16.2717533f32, const -759.601745f32, const -11849.8066f32, const -48438.5117f32];
        return;
    }
}

j1f::QR8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QS8: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 161.39537f32, const 7825.38623f32, const 133875.344f32, const 719657.75f32, const 666601.25f32, const -294490.25f32];
        return;
    }
}

j1f::QS8::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QR5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -2.08979934E-11f32, const -0.102539048f32, const -8.05644798f32, const -183.669601f32, const -1373.19373f32, const -2612.44434f32];
        return;
    }
}

j1f::QR5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QS5: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 81.2765503f32, const 1991.79871f32, const 17468.4844f32, const 49851.4258f32, const 27948.0742f32, const -4719.18359f32];
        return;
    }
}

j1f::QS5::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QR3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -5.07831244E-9f32, const -0.102537833f32, const -4.610116f32, const -57.8472214f32, const -228.244537f32, const -219.210129f32];
        return;
    }
}

j1f::QR3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QS3: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 47.6651535f32, const 673.865112f32, const 3380.15283f32, const 5547.729f32, const 1903.11914f32, const -135.201187f32];
        return;
    }
}

j1f::QS3::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QR2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const -1.78381725E-7f32, const -0.102517046f32, const -2.75220561f32, const -19.6636162f32, const -42.3253136f32, const -21.3719215f32];
        return;
    }
}

j1f::QR2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const j1f::QS2: [f32; 6] = {
    let mut _0: [f32; 6];

    bb0: {
        _0 = [const 29.5333633f32, const 252.981552f32, const 757.502808f32, const 739.393188f32, const 155.949005f32, const -4.95949888f32];
        return;
    }
}

j1f::QS2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

fn qonef(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: &[f32; 6];
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: f32;
    let mut _16: f32;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: f32;
    let _23: usize;
    let mut _24: usize;
    let mut _25: bool;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let _29: usize;
    let mut _30: usize;
    let mut _31: bool;
    let mut _32: f32;
    let mut _33: f32;
    let mut _34: f32;
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let _41: usize;
    let mut _42: usize;
    let mut _43: bool;
    let mut _44: f32;
    let mut _45: f32;
    let _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let _52: usize;
    let mut _53: usize;
    let mut _54: bool;
    let mut _55: f32;
    let mut _56: f32;
    let mut _57: f32;
    let _58: usize;
    let mut _59: usize;
    let mut _60: bool;
    let mut _61: f32;
    let mut _62: f32;
    let mut _63: f32;
    let _64: usize;
    let mut _65: usize;
    let mut _66: bool;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let _70: usize;
    let mut _71: usize;
    let mut _72: bool;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let _76: usize;
    let mut _77: usize;
    let mut _78: bool;
    let mut _79: f32;
    let mut _80: f32;
    let _81: usize;
    let mut _82: usize;
    let mut _83: bool;
    let mut _84: f32;
    let mut _85: f32;
    scope 1 {
        debug p => _2;
        let _3: &[f32; 6];
        scope 2 {
            debug q => _3;
            let _4: f32;
            scope 3 {
                debug s => _4;
                let _5: f32;
                scope 4 {
                    debug r => _5;
                    let _6: f32;
                    scope 5 {
                        debug z => _6;
                        let mut _7: u32;
                        scope 6 {
                            debug ix => _7;
                            let mut _86: &[f32; 6];
                            let mut _87: &[f32; 6];
                            let mut _88: &[f32; 6];
                            let mut _89: &[f32; 6];
                            let mut _90: &[f32; 6];
                            let mut _91: &[f32; 6];
                            let mut _92: &[f32; 6];
                            let mut _93: &[f32; 6];
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _8 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _8;
        _7 = BitAnd(_7, const 2147483647_u32);
        _10 = _7;
        _9 = Ge(move _10, const 1090519040_u32);
        switchInt(move _9) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _87 = const _;
        _2 = _87;
        _86 = const _;
        _3 = _86;
        goto -> bb8;
    }

    bb3: {
        _12 = _7;
        _11 = Ge(move _12, const 1083274219_u32);
        switchInt(move _11) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _89 = const _;
        _2 = _89;
        _88 = const _;
        _3 = _88;
        goto -> bb8;
    }

    bb5: {
        _14 = _7;
        _13 = Ge(move _14, const 1077336343_u32);
        switchInt(move _13) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _91 = const _;
        _2 = _91;
        _90 = const _;
        _3 = _90;
        goto -> bb8;
    }

    bb7: {
        _93 = const _;
        _2 = _93;
        _92 = const _;
        _3 = _92;
        goto -> bb8;
    }

    bb8: {
        _15 = Mul(_1, _1);
        _6 = Div(const 1f32, move _15);
        _17 = const 0_usize;
        _18 = const 6_usize;
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _16 = (*_2)[_17];
        _23 = const 1_usize;
        _24 = const 6_usize;
        _25 = Lt(_23, _24);
        assert(move _25, "index out of bounds: the length is {} but the index is {}", move _24, _23) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _22 = (*_2)[_23];
        _29 = const 2_usize;
        _30 = const 6_usize;
        _31 = Lt(_29, _30);
        assert(move _31, "index out of bounds: the length is {} but the index is {}", move _30, _29) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = (*_2)[_29];
        _35 = const 3_usize;
        _36 = const 6_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _34 = (*_2)[_35];
        _41 = const 4_usize;
        _42 = const 6_usize;
        _43 = Lt(_41, _42);
        assert(move _43, "index out of bounds: the length is {} but the index is {}", move _42, _41) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _40 = (*_2)[_41];
        _46 = const 5_usize;
        _47 = const 6_usize;
        _48 = Lt(_46, _47);
        assert(move _48, "index out of bounds: the length is {} but the index is {}", move _47, _46) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _45 = (*_2)[_46];
        _44 = Mul(_6, move _45);
        _39 = Add(move _40, move _44);
        _38 = Mul(_6, move _39);
        _33 = Add(move _34, move _38);
        _32 = Mul(_6, move _33);
        _27 = Add(move _28, move _32);
        _26 = Mul(_6, move _27);
        _21 = Add(move _22, move _26);
        _20 = Mul(_6, move _21);
        _5 = Add(move _16, move _20);
        _52 = const 0_usize;
        _53 = const 6_usize;
        _54 = Lt(_52, _53);
        assert(move _54, "index out of bounds: the length is {} but the index is {}", move _53, _52) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _51 = (*_3)[_52];
        _58 = const 1_usize;
        _59 = const 6_usize;
        _60 = Lt(_58, _59);
        assert(move _60, "index out of bounds: the length is {} but the index is {}", move _59, _58) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _57 = (*_3)[_58];
        _64 = const 2_usize;
        _65 = const 6_usize;
        _66 = Lt(_64, _65);
        assert(move _66, "index out of bounds: the length is {} but the index is {}", move _65, _64) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _63 = (*_3)[_64];
        _70 = const 3_usize;
        _71 = const 6_usize;
        _72 = Lt(_70, _71);
        assert(move _72, "index out of bounds: the length is {} but the index is {}", move _71, _70) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _69 = (*_3)[_70];
        _76 = const 4_usize;
        _77 = const 6_usize;
        _78 = Lt(_76, _77);
        assert(move _78, "index out of bounds: the length is {} but the index is {}", move _77, _76) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _75 = (*_3)[_76];
        _81 = const 5_usize;
        _82 = const 6_usize;
        _83 = Lt(_81, _82);
        assert(move _83, "index out of bounds: the length is {} but the index is {}", move _82, _81) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _80 = (*_3)[_81];
        _79 = Mul(_6, move _80);
        _74 = Add(move _75, move _79);
        _73 = Mul(_6, move _74);
        _68 = Add(move _69, move _73);
        _67 = Mul(_6, move _68);
        _62 = Add(move _63, move _67);
        _61 = Mul(_6, move _62);
        _56 = Add(move _57, move _61);
        _55 = Mul(_6, move _56);
        _50 = Add(move _51, move _55);
        _49 = Mul(_6, move _50);
        _4 = Add(const 1f32, move _49);
        _85 = Div(_5, _4);
        _84 = Add(const 0.375f32, move _85);
        _0 = Div(move _84, _1);
        return;
    }
}

promoted[0] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in qonef: &[f32; 6] = {
    let mut _0: &[f32; 6];
    let mut _1: [f32; 6];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

qonef::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

qonef::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

const jn::INVSQRTPI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.56418958354775628f64;
        return;
    }
}

fn jn(_1: i32, _2: f64) -> f64 {
    debug n => _1;
    debug x => _2;
    let mut _0: f64;
    let mut _3: u32;
    let mut _10: u32;
    let mut _11: f64;
    let mut _12: u32;
    let mut _13: f64;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: bool;
    let mut _27: f64;
    let mut _28: bool;
    let mut _29: i32;
    let mut _30: (i32, bool);
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: bool;
    let mut _34: (i32, bool);
    let mut _35: i32;
    let mut _36: f64;
    let mut _37: bool;
    let mut _38: i32;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: u32;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: bool;
    let mut _45: f64;
    let mut _46: i32;
    let mut _47: f64;
    let mut _48: bool;
    let mut _49: u32;
    let mut _50: f64;
    let mut _51: i32;
    let mut _52: i32;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _62: f64;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: bool;
    let mut _80: i32;
    let mut _81: i32;
    let mut _82: (i32, bool);
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: i32;
    let mut _90: f64;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: bool;
    let mut _94: u32;
    let mut _95: bool;
    let mut _96: i32;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: bool;
    let mut _100: i32;
    let mut _101: i32;
    let mut _102: i32;
    let mut _103: (i32, bool);
    let mut _104: f64;
    let mut _105: i32;
    let mut _106: f64;
    let mut _107: (i32, bool);
    let mut _108: f64;
    let mut _109: f64;
    let mut _119: f64;
    let mut _120: i32;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: f64;
    let mut _124: f64;
    let mut _125: f64;
    let mut _126: f64;
    let mut _127: f64;
    let mut _128: f64;
    let mut _129: bool;
    let mut _130: f64;
    let mut _131: (i32, bool);
    let mut _132: f64;
    let mut _133: f64;
    let mut _134: f64;
    let mut _135: f64;
    let mut _136: f64;
    let mut _137: f64;
    let mut _138: i32;
    let mut _139: bool;
    let mut _140: i32;
    let mut _141: f64;
    let mut _142: f64;
    let mut _143: f64;
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: i32;
    let mut _147: f64;
    let mut _148: f64;
    let mut _149: (i32, bool);
    let mut _150: f64;
    let mut _151: f64;
    let mut _152: f64;
    let mut _153: f64;
    let mut _154: bool;
    let mut _155: f64;
    let mut _156: i32;
    let mut _157: bool;
    let mut _158: i32;
    let mut _159: f64;
    let mut _160: f64;
    let mut _161: f64;
    let mut _162: f64;
    let mut _163: f64;
    let mut _164: f64;
    let mut _165: i32;
    let mut _166: f64;
    let mut _167: f64;
    let mut _168: f64;
    let mut _169: (i32, bool);
    let mut _170: i32;
    let mut _171: bool;
    let mut _172: i32;
    let mut _173: f64;
    let mut _174: f64;
    let mut _175: f64;
    let mut _176: f64;
    let mut _177: f64;
    let mut _178: f64;
    let mut _179: i32;
    let mut _180: f64;
    let mut _181: f64;
    let mut _182: f64;
    let mut _184: bool;
    let mut _185: f64;
    let mut _186: f64;
    let mut _187: f64;
    let mut _188: (i32, bool);
    let mut _189: f64;
    let mut _190: f64;
    let mut _191: f64;
    let mut _192: f64;
    let mut _193: bool;
    let mut _194: f64;
    let mut _195: f64;
    let mut _196: f64;
    let mut _197: f64;
    let mut _198: f64;
    let mut _199: f64;
    let mut _200: f64;
    let mut _201: f64;
    let mut _202: f64;
    let mut _203: f64;
    let mut _204: f64;
    let mut _205: f64;
    let mut _206: bool;
    let mut _207: f64;
    scope 1 {
        debug ix => _3;
        scope 2 {
            debug lx => _12;
            let _4: i32;
            scope 3 {
                debug nm1 => _4;
                let mut _5: i32;
                scope 4 {
                    debug i => _5;
                    let mut _6: bool;
                    scope 5 {
                        debug sign => _6;
                        let mut _7: f64;
                        scope 6 {
                            debug a => _7;
                            let mut _8: f64;
                            scope 7 {
                                debug b => _8;
                                let mut _9: f64;
                                scope 8 {
                                    debug temp => _9;
                                    let mut _110: f64;
                                    scope 9 {
                                        debug t => _110;
                                        let mut _111: f64;
                                        scope 10 {
                                            debug q0 => _111;
                                            let mut _112: f64;
                                            scope 11 {
                                                debug q1 => _112;
                                                let mut _113: f64;
                                                scope 12 {
                                                    debug w => _113;
                                                    let _114: f64;
                                                    scope 13 {
                                                        debug h => _114;
                                                        let mut _115: f64;
                                                        scope 14 {
                                                            debug z => _115;
                                                            let mut _116: f64;
                                                            scope 15 {
                                                                debug tmp => _116;
                                                                let _117: f64;
                                                                scope 16 {
                                                                    debug nf => _117;
                                                                    let mut _118: i32;
                                                                    scope 17 {
                                                                        debug k => _118;
                                                                        let _183: f64;
                                                                        scope 18 {
                                                                            debug x1p500 => _183;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _11 = _2;
        _10 = get_high_word(move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _10;
        _13 = _2;
        _12 = get_low_word(move _13) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _15 = _3;
        _16 = const 31_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 32_u32);
        assert(move _17, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _14 = Shr(move _15, const 31_i32);
        _6 = Ne(move _14, const 0_u32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _20 = _3;
        _24 = Not(_12);
        _23 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _24, const 1_u32) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _22 = BitOr(_12, move _23);
        _25 = const 31_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 32_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _21 = Shr(move _22, const 31_i32);
        _19 = BitOr(move _20, move _21);
        _18 = Gt(move _19, const 2146435072_u32);
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _2;
        goto -> bb85;
    }

    bb7: {
        switchInt(move _1) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _27 = _2;
        _0 = j0(move _27) -> [return: bb85, unwind unreachable];
    }

    bb9: {
        _28 = Lt(_1, const 0_i32);
        switchInt(move _28) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _30 = CheckedAdd(_1, const 1_i32);
        assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> [success: bb12, unwind unreachable];
    }

    bb11: {
        _34 = CheckedSub(_1, const 1_i32);
        assert(!move (_34.1: bool), "attempt to compute `{} - {}`, which would overflow", _1, const 1_i32) -> [success: bb14, unwind unreachable];
    }

    bb12: {
        _29 = move (_30.0: i32);
        _31 = Eq(_29, const i32::MIN);
        assert(!move _31, "attempt to negate `{}`, which would overflow", _29) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _4 = Neg(move _29);
        _32 = _2;
        _2 = Neg(move _32);
        _33 = _6;
        _6 = Not(move _33);
        goto -> bb15;
    }

    bb14: {
        _4 = move (_34.0: i32);
        goto -> bb15;
    }

    bb15: {
        _35 = _4;
        switchInt(move _35) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        _36 = _2;
        _0 = j1(move _36) -> [return: bb85, unwind unreachable];
    }

    bb17: {
        _38 = BitAnd(_1, const 1_i32);
        _37 = Ne(move _38, const 0_i32);
        _6 = BitAnd(_6, move _37);
        _40 = _2;
        _39 = fabs(move _40) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _2 = move _39;
        _42 = _3;
        _41 = BitOr(move _42, _12);
        switchInt(move _41) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _43 = _3;
        switchInt(move _43) -> [2146435072: bb20, otherwise: bb21];
    }

    bb20: {
        _8 = const 0f64;
        goto -> bb82;
    }

    bb21: {
        _46 = _4;
        _45 = move _46 as f64 (IntToFloat);
        _47 = _2;
        _44 = Lt(move _45, move _47);
        switchInt(move _44) -> [0: bb44, otherwise: bb22];
    }

    bb22: {
        _49 = _3;
        _48 = Ge(move _49, const 1389363200_u32);
        switchInt(move _48) -> [0: bb38, otherwise: bb23];
    }

    bb23: {
        _52 = _4;
        _51 = BitAnd(move _52, const 3_i32);
        switchInt(_51) -> [0: bb24, 1: bb27, 2: bb30, otherwise: bb33];
    }

    bb24: {
        _55 = _2;
        _54 = cos(move _55) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _53 = Neg(move _54);
        _57 = _2;
        _56 = sin(move _57) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _50 = Add(move _53, move _56);
        goto -> bb36;
    }

    bb27: {
        _60 = _2;
        _59 = cos(move _60) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _58 = Neg(move _59);
        _62 = _2;
        _61 = sin(move _62) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _50 = Sub(move _58, move _61);
        goto -> bb36;
    }

    bb30: {
        _64 = _2;
        _63 = cos(move _64) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _66 = _2;
        _65 = sin(move _66) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _50 = Sub(move _63, move _65);
        goto -> bb36;
    }

    bb33: {
        _68 = _2;
        _67 = cos(move _68) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _70 = _2;
        _69 = sin(move _70) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _50 = Add(move _67, move _69);
        goto -> bb36;
    }

    bb36: {
        _9 = move _50;
        _72 = _9;
        _71 = Mul(const _, move _72);
        _74 = _2;
        _73 = sqrt(move _74) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _8 = Div(move _71, move _73);
        goto -> bb82;
    }

    bb38: {
        _76 = _2;
        _75 = j0(move _76) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _7 = move _75;
        _78 = _2;
        _77 = j1(move _78) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _8 = move _77;
        _5 = const 0_i32;
        goto -> bb41;
    }

    bb41: {
        _80 = _5;
        _81 = _4;
        _79 = Lt(move _80, move _81);
        switchInt(move _79) -> [0: bb82, otherwise: bb42];
    }

    bb42: {
        _82 = CheckedAdd(_5, const 1_i32);
        assert(!move (_82.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _5 = move (_82.0: i32);
        _83 = _8;
        _9 = move _83;
        _85 = _8;
        _89 = _5;
        _88 = move _89 as f64 (IntToFloat);
        _87 = Mul(const 2f64, move _88);
        _90 = _2;
        _86 = Div(move _87, move _90);
        _84 = Mul(move _85, move _86);
        _91 = _7;
        _8 = Sub(move _84, move _91);
        _92 = _9;
        _7 = move _92;
        goto -> bb41;
    }

    bb44: {
        _94 = _3;
        _93 = Lt(move _94, const 1041235968_u32);
        switchInt(move _93) -> [0: bb53, otherwise: bb45];
    }

    bb45: {
        _96 = _4;
        _95 = Gt(move _96, const 32_i32);
        switchInt(move _95) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _8 = const 0f64;
        goto -> bb82;
    }

    bb47: {
        _97 = _2;
        _9 = Mul(move _97, const 0.5f64);
        _98 = _9;
        _8 = move _98;
        _7 = const 1f64;
        _5 = const 2_i32;
        goto -> bb48;
    }

    bb48: {
        _100 = _5;
        _102 = _4;
        _103 = CheckedAdd(_102, const 1_i32);
        assert(!move (_103.1: bool), "attempt to compute `{} + {}`, which would overflow", move _102, const 1_i32) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _101 = move (_103.0: i32);
        _99 = Le(move _100, move _101);
        switchInt(move _99) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _105 = _5;
        _104 = move _105 as f64 (IntToFloat);
        _7 = Mul(_7, move _104);
        _106 = _9;
        _8 = Mul(_8, move _106);
        _107 = CheckedAdd(_5, const 1_i32);
        assert(!move (_107.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> [success: bb51, unwind unreachable];
    }

    bb51: {
        _5 = move (_107.0: i32);
        goto -> bb48;
    }

    bb52: {
        _108 = _8;
        _109 = _7;
        _8 = Div(move _108, move _109);
        goto -> bb82;
    }

    bb53: {
        _120 = _4;
        _119 = move _120 as f64 (IntToFloat);
        _117 = Add(move _119, const 1f64);
        _121 = Mul(const 2f64, _117);
        _122 = _2;
        _113 = Div(move _121, move _122);
        _123 = _2;
        _114 = Div(const 2f64, move _123);
        _124 = _113;
        _115 = Add(move _124, _114);
        _125 = _113;
        _111 = move _125;
        _127 = _113;
        _128 = _115;
        _126 = Mul(move _127, move _128);
        _112 = Sub(move _126, const 1f64);
        _118 = const 1_i32;
        goto -> bb54;
    }

    bb54: {
        _130 = _112;
        _129 = Lt(move _130, const 1.0E+9f64);
        switchInt(move _129) -> [0: bb57, otherwise: bb55];
    }

    bb55: {
        _131 = CheckedAdd(_118, const 1_i32);
        assert(!move (_131.1: bool), "attempt to compute `{} + {}`, which would overflow", _118, const 1_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _118 = move (_131.0: i32);
        _115 = Add(_115, _114);
        _133 = _115;
        _134 = _112;
        _132 = Mul(move _133, move _134);
        _135 = _111;
        _116 = Sub(move _132, move _135);
        _136 = _112;
        _111 = move _136;
        _137 = _116;
        _112 = move _137;
        goto -> bb54;
    }

    bb57: {
        _110 = const 0f64;
        _138 = _118;
        _5 = move _138;
        goto -> bb58;
    }

    bb58: {
        _140 = _5;
        _139 = Ge(move _140, const 0_i32);
        switchInt(move _139) -> [0: bb61, otherwise: bb59];
    }

    bb59: {
        _146 = _5;
        _145 = move _146 as f64 (IntToFloat);
        _144 = Add(move _145, _117);
        _143 = Mul(const 2f64, move _144);
        _147 = _2;
        _142 = Div(move _143, move _147);
        _148 = _110;
        _141 = Sub(move _142, move _148);
        _110 = Div(const 1f64, move _141);
        _149 = CheckedSub(_5, const 1_i32);
        assert(!move (_149.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb60, unwind unreachable];
    }

    bb60: {
        _5 = move (_149.0: i32);
        goto -> bb58;
    }

    bb61: {
        _150 = _110;
        _7 = move _150;
        _8 = const 1f64;
        _153 = _113;
        _152 = fabs(move _153) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _151 = log(move _152) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _116 = Mul(_117, move _151);
        _155 = _116;
        _154 = Lt(move _155, const 709.78271289338397f64);
        switchInt(move _154) -> [0: bb68, otherwise: bb64];
    }

    bb64: {
        _156 = _4;
        _5 = move _156;
        goto -> bb65;
    }

    bb65: {
        _158 = _5;
        _157 = Gt(move _158, const 0_i32);
        switchInt(move _157) -> [0: bb75, otherwise: bb66];
    }

    bb66: {
        _159 = _8;
        _9 = move _159;
        _162 = _8;
        _165 = _5;
        _164 = move _165 as f64 (IntToFloat);
        _163 = Mul(const 2f64, move _164);
        _161 = Mul(move _162, move _163);
        _166 = _2;
        _160 = Div(move _161, move _166);
        _167 = _7;
        _8 = Sub(move _160, move _167);
        _168 = _9;
        _7 = move _168;
        _169 = CheckedSub(_5, const 1_i32);
        assert(!move (_169.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb67, unwind unreachable];
    }

    bb67: {
        _5 = move (_169.0: i32);
        goto -> bb65;
    }

    bb68: {
        _170 = _4;
        _5 = move _170;
        goto -> bb69;
    }

    bb69: {
        _172 = _5;
        _171 = Gt(move _172, const 0_i32);
        switchInt(move _171) -> [0: bb75, otherwise: bb70];
    }

    bb70: {
        _173 = _8;
        _9 = move _173;
        _176 = _8;
        _179 = _5;
        _178 = move _179 as f64 (IntToFloat);
        _177 = Mul(const 2f64, move _178);
        _175 = Mul(move _176, move _177);
        _180 = _2;
        _174 = Div(move _175, move _180);
        _181 = _7;
        _8 = Sub(move _174, move _181);
        _182 = _9;
        _7 = move _182;
        _183 = f64::<impl f64>::from_bits(const 6858982232485265408_u64) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _185 = _8;
        _184 = Gt(move _185, _183);
        switchInt(move _184) -> [0: bb73, otherwise: bb72];
    }

    bb72: {
        _186 = _8;
        _7 = Div(_7, move _186);
        _187 = _8;
        _110 = Div(_110, move _187);
        _8 = const 1f64;
        goto -> bb73;
    }

    bb73: {
        _188 = CheckedSub(_5, const 1_i32);
        assert(!move (_188.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_i32) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _5 = move (_188.0: i32);
        goto -> bb69;
    }

    bb75: {
        _190 = _2;
        _189 = j0(move _190) -> [return: bb76, unwind unreachable];
    }

    bb76: {
        _115 = move _189;
        _192 = _2;
        _191 = j1(move _192) -> [return: bb77, unwind unreachable];
    }

    bb77: {
        _113 = move _191;
        _195 = _115;
        _194 = fabs(move _195) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _197 = _113;
        _196 = fabs(move _197) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _193 = Ge(move _194, move _196);
        switchInt(move _193) -> [0: bb81, otherwise: bb80];
    }

    bb80: {
        _199 = _110;
        _200 = _115;
        _198 = Mul(move _199, move _200);
        _201 = _8;
        _8 = Div(move _198, move _201);
        goto -> bb82;
    }

    bb81: {
        _203 = _110;
        _204 = _113;
        _202 = Mul(move _203, move _204);
        _205 = _7;
        _8 = Div(move _202, move _205);
        goto -> bb82;
    }

    bb82: {
        _206 = _6;
        switchInt(move _206) -> [0: bb84, otherwise: bb83];
    }

    bb83: {
        _207 = _8;
        _0 = Neg(move _207);
        goto -> bb85;
    }

    bb84: {
        _0 = _8;
        goto -> bb85;
    }

    bb85: {
        return;
    }
}

fn yn(_1: i32, _2: f64) -> f64 {
    debug n => _1;
    debug x => _2;
    let mut _0: f64;
    let mut _3: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: i32;
    let mut _32: (i32, bool);
    let mut _33: bool;
    let mut _34: i32;
    let mut _35: (i32, bool);
    let mut _36: i32;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: bool;
    let mut _40: u32;
    let mut _41: f64;
    let mut _42: i32;
    let mut _43: i32;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: u32;
    let mut _60: f64;
    let mut _61: bool;
    let mut _62: i32;
    let mut _63: i32;
    let mut _64: u32;
    let mut _65: (i32, bool);
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: i32;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: u32;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: bool;
    let mut _78: f64;
    scope 1 {
        debug ix => _3;
        scope 2 {
            debug lx => _12;
            let mut _4: u32;
            scope 3 {
                debug ib => _4;
                let _5: i32;
                scope 4 {
                    debug nm1 => _5;
                    let mut _6: bool;
                    scope 5 {
                        debug sign => _6;
                        let mut _7: i32;
                        scope 6 {
                            debug i => _7;
                            let mut _8: f64;
                            scope 7 {
                                debug a => _8;
                                let mut _9: f64;
                                scope 8 {
                                    debug b => _9;
                                    let mut _10: f64;
                                    scope 9 {
                                        debug temp => _10;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _11 = get_high_word(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _11;
        _12 = get_low_word(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _14 = _3;
        _15 = const 31_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 32_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _13 = Shr(move _14, const 31_i32);
        _6 = Ne(move _13, const 0_u32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _19 = _3;
        _23 = Not(_12);
        _22 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _23, const 1_u32) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _21 = BitOr(_12, move _22);
        _24 = const 31_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 32_u32);
        assert(move _25, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _20 = Shr(move _21, const 31_i32);
        _18 = BitOr(move _19, move _20);
        _17 = Gt(move _18, const 2146435072_u32);
        switchInt(move _17) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = _2;
        goto -> bb53;
    }

    bb7: {
        _26 = _6;
        switchInt(move _26) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _28 = _3;
        _27 = BitOr(move _28, _12);
        switchInt(move _27) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = Div(const 0f64, const 0f64);
        goto -> bb53;
    }

    bb10: {
        _29 = _3;
        switchInt(move _29) -> [2146435072: bb11, otherwise: bb12];
    }

    bb11: {
        _0 = const 0f64;
        goto -> bb53;
    }

    bb12: {
        switchInt(move _1) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _0 = y0(_2) -> [return: bb53, unwind unreachable];
    }

    bb14: {
        _30 = Lt(_1, const 0_i32);
        switchInt(move _30) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _32 = CheckedAdd(_1, const 1_i32);
        assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> [success: bb17, unwind unreachable];
    }

    bb16: {
        _35 = CheckedSub(_1, const 1_i32);
        assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", _1, const 1_i32) -> [success: bb19, unwind unreachable];
    }

    bb17: {
        _31 = move (_32.0: i32);
        _33 = Eq(_31, const i32::MIN);
        assert(!move _33, "attempt to negate `{}`, which would overflow", _31) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _5 = Neg(move _31);
        _34 = BitAnd(_1, const 1_i32);
        _6 = Ne(move _34, const 0_i32);
        goto -> bb20;
    }

    bb19: {
        _5 = move (_35.0: i32);
        _6 = const false;
        goto -> bb20;
    }

    bb20: {
        _36 = _5;
        switchInt(move _36) -> [0: bb21, otherwise: bb25];
    }

    bb21: {
        _37 = _6;
        switchInt(move _37) -> [0: bb24, otherwise: bb22];
    }

    bb22: {
        _38 = y1(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _0 = Neg(move _38);
        goto -> bb53;
    }

    bb24: {
        _0 = y1(_2) -> [return: bb53, unwind unreachable];
    }

    bb25: {
        _40 = _3;
        _39 = Ge(move _40, const 1389363200_u32);
        switchInt(move _39) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _43 = _5;
        _42 = BitAnd(move _43, const 3_i32);
        switchInt(_42) -> [0: bb28, 1: bb31, 2: bb34, otherwise: bb37];
    }

    bb27: {
        _57 = y0(_2) -> [return: bb42, unwind unreachable];
    }

    bb28: {
        _45 = sin(_2) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _44 = Neg(move _45);
        _46 = cos(_2) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _41 = Sub(move _44, move _46);
        goto -> bb40;
    }

    bb31: {
        _48 = sin(_2) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _47 = Neg(move _48);
        _49 = cos(_2) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _41 = Add(move _47, move _49);
        goto -> bb40;
    }

    bb34: {
        _50 = sin(_2) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _51 = cos(_2) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _41 = Add(move _50, move _51);
        goto -> bb40;
    }

    bb37: {
        _52 = sin(_2) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _53 = cos(_2) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _41 = Sub(move _52, move _53);
        goto -> bb40;
    }

    bb40: {
        _10 = move _41;
        _55 = _10;
        _54 = Mul(const _, move _55);
        _56 = sqrt(_2) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _9 = Div(move _54, move _56);
        goto -> bb50;
    }

    bb42: {
        _8 = move _57;
        _58 = y1(_2) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _9 = move _58;
        _60 = _9;
        _59 = get_high_word(move _60) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _4 = move _59;
        _7 = const 0_i32;
        goto -> bb45;
    }

    bb45: {
        _62 = _7;
        _63 = _5;
        _61 = Lt(move _62, move _63);
        switchInt(move _61) -> [0: bb50, otherwise: bb46];
    }

    bb46: {
        _64 = _4;
        switchInt(move _64) -> [4293918720: bb50, otherwise: bb47];
    }

    bb47: {
        _65 = CheckedAdd(_7, const 1_i32);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _7 = move (_65.0: i32);
        _66 = _9;
        _10 = move _66;
        _71 = _7;
        _70 = move _71 as f64 (IntToFloat);
        _69 = Mul(const 2f64, move _70);
        _68 = Div(move _69, _2);
        _72 = _9;
        _67 = Mul(move _68, move _72);
        _73 = _8;
        _9 = Sub(move _67, move _73);
        _75 = _9;
        _74 = get_high_word(move _75) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _4 = move _74;
        _76 = _10;
        _8 = move _76;
        goto -> bb45;
    }

    bb50: {
        _77 = _6;
        switchInt(move _77) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _78 = _9;
        _0 = Neg(move _78);
        goto -> bb53;
    }

    bb52: {
        _0 = _9;
        goto -> bb53;
    }

    bb53: {
        return;
    }
}

fn jnf(_1: i32, _2: f32) -> f32 {
    debug n => _1;
    debug x => _2;
    let mut _0: f32;
    let mut _3: u32;
    let mut _10: u32;
    let mut _11: f32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: u32;
    let mut _18: f32;
    let mut _19: bool;
    let mut _20: i32;
    let mut _21: (i32, bool);
    let mut _22: bool;
    let mut _23: f32;
    let mut _24: bool;
    let mut _25: (i32, bool);
    let mut _26: i32;
    let mut _27: f32;
    let mut _28: bool;
    let mut _29: i32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: u32;
    let mut _33: u32;
    let mut _34: bool;
    let mut _35: f32;
    let mut _36: i32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: bool;
    let mut _43: i32;
    let mut _44: i32;
    let mut _45: (i32, bool);
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: f32;
    let mut _52: i32;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: bool;
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: f32;
    let mut _61: f32;
    let mut _62: bool;
    let mut _63: i32;
    let mut _64: i32;
    let mut _65: i32;
    let mut _66: (i32, bool);
    let mut _67: f32;
    let mut _68: i32;
    let mut _69: f32;
    let mut _70: (i32, bool);
    let mut _71: f32;
    let mut _72: f32;
    let mut _82: f32;
    let mut _83: i32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: f32;
    let mut _91: f32;
    let mut _92: bool;
    let mut _93: f32;
    let mut _94: (i32, bool);
    let mut _95: f32;
    let mut _96: f32;
    let mut _97: f32;
    let mut _98: f32;
    let mut _99: f32;
    let mut _100: f32;
    let mut _101: i32;
    let mut _102: bool;
    let mut _103: i32;
    let mut _104: f32;
    let mut _105: f32;
    let mut _106: f32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: i32;
    let mut _110: f32;
    let mut _111: f32;
    let mut _112: (i32, bool);
    let mut _113: f32;
    let mut _114: f32;
    let mut _115: f32;
    let mut _116: f32;
    let mut _117: bool;
    let mut _118: f32;
    let mut _119: i32;
    let mut _120: bool;
    let mut _121: i32;
    let mut _122: f32;
    let mut _123: f32;
    let mut _124: f32;
    let mut _125: f32;
    let mut _126: f32;
    let mut _127: i32;
    let mut _128: f32;
    let mut _129: f32;
    let mut _130: f32;
    let mut _131: f32;
    let mut _132: (i32, bool);
    let mut _133: i32;
    let mut _134: bool;
    let mut _135: i32;
    let mut _136: f32;
    let mut _137: f32;
    let mut _138: f32;
    let mut _139: f32;
    let mut _140: f32;
    let mut _141: i32;
    let mut _142: f32;
    let mut _143: f32;
    let mut _144: f32;
    let mut _145: f32;
    let mut _147: bool;
    let mut _148: f32;
    let mut _149: f32;
    let mut _150: f32;
    let mut _151: (i32, bool);
    let mut _152: f32;
    let mut _153: f32;
    let mut _154: f32;
    let mut _155: f32;
    let mut _156: bool;
    let mut _157: f32;
    let mut _158: f32;
    let mut _159: f32;
    let mut _160: f32;
    let mut _161: f32;
    let mut _162: f32;
    let mut _163: f32;
    let mut _164: f32;
    let mut _165: f32;
    let mut _166: f32;
    let mut _167: f32;
    let mut _168: f32;
    let mut _169: bool;
    let mut _170: f32;
    scope 1 {
        debug ix => _3;
        let mut _4: i32;
        scope 2 {
            debug nm1 => _4;
            let mut _5: bool;
            scope 3 {
                debug sign => _5;
                let mut _6: i32;
                scope 4 {
                    debug i => _6;
                    let mut _7: f32;
                    scope 5 {
                        debug a => _7;
                        let mut _8: f32;
                        scope 6 {
                            debug b => _8;
                            let mut _9: f32;
                            scope 7 {
                                debug temp => _9;
                                let mut _73: f32;
                                scope 8 {
                                    debug t => _73;
                                    let mut _74: f32;
                                    scope 9 {
                                        debug q0 => _74;
                                        let mut _75: f32;
                                        scope 10 {
                                            debug q1 => _75;
                                            let mut _76: f32;
                                            scope 11 {
                                                debug w => _76;
                                                let _77: f32;
                                                scope 12 {
                                                    debug h => _77;
                                                    let mut _78: f32;
                                                    scope 13 {
                                                        debug z => _78;
                                                        let mut _79: f32;
                                                        scope 14 {
                                                            debug tmp => _79;
                                                            let _80: f32;
                                                            scope 15 {
                                                                debug nf => _80;
                                                                let mut _81: i32;
                                                                scope 16 {
                                                                    debug k => _81;
                                                                    let _146: f32;
                                                                    scope 17 {
                                                                        debug x1p60 => _146;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _11 = _2;
        _10 = f32::<impl f32>::to_bits(move _11) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _10;
        _13 = _3;
        _14 = const 31_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _12 = Shr(move _13, const 31_i32);
        _5 = Ne(move _12, const 0_u32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _17 = _3;
        _16 = Gt(move _17, const 2139095040_u32);
        switchInt(move _16) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = _2;
        goto -> bb66;
    }

    bb4: {
        switchInt(move _1) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _18 = _2;
        _0 = j0f(move _18) -> [return: bb66, unwind unreachable];
    }

    bb6: {
        _19 = Lt(_1, const 0_i32);
        switchInt(move _19) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _21 = CheckedAdd(_1, const 1_i32);
        assert(!move (_21.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> [success: bb9, unwind unreachable];
    }

    bb8: {
        _25 = CheckedSub(_1, const 1_i32);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", _1, const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb9: {
        _20 = move (_21.0: i32);
        _22 = Eq(_20, const i32::MIN);
        assert(!move _22, "attempt to negate `{}`, which would overflow", _20) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _4 = Neg(move _20);
        _23 = _2;
        _2 = Neg(move _23);
        _24 = _5;
        _5 = Not(move _24);
        goto -> bb12;
    }

    bb11: {
        _4 = move (_25.0: i32);
        goto -> bb12;
    }

    bb12: {
        _26 = _4;
        switchInt(move _26) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _27 = _2;
        _0 = j1f(move _27) -> [return: bb66, unwind unreachable];
    }

    bb14: {
        _29 = BitAnd(_1, const 1_i32);
        _28 = Ne(move _29, const 0_i32);
        _5 = BitAnd(_5, move _28);
        _31 = _2;
        _30 = fabsf(move _31) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move _30;
        _32 = _3;
        switchInt(move _32) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _33 = _3;
        switchInt(move _33) -> [2139095040: bb17, otherwise: bb18];
    }

    bb17: {
        _8 = const 0f32;
        goto -> bb63;
    }

    bb18: {
        _36 = _4;
        _35 = move _36 as f32 (IntToFloat);
        _37 = _2;
        _34 = Lt(move _35, move _37);
        switchInt(move _34) -> [0: bb25, otherwise: bb19];
    }

    bb19: {
        _39 = _2;
        _38 = j0f(move _39) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _7 = move _38;
        _41 = _2;
        _40 = j1f(move _41) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _8 = move _40;
        _6 = const 0_i32;
        goto -> bb22;
    }

    bb22: {
        _43 = _6;
        _44 = _4;
        _42 = Lt(move _43, move _44);
        switchInt(move _42) -> [0: bb63, otherwise: bb23];
    }

    bb23: {
        _45 = CheckedAdd(_6, const 1_i32);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _6 = move (_45.0: i32);
        _46 = _8;
        _9 = move _46;
        _48 = _8;
        _52 = _6;
        _51 = move _52 as f32 (IntToFloat);
        _50 = Mul(const 2f32, move _51);
        _53 = _2;
        _49 = Div(move _50, move _53);
        _47 = Mul(move _48, move _49);
        _54 = _7;
        _8 = Sub(move _47, move _54);
        _55 = _9;
        _7 = move _55;
        goto -> bb22;
    }

    bb25: {
        _57 = _3;
        _56 = Lt(move _57, const 897581056_u32);
        switchInt(move _56) -> [0: bb34, otherwise: bb26];
    }

    bb26: {
        _59 = _4;
        _58 = Gt(move _59, const 8_i32);
        switchInt(move _58) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _4 = const 8_i32;
        goto -> bb28;
    }

    bb28: {
        _60 = _2;
        _9 = Mul(const 0.5f32, move _60);
        _61 = _9;
        _8 = move _61;
        _7 = const 1f32;
        _6 = const 2_i32;
        goto -> bb29;
    }

    bb29: {
        _63 = _6;
        _65 = _4;
        _66 = CheckedAdd(_65, const 1_i32);
        assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", move _65, const 1_i32) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _64 = move (_66.0: i32);
        _62 = Le(move _63, move _64);
        switchInt(move _62) -> [0: bb33, otherwise: bb31];
    }

    bb31: {
        _68 = _6;
        _67 = move _68 as f32 (IntToFloat);
        _7 = Mul(_7, move _67);
        _69 = _9;
        _8 = Mul(_8, move _69);
        _70 = CheckedAdd(_6, const 1_i32);
        assert(!move (_70.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _6 = move (_70.0: i32);
        goto -> bb29;
    }

    bb33: {
        _71 = _8;
        _72 = _7;
        _8 = Div(move _71, move _72);
        goto -> bb63;
    }

    bb34: {
        _83 = _4;
        _82 = move _83 as f32 (IntToFloat);
        _80 = Add(move _82, const 1f32);
        _84 = Mul(const 2f32, _80);
        _85 = _2;
        _76 = Div(move _84, move _85);
        _86 = _2;
        _77 = Div(const 2f32, move _86);
        _87 = _76;
        _78 = Add(move _87, _77);
        _88 = _76;
        _74 = move _88;
        _90 = _76;
        _91 = _78;
        _89 = Mul(move _90, move _91);
        _75 = Sub(move _89, const 1f32);
        _81 = const 1_i32;
        goto -> bb35;
    }

    bb35: {
        _93 = _75;
        _92 = Lt(move _93, const 1.0E+4f32);
        switchInt(move _92) -> [0: bb38, otherwise: bb36];
    }

    bb36: {
        _94 = CheckedAdd(_81, const 1_i32);
        assert(!move (_94.1: bool), "attempt to compute `{} + {}`, which would overflow", _81, const 1_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _81 = move (_94.0: i32);
        _78 = Add(_78, _77);
        _96 = _78;
        _97 = _75;
        _95 = Mul(move _96, move _97);
        _98 = _74;
        _79 = Sub(move _95, move _98);
        _99 = _75;
        _74 = move _99;
        _100 = _79;
        _75 = move _100;
        goto -> bb35;
    }

    bb38: {
        _73 = const 0f32;
        _101 = _81;
        _6 = move _101;
        goto -> bb39;
    }

    bb39: {
        _103 = _6;
        _102 = Ge(move _103, const 0_i32);
        switchInt(move _102) -> [0: bb42, otherwise: bb40];
    }

    bb40: {
        _109 = _6;
        _108 = move _109 as f32 (IntToFloat);
        _107 = Add(move _108, _80);
        _106 = Mul(const 2f32, move _107);
        _110 = _2;
        _105 = Div(move _106, move _110);
        _111 = _73;
        _104 = Sub(move _105, move _111);
        _73 = Div(const 1f32, move _104);
        _112 = CheckedSub(_6, const 1_i32);
        assert(!move (_112.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _6 = move (_112.0: i32);
        goto -> bb39;
    }

    bb42: {
        _113 = _73;
        _7 = move _113;
        _8 = const 1f32;
        _116 = _76;
        _115 = fabsf(move _116) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _114 = logf(move _115) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _79 = Mul(_80, move _114);
        _118 = _79;
        _117 = Lt(move _118, const 88.7216796f32);
        switchInt(move _117) -> [0: bb49, otherwise: bb45];
    }

    bb45: {
        _119 = _4;
        _6 = move _119;
        goto -> bb46;
    }

    bb46: {
        _121 = _6;
        _120 = Gt(move _121, const 0_i32);
        switchInt(move _120) -> [0: bb56, otherwise: bb47];
    }

    bb47: {
        _122 = _8;
        _9 = move _122;
        _127 = _6;
        _126 = move _127 as f32 (IntToFloat);
        _125 = Mul(const 2f32, move _126);
        _128 = _8;
        _124 = Mul(move _125, move _128);
        _129 = _2;
        _123 = Div(move _124, move _129);
        _130 = _7;
        _8 = Sub(move _123, move _130);
        _131 = _9;
        _7 = move _131;
        _132 = CheckedSub(_6, const 1_i32);
        assert(!move (_132.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _6 = move (_132.0: i32);
        goto -> bb46;
    }

    bb49: {
        _133 = _4;
        _6 = move _133;
        goto -> bb50;
    }

    bb50: {
        _135 = _6;
        _134 = Gt(move _135, const 0_i32);
        switchInt(move _134) -> [0: bb56, otherwise: bb51];
    }

    bb51: {
        _136 = _8;
        _9 = move _136;
        _141 = _6;
        _140 = move _141 as f32 (IntToFloat);
        _139 = Mul(const 2f32, move _140);
        _142 = _8;
        _138 = Mul(move _139, move _142);
        _143 = _2;
        _137 = Div(move _138, move _143);
        _144 = _7;
        _8 = Sub(move _137, move _144);
        _145 = _9;
        _7 = move _145;
        _146 = f32::<impl f32>::from_bits(const 1568669696_u32) -> [return: bb52, unwind unreachable];
    }

    bb52: {
        _148 = _8;
        _147 = Gt(move _148, _146);
        switchInt(move _147) -> [0: bb54, otherwise: bb53];
    }

    bb53: {
        _149 = _8;
        _7 = Div(_7, move _149);
        _150 = _8;
        _73 = Div(_73, move _150);
        _8 = const 1f32;
        goto -> bb54;
    }

    bb54: {
        _151 = CheckedSub(_6, const 1_i32);
        assert(!move (_151.1: bool), "attempt to compute `{} - {}`, which would overflow", _6, const 1_i32) -> [success: bb55, unwind unreachable];
    }

    bb55: {
        _6 = move (_151.0: i32);
        goto -> bb50;
    }

    bb56: {
        _153 = _2;
        _152 = j0f(move _153) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        _78 = move _152;
        _155 = _2;
        _154 = j1f(move _155) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _76 = move _154;
        _158 = _78;
        _157 = fabsf(move _158) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _160 = _76;
        _159 = fabsf(move _160) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _156 = Ge(move _157, move _159);
        switchInt(move _156) -> [0: bb62, otherwise: bb61];
    }

    bb61: {
        _162 = _73;
        _163 = _78;
        _161 = Mul(move _162, move _163);
        _164 = _8;
        _8 = Div(move _161, move _164);
        goto -> bb63;
    }

    bb62: {
        _166 = _73;
        _167 = _76;
        _165 = Mul(move _166, move _167);
        _168 = _7;
        _8 = Div(move _165, move _168);
        goto -> bb63;
    }

    bb63: {
        _169 = _5;
        switchInt(move _169) -> [0: bb65, otherwise: bb64];
    }

    bb64: {
        _170 = _8;
        _0 = Neg(move _170);
        goto -> bb66;
    }

    bb65: {
        _0 = _8;
        goto -> bb66;
    }

    bb66: {
        return;
    }
}

fn ynf(_1: i32, _2: f32) -> f32 {
    debug n => _1;
    debug x => _2;
    let mut _0: f32;
    let mut _3: u32;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: i32;
    let mut _22: (i32, bool);
    let mut _23: bool;
    let mut _24: i32;
    let mut _25: (i32, bool);
    let mut _26: i32;
    let mut _27: bool;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: u32;
    let mut _32: f32;
    let mut _33: bool;
    let mut _34: i32;
    let mut _35: i32;
    let mut _36: u32;
    let mut _37: (i32, bool);
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: i32;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: u32;
    let mut _47: f32;
    let mut _48: bool;
    let mut _49: f32;
    scope 1 {
        debug ix => _3;
        let mut _4: u32;
        scope 2 {
            debug ib => _4;
            let _5: i32;
            scope 3 {
                debug nm1 => _5;
                let mut _6: bool;
                scope 4 {
                    debug sign => _6;
                    let mut _7: i32;
                    scope 5 {
                        debug i => _7;
                        let mut _8: f32;
                        scope 6 {
                            debug a => _8;
                            let mut _9: f32;
                            scope 7 {
                                debug b => _9;
                                scope 8 {
                                    debug temp => _38;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _10 = f32::<impl f32>::to_bits(_2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = move _10;
        _12 = _3;
        _13 = const 31_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Shr(move _12, const 31_i32);
        _6 = Ne(move _11, const 0_u32);
        _3 = BitAnd(_3, const 2147483647_u32);
        _16 = _3;
        _15 = Gt(move _16, const 2139095040_u32);
        switchInt(move _15) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = _2;
        goto -> bb34;
    }

    bb4: {
        _17 = _6;
        switchInt(move _17) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        _18 = _3;
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Div(const 0f32, const 0f32);
        goto -> bb34;
    }

    bb7: {
        _19 = _3;
        switchInt(move _19) -> [2139095040: bb8, otherwise: bb9];
    }

    bb8: {
        _0 = const 0f32;
        goto -> bb34;
    }

    bb9: {
        switchInt(move _1) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _0 = y0f(_2) -> [return: bb34, unwind unreachable];
    }

    bb11: {
        _20 = Lt(_1, const 0_i32);
        switchInt(move _20) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _22 = CheckedAdd(_1, const 1_i32);
        assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", _1, const 1_i32) -> [success: bb14, unwind unreachable];
    }

    bb13: {
        _25 = CheckedSub(_1, const 1_i32);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", _1, const 1_i32) -> [success: bb16, unwind unreachable];
    }

    bb14: {
        _21 = move (_22.0: i32);
        _23 = Eq(_21, const i32::MIN);
        assert(!move _23, "attempt to negate `{}`, which would overflow", _21) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _5 = Neg(move _21);
        _24 = BitAnd(_1, const 1_i32);
        _6 = Ne(move _24, const 0_i32);
        goto -> bb17;
    }

    bb16: {
        _5 = move (_25.0: i32);
        _6 = const false;
        goto -> bb17;
    }

    bb17: {
        _26 = _5;
        switchInt(move _26) -> [0: bb18, otherwise: bb22];
    }

    bb18: {
        _27 = _6;
        switchInt(move _27) -> [0: bb21, otherwise: bb19];
    }

    bb19: {
        _28 = y1f(_2) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _0 = Neg(move _28);
        goto -> bb34;
    }

    bb21: {
        _0 = y1f(_2) -> [return: bb34, unwind unreachable];
    }

    bb22: {
        _29 = y0f(_2) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _8 = move _29;
        _30 = y1f(_2) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _9 = move _30;
        _32 = _9;
        _31 = f32::<impl f32>::to_bits(move _32) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _4 = move _31;
        _7 = const 0_i32;
        goto -> bb26;
    }

    bb26: {
        _34 = _7;
        _35 = _5;
        _33 = Lt(move _34, move _35);
        switchInt(move _33) -> [0: bb31, otherwise: bb27];
    }

    bb27: {
        _36 = _4;
        switchInt(move _36) -> [4286578688: bb31, otherwise: bb28];
    }

    bb28: {
        _37 = CheckedAdd(_7, const 1_i32);
        assert(!move (_37.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _7 = move (_37.0: i32);
        _38 = _9;
        _43 = _7;
        _42 = move _43 as f32 (IntToFloat);
        _41 = Mul(const 2f32, move _42);
        _40 = Div(move _41, _2);
        _44 = _9;
        _39 = Mul(move _40, move _44);
        _45 = _8;
        _9 = Sub(move _39, move _45);
        _47 = _9;
        _46 = f32::<impl f32>::to_bits(move _47) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _4 = move _46;
        _8 = _38;
        goto -> bb26;
    }

    bb31: {
        _48 = _6;
        switchInt(move _48) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _49 = _9;
        _0 = Neg(move _49);
        goto -> bb34;
    }

    bb33: {
        _0 = _9;
        goto -> bb34;
    }

    bb34: {
        return;
    }
}

fn ldexp(_1: f64, _2: i32) -> f64 {
    debug x => _1;
    debug n => _2;
    let mut _0: f64;

    bb0: {
        _0 = scalbn(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn ldexpf(_1: f32, _2: i32) -> f32 {
    debug x => _1;
    debug n => _2;
    let mut _0: f32;

    bb0: {
        _0 = scalbnf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn lgamma(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: (f64, i32);

    bb0: {
        _2 = lgamma_r(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_2.0: f64);
        return;
    }
}

const lgamma_r::PI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.1415926535897931f64;
        return;
    }
}

const lgamma_r::A0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.077215664901532866f64;
        return;
    }
}

const lgamma_r::A1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.32246703342411359f64;
        return;
    }
}

const lgamma_r::A2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.067352301053129268f64;
        return;
    }
}

const lgamma_r::A3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.020580808432516733f64;
        return;
    }
}

const lgamma_r::A4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0073855508608140288f64;
        return;
    }
}

const lgamma_r::A5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0028905138367341563f64;
        return;
    }
}

const lgamma_r::A6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0011927076318336207f64;
        return;
    }
}

const lgamma_r::A7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 5.1006979215351134E-4f64;
        return;
    }
}

const lgamma_r::A8: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.2086279071390839E-4f64;
        return;
    }
}

const lgamma_r::A9: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.0801156724758394E-4f64;
        return;
    }
}

const lgamma_r::A10: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.5214456545125733E-5f64;
        return;
    }
}

const lgamma_r::A11: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.4864094961891516E-5f64;
        return;
    }
}

const lgamma_r::TC: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4616321449683622f64;
        return;
    }
}

const lgamma_r::TF: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.12148629053584961f64;
        return;
    }
}

const lgamma_r::TT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -3.6386769970395054E-18f64;
        return;
    }
}

const lgamma_r::T0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.48383612272381005f64;
        return;
    }
}

const lgamma_r::T1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.14758772299459391f64;
        return;
    }
}

const lgamma_r::T2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.064624940239133385f64;
        return;
    }
}

const lgamma_r::T3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.032788541075985965f64;
        return;
    }
}

const lgamma_r::T4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.017970675081182039f64;
        return;
    }
}

const lgamma_r::T5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.010314224129834144f64;
        return;
    }
}

const lgamma_r::T6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0061005387024629133f64;
        return;
    }
}

const lgamma_r::T7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0036845201678113826f64;
        return;
    }
}

const lgamma_r::T8: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0022596478090061247f64;
        return;
    }
}

const lgamma_r::T9: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0014034646998923284f64;
        return;
    }
}

const lgamma_r::T10: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 8.8108188243765401E-4f64;
        return;
    }
}

const lgamma_r::T11: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -5.3859530535674055E-4f64;
        return;
    }
}

const lgamma_r::T12: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.1563207090362595E-4f64;
        return;
    }
}

const lgamma_r::T13: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -3.1275416837512086E-4f64;
        return;
    }
}

const lgamma_r::T14: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.3552919263551907E-4f64;
        return;
    }
}

const lgamma_r::U0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.077215664901532866f64;
        return;
    }
}

const lgamma_r::U1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.63282706402509337f64;
        return;
    }
}

const lgamma_r::U2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4549225013723477f64;
        return;
    }
}

const lgamma_r::U3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.97771752796337275f64;
        return;
    }
}

const lgamma_r::U4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.22896372806469245f64;
        return;
    }
}

const lgamma_r::U5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.013381091853678766f64;
        return;
    }
}

const lgamma_r::V1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.4559779371304113f64;
        return;
    }
}

const lgamma_r::V2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.128489763798934f64;
        return;
    }
}

const lgamma_r::V3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.76928515045667278f64;
        return;
    }
}

const lgamma_r::V4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.10422264559336913f64;
        return;
    }
}

const lgamma_r::V5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0032170924228242391f64;
        return;
    }
}

const lgamma_r::S0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.077215664901532866f64;
        return;
    }
}

const lgamma_r::S1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.21498241596060885f64;
        return;
    }
}

const lgamma_r::S2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.32577879640893098f64;
        return;
    }
}

const lgamma_r::S3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14635047265246445f64;
        return;
    }
}

const lgamma_r::S4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.026642270303363861f64;
        return;
    }
}

const lgamma_r::S5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0018402845140733772f64;
        return;
    }
}

const lgamma_r::S6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.1947532658410087E-5f64;
        return;
    }
}

const lgamma_r::R1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.3920053346762105f64;
        return;
    }
}

const lgamma_r::R2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.72193554756713807f64;
        return;
    }
}

const lgamma_r::R3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.17193386563280308f64;
        return;
    }
}

const lgamma_r::R4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.01864591917156529f64;
        return;
    }
}

const lgamma_r::R5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.779424963818936E-4f64;
        return;
    }
}

const lgamma_r::R6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.3266843074462564E-6f64;
        return;
    }
}

const lgamma_r::W0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.41893853320467273f64;
        return;
    }
}

const lgamma_r::W1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.083333333333332968f64;
        return;
    }
}

const lgamma_r::W2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0027777777772877554f64;
        return;
    }
}

const lgamma_r::W3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 7.9365055864301956E-4f64;
        return;
    }
}

const lgamma_r::W4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -5.9518755745033996E-4f64;
        return;
    }
}

const lgamma_r::W5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 8.3633991899628213E-4f64;
        return;
    }
}

const lgamma_r::W6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0016309293409657527f64;
        return;
    }
}

fn lgamma_r::sin_pi(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: i32;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: i32;
    let mut _12: i32;
    let mut _13: (i32, bool);
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: i32;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    scope 1 {
        debug n => _2;
    }

    bb0: {
        _5 = _1;
        _4 = Mul(move _5, const 0.5f64);
        _8 = _1;
        _7 = Mul(move _8, const 0.5f64);
        _6 = floor(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = Sub(move _4, move _6);
        _1 = Mul(const 2f64, move _3);
        _10 = _1;
        _9 = Mul(move _10, const 4f64);
        _2 = move _9 as i32 (FloatToInt);
        _12 = _2;
        _13 = CheckedAdd(_12, const 1_i32);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _12, const 1_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = move (_13.0: i32);
        _14 = Eq(const 2_i32, const 0_i32);
        assert(!move _14, "attempt to divide `{}` by zero", _11) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _15 = Eq(const 2_i32, const -1_i32);
        _16 = Eq(_11, const i32::MIN);
        _17 = BitAnd(move _15, move _16);
        assert(!move _17, "attempt to compute `{} / {}`, which would overflow", _11, const 2_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = Div(move _11, const 2_i32);
        _20 = _2;
        _19 = move _20 as f64 (IntToFloat);
        _18 = Mul(move _19, const 0.5f64);
        _1 = Sub(_1, move _18);
        _1 = Mul(_1, const _);
        switchInt(_2) -> [1: bb5, 2: bb6, 3: bb7, otherwise: bb9];
    }

    bb5: {
        _21 = _1;
        _0 = k_cos(move _21, const 0f64) -> [return: bb10, unwind unreachable];
    }

    bb6: {
        _23 = _1;
        _22 = Neg(move _23);
        _0 = k_sin(move _22, const 0f64, const 0_i32) -> [return: bb10, unwind unreachable];
    }

    bb7: {
        _25 = _1;
        _24 = k_cos(move _25, const 0f64) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Neg(move _24);
        goto -> bb10;
    }

    bb9: {
        _26 = _1;
        _0 = k_sin(move _26, const 0f64, const 0_i32) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn lgamma_r(_1: f64) -> (f64, i32) {
    debug x => _1;
    let mut _0: (f64, i32);
    let _2: u64;
    let mut _3: f64;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: u64;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: i32;
    let mut _31: bool;
    let mut _32: u32;
    let mut _33: u32;
    let mut _34: (u32, bool);
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: i32;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: bool;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: i32;
    let mut _52: bool;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: u64;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: bool;
    let mut _66: f64;
    let mut _67: bool;
    let mut _68: f64;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: bool;
    let mut _72: f64;
    let mut _73: bool;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: f64;
    let mut _102: f64;
    let mut _103: f64;
    let mut _104: f64;
    let mut _105: f64;
    let mut _106: f64;
    let mut _107: f64;
    let mut _108: f64;
    let mut _109: f64;
    let mut _110: f64;
    let mut _111: f64;
    let mut _112: f64;
    let mut _113: f64;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: f64;
    let mut _117: f64;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: f64;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: f64;
    let mut _124: f64;
    let mut _125: f64;
    let mut _126: f64;
    let mut _127: f64;
    let mut _128: f64;
    let mut _129: f64;
    let mut _130: f64;
    let mut _131: f64;
    let mut _132: f64;
    let mut _133: f64;
    let mut _134: f64;
    let mut _135: f64;
    let mut _136: f64;
    let mut _137: f64;
    let mut _138: f64;
    let mut _139: f64;
    let mut _140: f64;
    let mut _141: f64;
    let mut _142: f64;
    let mut _143: f64;
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: f64;
    let mut _147: f64;
    let mut _148: f64;
    let mut _149: f64;
    let mut _150: f64;
    let mut _151: f64;
    let mut _152: f64;
    let mut _153: f64;
    let mut _154: f64;
    let mut _155: f64;
    let mut _156: f64;
    let mut _157: f64;
    let mut _158: f64;
    let mut _159: f64;
    let mut _160: f64;
    let mut _161: f64;
    let mut _162: f64;
    let mut _163: f64;
    let mut _164: f64;
    let mut _165: f64;
    let mut _166: f64;
    let mut _167: f64;
    let mut _168: f64;
    let mut _169: f64;
    let mut _170: f64;
    let mut _171: f64;
    let mut _172: f64;
    let mut _173: f64;
    let mut _174: f64;
    let mut _175: f64;
    let mut _176: f64;
    let mut _177: f64;
    let mut _178: f64;
    let mut _179: f64;
    let mut _180: f64;
    let mut _181: f64;
    let mut _182: f64;
    let mut _183: f64;
    let mut _184: f64;
    let mut _185: f64;
    let mut _186: f64;
    let mut _187: f64;
    let mut _188: f64;
    let mut _189: f64;
    let mut _190: f64;
    let mut _191: f64;
    let mut _192: f64;
    let mut _193: f64;
    let mut _194: f64;
    let mut _195: f64;
    let mut _196: f64;
    let mut _197: f64;
    let mut _198: f64;
    let mut _199: f64;
    let mut _200: f64;
    let mut _201: !;
    let mut _202: bool;
    let mut _203: f64;
    let mut _204: f64;
    let mut _205: f64;
    let mut _206: i32;
    let mut _207: f64;
    let mut _208: f64;
    let mut _209: f64;
    let mut _210: f64;
    let mut _211: f64;
    let mut _212: f64;
    let mut _213: f64;
    let mut _214: f64;
    let mut _215: f64;
    let mut _216: f64;
    let mut _217: f64;
    let mut _218: f64;
    let mut _219: f64;
    let mut _220: f64;
    let mut _221: f64;
    let mut _222: f64;
    let mut _223: f64;
    let mut _224: f64;
    let mut _225: f64;
    let mut _226: f64;
    let mut _227: f64;
    let mut _228: f64;
    let mut _229: f64;
    let mut _230: f64;
    let mut _231: f64;
    let mut _232: f64;
    let mut _233: f64;
    let mut _234: f64;
    let mut _235: f64;
    let mut _236: f64;
    let mut _237: f64;
    let mut _238: f64;
    let mut _239: f64;
    let mut _240: f64;
    let mut _241: f64;
    let mut _242: f64;
    let mut _243: f64;
    let mut _244: f64;
    let mut _245: f64;
    let mut _246: f64;
    let mut _247: bool;
    let mut _248: i32;
    let mut _249: f64;
    let mut _250: f64;
    let mut _251: bool;
    let mut _252: i32;
    let mut _253: f64;
    let mut _254: f64;
    let mut _255: bool;
    let mut _256: i32;
    let mut _257: f64;
    let mut _258: f64;
    let mut _259: bool;
    let mut _260: i32;
    let mut _261: f64;
    let mut _262: f64;
    let mut _263: bool;
    let mut _264: i32;
    let mut _265: f64;
    let mut _266: f64;
    let mut _267: f64;
    let mut _268: f64;
    let mut _269: bool;
    let mut _270: f64;
    let mut _271: f64;
    let mut _272: f64;
    let mut _273: f64;
    let mut _274: f64;
    let mut _275: f64;
    let mut _276: f64;
    let mut _277: f64;
    let mut _278: f64;
    let mut _279: f64;
    let mut _280: f64;
    let mut _281: f64;
    let mut _282: f64;
    let mut _283: f64;
    let mut _284: f64;
    let mut _285: f64;
    let mut _286: f64;
    let mut _287: f64;
    let mut _288: f64;
    let mut _289: f64;
    let mut _290: f64;
    let mut _291: f64;
    let mut _292: f64;
    let mut _293: f64;
    let mut _294: f64;
    let mut _295: f64;
    let mut _296: f64;
    let mut _297: f64;
    let mut _298: f64;
    let mut _299: f64;
    let mut _300: f64;
    let mut _301: f64;
    let mut _302: f64;
    let mut _303: f64;
    let mut _304: f64;
    let mut _305: i32;
    scope 1 {
        debug u => _2;
        let mut _4: f64;
        scope 2 {
            debug t => _4;
            let _5: f64;
            scope 3 {
                debug y => _5;
                let mut _6: f64;
                scope 4 {
                    debug z => _6;
                    let _7: f64;
                    scope 5 {
                        debug nadj => _7;
                        let _8: f64;
                        scope 6 {
                            debug p => _8;
                            let _9: f64;
                            scope 7 {
                                debug p1 => _9;
                                let _10: f64;
                                scope 8 {
                                    debug p2 => _10;
                                    let _11: f64;
                                    scope 9 {
                                        debug p3 => _11;
                                        let _12: f64;
                                        scope 10 {
                                            debug q => _12;
                                            let mut _13: f64;
                                            scope 11 {
                                                debug r => _13;
                                                let _14: f64;
                                                scope 12 {
                                                    debug w => _14;
                                                    let _15: u32;
                                                    scope 13 {
                                                        debug ix => _15;
                                                        let _16: bool;
                                                        scope 14 {
                                                            debug sign => _16;
                                                            let _17: i32;
                                                            scope 15 {
                                                                debug i => _17;
                                                                let mut _18: i32;
                                                                scope 16 {
                                                                    debug signgam => _18;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f64::<impl f64>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _18 = const 1_i32;
        _20 = const 63_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _19 = Shr(_2, const 63_i32);
        _16 = Ne(move _19, const 0_u64);
        _24 = const 32_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 64_u32);
        assert(move _25, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _23 = Shr(_2, const 32_i32);
        _22 = move _23 as u32 (IntToInt);
        _15 = BitAnd(move _22, const 2147483647_u32);
        _26 = Ge(_15, const 2146435072_u32);
        switchInt(move _26) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _28 = _1;
        _29 = _1;
        _27 = Mul(move _28, move _29);
        _30 = _18;
        _0 = (move _27, move _30);
        goto -> bb64;
    }

    bb5: {
        _34 = CheckedSub(const 1023_u32, const 70_u32);
        assert(!move (_34.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_u32, const 70_u32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _33 = move (_34.0: u32);
        _35 = const 20_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _32 = Shl(move _33, const 20_i32);
        _31 = Lt(_15, move _32);
        switchInt(move _31) -> [0: bb12, otherwise: bb8];
    }

    bb8: {
        switchInt(_16) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _37 = _1;
        _1 = Neg(move _37);
        _18 = const -1_i32;
        goto -> bb10;
    }

    bb10: {
        _40 = _1;
        _39 = log(move _40) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _38 = Neg(move _39);
        _41 = _18;
        _0 = (move _38, move _41);
        goto -> bb64;
    }

    bb12: {
        switchInt(_16) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _42 = _1;
        _1 = Neg(move _42);
        _44 = _1;
        _43 = lgamma_r::sin_pi(move _44) -> [return: bb15, unwind unreachable];
    }

    bb14: {
        _7 = const 0f64;
        goto -> bb22;
    }

    bb15: {
        _4 = move _43;
        _46 = _4;
        _45 = Eq(move _46, const 0f64);
        switchInt(move _45) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _49 = _1;
        _50 = _1;
        _48 = Sub(move _49, move _50);
        _47 = Div(const 1f64, move _48);
        _51 = _18;
        _0 = (move _47, move _51);
        goto -> bb64;
    }

    bb17: {
        _53 = _4;
        _52 = Gt(move _53, const 0f64);
        switchInt(move _52) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _18 = const -1_i32;
        goto -> bb20;
    }

    bb19: {
        _54 = _4;
        _4 = Neg(move _54);
        goto -> bb20;
    }

    bb20: {
        _58 = _4;
        _59 = _1;
        _57 = Mul(move _58, move _59);
        _56 = Div(const _, move _57);
        _55 = log(move _56) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _7 = move _55;
        goto -> bb22;
    }

    bb22: {
        switchInt(move _15) -> [1072693248: bb24, otherwise: bb23];
    }

    bb23: {
        switchInt(move _15) -> [1073741824: bb24, otherwise: bb26];
    }

    bb24: {
        _60 = BitAnd(_2, const 4294967295_u64);
        switchInt(move _60) -> [0: bb25, otherwise: bb26];
    }

    bb25: {
        _13 = const 0f64;
        goto -> bb61;
    }

    bb26: {
        _61 = Lt(_15, const 1073741824_u32);
        switchInt(move _61) -> [0: bb44, otherwise: bb27];
    }

    bb27: {
        _62 = Le(_15, const 1072483532_u32);
        switchInt(move _62) -> [0: bb34, otherwise: bb28];
    }

    bb28: {
        _64 = _1;
        _63 = log(move _64) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _13 = Neg(move _63);
        _65 = Ge(_15, const 1072130372_u32);
        switchInt(move _65) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _66 = _1;
        _5 = Sub(const 1f64, move _66);
        _17 = const 0_i32;
        goto -> bb39;
    }

    bb31: {
        _67 = Ge(_15, const 1070442081_u32);
        switchInt(move _67) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _68 = _1;
        _69 = Sub(const _, const 1f64);
        _5 = Sub(move _68, move _69);
        _17 = const 1_i32;
        goto -> bb39;
    }

    bb33: {
        _70 = _1;
        _5 = move _70;
        _17 = const 2_i32;
        goto -> bb39;
    }

    bb34: {
        _13 = const 0f64;
        _71 = Ge(_15, const 1073460419_u32);
        switchInt(move _71) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _72 = _1;
        _5 = Sub(const 2f64, move _72);
        _17 = const 0_i32;
        goto -> bb39;
    }

    bb36: {
        _73 = Ge(_15, const 1072936132_u32);
        switchInt(move _73) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _74 = _1;
        _5 = Sub(move _74, const _);
        _17 = const 1_i32;
        goto -> bb39;
    }

    bb38: {
        _75 = _1;
        _5 = Sub(move _75, const 1f64);
        _17 = const 2_i32;
        goto -> bb39;
    }

    bb39: {
        switchInt(_17) -> [0: bb41, 1: bb42, 2: bb43, otherwise: bb40];
    }

    bb40: {
        _201 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb41: {
        _76 = _5;
        _77 = _5;
        _6 = Mul(move _76, move _77);
        _79 = _6;
        _82 = _6;
        _85 = _6;
        _88 = _6;
        _91 = _6;
        _90 = Mul(move _91, const _);
        _89 = Add(const _, move _90);
        _87 = Mul(move _88, move _89);
        _86 = Add(const _, move _87);
        _84 = Mul(move _85, move _86);
        _83 = Add(const _, move _84);
        _81 = Mul(move _82, move _83);
        _80 = Add(const _, move _81);
        _78 = Mul(move _79, move _80);
        _9 = Add(const _, move _78);
        _92 = _6;
        _95 = _6;
        _98 = _6;
        _101 = _6;
        _104 = _6;
        _107 = _6;
        _106 = Mul(move _107, const _);
        _105 = Add(const _, move _106);
        _103 = Mul(move _104, move _105);
        _102 = Add(const _, move _103);
        _100 = Mul(move _101, move _102);
        _99 = Add(const _, move _100);
        _97 = Mul(move _98, move _99);
        _96 = Add(const _, move _97);
        _94 = Mul(move _95, move _96);
        _93 = Add(const _, move _94);
        _10 = Mul(move _92, move _93);
        _109 = _5;
        _110 = _9;
        _108 = Mul(move _109, move _110);
        _111 = _10;
        _8 = Add(move _108, move _111);
        _113 = _8;
        _115 = _5;
        _114 = Mul(const 0.5f64, move _115);
        _112 = Sub(move _113, move _114);
        _13 = Add(_13, move _112);
        goto -> bb61;
    }

    bb42: {
        _116 = _5;
        _117 = _5;
        _6 = Mul(move _116, move _117);
        _118 = _6;
        _119 = _5;
        _14 = Mul(move _118, move _119);
        _121 = _14;
        _124 = _14;
        _127 = _14;
        _130 = _14;
        _129 = Mul(move _130, const _);
        _128 = Add(const _, move _129);
        _126 = Mul(move _127, move _128);
        _125 = Add(const _, move _126);
        _123 = Mul(move _124, move _125);
        _122 = Add(const _, move _123);
        _120 = Mul(move _121, move _122);
        _9 = Add(const _, move _120);
        _132 = _14;
        _135 = _14;
        _138 = _14;
        _141 = _14;
        _140 = Mul(move _141, const _);
        _139 = Add(const _, move _140);
        _137 = Mul(move _138, move _139);
        _136 = Add(const _, move _137);
        _134 = Mul(move _135, move _136);
        _133 = Add(const _, move _134);
        _131 = Mul(move _132, move _133);
        _10 = Add(const _, move _131);
        _143 = _14;
        _146 = _14;
        _149 = _14;
        _152 = _14;
        _151 = Mul(move _152, const _);
        _150 = Add(const _, move _151);
        _148 = Mul(move _149, move _150);
        _147 = Add(const _, move _148);
        _145 = Mul(move _146, move _147);
        _144 = Add(const _, move _145);
        _142 = Mul(move _143, move _144);
        _11 = Add(const _, move _142);
        _154 = _6;
        _155 = _9;
        _153 = Mul(move _154, move _155);
        _158 = _14;
        _160 = _10;
        _162 = _5;
        _161 = Mul(move _162, _11);
        _159 = Add(move _160, move _161);
        _157 = Mul(move _158, move _159);
        _156 = Sub(const _, move _157);
        _8 = Sub(move _153, move _156);
        _164 = _8;
        _163 = Add(const _, move _164);
        _13 = Add(_13, move _163);
        goto -> bb61;
    }

    bb43: {
        _165 = _5;
        _168 = _5;
        _171 = _5;
        _174 = _5;
        _177 = _5;
        _180 = _5;
        _179 = Mul(move _180, const _);
        _178 = Add(const _, move _179);
        _176 = Mul(move _177, move _178);
        _175 = Add(const _, move _176);
        _173 = Mul(move _174, move _175);
        _172 = Add(const _, move _173);
        _170 = Mul(move _171, move _172);
        _169 = Add(const _, move _170);
        _167 = Mul(move _168, move _169);
        _166 = Add(const _, move _167);
        _9 = Mul(move _165, move _166);
        _182 = _5;
        _185 = _5;
        _188 = _5;
        _191 = _5;
        _194 = _5;
        _193 = Mul(move _194, const _);
        _192 = Add(const _, move _193);
        _190 = Mul(move _191, move _192);
        _189 = Add(const _, move _190);
        _187 = Mul(move _188, move _189);
        _186 = Add(const _, move _187);
        _184 = Mul(move _185, move _186);
        _183 = Add(const _, move _184);
        _181 = Mul(move _182, move _183);
        _10 = Add(const 1f64, move _181);
        _197 = _5;
        _196 = Mul(const -0.5f64, move _197);
        _199 = _9;
        _200 = _10;
        _198 = Div(move _199, move _200);
        _195 = Add(move _196, move _198);
        _13 = Add(_13, move _195);
        goto -> bb61;
    }

    bb44: {
        _202 = Lt(_15, const 1075838976_u32);
        switchInt(move _202) -> [0: bb56, otherwise: bb45];
    }

    bb45: {
        _203 = _1;
        _17 = move _203 as i32 (FloatToInt);
        _204 = _1;
        _206 = _17;
        _205 = move _206 as f64 (IntToFloat);
        _5 = Sub(move _204, move _205);
        _207 = _5;
        _210 = _5;
        _213 = _5;
        _216 = _5;
        _219 = _5;
        _222 = _5;
        _225 = _5;
        _224 = Mul(move _225, const _);
        _223 = Add(const _, move _224);
        _221 = Mul(move _222, move _223);
        _220 = Add(const _, move _221);
        _218 = Mul(move _219, move _220);
        _217 = Add(const _, move _218);
        _215 = Mul(move _216, move _217);
        _214 = Add(const _, move _215);
        _212 = Mul(move _213, move _214);
        _211 = Add(const _, move _212);
        _209 = Mul(move _210, move _211);
        _208 = Add(const _, move _209);
        _8 = Mul(move _207, move _208);
        _227 = _5;
        _230 = _5;
        _233 = _5;
        _236 = _5;
        _239 = _5;
        _242 = _5;
        _241 = Mul(move _242, const _);
        _240 = Add(const _, move _241);
        _238 = Mul(move _239, move _240);
        _237 = Add(const _, move _238);
        _235 = Mul(move _236, move _237);
        _234 = Add(const _, move _235);
        _232 = Mul(move _233, move _234);
        _231 = Add(const _, move _232);
        _229 = Mul(move _230, move _231);
        _228 = Add(const _, move _229);
        _226 = Mul(move _227, move _228);
        _12 = Add(const 1f64, move _226);
        _244 = _5;
        _243 = Mul(const 0.5f64, move _244);
        _246 = _8;
        _245 = Div(move _246, _12);
        _13 = Add(move _243, move _245);
        _6 = const 1f64;
        _248 = _17;
        _247 = Ge(move _248, const 7_i32);
        switchInt(move _247) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _250 = _5;
        _249 = Add(move _250, const 6f64);
        _6 = Mul(_6, move _249);
        goto -> bb47;
    }

    bb47: {
        _252 = _17;
        _251 = Ge(move _252, const 6_i32);
        switchInt(move _251) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _254 = _5;
        _253 = Add(move _254, const 5f64);
        _6 = Mul(_6, move _253);
        goto -> bb49;
    }

    bb49: {
        _256 = _17;
        _255 = Ge(move _256, const 5_i32);
        switchInt(move _255) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _258 = _5;
        _257 = Add(move _258, const 4f64);
        _6 = Mul(_6, move _257);
        goto -> bb51;
    }

    bb51: {
        _260 = _17;
        _259 = Ge(move _260, const 4_i32);
        switchInt(move _259) -> [0: bb53, otherwise: bb52];
    }

    bb52: {
        _262 = _5;
        _261 = Add(move _262, const 3f64);
        _6 = Mul(_6, move _261);
        goto -> bb53;
    }

    bb53: {
        _264 = _17;
        _263 = Ge(move _264, const 3_i32);
        switchInt(move _263) -> [0: bb61, otherwise: bb54];
    }

    bb54: {
        _266 = _5;
        _265 = Add(move _266, const 2f64);
        _6 = Mul(_6, move _265);
        _268 = _6;
        _267 = log(move _268) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _13 = Add(_13, move _267);
        goto -> bb61;
    }

    bb56: {
        _269 = Lt(_15, const 1133510656_u32);
        switchInt(move _269) -> [0: bb59, otherwise: bb57];
    }

    bb57: {
        _271 = _1;
        _270 = log(move _271) -> [return: bb58, unwind unreachable];
    }

    bb58: {
        _4 = move _270;
        _272 = _1;
        _6 = Div(const 1f64, move _272);
        _273 = _6;
        _274 = _6;
        _5 = Mul(move _273, move _274);
        _276 = _6;
        _279 = _5;
        _282 = _5;
        _285 = _5;
        _288 = _5;
        _291 = _5;
        _290 = Mul(move _291, const _);
        _289 = Add(const _, move _290);
        _287 = Mul(move _288, move _289);
        _286 = Add(const _, move _287);
        _284 = Mul(move _285, move _286);
        _283 = Add(const _, move _284);
        _281 = Mul(move _282, move _283);
        _280 = Add(const _, move _281);
        _278 = Mul(move _279, move _280);
        _277 = Add(const _, move _278);
        _275 = Mul(move _276, move _277);
        _14 = Add(const _, move _275);
        _294 = _1;
        _293 = Sub(move _294, const 0.5f64);
        _296 = _4;
        _295 = Sub(move _296, const 1f64);
        _292 = Mul(move _293, move _295);
        _297 = _14;
        _13 = Add(move _292, move _297);
        goto -> bb61;
    }

    bb59: {
        _298 = _1;
        _301 = _1;
        _300 = log(move _301) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _299 = Sub(move _300, const 1f64);
        _13 = Mul(move _298, move _299);
        goto -> bb61;
    }

    bb61: {
        switchInt(_16) -> [0: bb63, otherwise: bb62];
    }

    bb62: {
        _302 = _7;
        _303 = _13;
        _13 = Sub(move _302, move _303);
        goto -> bb63;
    }

    bb63: {
        _304 = _13;
        _305 = _18;
        _0 = (move _304, move _305);
        goto -> bb64;
    }

    bb64: {
        return;
    }
}

fn lgammaf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: (f32, i32);

    bb0: {
        _2 = lgammaf_r(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_2.0: f32);
        return;
    }
}

const lgammaf_r::PI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.14159274f32;
        return;
    }
}

const lgammaf_r::A0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0772156641f32;
        return;
    }
}

const lgammaf_r::A1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.322467029f32;
        return;
    }
}

const lgammaf_r::A2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0673523024f32;
        return;
    }
}

const lgammaf_r::A3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0205808077f32;
        return;
    }
}

const lgammaf_r::A4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.007385551f32;
        return;
    }
}

const lgammaf_r::A5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00289051374f32;
        return;
    }
}

const lgammaf_r::A6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00119270768f32;
        return;
    }
}

const lgammaf_r::A7: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 5.10069774E-4f32;
        return;
    }
}

const lgammaf_r::A8: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2.20862785E-4f32;
        return;
    }
}

const lgammaf_r::A9: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.08011569E-4f32;
        return;
    }
}

const lgammaf_r::A10: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2.52144564E-5f32;
        return;
    }
}

const lgammaf_r::A11: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 4.48640967E-5f32;
        return;
    }
}

const lgammaf_r::TC: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.46163213f32;
        return;
    }
}

const lgammaf_r::TF: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.121486284f32;
        return;
    }
}

const lgammaf_r::TT: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 6.69710065E-9f32;
        return;
    }
}

const lgammaf_r::T0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.483836114f32;
        return;
    }
}

const lgammaf_r::T1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.147587717f32;
        return;
    }
}

const lgammaf_r::T2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0646249428f32;
        return;
    }
}

const lgammaf_r::T3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0327885412f32;
        return;
    }
}

const lgammaf_r::T4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0179706756f32;
        return;
    }
}

const lgammaf_r::T5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0103142243f32;
        return;
    }
}

const lgammaf_r::T6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00610053865f32;
        return;
    }
}

const lgammaf_r::T7: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00368452026f32;
        return;
    }
}

const lgammaf_r::T8: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00225964771f32;
        return;
    }
}

const lgammaf_r::T9: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0014034647f32;
        return;
    }
}

const lgammaf_r::T10: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 8.81081854E-4f32;
        return;
    }
}

const lgammaf_r::T11: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -5.38595312E-4f32;
        return;
    }
}

const lgammaf_r::T12: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.1563206E-4f32;
        return;
    }
}

const lgammaf_r::T13: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -3.12754157E-4f32;
        return;
    }
}

const lgammaf_r::T14: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.35529185E-4f32;
        return;
    }
}

const lgammaf_r::U0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0772156641f32;
        return;
    }
}

const lgammaf_r::U1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.632827044f32;
        return;
    }
}

const lgammaf_r::U2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.45492256f32;
        return;
    }
}

const lgammaf_r::U3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.977717518f32;
        return;
    }
}

const lgammaf_r::U4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.228963733f32;
        return;
    }
}

const lgammaf_r::U5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0133810919f32;
        return;
    }
}

const lgammaf_r::V1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2.45597792f32;
        return;
    }
}

const lgammaf_r::V2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 2.12848973f32;
        return;
    }
}

const lgammaf_r::V3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.769285142f32;
        return;
    }
}

const lgammaf_r::V4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.104222648f32;
        return;
    }
}

const lgammaf_r::V5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00321709248f32;
        return;
    }
}

const lgammaf_r::S0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0772156641f32;
        return;
    }
}

const lgammaf_r::S1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.21498242f32;
        return;
    }
}

const lgammaf_r::S2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.325778782f32;
        return;
    }
}

const lgammaf_r::S3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.146350473f32;
        return;
    }
}

const lgammaf_r::S4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0266422704f32;
        return;
    }
}

const lgammaf_r::S5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.00184028456f32;
        return;
    }
}

const lgammaf_r::S6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 3.1947533E-5f32;
        return;
    }
}

const lgammaf_r::R1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.39200532f32;
        return;
    }
}

const lgammaf_r::R2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.72193557f32;
        return;
    }
}

const lgammaf_r::R3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.17193386f32;
        return;
    }
}

const lgammaf_r::R4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0186459199f32;
        return;
    }
}

const lgammaf_r::R5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.77942477E-4f32;
        return;
    }
}

const lgammaf_r::R6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.32668422E-6f32;
        return;
    }
}

const lgammaf_r::W0: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.418938547f32;
        return;
    }
}

const lgammaf_r::W1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.0833333358f32;
        return;
    }
}

const lgammaf_r::W2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00277777785f32;
        return;
    }
}

const lgammaf_r::W3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.93650572E-4f32;
        return;
    }
}

const lgammaf_r::W4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -5.95187536E-4f32;
        return;
    }
}

const lgammaf_r::W5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 8.36339895E-4f32;
        return;
    }
}

const lgammaf_r::W6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.0016309293f32;
        return;
    }
}

fn lgammaf_r::sin_pi(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f64;
    let mut _4: f32;
    let mut _5: f32;
    let mut _6: f32;
    let mut _7: f32;
    let mut _8: f32;
    let mut _9: f32;
    let mut _10: f32;
    let mut _11: f32;
    let mut _12: isize;
    let mut _13: isize;
    let mut _14: (isize, bool);
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: f64;
    let mut _20: f32;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: isize;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f32;
    let mut _28: f64;
    let mut _29: f64;
    scope 1 {
        debug y => _2;
        let mut _3: isize;
        scope 2 {
            debug n => _3;
        }
    }

    bb0: {
        _6 = _1;
        _5 = Mul(move _6, const 0.5f32);
        _9 = _1;
        _8 = Mul(move _9, const 0.5f32);
        _7 = floorf(move _8) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Sub(move _5, move _7);
        _1 = Mul(const 2f32, move _4);
        _11 = _1;
        _10 = Mul(move _11, const 4f32);
        _3 = move _10 as isize (FloatToInt);
        _13 = _3;
        _14 = CheckedAdd(_13, const 1_isize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _13, const 1_isize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _12 = move (_14.0: isize);
        _15 = Eq(const 2_isize, const 0_isize);
        assert(!move _15, "attempt to divide `{}` by zero", _12) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _16 = Eq(const 2_isize, const -1_isize);
        _17 = Eq(_12, const isize::MIN);
        _18 = BitAnd(move _16, move _17);
        assert(!move _18, "attempt to compute `{} / {}`, which would overflow", _12, const 2_isize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _3 = Div(move _12, const 2_isize);
        _20 = _1;
        _19 = move _20 as f64 (FloatToFloat);
        _23 = _3;
        _22 = move _23 as f64 (IntToFloat);
        _21 = Mul(move _22, const 0.5f64);
        _2 = Sub(move _19, move _21);
        _2 = Mul(_2, const 3.1415926535897931f64);
        switchInt(_3) -> [1: bb5, 2: bb6, 3: bb7, otherwise: bb9];
    }

    bb5: {
        _24 = _2;
        _0 = k_cosf(move _24) -> [return: bb10, unwind unreachable];
    }

    bb6: {
        _26 = _2;
        _25 = Neg(move _26);
        _0 = k_sinf(move _25) -> [return: bb10, unwind unreachable];
    }

    bb7: {
        _28 = _2;
        _27 = k_cosf(move _28) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Neg(move _27);
        goto -> bb10;
    }

    bb9: {
        _29 = _2;
        _0 = k_sinf(move _29) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

fn lgammaf_r(_1: f32) -> (f32, i32) {
    debug x => _1;
    let mut _0: (f32, i32);
    let _2: u32;
    let mut _3: f32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: i32;
    let mut _27: bool;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: i32;
    let mut _33: f32;
    let mut _34: f32;
    let mut _35: f32;
    let mut _36: bool;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: i32;
    let mut _43: bool;
    let mut _44: f32;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f32;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f32;
    let mut _51: bool;
    let mut _52: bool;
    let mut _53: f32;
    let mut _54: f32;
    let mut _55: bool;
    let mut _56: f32;
    let mut _57: bool;
    let mut _58: f32;
    let mut _59: f32;
    let mut _60: f32;
    let mut _61: bool;
    let mut _62: f32;
    let mut _63: bool;
    let mut _64: f32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f32;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: f32;
    let mut _91: f32;
    let mut _92: f32;
    let mut _93: f32;
    let mut _94: f32;
    let mut _95: f32;
    let mut _96: f32;
    let mut _97: f32;
    let mut _98: f32;
    let mut _99: f32;
    let mut _100: f32;
    let mut _101: f32;
    let mut _102: f32;
    let mut _103: f32;
    let mut _104: f32;
    let mut _105: f32;
    let mut _106: f32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: f32;
    let mut _110: f32;
    let mut _111: f32;
    let mut _112: f32;
    let mut _113: f32;
    let mut _114: f32;
    let mut _115: f32;
    let mut _116: f32;
    let mut _117: f32;
    let mut _118: f32;
    let mut _119: f32;
    let mut _120: f32;
    let mut _121: f32;
    let mut _122: f32;
    let mut _123: f32;
    let mut _124: f32;
    let mut _125: f32;
    let mut _126: f32;
    let mut _127: f32;
    let mut _128: f32;
    let mut _129: f32;
    let mut _130: f32;
    let mut _131: f32;
    let mut _132: f32;
    let mut _133: f32;
    let mut _134: f32;
    let mut _135: f32;
    let mut _136: f32;
    let mut _137: f32;
    let mut _138: f32;
    let mut _139: f32;
    let mut _140: f32;
    let mut _141: f32;
    let mut _142: f32;
    let mut _143: f32;
    let mut _144: f32;
    let mut _145: f32;
    let mut _146: f32;
    let mut _147: f32;
    let mut _148: f32;
    let mut _149: f32;
    let mut _150: f32;
    let mut _151: f32;
    let mut _152: f32;
    let mut _153: f32;
    let mut _154: f32;
    let mut _155: f32;
    let mut _156: f32;
    let mut _157: f32;
    let mut _158: f32;
    let mut _159: f32;
    let mut _160: f32;
    let mut _161: f32;
    let mut _162: f32;
    let mut _163: f32;
    let mut _164: f32;
    let mut _165: f32;
    let mut _166: f32;
    let mut _167: f32;
    let mut _168: f32;
    let mut _169: f32;
    let mut _170: f32;
    let mut _171: f32;
    let mut _172: f32;
    let mut _173: f32;
    let mut _174: f32;
    let mut _175: f32;
    let mut _176: f32;
    let mut _177: f32;
    let mut _178: f32;
    let mut _179: f32;
    let mut _180: f32;
    let mut _181: f32;
    let mut _182: f32;
    let mut _183: f32;
    let mut _184: f32;
    let mut _185: f32;
    let mut _186: f32;
    let mut _187: f32;
    let mut _188: f32;
    let mut _189: f32;
    let mut _190: f32;
    let mut _191: !;
    let mut _192: bool;
    let mut _193: f32;
    let mut _194: f32;
    let mut _195: f32;
    let mut _196: i32;
    let mut _197: f32;
    let mut _198: f32;
    let mut _199: f32;
    let mut _200: f32;
    let mut _201: f32;
    let mut _202: f32;
    let mut _203: f32;
    let mut _204: f32;
    let mut _205: f32;
    let mut _206: f32;
    let mut _207: f32;
    let mut _208: f32;
    let mut _209: f32;
    let mut _210: f32;
    let mut _211: f32;
    let mut _212: f32;
    let mut _213: f32;
    let mut _214: f32;
    let mut _215: f32;
    let mut _216: f32;
    let mut _217: f32;
    let mut _218: f32;
    let mut _219: f32;
    let mut _220: f32;
    let mut _221: f32;
    let mut _222: f32;
    let mut _223: f32;
    let mut _224: f32;
    let mut _225: f32;
    let mut _226: f32;
    let mut _227: f32;
    let mut _228: f32;
    let mut _229: f32;
    let mut _230: f32;
    let mut _231: f32;
    let mut _232: f32;
    let mut _233: f32;
    let mut _234: f32;
    let mut _235: f32;
    let mut _236: f32;
    let mut _237: bool;
    let mut _238: i32;
    let mut _239: f32;
    let mut _240: f32;
    let mut _241: bool;
    let mut _242: i32;
    let mut _243: f32;
    let mut _244: f32;
    let mut _245: bool;
    let mut _246: i32;
    let mut _247: f32;
    let mut _248: f32;
    let mut _249: bool;
    let mut _250: i32;
    let mut _251: f32;
    let mut _252: f32;
    let mut _253: bool;
    let mut _254: i32;
    let mut _255: f32;
    let mut _256: f32;
    let mut _257: f32;
    let mut _258: f32;
    let mut _259: bool;
    let mut _260: f32;
    let mut _261: f32;
    let mut _262: f32;
    let mut _263: f32;
    let mut _264: f32;
    let mut _265: f32;
    let mut _266: f32;
    let mut _267: f32;
    let mut _268: f32;
    let mut _269: f32;
    let mut _270: f32;
    let mut _271: f32;
    let mut _272: f32;
    let mut _273: f32;
    let mut _274: f32;
    let mut _275: f32;
    let mut _276: f32;
    let mut _277: f32;
    let mut _278: f32;
    let mut _279: f32;
    let mut _280: f32;
    let mut _281: f32;
    let mut _282: f32;
    let mut _283: f32;
    let mut _284: f32;
    let mut _285: f32;
    let mut _286: f32;
    let mut _287: f32;
    let mut _288: f32;
    let mut _289: f32;
    let mut _290: f32;
    let mut _291: f32;
    let mut _292: f32;
    let mut _293: f32;
    let mut _294: f32;
    let mut _295: i32;
    scope 1 {
        debug u => _2;
        let mut _4: f32;
        scope 2 {
            debug t => _4;
            let _5: f32;
            scope 3 {
                debug y => _5;
                let mut _6: f32;
                scope 4 {
                    debug z => _6;
                    let _7: f32;
                    scope 5 {
                        debug nadj => _7;
                        let _8: f32;
                        scope 6 {
                            debug p => _8;
                            let _9: f32;
                            scope 7 {
                                debug p1 => _9;
                                let _10: f32;
                                scope 8 {
                                    debug p2 => _10;
                                    let _11: f32;
                                    scope 9 {
                                        debug p3 => _11;
                                        let _12: f32;
                                        scope 10 {
                                            debug q => _12;
                                            let mut _13: f32;
                                            scope 11 {
                                                debug r => _13;
                                                let _14: f32;
                                                scope 12 {
                                                    debug w => _14;
                                                    let _15: u32;
                                                    scope 13 {
                                                        debug ix => _15;
                                                        let _16: i32;
                                                        scope 14 {
                                                            debug i => _16;
                                                            let _17: bool;
                                                            scope 15 {
                                                                debug sign => _17;
                                                                let mut _18: i32;
                                                                scope 16 {
                                                                    debug signgam => _18;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f32::<impl f32>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _18 = const 1_i32;
        _20 = const 31_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 32_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _19 = Shr(_2, const 31_i32);
        _17 = Ne(move _19, const 0_u32);
        _15 = BitAnd(_2, const 2147483647_u32);
        _22 = Ge(_15, const 2139095040_u32);
        switchInt(move _22) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _24 = _1;
        _25 = _1;
        _23 = Mul(move _24, move _25);
        _26 = _18;
        _0 = (move _23, move _26);
        goto -> bb60;
    }

    bb4: {
        _27 = Lt(_15, const 889192448_u32);
        switchInt(move _27) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        switchInt(_17) -> [0: bb8, otherwise: bb7];
    }

    bb6: {
        switchInt(_17) -> [0: bb11, otherwise: bb10];
    }

    bb7: {
        _18 = const -1_i32;
        _28 = _1;
        _1 = Neg(move _28);
        goto -> bb8;
    }

    bb8: {
        _31 = _1;
        _30 = logf(move _31) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _29 = Neg(move _30);
        _32 = _18;
        _0 = (move _29, move _32);
        goto -> bb60;
    }

    bb10: {
        _33 = _1;
        _1 = Neg(move _33);
        _35 = _1;
        _34 = lgammaf_r::sin_pi(move _35) -> [return: bb12, unwind unreachable];
    }

    bb11: {
        _7 = const 0f32;
        goto -> bb19;
    }

    bb12: {
        _4 = move _34;
        _37 = _4;
        _36 = Eq(move _37, const 0f32);
        switchInt(move _36) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _40 = _1;
        _41 = _1;
        _39 = Sub(move _40, move _41);
        _38 = Div(const 1f32, move _39);
        _42 = _18;
        _0 = (move _38, move _42);
        goto -> bb60;
    }

    bb14: {
        _44 = _4;
        _43 = Gt(move _44, const 0f32);
        switchInt(move _43) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _18 = const -1_i32;
        goto -> bb17;
    }

    bb16: {
        _45 = _4;
        _4 = Neg(move _45);
        goto -> bb17;
    }

    bb17: {
        _49 = _4;
        _50 = _1;
        _48 = Mul(move _49, move _50);
        _47 = Div(const _, move _48);
        _46 = logf(move _47) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _7 = move _46;
        goto -> bb19;
    }

    bb19: {
        switchInt(move _15) -> [1065353216: bb21, otherwise: bb20];
    }

    bb20: {
        switchInt(move _15) -> [1073741824: bb21, otherwise: bb22];
    }

    bb21: {
        _13 = const 0f32;
        goto -> bb57;
    }

    bb22: {
        _51 = Lt(_15, const 1073741824_u32);
        switchInt(move _51) -> [0: bb40, otherwise: bb23];
    }

    bb23: {
        _52 = Le(_15, const 1063675494_u32);
        switchInt(move _52) -> [0: bb30, otherwise: bb24];
    }

    bb24: {
        _54 = _1;
        _53 = logf(move _54) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _13 = Neg(move _53);
        _55 = Ge(_15, const 1060850208_u32);
        switchInt(move _55) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _56 = _1;
        _5 = Sub(const 1f32, move _56);
        _16 = const 0_i32;
        goto -> bb35;
    }

    bb27: {
        _57 = Ge(_15, const 1047343880_u32);
        switchInt(move _57) -> [0: bb29, otherwise: bb28];
    }

    bb28: {
        _58 = _1;
        _59 = Sub(const _, const 1f32);
        _5 = Sub(move _58, move _59);
        _16 = const 1_i32;
        goto -> bb35;
    }

    bb29: {
        _60 = _1;
        _5 = move _60;
        _16 = const 2_i32;
        goto -> bb35;
    }

    bb30: {
        _13 = const 0f32;
        _61 = Ge(_15, const 1071490584_u32);
        switchInt(move _61) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _62 = _1;
        _5 = Sub(const 2f32, move _62);
        _16 = const 0_i32;
        goto -> bb35;
    }

    bb32: {
        _63 = Ge(_15, const 1067296288_u32);
        switchInt(move _63) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _64 = _1;
        _5 = Sub(move _64, const _);
        _16 = const 1_i32;
        goto -> bb35;
    }

    bb34: {
        _65 = _1;
        _5 = Sub(move _65, const 1f32);
        _16 = const 2_i32;
        goto -> bb35;
    }

    bb35: {
        switchInt(_16) -> [0: bb37, 1: bb38, 2: bb39, otherwise: bb36];
    }

    bb36: {
        _191 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb37: {
        _66 = _5;
        _67 = _5;
        _6 = Mul(move _66, move _67);
        _69 = _6;
        _72 = _6;
        _75 = _6;
        _78 = _6;
        _81 = _6;
        _80 = Mul(move _81, const _);
        _79 = Add(const _, move _80);
        _77 = Mul(move _78, move _79);
        _76 = Add(const _, move _77);
        _74 = Mul(move _75, move _76);
        _73 = Add(const _, move _74);
        _71 = Mul(move _72, move _73);
        _70 = Add(const _, move _71);
        _68 = Mul(move _69, move _70);
        _9 = Add(const _, move _68);
        _82 = _6;
        _85 = _6;
        _88 = _6;
        _91 = _6;
        _94 = _6;
        _97 = _6;
        _96 = Mul(move _97, const _);
        _95 = Add(const _, move _96);
        _93 = Mul(move _94, move _95);
        _92 = Add(const _, move _93);
        _90 = Mul(move _91, move _92);
        _89 = Add(const _, move _90);
        _87 = Mul(move _88, move _89);
        _86 = Add(const _, move _87);
        _84 = Mul(move _85, move _86);
        _83 = Add(const _, move _84);
        _10 = Mul(move _82, move _83);
        _99 = _5;
        _100 = _9;
        _98 = Mul(move _99, move _100);
        _101 = _10;
        _8 = Add(move _98, move _101);
        _103 = _8;
        _105 = _5;
        _104 = Mul(const 0.5f32, move _105);
        _102 = Sub(move _103, move _104);
        _13 = Add(_13, move _102);
        goto -> bb57;
    }

    bb38: {
        _106 = _5;
        _107 = _5;
        _6 = Mul(move _106, move _107);
        _108 = _6;
        _109 = _5;
        _14 = Mul(move _108, move _109);
        _111 = _14;
        _114 = _14;
        _117 = _14;
        _120 = _14;
        _119 = Mul(move _120, const _);
        _118 = Add(const _, move _119);
        _116 = Mul(move _117, move _118);
        _115 = Add(const _, move _116);
        _113 = Mul(move _114, move _115);
        _112 = Add(const _, move _113);
        _110 = Mul(move _111, move _112);
        _9 = Add(const _, move _110);
        _122 = _14;
        _125 = _14;
        _128 = _14;
        _131 = _14;
        _130 = Mul(move _131, const _);
        _129 = Add(const _, move _130);
        _127 = Mul(move _128, move _129);
        _126 = Add(const _, move _127);
        _124 = Mul(move _125, move _126);
        _123 = Add(const _, move _124);
        _121 = Mul(move _122, move _123);
        _10 = Add(const _, move _121);
        _133 = _14;
        _136 = _14;
        _139 = _14;
        _142 = _14;
        _141 = Mul(move _142, const _);
        _140 = Add(const _, move _141);
        _138 = Mul(move _139, move _140);
        _137 = Add(const _, move _138);
        _135 = Mul(move _136, move _137);
        _134 = Add(const _, move _135);
        _132 = Mul(move _133, move _134);
        _11 = Add(const _, move _132);
        _144 = _6;
        _145 = _9;
        _143 = Mul(move _144, move _145);
        _148 = _14;
        _150 = _10;
        _152 = _5;
        _151 = Mul(move _152, _11);
        _149 = Add(move _150, move _151);
        _147 = Mul(move _148, move _149);
        _146 = Sub(const _, move _147);
        _8 = Sub(move _143, move _146);
        _154 = _8;
        _153 = Add(const _, move _154);
        _13 = Add(_13, move _153);
        goto -> bb57;
    }

    bb39: {
        _155 = _5;
        _158 = _5;
        _161 = _5;
        _164 = _5;
        _167 = _5;
        _170 = _5;
        _169 = Mul(move _170, const _);
        _168 = Add(const _, move _169);
        _166 = Mul(move _167, move _168);
        _165 = Add(const _, move _166);
        _163 = Mul(move _164, move _165);
        _162 = Add(const _, move _163);
        _160 = Mul(move _161, move _162);
        _159 = Add(const _, move _160);
        _157 = Mul(move _158, move _159);
        _156 = Add(const _, move _157);
        _9 = Mul(move _155, move _156);
        _172 = _5;
        _175 = _5;
        _178 = _5;
        _181 = _5;
        _184 = _5;
        _183 = Mul(move _184, const _);
        _182 = Add(const _, move _183);
        _180 = Mul(move _181, move _182);
        _179 = Add(const _, move _180);
        _177 = Mul(move _178, move _179);
        _176 = Add(const _, move _177);
        _174 = Mul(move _175, move _176);
        _173 = Add(const _, move _174);
        _171 = Mul(move _172, move _173);
        _10 = Add(const 1f32, move _171);
        _187 = _5;
        _186 = Mul(const -0.5f32, move _187);
        _189 = _9;
        _190 = _10;
        _188 = Div(move _189, move _190);
        _185 = Add(move _186, move _188);
        _13 = Add(_13, move _185);
        goto -> bb57;
    }

    bb40: {
        _192 = Lt(_15, const 1090519040_u32);
        switchInt(move _192) -> [0: bb52, otherwise: bb41];
    }

    bb41: {
        _193 = _1;
        _16 = move _193 as i32 (FloatToInt);
        _194 = _1;
        _196 = _16;
        _195 = move _196 as f32 (IntToFloat);
        _5 = Sub(move _194, move _195);
        _197 = _5;
        _200 = _5;
        _203 = _5;
        _206 = _5;
        _209 = _5;
        _212 = _5;
        _215 = _5;
        _214 = Mul(move _215, const _);
        _213 = Add(const _, move _214);
        _211 = Mul(move _212, move _213);
        _210 = Add(const _, move _211);
        _208 = Mul(move _209, move _210);
        _207 = Add(const _, move _208);
        _205 = Mul(move _206, move _207);
        _204 = Add(const _, move _205);
        _202 = Mul(move _203, move _204);
        _201 = Add(const _, move _202);
        _199 = Mul(move _200, move _201);
        _198 = Add(const _, move _199);
        _8 = Mul(move _197, move _198);
        _217 = _5;
        _220 = _5;
        _223 = _5;
        _226 = _5;
        _229 = _5;
        _232 = _5;
        _231 = Mul(move _232, const _);
        _230 = Add(const _, move _231);
        _228 = Mul(move _229, move _230);
        _227 = Add(const _, move _228);
        _225 = Mul(move _226, move _227);
        _224 = Add(const _, move _225);
        _222 = Mul(move _223, move _224);
        _221 = Add(const _, move _222);
        _219 = Mul(move _220, move _221);
        _218 = Add(const _, move _219);
        _216 = Mul(move _217, move _218);
        _12 = Add(const 1f32, move _216);
        _234 = _5;
        _233 = Mul(const 0.5f32, move _234);
        _236 = _8;
        _235 = Div(move _236, _12);
        _13 = Add(move _233, move _235);
        _6 = const 1f32;
        _238 = _16;
        _237 = Ge(move _238, const 7_i32);
        switchInt(move _237) -> [0: bb43, otherwise: bb42];
    }

    bb42: {
        _240 = _5;
        _239 = Add(move _240, const 6f32);
        _6 = Mul(_6, move _239);
        goto -> bb43;
    }

    bb43: {
        _242 = _16;
        _241 = Ge(move _242, const 6_i32);
        switchInt(move _241) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _244 = _5;
        _243 = Add(move _244, const 5f32);
        _6 = Mul(_6, move _243);
        goto -> bb45;
    }

    bb45: {
        _246 = _16;
        _245 = Ge(move _246, const 5_i32);
        switchInt(move _245) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _248 = _5;
        _247 = Add(move _248, const 4f32);
        _6 = Mul(_6, move _247);
        goto -> bb47;
    }

    bb47: {
        _250 = _16;
        _249 = Ge(move _250, const 4_i32);
        switchInt(move _249) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _252 = _5;
        _251 = Add(move _252, const 3f32);
        _6 = Mul(_6, move _251);
        goto -> bb49;
    }

    bb49: {
        _254 = _16;
        _253 = Ge(move _254, const 3_i32);
        switchInt(move _253) -> [0: bb57, otherwise: bb50];
    }

    bb50: {
        _256 = _5;
        _255 = Add(move _256, const 2f32);
        _6 = Mul(_6, move _255);
        _258 = _6;
        _257 = logf(move _258) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _13 = Add(_13, move _257);
        goto -> bb57;
    }

    bb52: {
        _259 = Lt(_15, const 1551892480_u32);
        switchInt(move _259) -> [0: bb55, otherwise: bb53];
    }

    bb53: {
        _261 = _1;
        _260 = logf(move _261) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _4 = move _260;
        _262 = _1;
        _6 = Div(const 1f32, move _262);
        _263 = _6;
        _264 = _6;
        _5 = Mul(move _263, move _264);
        _266 = _6;
        _269 = _5;
        _272 = _5;
        _275 = _5;
        _278 = _5;
        _281 = _5;
        _280 = Mul(move _281, const _);
        _279 = Add(const _, move _280);
        _277 = Mul(move _278, move _279);
        _276 = Add(const _, move _277);
        _274 = Mul(move _275, move _276);
        _273 = Add(const _, move _274);
        _271 = Mul(move _272, move _273);
        _270 = Add(const _, move _271);
        _268 = Mul(move _269, move _270);
        _267 = Add(const _, move _268);
        _265 = Mul(move _266, move _267);
        _14 = Add(const _, move _265);
        _284 = _1;
        _283 = Sub(move _284, const 0.5f32);
        _286 = _4;
        _285 = Sub(move _286, const 1f32);
        _282 = Mul(move _283, move _285);
        _287 = _14;
        _13 = Add(move _282, move _287);
        goto -> bb57;
    }

    bb55: {
        _288 = _1;
        _291 = _1;
        _290 = logf(move _291) -> [return: bb56, unwind unreachable];
    }

    bb56: {
        _289 = Sub(move _290, const 1f32);
        _13 = Mul(move _288, move _289);
        goto -> bb57;
    }

    bb57: {
        switchInt(_17) -> [0: bb59, otherwise: bb58];
    }

    bb58: {
        _292 = _7;
        _293 = _13;
        _13 = Sub(move _292, move _293);
        goto -> bb59;
    }

    bb59: {
        _294 = _13;
        _295 = _18;
        _0 = (move _294, move _295);
        goto -> bb60;
    }

    bb60: {
        return;
    }
}

const log::LN2_HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718036912382f64;
        return;
    }
}

const log::LN2_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9082149292705877E-10f64;
        return;
    }
}

const log::LG1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.66666666666667351f64;
        return;
    }
}

const log::LG2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.39999999999409419f64;
        return;
    }
}

const log::LG3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.28571428743662391f64;
        return;
    }
}

const log::LG4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.22222198432149784f64;
        return;
    }
}

const log::LG5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.1818357216161805f64;
        return;
    }
}

const log::LG6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.15313837699209373f64;
        return;
    }
}

const log::LG7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14798198605116586f64;
        return;
    }
}

fn log(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: f64;
    let mut _6: u64;
    let mut _7: u64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: (i32, bool);
    let mut _32: u64;
    let mut _33: f64;
    let mut _34: u64;
    let mut _35: u64;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: u64;
    let mut _42: u64;
    let mut _43: u32;
    let mut _44: bool;
    let mut _45: u32;
    let mut _46: (u32, bool);
    let mut _47: (u32, bool);
    let mut _48: i32;
    let mut _49: i32;
    let mut _50: u32;
    let mut _51: u32;
    let mut _52: u32;
    let mut _53: bool;
    let mut _54: (i32, bool);
    let mut _55: (i32, bool);
    let mut _56: u32;
    let mut _57: u32;
    let mut _58: (u32, bool);
    let mut _59: u64;
    let mut _60: u64;
    let mut _61: u32;
    let mut _62: u32;
    let mut _63: bool;
    let mut _64: u64;
    let mut _65: u64;
    let mut _66: f64;
    let mut _67: u64;
    let mut _69: f64;
    let mut _71: f64;
    let mut _73: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _90: i32;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    scope 1 {
        debug x1p54 => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let mut _5: u32;
            scope 3 {
                debug hx => _5;
                let mut _10: i32;
                scope 4 {
                    debug k => _10;
                    let _68: f64;
                    scope 5 {
                        debug f => _68;
                        let _70: f64;
                        scope 6 {
                            debug hfsq => _70;
                            let _72: f64;
                            scope 7 {
                                debug s => _72;
                                let _74: f64;
                                scope 8 {
                                    debug z => _74;
                                    let _75: f64;
                                    scope 9 {
                                        debug w => _75;
                                        let _76: f64;
                                        scope 10 {
                                            debug t1 => _76;
                                            let _81: f64;
                                            scope 11 {
                                                debug t2 => _81;
                                                let _88: f64;
                                                scope 12 {
                                                    debug r => _88;
                                                    let _89: f64;
                                                    scope 13 {
                                                        debug dk => _89;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4850376798678024192_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _3;
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 32_i32);
        _5 = move _6 as u32 (IntToInt);
        _10 = const 0_i32;
        _12 = _5;
        _11 = Lt(move _12, const 1048576_u32);
        switchInt(move _11) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _14 = _5;
        _15 = const 31_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 32_u32);
        assert(move _16, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Shr(move _14, const 31_i32);
        switchInt(move _13) -> [0: bb16, otherwise: bb6];
    }

    bb6: {
        _18 = _3;
        _19 = const 1_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 64_u32);
        assert(move _20, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _17 = Shl(move _18, const 1_i32);
        switchInt(move _17) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _22 = _1;
        _23 = _1;
        _21 = Mul(move _22, move _23);
        _0 = Div(const -1f64, move _21);
        goto -> bb31;
    }

    bb9: {
        _25 = _5;
        _26 = const 31_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _24 = Shr(move _25, const 31_i32);
        switchInt(move _24) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _29 = _1;
        _30 = _1;
        _28 = Sub(move _29, move _30);
        _0 = Div(move _28, const 0f64);
        goto -> bb31;
    }

    bb12: {
        _31 = CheckedSub(_10, const 54_i32);
        assert(!move (_31.1: bool), "attempt to compute `{} - {}`, which would overflow", _10, const 54_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _10 = move (_31.0: i32);
        _1 = Mul(_1, _2);
        _33 = _1;
        _32 = f64::<impl f64>::to_bits(move _33) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _3 = move _32;
        _35 = _3;
        _36 = const 32_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _34 = Shr(move _35, const 32_i32);
        _5 = move _34 as u32 (IntToInt);
        goto -> bb22;
    }

    bb16: {
        _39 = _5;
        _38 = Ge(move _39, const 2146435072_u32);
        switchInt(move _38) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = _1;
        goto -> bb31;
    }

    bb18: {
        _40 = _5;
        switchInt(move _40) -> [1072693248: bb19, otherwise: bb22];
    }

    bb19: {
        _42 = _3;
        _43 = const 32_i32 as u32 (IntToInt);
        _44 = Lt(move _43, const 64_u32);
        assert(move _44, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _41 = Shl(move _42, const 32_i32);
        switchInt(move _41) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _0 = const 0f64;
        goto -> bb31;
    }

    bb22: {
        _46 = CheckedSub(const 1072693248_u32, const 1072079006_u32);
        assert(!move (_46.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u32, const 1072079006_u32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _45 = move (_46.0: u32);
        _47 = CheckedAdd(_5, _45);
        assert(!move (_47.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, move _45) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _5 = move (_47.0: u32);
        _51 = _5;
        _52 = const 20_i32 as u32 (IntToInt);
        _53 = Lt(move _52, const 32_u32);
        assert(move _53, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _50 = Shr(move _51, const 20_i32);
        _49 = move _50 as i32 (IntToInt);
        _54 = CheckedSub(_49, const 1023_i32);
        assert(!move (_54.1: bool), "attempt to compute `{} - {}`, which would overflow", move _49, const 1023_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _48 = move (_54.0: i32);
        _55 = CheckedAdd(_10, _48);
        assert(!move (_55.1: bool), "attempt to compute `{} + {}`, which would overflow", _10, move _48) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _10 = move (_55.0: i32);
        _57 = _5;
        _56 = BitAnd(move _57, const 1048575_u32);
        _58 = CheckedAdd(_56, const 1072079006_u32);
        assert(!move (_58.1: bool), "attempt to compute `{} + {}`, which would overflow", move _56, const 1072079006_u32) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _5 = move (_58.0: u32);
        _61 = _5;
        _60 = move _61 as u64 (IntToInt);
        _62 = const 32_i32 as u32 (IntToInt);
        _63 = Lt(move _62, const 64_u32);
        assert(move _63, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _59 = Shl(move _60, const 32_i32);
        _65 = _3;
        _64 = BitAnd(move _65, const 4294967295_u64);
        _3 = BitOr(move _59, move _64);
        _67 = _3;
        _66 = f64::<impl f64>::from_bits(move _67) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _1 = move _66;
        _69 = _1;
        _68 = Sub(move _69, const 1f64);
        _71 = Mul(const 0.5f64, _68);
        _70 = Mul(move _71, _68);
        _73 = Add(const 2f64, _68);
        _72 = Div(_68, move _73);
        _74 = Mul(_72, _72);
        _75 = Mul(_74, _74);
        _80 = Mul(_75, const _);
        _79 = Add(const _, move _80);
        _78 = Mul(_75, move _79);
        _77 = Add(const _, move _78);
        _76 = Mul(_75, move _77);
        _87 = Mul(_75, const _);
        _86 = Add(const _, move _87);
        _85 = Mul(_75, move _86);
        _84 = Add(const _, move _85);
        _83 = Mul(_75, move _84);
        _82 = Add(const _, move _83);
        _81 = Mul(_74, move _82);
        _88 = Add(_81, _76);
        _90 = _10;
        _89 = move _90 as f64 (IntToFloat);
        _95 = Add(_70, _88);
        _94 = Mul(_72, move _95);
        _96 = Mul(_89, const _);
        _93 = Add(move _94, move _96);
        _92 = Sub(move _93, _70);
        _91 = Add(move _92, _68);
        _97 = Mul(_89, const _);
        _0 = Add(move _91, move _97);
        goto -> bb31;
    }

    bb31: {
        return;
    }
}

const log10::IVLN10HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.43429448187816888f64;
        return;
    }
}

const log10::IVLN10LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.5082946711645275E-11f64;
        return;
    }
}

const log10::LOG10_2HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.30102999566361177f64;
        return;
    }
}

const log10::LOG10_2LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.6942390771589308E-13f64;
        return;
    }
}

const log10::LG1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.66666666666667351f64;
        return;
    }
}

const log10::LG2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.39999999999409419f64;
        return;
    }
}

const log10::LG3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.28571428743662391f64;
        return;
    }
}

const log10::LG4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.22222198432149784f64;
        return;
    }
}

const log10::LG5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.1818357216161805f64;
        return;
    }
}

const log10::LG6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.15313837699209373f64;
        return;
    }
}

const log10::LG7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14798198605116586f64;
        return;
    }
}

fn log10(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: f64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: u64;
    let mut _33: u64;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: bool;
    let mut _40: u32;
    let mut _41: u32;
    let mut _42: u32;
    let mut _43: bool;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: (i32, bool);
    let mut _48: u64;
    let mut _49: f64;
    let mut _50: u64;
    let mut _51: u64;
    let mut _52: u32;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: u32;
    let mut _56: u32;
    let mut _57: u64;
    let mut _58: u64;
    let mut _59: u32;
    let mut _60: bool;
    let mut _61: u32;
    let mut _62: (u32, bool);
    let mut _63: (u32, bool);
    let mut _64: i32;
    let mut _65: i32;
    let mut _66: u32;
    let mut _67: u32;
    let mut _68: u32;
    let mut _69: bool;
    let mut _70: (i32, bool);
    let mut _71: (i32, bool);
    let mut _72: u32;
    let mut _73: u32;
    let mut _74: (u32, bool);
    let mut _75: u64;
    let mut _76: u64;
    let mut _77: u32;
    let mut _78: u32;
    let mut _79: bool;
    let mut _80: u64;
    let mut _81: u64;
    let mut _82: f64;
    let mut _83: u64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: f64;
    let mut _102: f64;
    let mut _103: u64;
    let mut _104: f64;
    let mut _105: u64;
    let mut _106: u64;
    let mut _107: u32;
    let mut _108: bool;
    let mut _109: f64;
    let mut _110: u64;
    let mut _111: f64;
    let mut _112: f64;
    let mut _113: f64;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: f64;
    let mut _117: i32;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: f64;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: f64;
    let mut _124: f64;
    let mut _125: f64;
    let mut _126: f64;
    let mut _127: f64;
    let mut _128: f64;
    let mut _129: f64;
    let mut _130: f64;
    let mut _131: f64;
    scope 1 {
        debug x1p54 => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let _5: f64;
            scope 3 {
                debug hfsq => _5;
                let _6: f64;
                scope 4 {
                    debug f => _6;
                    let _7: f64;
                    scope 5 {
                        debug s => _7;
                        let _8: f64;
                        scope 6 {
                            debug z => _8;
                            let _9: f64;
                            scope 7 {
                                debug r => _9;
                                let mut _10: f64;
                                scope 8 {
                                    debug w => _10;
                                    let _11: f64;
                                    scope 9 {
                                        debug t1 => _11;
                                        let _12: f64;
                                        scope 10 {
                                            debug t2 => _12;
                                            let _13: f64;
                                            scope 11 {
                                                debug dk => _13;
                                                let _14: f64;
                                                scope 12 {
                                                    debug y => _14;
                                                    let mut _15: f64;
                                                    scope 13 {
                                                        debug hi => _15;
                                                        let _16: f64;
                                                        scope 14 {
                                                            debug lo => _16;
                                                            let mut _17: f64;
                                                            scope 15 {
                                                                debug val_hi => _17;
                                                                let mut _18: f64;
                                                                scope 16 {
                                                                    debug val_lo => _18;
                                                                    let mut _19: u32;
                                                                    scope 17 {
                                                                        debug hx => _19;
                                                                        let mut _20: i32;
                                                                        scope 18 {
                                                                            debug k => _20;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4850376798678024192_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _22 = _3;
        _23 = const 32_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 64_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _21 = Shr(move _22, const 32_i32);
        _19 = move _21 as u32 (IntToInt);
        _20 = const 0_i32;
        _26 = _19;
        _25 = Lt(move _26, const 1048576_u32);
        switchInt(move _25) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _29 = _19;
        _30 = const 31_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 32_u32);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _28 = Shr(move _29, const 31_i32);
        _27 = Gt(move _28, const 0_u32);
        switchInt(move _27) -> [0: bb16, otherwise: bb6];
    }

    bb6: {
        _33 = _3;
        _34 = const 1_i32 as u32 (IntToInt);
        _35 = Lt(move _34, const 64_u32);
        assert(move _35, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _32 = Shl(move _33, const 1_i32);
        switchInt(move _32) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _37 = _1;
        _38 = _1;
        _36 = Mul(move _37, move _38);
        _0 = Div(const -1f64, move _36);
        goto -> bb34;
    }

    bb9: {
        _41 = _19;
        _42 = const 31_i32 as u32 (IntToInt);
        _43 = Lt(move _42, const 32_u32);
        assert(move _43, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _40 = Shr(move _41, const 31_i32);
        _39 = Gt(move _40, const 0_u32);
        switchInt(move _39) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _45 = _1;
        _46 = _1;
        _44 = Sub(move _45, move _46);
        _0 = Div(move _44, const 0f64);
        goto -> bb34;
    }

    bb12: {
        _47 = CheckedSub(_20, const 54_i32);
        assert(!move (_47.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, const 54_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _20 = move (_47.0: i32);
        _1 = Mul(_1, _2);
        _49 = _1;
        _48 = f64::<impl f64>::to_bits(move _49) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _3 = move _48;
        _51 = _3;
        _52 = const 32_i32 as u32 (IntToInt);
        _53 = Lt(move _52, const 64_u32);
        assert(move _53, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _50 = Shr(move _51, const 32_i32);
        _19 = move _50 as u32 (IntToInt);
        goto -> bb22;
    }

    bb16: {
        _55 = _19;
        _54 = Ge(move _55, const 2146435072_u32);
        switchInt(move _54) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = _1;
        goto -> bb34;
    }

    bb18: {
        _56 = _19;
        switchInt(move _56) -> [1072693248: bb19, otherwise: bb22];
    }

    bb19: {
        _58 = _3;
        _59 = const 32_i32 as u32 (IntToInt);
        _60 = Lt(move _59, const 64_u32);
        assert(move _60, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _57 = Shl(move _58, const 32_i32);
        switchInt(move _57) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _0 = const 0f64;
        goto -> bb34;
    }

    bb22: {
        _62 = CheckedSub(const 1072693248_u32, const 1072079006_u32);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u32, const 1072079006_u32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _61 = move (_62.0: u32);
        _63 = CheckedAdd(_19, _61);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, move _61) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _19 = move (_63.0: u32);
        _67 = _19;
        _68 = const 20_i32 as u32 (IntToInt);
        _69 = Lt(move _68, const 32_u32);
        assert(move _69, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _66 = Shr(move _67, const 20_i32);
        _65 = move _66 as i32 (IntToInt);
        _70 = CheckedSub(_65, const 1023_i32);
        assert(!move (_70.1: bool), "attempt to compute `{} - {}`, which would overflow", move _65, const 1023_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _64 = move (_70.0: i32);
        _71 = CheckedAdd(_20, _64);
        assert(!move (_71.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, move _64) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _20 = move (_71.0: i32);
        _73 = _19;
        _72 = BitAnd(move _73, const 1048575_u32);
        _74 = CheckedAdd(_72, const 1072079006_u32);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", move _72, const 1072079006_u32) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _19 = move (_74.0: u32);
        _77 = _19;
        _76 = move _77 as u64 (IntToInt);
        _78 = const 32_i32 as u32 (IntToInt);
        _79 = Lt(move _78, const 64_u32);
        assert(move _79, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _75 = Shl(move _76, const 32_i32);
        _81 = _3;
        _80 = BitAnd(move _81, const 4294967295_u64);
        _3 = BitOr(move _75, move _80);
        _83 = _3;
        _82 = f64::<impl f64>::from_bits(move _83) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _1 = move _82;
        _84 = _1;
        _6 = Sub(move _84, const 1f64);
        _85 = Mul(const 0.5f64, _6);
        _5 = Mul(move _85, _6);
        _86 = Add(const 2f64, _6);
        _7 = Div(_6, move _86);
        _8 = Mul(_7, _7);
        _10 = Mul(_8, _8);
        _87 = _10;
        _90 = _10;
        _93 = _10;
        _92 = Mul(move _93, const _);
        _91 = Add(const _, move _92);
        _89 = Mul(move _90, move _91);
        _88 = Add(const _, move _89);
        _11 = Mul(move _87, move _88);
        _96 = _10;
        _99 = _10;
        _102 = _10;
        _101 = Mul(move _102, const _);
        _100 = Add(const _, move _101);
        _98 = Mul(move _99, move _100);
        _97 = Add(const _, move _98);
        _95 = Mul(move _96, move _97);
        _94 = Add(const _, move _95);
        _12 = Mul(_8, move _94);
        _9 = Add(_12, _11);
        _15 = Sub(_6, _5);
        _104 = _15;
        _103 = f64::<impl f64>::to_bits(move _104) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _3 = move _103;
        _106 = const -1_i64 as u64 (IntToInt);
        _107 = const 32_i32 as u32 (IntToInt);
        _108 = Lt(move _107, const 64_u32);
        assert(move _108, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _105 = Shl(move _106, const 32_i32);
        _3 = BitAnd(_3, move _105);
        _110 = _3;
        _109 = f64::<impl f64>::from_bits(move _110) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _15 = move _109;
        _113 = _15;
        _112 = Sub(_6, move _113);
        _111 = Sub(move _112, _5);
        _115 = Add(_5, _9);
        _114 = Mul(_7, move _115);
        _16 = Add(move _111, move _114);
        _116 = _15;
        _17 = Mul(move _116, const _);
        _117 = _20;
        _13 = move _117 as f64 (IntToFloat);
        _14 = Mul(_13, const _);
        _119 = Mul(_13, const _);
        _122 = _15;
        _121 = Add(_16, move _122);
        _120 = Mul(move _121, const _);
        _118 = Add(move _119, move _120);
        _123 = Mul(_16, const _);
        _18 = Add(move _118, move _123);
        _124 = _17;
        _10 = Add(_14, move _124);
        _127 = _10;
        _126 = Sub(_14, move _127);
        _128 = _17;
        _125 = Add(move _126, move _128);
        _18 = Add(_18, move _125);
        _129 = _10;
        _17 = move _129;
        _130 = _18;
        _131 = _17;
        _0 = Add(move _130, move _131);
        goto -> bb34;
    }

    bb34: {
        return;
    }
}

const log10f::IVLN10HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.434326172f32;
        return;
    }
}

const log10f::IVLN10LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -3.16899714E-5f32;
        return;
    }
}

const log10f::LOG10_2HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.301029205f32;
        return;
    }
}

const log10f::LOG10_2LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.90341517E-7f32;
        return;
    }
}

const log10f::LG1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.666666627f32;
        return;
    }
}

const log10f::LG2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.400009722f32;
        return;
    }
}

const log10f::LG3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.284987867f32;
        return;
    }
}

const log10f::LG4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.242790788f32;
        return;
    }
}

fn log10f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: f32;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: bool;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: bool;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: (i32, bool);
    let mut _42: u32;
    let mut _43: f32;
    let mut _44: u32;
    let mut _45: bool;
    let mut _46: u32;
    let mut _47: u32;
    let mut _48: u32;
    let mut _49: (u32, bool);
    let mut _50: (u32, bool);
    let mut _51: i32;
    let mut _52: i32;
    let mut _53: u32;
    let mut _54: u32;
    let mut _55: u32;
    let mut _56: bool;
    let mut _57: (i32, bool);
    let mut _58: (i32, bool);
    let mut _59: u32;
    let mut _60: u32;
    let mut _61: (u32, bool);
    let mut _62: u32;
    let mut _63: f32;
    let mut _64: u32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f32;
    let mut _72: u32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: u32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: i32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: f32;
    let mut _91: f32;
    let mut _92: f32;
    scope 1 {
        debug x1p25f => _2;
        let mut _3: u32;
        scope 2 {
            debug ui => _3;
            let _5: f32;
            scope 3 {
                debug hfsq => _5;
                let _6: f32;
                scope 4 {
                    debug f => _6;
                    let _7: f32;
                    scope 5 {
                        debug s => _7;
                        let _8: f32;
                        scope 6 {
                            debug z => _8;
                            let _9: f32;
                            scope 7 {
                                debug r => _9;
                                let _10: f32;
                                scope 8 {
                                    debug w => _10;
                                    let _11: f32;
                                    scope 9 {
                                        debug t1 => _11;
                                        let _12: f32;
                                        scope 10 {
                                            debug t2 => _12;
                                            let _13: f32;
                                            scope 11 {
                                                debug dk => _13;
                                                let mut _14: f32;
                                                scope 12 {
                                                    debug hi => _14;
                                                    let _15: f32;
                                                    scope 13 {
                                                        debug lo => _15;
                                                        let mut _16: u32;
                                                        scope 14 {
                                                            debug ix => _16;
                                                            let mut _17: i32;
                                                            scope 15 {
                                                                debug k => _17;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 1275068416_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _18 = _3;
        _16 = move _18;
        _17 = const 0_i32;
        _20 = _16;
        _19 = Lt(move _20, const 8388608_u32);
        switchInt(move _19) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _23 = _16;
        _24 = const 31_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 32_u32);
        assert(move _25, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _22 = Shr(move _23, const 31_i32);
        _21 = Gt(move _22, const 0_u32);
        switchInt(move _21) -> [0: bb14, otherwise: bb5];
    }

    bb5: {
        _27 = _16;
        _28 = const 1_i32 as u32 (IntToInt);
        _29 = Lt(move _28, const 32_u32);
        assert(move _29, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _26 = Shl(move _27, const 1_i32);
        switchInt(move _26) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _31 = _1;
        _32 = _1;
        _30 = Mul(move _31, move _32);
        _0 = Div(const -1f32, move _30);
        goto -> bb28;
    }

    bb8: {
        _35 = _16;
        _36 = const 31_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 32_u32);
        assert(move _37, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _34 = Shr(move _35, const 31_i32);
        _33 = Gt(move _34, const 0_u32);
        switchInt(move _33) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _39 = _1;
        _40 = _1;
        _38 = Sub(move _39, move _40);
        _0 = Div(move _38, const 0f32);
        goto -> bb28;
    }

    bb11: {
        _41 = CheckedSub(_17, const 25_i32);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", _17, const 25_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _17 = move (_41.0: i32);
        _1 = Mul(_1, _2);
        _43 = _1;
        _42 = f32::<impl f32>::to_bits(move _43) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _3 = move _42;
        _44 = _3;
        _16 = move _44;
        goto -> bb18;
    }

    bb14: {
        _46 = _16;
        _45 = Ge(move _46, const 2139095040_u32);
        switchInt(move _45) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _0 = _1;
        goto -> bb28;
    }

    bb16: {
        _47 = _16;
        switchInt(move _47) -> [1065353216: bb17, otherwise: bb18];
    }

    bb17: {
        _0 = const 0f32;
        goto -> bb28;
    }

    bb18: {
        _49 = CheckedSub(const 1065353216_u32, const 1060439283_u32);
        assert(!move (_49.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, const 1060439283_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _48 = move (_49.0: u32);
        _50 = CheckedAdd(_16, _48);
        assert(!move (_50.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, move _48) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _16 = move (_50.0: u32);
        _54 = _16;
        _55 = const 23_i32 as u32 (IntToInt);
        _56 = Lt(move _55, const 32_u32);
        assert(move _56, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _53 = Shr(move _54, const 23_i32);
        _52 = move _53 as i32 (IntToInt);
        _57 = CheckedSub(_52, const 127_i32);
        assert(!move (_57.1: bool), "attempt to compute `{} - {}`, which would overflow", move _52, const 127_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _51 = move (_57.0: i32);
        _58 = CheckedAdd(_17, _51);
        assert(!move (_58.1: bool), "attempt to compute `{} + {}`, which would overflow", _17, move _51) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _17 = move (_58.0: i32);
        _60 = _16;
        _59 = BitAnd(move _60, const 8388607_u32);
        _61 = CheckedAdd(_59, const 1060439283_u32);
        assert(!move (_61.1: bool), "attempt to compute `{} + {}`, which would overflow", move _59, const 1060439283_u32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _16 = move (_61.0: u32);
        _62 = _16;
        _3 = move _62;
        _64 = _3;
        _63 = f32::<impl f32>::from_bits(move _64) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _1 = move _63;
        _65 = _1;
        _6 = Sub(move _65, const 1f32);
        _66 = Add(const 2f32, _6);
        _7 = Div(_6, move _66);
        _8 = Mul(_7, _7);
        _10 = Mul(_8, _8);
        _68 = Mul(_10, const _);
        _67 = Add(const _, move _68);
        _11 = Mul(_10, move _67);
        _70 = Mul(_10, const _);
        _69 = Add(const _, move _70);
        _12 = Mul(_8, move _69);
        _9 = Add(_12, _11);
        _71 = Mul(const 0.5f32, _6);
        _5 = Mul(move _71, _6);
        _14 = Sub(_6, _5);
        _73 = _14;
        _72 = f32::<impl f32>::to_bits(move _73) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _3 = move _72;
        _3 = BitAnd(_3, const 4294963200_u32);
        _75 = _3;
        _74 = f32::<impl f32>::from_bits(move _75) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _14 = move _74;
        _78 = _14;
        _77 = Sub(_6, move _78);
        _76 = Sub(move _77, _5);
        _80 = Add(_5, _9);
        _79 = Mul(_7, move _80);
        _15 = Add(move _76, move _79);
        _81 = _17;
        _13 = move _81 as f32 (IntToFloat);
        _85 = Mul(_13, const _);
        _88 = _14;
        _87 = Add(_15, move _88);
        _86 = Mul(move _87, const _);
        _84 = Add(move _85, move _86);
        _89 = Mul(_15, const _);
        _83 = Add(move _84, move _89);
        _91 = _14;
        _90 = Mul(move _91, const _);
        _82 = Add(move _83, move _90);
        _92 = Mul(_13, const _);
        _0 = Add(move _82, move _92);
        goto -> bb28;
    }

    bb28: {
        return;
    }
}

const log1p::LN2_HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718036912382f64;
        return;
    }
}

const log1p::LN2_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9082149292705877E-10f64;
        return;
    }
}

const log1p::LG1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.66666666666667351f64;
        return;
    }
}

const log1p::LG2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.39999999999409419f64;
        return;
    }
}

const log1p::LG3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.28571428743662391f64;
        return;
    }
}

const log1p::LG4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.22222198432149784f64;
        return;
    }
}

const log1p::LG5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.1818357216161805f64;
        return;
    }
}

const log1p::LG6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.15313837699209373f64;
        return;
    }
}

const log1p::LG7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14798198605116586f64;
        return;
    }
}

fn log1p(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: f64;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: u32;
    let mut _31: bool;
    let mut _32: u32;
    let mut _33: u32;
    let mut _34: bool;
    let mut _35: u32;
    let _36: f32;
    let mut _37: *const f32;
    let _38: &f32;
    let _39: f32;
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: i32;
    let mut _44: u64;
    let mut _45: f64;
    let mut _46: u64;
    let mut _47: u64;
    let mut _48: u32;
    let mut _49: bool;
    let mut _50: u32;
    let mut _51: (u32, bool);
    let mut _52: (u32, bool);
    let mut _53: i32;
    let mut _54: u32;
    let mut _55: u32;
    let mut _56: u32;
    let mut _57: bool;
    let mut _58: (i32, bool);
    let mut _59: bool;
    let mut _60: i32;
    let mut _61: f64;
    let mut _62: bool;
    let mut _63: i32;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: u64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: u64;
    let mut _70: f64;
    let mut _71: u64;
    let mut _72: u32;
    let mut _73: u32;
    let mut _74: (u32, bool);
    let mut _75: u64;
    let mut _76: u64;
    let mut _77: u32;
    let mut _78: u32;
    let mut _79: bool;
    let mut _80: u64;
    let mut _81: u64;
    let mut _82: f64;
    let mut _83: u64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: i32;
    let mut _101: f64;
    let mut _102: f64;
    let mut _103: f64;
    let mut _104: f64;
    let mut _105: f64;
    let mut _106: f64;
    let mut _107: f64;
    let mut _108: f64;
    let mut _109: f64;
    let mut _110: f64;
    scope 1 {
        debug ui => _2;
        let _3: f64;
        scope 2 {
            debug hfsq => _3;
            let mut _4: f64;
            scope 3 {
                debug f => _4;
                let mut _5: f64;
                scope 4 {
                    debug c => _5;
                    let _6: f64;
                    scope 5 {
                        debug s => _6;
                        let _7: f64;
                        scope 6 {
                            debug z => _7;
                            let _8: f64;
                            scope 7 {
                                debug r => _8;
                                let _9: f64;
                                scope 8 {
                                    debug w => _9;
                                    let _10: f64;
                                    scope 9 {
                                        debug t1 => _10;
                                        let _11: f64;
                                        scope 10 {
                                            debug t2 => _11;
                                            let _12: f64;
                                            scope 11 {
                                                debug dk => _12;
                                                let _13: u32;
                                                scope 12 {
                                                    debug hx => _13;
                                                    let mut _14: u32;
                                                    scope 13 {
                                                        debug hu => _14;
                                                        let mut _15: i32;
                                                        scope 14 {
                                                            debug k => _15;
                                                            scope 15 {
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 0f64;
        _5 = const 0f64;
        _17 = _2;
        _18 = const 32_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _16 = Shr(move _17, const 32_i32);
        _13 = move _16 as u32 (IntToInt);
        _15 = const 1_i32;
        _20 = Lt(_13, const 1071284858_u32);
        switchInt(move _20) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _23 = const 31_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 32_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _22 = Shr(_13, const 31_i32);
        _21 = Gt(move _22, const 0_u32);
        switchInt(move _21) -> [0: bb17, otherwise: bb5];
    }

    bb5: {
        _25 = Ge(_13, const 3220176896_u32);
        switchInt(move _25) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _26 = Eq(_1, const -1f64);
        switchInt(move _26) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Div(_1, const 0f64);
        goto -> bb40;
    }

    bb8: {
        _27 = Sub(_1, _1);
        _0 = Div(move _27, const 0f64);
        goto -> bb40;
    }

    bb9: {
        _30 = const 1_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 32_u32);
        assert(move _31, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _29 = Shl(_13, const 1_i32);
        _33 = const 1_i32 as u32 (IntToInt);
        _34 = Lt(move _33, const 32_u32);
        assert(move _34, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _32 = Shl(const 1017118720_u32, const 1_i32);
        _28 = Lt(move _29, move _32);
        switchInt(move _28) -> [0: bb15, otherwise: bb12];
    }

    bb12: {
        _35 = BitAnd(_13, const 2146435072_u32);
        switchInt(move _35) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _39 = _1 as f32 (FloatToFloat);
        _38 = &_39;
        _37 = &raw const (*_38);
        _36 = read_volatile::<f32>(move _37) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _0 = _1;
        goto -> bb40;
    }

    bb15: {
        _40 = Le(_13, const 3218259652_u32);
        switchInt(move _40) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _15 = const 0_i32;
        _5 = const 0f64;
        _4 = _1;
        goto -> bb19;
    }

    bb17: {
        _41 = Ge(_13, const 2146435072_u32);
        switchInt(move _41) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _0 = _1;
        goto -> bb40;
    }

    bb19: {
        _43 = _15;
        _42 = Gt(move _43, const 0_i32);
        switchInt(move _42) -> [0: bb39, otherwise: bb20];
    }

    bb20: {
        _45 = Add(const 1f64, _1);
        _44 = f64::<impl f64>::to_bits(move _45) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _2 = move _44;
        _47 = _2;
        _48 = const 32_i32 as u32 (IntToInt);
        _49 = Lt(move _48, const 64_u32);
        assert(move _49, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _46 = Shr(move _47, const 32_i32);
        _14 = move _46 as u32 (IntToInt);
        _51 = CheckedSub(const 1072693248_u32, const 1072079006_u32);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u32, const 1072079006_u32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _50 = move (_51.0: u32);
        _52 = CheckedAdd(_14, _50);
        assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", _14, move _50) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _14 = move (_52.0: u32);
        _55 = _14;
        _56 = const 20_i32 as u32 (IntToInt);
        _57 = Lt(move _56, const 32_u32);
        assert(move _57, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _54 = Shr(move _55, const 20_i32);
        _53 = move _54 as i32 (IntToInt);
        _58 = CheckedSub(_53, const 1023_i32);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _53, const 1023_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _15 = move (_58.0: i32);
        _60 = _15;
        _59 = Lt(move _60, const 54_i32);
        switchInt(move _59) -> [0: bb34, otherwise: bb27];
    }

    bb27: {
        _63 = _15;
        _62 = Ge(move _63, const 2_i32);
        switchInt(move _62) -> [0: bb30, otherwise: bb28];
    }

    bb28: {
        _66 = _2;
        _65 = f64::<impl f64>::from_bits(move _66) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _64 = Sub(move _65, _1);
        _61 = Sub(const 1f64, move _64);
        goto -> bb32;
    }

    bb30: {
        _69 = _2;
        _68 = f64::<impl f64>::from_bits(move _69) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _67 = Sub(move _68, const 1f64);
        _61 = Sub(_1, move _67);
        goto -> bb32;
    }

    bb32: {
        _5 = move _61;
        _71 = _2;
        _70 = f64::<impl f64>::from_bits(move _71) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _5 = Div(_5, move _70);
        goto -> bb35;
    }

    bb34: {
        _5 = const 0f64;
        goto -> bb35;
    }

    bb35: {
        _73 = _14;
        _72 = BitAnd(move _73, const 1048575_u32);
        _74 = CheckedAdd(_72, const 1072079006_u32);
        assert(!move (_74.1: bool), "attempt to compute `{} + {}`, which would overflow", move _72, const 1072079006_u32) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _14 = move (_74.0: u32);
        _77 = _14;
        _76 = move _77 as u64 (IntToInt);
        _78 = const 32_i32 as u32 (IntToInt);
        _79 = Lt(move _78, const 64_u32);
        assert(move _79, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _75 = Shl(move _76, const 32_i32);
        _81 = _2;
        _80 = BitAnd(move _81, const 4294967295_u64);
        _2 = BitOr(move _75, move _80);
        _83 = _2;
        _82 = f64::<impl f64>::from_bits(move _83) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _4 = Sub(move _82, const 1f64);
        goto -> bb39;
    }

    bb39: {
        _85 = _4;
        _84 = Mul(const 0.5f64, move _85);
        _86 = _4;
        _3 = Mul(move _84, move _86);
        _87 = _4;
        _89 = _4;
        _88 = Add(const 2f64, move _89);
        _6 = Div(move _87, move _88);
        _7 = Mul(_6, _6);
        _9 = Mul(_7, _7);
        _93 = Mul(_9, const _);
        _92 = Add(const _, move _93);
        _91 = Mul(_9, move _92);
        _90 = Add(const _, move _91);
        _10 = Mul(_9, move _90);
        _99 = Mul(_9, const _);
        _98 = Add(const _, move _99);
        _97 = Mul(_9, move _98);
        _96 = Add(const _, move _97);
        _95 = Mul(_9, move _96);
        _94 = Add(const _, move _95);
        _11 = Mul(_7, move _94);
        _8 = Add(_11, _10);
        _100 = _15;
        _12 = move _100 as f64 (IntToFloat);
        _105 = Add(_3, _8);
        _104 = Mul(_6, move _105);
        _107 = Mul(_12, const _);
        _108 = _5;
        _106 = Add(move _107, move _108);
        _103 = Add(move _104, move _106);
        _102 = Sub(move _103, _3);
        _109 = _4;
        _101 = Add(move _102, move _109);
        _110 = Mul(_12, const _);
        _0 = Add(move _101, move _110);
        goto -> bb40;
    }

    bb40: {
        return;
    }
}

const log1pf::LN2_HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693138123f32;
        return;
    }
}

const log1pf::LN2_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 9.05800061E-6f32;
        return;
    }
}

const log1pf::LG1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.666666627f32;
        return;
    }
}

const log1pf::LG2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.400009722f32;
        return;
    }
}

const log1pf::LG3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.284987867f32;
        return;
    }
}

const log1pf::LG4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.242790788f32;
        return;
    }
}

fn log1pf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: u32;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: f32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: u32;
    let _32: f32;
    let mut _33: *const f32;
    let _34: &f32;
    let _35: f32;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: i32;
    let mut _40: u32;
    let mut _41: f32;
    let mut _42: u32;
    let mut _43: u32;
    let mut _44: (u32, bool);
    let mut _45: (u32, bool);
    let mut _46: i32;
    let mut _47: u32;
    let mut _48: u32;
    let mut _49: u32;
    let mut _50: bool;
    let mut _51: (i32, bool);
    let mut _52: bool;
    let mut _53: i32;
    let mut _54: f32;
    let mut _55: bool;
    let mut _56: i32;
    let mut _57: f32;
    let mut _58: f32;
    let mut _59: u32;
    let mut _60: f32;
    let mut _61: f32;
    let mut _62: u32;
    let mut _63: f32;
    let mut _64: u32;
    let mut _65: u32;
    let mut _66: u32;
    let mut _67: (u32, bool);
    let mut _68: u32;
    let mut _69: f32;
    let mut _70: u32;
    let mut _71: f32;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: f32;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: i32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: f32;
    let mut _91: f32;
    scope 1 {
        debug ui => _2;
        let _3: f32;
        scope 2 {
            debug hfsq => _3;
            let mut _4: f32;
            scope 3 {
                debug f => _4;
                let mut _5: f32;
                scope 4 {
                    debug c => _5;
                    let _6: f32;
                    scope 5 {
                        debug s => _6;
                        let _7: f32;
                        scope 6 {
                            debug z => _7;
                            let _8: f32;
                            scope 7 {
                                debug r => _8;
                                let _9: f32;
                                scope 8 {
                                    debug w => _9;
                                    let _10: f32;
                                    scope 9 {
                                        debug t1 => _10;
                                        let _11: f32;
                                        scope 10 {
                                            debug t2 => _11;
                                            let _12: f32;
                                            scope 11 {
                                                debug dk => _12;
                                                scope 12 {
                                                    debug ix => _15;
                                                    let mut _13: u32;
                                                    scope 13 {
                                                        debug iu => _13;
                                                        let mut _14: i32;
                                                        scope 14 {
                                                            debug k => _14;
                                                            scope 15 {
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 0f32;
        _5 = const 0f32;
        _15 = _2;
        _14 = const 1_i32;
        _16 = Lt(_15, const 1054086096_u32);
        switchInt(move _16) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _19 = const 31_i32 as u32 (IntToInt);
        _20 = Lt(move _19, const 32_u32);
        assert(move _20, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _18 = Shr(_15, const 31_i32);
        _17 = Gt(move _18, const 0_u32);
        switchInt(move _17) -> [0: bb16, otherwise: bb4];
    }

    bb4: {
        _21 = Ge(_15, const 3212836864_u32);
        switchInt(move _21) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _22 = Eq(_1, const -1f32);
        switchInt(move _22) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Div(_1, const 0f32);
        goto -> bb37;
    }

    bb7: {
        _23 = Sub(_1, _1);
        _0 = Div(move _23, const 0f32);
        goto -> bb37;
    }

    bb8: {
        _26 = const 1_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _25 = Shl(_15, const 1_i32);
        _29 = const 1_i32 as u32 (IntToInt);
        _30 = Lt(move _29, const 32_u32);
        assert(move _30, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _28 = Shl(const 864026624_u32, const 1_i32);
        _24 = Lt(move _25, move _28);
        switchInt(move _24) -> [0: bb14, otherwise: bb11];
    }

    bb11: {
        _31 = BitAnd(_15, const 2139095040_u32);
        switchInt(move _31) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        _35 = Mul(_1, _1);
        _34 = &_35;
        _33 = &raw const (*_34);
        _32 = read_volatile::<f32>(move _33) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _0 = _1;
        goto -> bb37;
    }

    bb14: {
        _36 = Le(_15, const 3197498905_u32);
        switchInt(move _36) -> [0: bb18, otherwise: bb15];
    }

    bb15: {
        _14 = const 0_i32;
        _5 = const 0f32;
        _4 = _1;
        goto -> bb18;
    }

    bb16: {
        _37 = Ge(_15, const 2139095040_u32);
        switchInt(move _37) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = _1;
        goto -> bb37;
    }

    bb18: {
        _39 = _14;
        _38 = Gt(move _39, const 0_i32);
        switchInt(move _38) -> [0: bb36, otherwise: bb19];
    }

    bb19: {
        _41 = Add(const 1f32, _1);
        _40 = f32::<impl f32>::to_bits(move _41) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move _40;
        _42 = _2;
        _13 = move _42;
        _44 = CheckedSub(const 1065353216_u32, const 1060439283_u32);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, const 1060439283_u32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _43 = move (_44.0: u32);
        _45 = CheckedAdd(_13, _43);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _13, move _43) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _13 = move (_45.0: u32);
        _48 = _13;
        _49 = const 23_i32 as u32 (IntToInt);
        _50 = Lt(move _49, const 32_u32);
        assert(move _50, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _47 = Shr(move _48, const 23_i32);
        _46 = move _47 as i32 (IntToInt);
        _51 = CheckedSub(_46, const 127_i32);
        assert(!move (_51.1: bool), "attempt to compute `{} - {}`, which would overflow", move _46, const 127_i32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _14 = move (_51.0: i32);
        _53 = _14;
        _52 = Lt(move _53, const 25_i32);
        switchInt(move _52) -> [0: bb32, otherwise: bb25];
    }

    bb25: {
        _56 = _14;
        _55 = Ge(move _56, const 2_i32);
        switchInt(move _55) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _59 = _2;
        _58 = f32::<impl f32>::from_bits(move _59) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _57 = Sub(move _58, _1);
        _54 = Sub(const 1f32, move _57);
        goto -> bb30;
    }

    bb28: {
        _62 = _2;
        _61 = f32::<impl f32>::from_bits(move _62) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _60 = Sub(move _61, const 1f32);
        _54 = Sub(_1, move _60);
        goto -> bb30;
    }

    bb30: {
        _5 = move _54;
        _64 = _2;
        _63 = f32::<impl f32>::from_bits(move _64) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _5 = Div(_5, move _63);
        goto -> bb33;
    }

    bb32: {
        _5 = const 0f32;
        goto -> bb33;
    }

    bb33: {
        _66 = _13;
        _65 = BitAnd(move _66, const 8388607_u32);
        _67 = CheckedAdd(_65, const 1060439283_u32);
        assert(!move (_67.1: bool), "attempt to compute `{} + {}`, which would overflow", move _65, const 1060439283_u32) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _13 = move (_67.0: u32);
        _68 = _13;
        _2 = move _68;
        _70 = _2;
        _69 = f32::<impl f32>::from_bits(move _70) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _4 = Sub(move _69, const 1f32);
        goto -> bb36;
    }

    bb36: {
        _71 = _4;
        _73 = _4;
        _72 = Add(const 2f32, move _73);
        _6 = Div(move _71, move _72);
        _7 = Mul(_6, _6);
        _9 = Mul(_7, _7);
        _75 = Mul(_9, const _);
        _74 = Add(const _, move _75);
        _10 = Mul(_9, move _74);
        _77 = Mul(_9, const _);
        _76 = Add(const _, move _77);
        _11 = Mul(_7, move _76);
        _8 = Add(_11, _10);
        _79 = _4;
        _78 = Mul(const 0.5f32, move _79);
        _80 = _4;
        _3 = Mul(move _78, move _80);
        _81 = _14;
        _12 = move _81 as f32 (IntToFloat);
        _86 = Add(_3, _8);
        _85 = Mul(_6, move _86);
        _88 = Mul(_12, const _);
        _89 = _5;
        _87 = Add(move _88, move _89);
        _84 = Add(move _85, move _87);
        _83 = Sub(move _84, _3);
        _90 = _4;
        _82 = Add(move _83, move _90);
        _91 = Mul(_12, const _);
        _0 = Add(move _82, move _91);
        goto -> bb37;
    }

    bb37: {
        return;
    }
}

const log2::IVLN2HI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4426950407214463f64;
        return;
    }
}

const log2::IVLN2LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.6751713164886512E-10f64;
        return;
    }
}

const log2::LG1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.66666666666667351f64;
        return;
    }
}

const log2::LG2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.39999999999409419f64;
        return;
    }
}

const log2::LG3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.28571428743662391f64;
        return;
    }
}

const log2::LG4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.22222198432149784f64;
        return;
    }
}

const log2::LG5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.1818357216161805f64;
        return;
    }
}

const log2::LG6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.15313837699209373f64;
        return;
    }
}

const log2::LG7: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.14798198605116586f64;
        return;
    }
}

fn log2(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: f64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: bool;
    let mut _30: u64;
    let mut _31: u64;
    let mut _32: u32;
    let mut _33: bool;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: bool;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: (i32, bool);
    let mut _46: u64;
    let mut _47: f64;
    let mut _48: u64;
    let mut _49: u64;
    let mut _50: u32;
    let mut _51: bool;
    let mut _52: bool;
    let mut _53: u32;
    let mut _54: u32;
    let mut _55: u64;
    let mut _56: u64;
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: u32;
    let mut _60: (u32, bool);
    let mut _61: (u32, bool);
    let mut _62: i32;
    let mut _63: i32;
    let mut _64: u32;
    let mut _65: u32;
    let mut _66: u32;
    let mut _67: bool;
    let mut _68: (i32, bool);
    let mut _69: (i32, bool);
    let mut _70: u32;
    let mut _71: u32;
    let mut _72: (u32, bool);
    let mut _73: u64;
    let mut _74: u64;
    let mut _75: u32;
    let mut _76: u32;
    let mut _77: bool;
    let mut _78: u64;
    let mut _79: u64;
    let mut _80: f64;
    let mut _81: u64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    let mut _92: f64;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: f64;
    let mut _97: f64;
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: u64;
    let mut _102: f64;
    let mut _103: u64;
    let mut _104: u64;
    let mut _105: u32;
    let mut _106: bool;
    let mut _107: f64;
    let mut _108: u64;
    let mut _109: f64;
    let mut _110: f64;
    let mut _111: f64;
    let mut _112: f64;
    let mut _113: f64;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: f64;
    let mut _117: f64;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: i32;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: f64;
    let mut _124: f64;
    let mut _125: f64;
    let mut _126: f64;
    let mut _127: f64;
    let mut _128: f64;
    scope 1 {
        debug x1p54 => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let _5: f64;
            scope 3 {
                debug hfsq => _5;
                let _6: f64;
                scope 4 {
                    debug f => _6;
                    let _7: f64;
                    scope 5 {
                        debug s => _7;
                        let _8: f64;
                        scope 6 {
                            debug z => _8;
                            let _9: f64;
                            scope 7 {
                                debug r => _9;
                                let mut _10: f64;
                                scope 8 {
                                    debug w => _10;
                                    let _11: f64;
                                    scope 9 {
                                        debug t1 => _11;
                                        let _12: f64;
                                        scope 10 {
                                            debug t2 => _12;
                                            scope 11 {
                                                debug y => _119;
                                                let mut _13: f64;
                                                scope 12 {
                                                    debug hi => _13;
                                                    let _14: f64;
                                                    scope 13 {
                                                        debug lo => _14;
                                                        let mut _15: f64;
                                                        scope 14 {
                                                            debug val_hi => _15;
                                                            let mut _16: f64;
                                                            scope 15 {
                                                                debug val_lo => _16;
                                                                let mut _17: u32;
                                                                scope 16 {
                                                                    debug hx => _17;
                                                                    let mut _18: i32;
                                                                    scope 17 {
                                                                        debug k => _18;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4850376798678024192_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _20 = _3;
        _21 = const 32_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _19 = Shr(move _20, const 32_i32);
        _17 = move _19 as u32 (IntToInt);
        _18 = const 0_i32;
        _24 = _17;
        _23 = Lt(move _24, const 1048576_u32);
        switchInt(move _23) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _27 = _17;
        _28 = const 31_i32 as u32 (IntToInt);
        _29 = Lt(move _28, const 32_u32);
        assert(move _29, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _26 = Shr(move _27, const 31_i32);
        _25 = Gt(move _26, const 0_u32);
        switchInt(move _25) -> [0: bb16, otherwise: bb6];
    }

    bb6: {
        _31 = _3;
        _32 = const 1_i32 as u32 (IntToInt);
        _33 = Lt(move _32, const 64_u32);
        assert(move _33, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _30 = Shl(move _31, const 1_i32);
        switchInt(move _30) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _35 = _1;
        _36 = _1;
        _34 = Mul(move _35, move _36);
        _0 = Div(const -1f64, move _34);
        goto -> bb35;
    }

    bb9: {
        _39 = _17;
        _40 = const 31_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 32_u32);
        assert(move _41, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _38 = Shr(move _39, const 31_i32);
        _37 = Gt(move _38, const 0_u32);
        switchInt(move _37) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _43 = _1;
        _44 = _1;
        _42 = Sub(move _43, move _44);
        _0 = Div(move _42, const 0f64);
        goto -> bb35;
    }

    bb12: {
        _45 = CheckedSub(_18, const 54_i32);
        assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", _18, const 54_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _18 = move (_45.0: i32);
        _1 = Mul(_1, _2);
        _47 = _1;
        _46 = f64::<impl f64>::to_bits(move _47) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _3 = move _46;
        _49 = _3;
        _50 = const 32_i32 as u32 (IntToInt);
        _51 = Lt(move _50, const 64_u32);
        assert(move _51, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _48 = Shr(move _49, const 32_i32);
        _17 = move _48 as u32 (IntToInt);
        goto -> bb22;
    }

    bb16: {
        _53 = _17;
        _52 = Ge(move _53, const 2146435072_u32);
        switchInt(move _52) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = _1;
        goto -> bb35;
    }

    bb18: {
        _54 = _17;
        switchInt(move _54) -> [1072693248: bb19, otherwise: bb22];
    }

    bb19: {
        _56 = _3;
        _57 = const 32_i32 as u32 (IntToInt);
        _58 = Lt(move _57, const 64_u32);
        assert(move _58, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _55 = Shl(move _56, const 32_i32);
        switchInt(move _55) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _0 = const 0f64;
        goto -> bb35;
    }

    bb22: {
        _60 = CheckedSub(const 1072693248_u32, const 1072079006_u32);
        assert(!move (_60.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u32, const 1072079006_u32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _59 = move (_60.0: u32);
        _61 = CheckedAdd(_17, _59);
        assert(!move (_61.1: bool), "attempt to compute `{} + {}`, which would overflow", _17, move _59) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _17 = move (_61.0: u32);
        _65 = _17;
        _66 = const 20_i32 as u32 (IntToInt);
        _67 = Lt(move _66, const 32_u32);
        assert(move _67, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _64 = Shr(move _65, const 20_i32);
        _63 = move _64 as i32 (IntToInt);
        _68 = CheckedSub(_63, const 1023_i32);
        assert(!move (_68.1: bool), "attempt to compute `{} - {}`, which would overflow", move _63, const 1023_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _62 = move (_68.0: i32);
        _69 = CheckedAdd(_18, _62);
        assert(!move (_69.1: bool), "attempt to compute `{} + {}`, which would overflow", _18, move _62) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _18 = move (_69.0: i32);
        _71 = _17;
        _70 = BitAnd(move _71, const 1048575_u32);
        _72 = CheckedAdd(_70, const 1072079006_u32);
        assert(!move (_72.1: bool), "attempt to compute `{} + {}`, which would overflow", move _70, const 1072079006_u32) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _17 = move (_72.0: u32);
        _75 = _17;
        _74 = move _75 as u64 (IntToInt);
        _76 = const 32_i32 as u32 (IntToInt);
        _77 = Lt(move _76, const 64_u32);
        assert(move _77, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _73 = Shl(move _74, const 32_i32);
        _79 = _3;
        _78 = BitAnd(move _79, const 4294967295_u64);
        _3 = BitOr(move _73, move _78);
        _81 = _3;
        _80 = f64::<impl f64>::from_bits(move _81) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _1 = move _80;
        _82 = _1;
        _6 = Sub(move _82, const 1f64);
        _83 = Mul(const 0.5f64, _6);
        _5 = Mul(move _83, _6);
        _84 = Add(const 2f64, _6);
        _7 = Div(_6, move _84);
        _8 = Mul(_7, _7);
        _10 = Mul(_8, _8);
        _85 = _10;
        _88 = _10;
        _91 = _10;
        _90 = Mul(move _91, const _);
        _89 = Add(const _, move _90);
        _87 = Mul(move _88, move _89);
        _86 = Add(const _, move _87);
        _11 = Mul(move _85, move _86);
        _94 = _10;
        _97 = _10;
        _100 = _10;
        _99 = Mul(move _100, const _);
        _98 = Add(const _, move _99);
        _96 = Mul(move _97, move _98);
        _95 = Add(const _, move _96);
        _93 = Mul(move _94, move _95);
        _92 = Add(const _, move _93);
        _12 = Mul(_8, move _92);
        _9 = Add(_12, _11);
        _13 = Sub(_6, _5);
        _102 = _13;
        _101 = f64::<impl f64>::to_bits(move _102) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _3 = move _101;
        _104 = const -1_i64 as u64 (IntToInt);
        _105 = const 32_i32 as u32 (IntToInt);
        _106 = Lt(move _105, const 64_u32);
        assert(move _106, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _103 = Shl(move _104, const 32_i32);
        _3 = BitAnd(_3, move _103);
        _108 = _3;
        _107 = f64::<impl f64>::from_bits(move _108) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _13 = move _107;
        _111 = _13;
        _110 = Sub(_6, move _111);
        _109 = Sub(move _110, _5);
        _113 = Add(_5, _9);
        _112 = Mul(_7, move _113);
        _14 = Add(move _109, move _112);
        _114 = _13;
        _15 = Mul(move _114, const _);
        _117 = _13;
        _116 = Add(_14, move _117);
        _115 = Mul(move _116, const _);
        _118 = Mul(_14, const _);
        _16 = Add(move _115, move _118);
        _120 = _18;
        _119 = <i32 as Into<f64>>::into(move _120) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _121 = _15;
        _10 = Add(_119, move _121);
        _124 = _10;
        _123 = Sub(_119, move _124);
        _125 = _15;
        _122 = Add(move _123, move _125);
        _16 = Add(_16, move _122);
        _126 = _10;
        _15 = move _126;
        _127 = _16;
        _128 = _15;
        _0 = Add(move _127, move _128);
        goto -> bb35;
    }

    bb35: {
        return;
    }
}

const log2f::IVLN2HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.44287109f32;
        return;
    }
}

const log2f::IVLN2LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1.76052854E-4f32;
        return;
    }
}

const log2f::LG1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.666666627f32;
        return;
    }
}

const log2f::LG2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.400009722f32;
        return;
    }
}

const log2f::LG3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.284987867f32;
        return;
    }
}

const log2f::LG4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.242790788f32;
        return;
    }
}

fn log2f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: f32;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: u32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: (i32, bool);
    let mut _41: u32;
    let mut _42: f32;
    let mut _43: u32;
    let mut _44: bool;
    let mut _45: u32;
    let mut _46: u32;
    let mut _47: u32;
    let mut _48: (u32, bool);
    let mut _49: (u32, bool);
    let mut _50: i32;
    let mut _51: i32;
    let mut _52: u32;
    let mut _53: u32;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: (i32, bool);
    let mut _57: (i32, bool);
    let mut _58: u32;
    let mut _59: u32;
    let mut _60: (u32, bool);
    let mut _61: u32;
    let mut _62: f32;
    let mut _63: u32;
    let mut _64: f32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: u32;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: u32;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: f32;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: i32;
    scope 1 {
        debug x1p25f => _2;
        let mut _3: u32;
        scope 2 {
            debug ui => _3;
            let _5: f32;
            scope 3 {
                debug hfsq => _5;
                let _6: f32;
                scope 4 {
                    debug f => _6;
                    let _7: f32;
                    scope 5 {
                        debug s => _7;
                        let _8: f32;
                        scope 6 {
                            debug z => _8;
                            let _9: f32;
                            scope 7 {
                                debug r => _9;
                                let _10: f32;
                                scope 8 {
                                    debug w => _10;
                                    let _11: f32;
                                    scope 9 {
                                        debug t1 => _11;
                                        let _12: f32;
                                        scope 10 {
                                            debug t2 => _12;
                                            let mut _13: f32;
                                            scope 11 {
                                                debug hi => _13;
                                                let _14: f32;
                                                scope 12 {
                                                    debug lo => _14;
                                                    let mut _15: u32;
                                                    scope 13 {
                                                        debug ix => _15;
                                                        let mut _16: i32;
                                                        scope 14 {
                                                            debug k => _16;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 1275068416_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _17 = _3;
        _15 = move _17;
        _16 = const 0_i32;
        _19 = _15;
        _18 = Lt(move _19, const 8388608_u32);
        switchInt(move _18) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _22 = _15;
        _23 = const 31_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 32_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _21 = Shr(move _22, const 31_i32);
        _20 = Gt(move _21, const 0_u32);
        switchInt(move _20) -> [0: bb14, otherwise: bb5];
    }

    bb5: {
        _26 = _15;
        _27 = const 1_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 32_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _25 = Shl(move _26, const 1_i32);
        switchInt(move _25) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _30 = _1;
        _31 = _1;
        _29 = Mul(move _30, move _31);
        _0 = Div(const -1f32, move _29);
        goto -> bb28;
    }

    bb8: {
        _34 = _15;
        _35 = const 31_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _33 = Shr(move _34, const 31_i32);
        _32 = Gt(move _33, const 0_u32);
        switchInt(move _32) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _38 = _1;
        _39 = _1;
        _37 = Sub(move _38, move _39);
        _0 = Div(move _37, const 0f32);
        goto -> bb28;
    }

    bb11: {
        _40 = CheckedSub(_16, const 25_i32);
        assert(!move (_40.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, const 25_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _16 = move (_40.0: i32);
        _1 = Mul(_1, _2);
        _42 = _1;
        _41 = f32::<impl f32>::to_bits(move _42) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _3 = move _41;
        _43 = _3;
        _15 = move _43;
        goto -> bb18;
    }

    bb14: {
        _45 = _15;
        _44 = Ge(move _45, const 2139095040_u32);
        switchInt(move _44) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _0 = _1;
        goto -> bb28;
    }

    bb16: {
        _46 = _15;
        switchInt(move _46) -> [1065353216: bb17, otherwise: bb18];
    }

    bb17: {
        _0 = const 0f32;
        goto -> bb28;
    }

    bb18: {
        _48 = CheckedSub(const 1065353216_u32, const 1060439283_u32);
        assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, const 1060439283_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _47 = move (_48.0: u32);
        _49 = CheckedAdd(_15, _47);
        assert(!move (_49.1: bool), "attempt to compute `{} + {}`, which would overflow", _15, move _47) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _15 = move (_49.0: u32);
        _53 = _15;
        _54 = const 23_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 32_u32);
        assert(move _55, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _52 = Shr(move _53, const 23_i32);
        _51 = move _52 as i32 (IntToInt);
        _56 = CheckedSub(_51, const 127_i32);
        assert(!move (_56.1: bool), "attempt to compute `{} - {}`, which would overflow", move _51, const 127_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _50 = move (_56.0: i32);
        _57 = CheckedAdd(_16, _50);
        assert(!move (_57.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, move _50) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _16 = move (_57.0: i32);
        _59 = _15;
        _58 = BitAnd(move _59, const 8388607_u32);
        _60 = CheckedAdd(_58, const 1060439283_u32);
        assert(!move (_60.1: bool), "attempt to compute `{} + {}`, which would overflow", move _58, const 1060439283_u32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _15 = move (_60.0: u32);
        _61 = _15;
        _3 = move _61;
        _63 = _3;
        _62 = f32::<impl f32>::from_bits(move _63) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _1 = move _62;
        _64 = _1;
        _6 = Sub(move _64, const 1f32);
        _65 = Add(const 2f32, _6);
        _7 = Div(_6, move _65);
        _8 = Mul(_7, _7);
        _10 = Mul(_8, _8);
        _67 = Mul(_10, const _);
        _66 = Add(const _, move _67);
        _11 = Mul(_10, move _66);
        _69 = Mul(_10, const _);
        _68 = Add(const _, move _69);
        _12 = Mul(_8, move _68);
        _9 = Add(_12, _11);
        _70 = Mul(const 0.5f32, _6);
        _5 = Mul(move _70, _6);
        _13 = Sub(_6, _5);
        _72 = _13;
        _71 = f32::<impl f32>::to_bits(move _72) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _3 = move _71;
        _3 = BitAnd(_3, const 4294963200_u32);
        _74 = _3;
        _73 = f32::<impl f32>::from_bits(move _74) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _13 = move _73;
        _77 = _13;
        _76 = Sub(_6, move _77);
        _75 = Sub(move _76, _5);
        _79 = Add(_5, _9);
        _78 = Mul(_7, move _79);
        _14 = Add(move _75, move _78);
        _84 = _13;
        _83 = Add(_14, move _84);
        _82 = Mul(move _83, const _);
        _85 = Mul(_14, const _);
        _81 = Add(move _82, move _85);
        _87 = _13;
        _86 = Mul(move _87, const _);
        _80 = Add(move _81, move _86);
        _89 = _16;
        _88 = move _89 as f32 (IntToFloat);
        _0 = Add(move _80, move _88);
        goto -> bb28;
    }

    bb28: {
        return;
    }
}

const logf::LN2_HI: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693138123f32;
        return;
    }
}

const logf::LN2_LO: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 9.05800061E-6f32;
        return;
    }
}

const logf::LG1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.666666627f32;
        return;
    }
}

const logf::LG2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.400009722f32;
        return;
    }
}

const logf::LG3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.284987867f32;
        return;
    }
}

const logf::LG4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.242790788f32;
        return;
    }
}

fn logf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: f32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: bool;
    let mut _16: f32;
    let mut _17: f32;
    let mut _18: f32;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: (i32, bool);
    let mut _27: u32;
    let mut _28: f32;
    let mut _29: bool;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: u32;
    let mut _33: (u32, bool);
    let mut _34: (u32, bool);
    let mut _35: i32;
    let mut _36: i32;
    let mut _37: u32;
    let mut _38: u32;
    let mut _39: u32;
    let mut _40: bool;
    let mut _41: (i32, bool);
    let mut _42: (i32, bool);
    let mut _43: u32;
    let mut _44: u32;
    let mut _45: (u32, bool);
    let mut _46: f32;
    let mut _47: u32;
    let mut _49: f32;
    let mut _51: f32;
    let mut _55: f32;
    let mut _56: f32;
    let mut _58: f32;
    let mut _59: f32;
    let mut _62: f32;
    let mut _64: i32;
    let mut _65: f32;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: f32;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f32;
    scope 1 {
        debug x1p25 => _2;
        let mut _3: u32;
        scope 2 {
            debug ix => _3;
            let mut _5: i32;
            scope 3 {
                debug k => _5;
                let _48: f32;
                scope 4 {
                    debug f => _48;
                    let _50: f32;
                    scope 5 {
                        debug s => _50;
                        let _52: f32;
                        scope 6 {
                            debug z => _52;
                            let _53: f32;
                            scope 7 {
                                debug w => _53;
                                let _54: f32;
                                scope 8 {
                                    debug t1 => _54;
                                    let _57: f32;
                                    scope 9 {
                                        debug t2 => _57;
                                        let _60: f32;
                                        scope 10 {
                                            debug r => _60;
                                            let _61: f32;
                                            scope 11 {
                                                debug hfsq => _61;
                                                let _63: f32;
                                                scope 12 {
                                                    debug dk => _63;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 1275068416_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = const 0_i32;
        _7 = _3;
        _6 = Lt(move _7, const 8388608_u32);
        switchInt(move _6) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _9 = _3;
        _10 = const 31_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = Shr(move _9, const 31_i32);
        switchInt(move _8) -> [0: bb14, otherwise: bb5];
    }

    bb5: {
        _13 = _3;
        _14 = const 1_i32 as u32 (IntToInt);
        _15 = Lt(move _14, const 32_u32);
        assert(move _15, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _12 = Shl(move _13, const 1_i32);
        switchInt(move _12) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _17 = _1;
        _18 = _1;
        _16 = Mul(move _17, move _18);
        _0 = Div(const -1f32, move _16);
        goto -> bb26;
    }

    bb8: {
        _20 = _3;
        _21 = const 31_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _19 = Shr(move _20, const 31_i32);
        switchInt(move _19) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _24 = _1;
        _25 = _1;
        _23 = Sub(move _24, move _25);
        _0 = Div(move _23, const 0f32);
        goto -> bb26;
    }

    bb11: {
        _26 = CheckedSub(_5, const 25_i32);
        assert(!move (_26.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 25_i32) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _5 = move (_26.0: i32);
        _1 = Mul(_1, _2);
        _28 = _1;
        _27 = f32::<impl f32>::to_bits(move _28) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _3 = move _27;
        goto -> bb18;
    }

    bb14: {
        _30 = _3;
        _29 = Ge(move _30, const 2139095040_u32);
        switchInt(move _29) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _0 = _1;
        goto -> bb26;
    }

    bb16: {
        _31 = _3;
        switchInt(move _31) -> [1065353216: bb17, otherwise: bb18];
    }

    bb17: {
        _0 = const 0f32;
        goto -> bb26;
    }

    bb18: {
        _33 = CheckedSub(const 1065353216_u32, const 1060439283_u32);
        assert(!move (_33.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, const 1060439283_u32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _32 = move (_33.0: u32);
        _34 = CheckedAdd(_3, _32);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, move _32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _3 = move (_34.0: u32);
        _38 = _3;
        _39 = const 23_i32 as u32 (IntToInt);
        _40 = Lt(move _39, const 32_u32);
        assert(move _40, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _37 = Shr(move _38, const 23_i32);
        _36 = move _37 as i32 (IntToInt);
        _41 = CheckedSub(_36, const 127_i32);
        assert(!move (_41.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, const 127_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _35 = move (_41.0: i32);
        _42 = CheckedAdd(_5, _35);
        assert(!move (_42.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, move _35) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _5 = move (_42.0: i32);
        _44 = _3;
        _43 = BitAnd(move _44, const 8388607_u32);
        _45 = CheckedAdd(_43, const 1060439283_u32);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", move _43, const 1060439283_u32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _3 = move (_45.0: u32);
        _47 = _3;
        _46 = f32::<impl f32>::from_bits(move _47) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _1 = move _46;
        _49 = _1;
        _48 = Sub(move _49, const 1f32);
        _51 = Add(const 2f32, _48);
        _50 = Div(_48, move _51);
        _52 = Mul(_50, _50);
        _53 = Mul(_52, _52);
        _56 = Mul(_53, const _);
        _55 = Add(const _, move _56);
        _54 = Mul(_53, move _55);
        _59 = Mul(_53, const _);
        _58 = Add(const _, move _59);
        _57 = Mul(_52, move _58);
        _60 = Add(_57, _54);
        _62 = Mul(const 0.5f32, _48);
        _61 = Mul(move _62, _48);
        _64 = _5;
        _63 = move _64 as f32 (IntToFloat);
        _69 = Add(_61, _60);
        _68 = Mul(_50, move _69);
        _70 = Mul(_63, const _);
        _67 = Add(move _68, move _70);
        _66 = Sub(move _67, _61);
        _65 = Add(move _66, _48);
        _71 = Mul(_63, const _);
        _0 = Add(move _65, move _71);
        goto -> bb26;
    }

    bb26: {
        return;
    }
}

fn modf(_1: f64) -> (f64, f64) {
    debug x => _1;
    let mut _0: (f64, f64);
    let _2: f64;
    let mut _6: i32;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: (i32, bool);
    let mut _13: bool;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: f64;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: f64;
    let mut _23: u64;
    let mut _24: f64;
    let mut _25: bool;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: f64;
    let mut _30: u64;
    let mut _31: f64;
    let mut _32: u64;
    let mut _33: u64;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: u32;
    let mut _37: bool;
    let mut _38: u64;
    let mut _39: u64;
    let mut _40: u64;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: f64;
    let mut _44: u64;
    let mut _45: f64;
    let mut _46: u64;
    let mut _47: f64;
    let mut _48: u64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    scope 1 {
        debug rv2 => _2;
        let mut _3: u64;
        scope 2 {
            debug u => _3;
            let _4: u64;
            scope 3 {
                debug mask => _4;
                let _5: i32;
                scope 4 {
                    debug e => _5;
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = _3;
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 52_i32);
        _7 = BitAnd(move _8, const 2047_u64);
        _6 = move _7 as i32 (IntToInt);
        _12 = CheckedSub(_6, const 1023_i32);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _6, const 1023_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move (_12.0: i32);
        _13 = Ge(_5, const 52_i32);
        switchInt(move _13) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _2 = _1;
        switchInt(move _5) -> [1024: bb5, otherwise: bb8];
    }

    bb5: {
        _15 = _3;
        _16 = const 12_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 64_u32);
        assert(move _17, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _14 = Shl(move _15, const 12_i32);
        switchInt(move _14) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _18 = _2;
        _0 = (_1, move _18);
        goto -> bb23;
    }

    bb8: {
        _20 = const 63_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _19 = Shl(const 1_u64, const 63_i32);
        _3 = BitAnd(_3, move _19);
        _23 = _3;
        _22 = f64::<impl f64>::from_bits(move _23) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _24 = _2;
        _0 = (move _22, move _24);
        goto -> bb23;
    }

    bb11: {
        _25 = Lt(_5, const 0_i32);
        switchInt(move _25) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _27 = const 63_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb14, unwind unreachable];
    }

    bb13: {
        _33 = Not(const 0_u64);
        _34 = const 12_i32 as u32 (IntToInt);
        _35 = Lt(move _34, const 64_u32);
        assert(move _35, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb16, unwind unreachable];
    }

    bb14: {
        _26 = Shl(const 1_u64, const 63_i32);
        _3 = BitAnd(_3, move _26);
        _30 = _3;
        _29 = f64::<impl f64>::from_bits(move _30) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move _29;
        _31 = _2;
        _0 = (_1, move _31);
        goto -> bb23;
    }

    bb16: {
        _32 = Shr(move _33, const 12_i32);
        _36 = _5 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _4 = Shr(move _32, _5);
        _39 = _3;
        _38 = BitAnd(move _39, _4);
        switchInt(move _38) -> [0: bb18, otherwise: bb21];
    }

    bb18: {
        _2 = _1;
        _41 = const 63_i32 as u32 (IntToInt);
        _42 = Lt(move _41, const 64_u32);
        assert(move _42, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _40 = Shl(const 1_u64, const 63_i32);
        _3 = BitAnd(_3, move _40);
        _44 = _3;
        _43 = f64::<impl f64>::from_bits(move _44) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _45 = _2;
        _0 = (move _43, move _45);
        goto -> bb23;
    }

    bb21: {
        _46 = Not(_4);
        _3 = BitAnd(_3, move _46);
        _48 = _3;
        _47 = f64::<impl f64>::from_bits(move _48) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _2 = move _47;
        _50 = _2;
        _49 = Sub(_1, move _50);
        _51 = _2;
        _0 = (move _49, move _51);
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

fn modff(_1: f32) -> (f32, f32) {
    debug x => _1;
    let mut _0: (f32, f32);
    let _2: f32;
    let mut _6: i32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: (i32, bool);
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: u32;
    let mut _21: f32;
    let mut _22: bool;
    let mut _23: f32;
    let mut _24: u32;
    let mut _25: f32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: f32;
    let mut _31: u32;
    let mut _32: f32;
    let mut _33: u32;
    let mut _34: f32;
    let mut _35: u32;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    scope 1 {
        debug rv2 => _2;
        let mut _3: u32;
        scope 2 {
            debug u => _3;
            let _4: u32;
            scope 3 {
                debug mask => _4;
                let _5: i32;
                scope 4 {
                    debug e => _5;
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = _3;
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 23_i32);
        _7 = BitAnd(move _8, const 255_u32);
        _6 = move _7 as i32 (IntToInt);
        _12 = CheckedSub(_6, const 127_i32);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _6, const 127_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = move (_12.0: i32);
        _13 = Ge(_5, const 23_i32);
        switchInt(move _13) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _2 = _1;
        switchInt(move _5) -> [128: bb5, otherwise: bb8];
    }

    bb5: {
        _15 = _3;
        _16 = const 9_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 32_u32);
        assert(move _17, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _14 = Shl(move _15, const 9_i32);
        switchInt(move _14) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _18 = _2;
        _0 = (_1, move _18);
        goto -> bb19;
    }

    bb8: {
        _3 = BitAnd(_3, const 2147483648_u32);
        _20 = _3;
        _19 = f32::<impl f32>::from_bits(move _20) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _21 = _2;
        _0 = (move _19, move _21);
        goto -> bb19;
    }

    bb10: {
        _22 = Lt(_5, const 0_i32);
        switchInt(move _22) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _3 = BitAnd(_3, const 2147483648_u32);
        _24 = _3;
        _23 = f32::<impl f32>::from_bits(move _24) -> [return: bb13, unwind unreachable];
    }

    bb12: {
        _26 = _5 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", _5) -> [success: bb14, unwind unreachable];
    }

    bb13: {
        _2 = move _23;
        _25 = _2;
        _0 = (_1, move _25);
        goto -> bb19;
    }

    bb14: {
        _4 = Shr(const 8388607_u32, _5);
        _29 = _3;
        _28 = BitAnd(move _29, _4);
        switchInt(move _28) -> [0: bb15, otherwise: bb17];
    }

    bb15: {
        _2 = _1;
        _3 = BitAnd(_3, const 2147483648_u32);
        _31 = _3;
        _30 = f32::<impl f32>::from_bits(move _31) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _32 = _2;
        _0 = (move _30, move _32);
        goto -> bb19;
    }

    bb17: {
        _33 = Not(_4);
        _3 = BitAnd(_3, move _33);
        _35 = _3;
        _34 = f32::<impl f32>::from_bits(move _35) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _2 = move _34;
        _37 = _2;
        _36 = Sub(_1, move _37);
        _38 = _2;
        _0 = (move _36, move _38);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn nextafter(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u64;
    let mut _7: bool;
    let mut _8: u64;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u64;
    let mut _13: bool;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: bool;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: u64;
    let mut _24: u64;
    let mut _25: u64;
    let mut _26: u64;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: (u64, bool);
    let mut _30: (u64, bool);
    let mut _32: u64;
    let mut _33: u64;
    let mut _34: u32;
    let mut _35: bool;
    let _36: f64;
    let mut _37: *const f64;
    let _38: &f64;
    let _39: f64;
    let mut _41: u64;
    let _42: f64;
    let mut _43: *const f64;
    let _44: &f64;
    let _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    scope 1 {
        debug ux_i => _5;
        let _6: u64;
        scope 2 {
            debug uy_i => _6;
            let _9: u64;
            scope 3 {
                debug ax => _9;
                let _14: u64;
                scope 4 {
                    debug ay => _14;
                    let _31: u64;
                    scope 5 {
                        debug e => _31;
                        let _40: f64;
                        scope 6 {
                        }
                        scope 7 {
                            debug ux_f => _40;
                            scope 8 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = f64::<impl f64>::is_nan(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Add(_1, _2);
        goto -> bb30;
    }

    bb5: {
        _5 = f64::<impl f64>::to_bits(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _6 = f64::<impl f64>::to_bits(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _8 = _5;
        _7 = Eq(move _8, _6);
        switchInt(move _7) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = _2;
        goto -> bb30;
    }

    bb9: {
        _10 = _5;
        _12 = Not(const 1_u64);
        _13 = Eq(const 2_u64, const 0_u64);
        assert(!move _13, "attempt to divide `{}` by zero", _12) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _11 = Div(move _12, const 2_u64);
        _9 = BitAnd(move _10, move _11);
        _16 = Not(const 1_u64);
        _17 = Eq(const 2_u64, const 0_u64);
        assert(!move _17, "attempt to divide `{}` by zero", _16) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _15 = Div(move _16, const 2_u64);
        _14 = BitAnd(_6, move _15);
        switchInt(move _9) -> [0: bb12, otherwise: bb16];
    }

    bb12: {
        switchInt(move _14) -> [0: bb13, otherwise: bb14];
    }

    bb13: {
        _0 = _2;
        goto -> bb30;
    }

    bb14: {
        _20 = const 63_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _19 = Shl(const 1_u64, const 63_i32);
        _18 = BitAnd(_6, move _19);
        _5 = BitOr(move _18, const 1_u64);
        goto -> bb23;
    }

    bb16: {
        _22 = Gt(_9, _14);
        switchInt(move _22) -> [0: bb17, otherwise: bb19];
    }

    bb17: {
        _25 = _5;
        _24 = BitXor(move _25, _6);
        _27 = const 63_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 64_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 63_i32) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _26 = Shl(const 1_u64, const 63_i32);
        _23 = BitAnd(move _24, move _26);
        switchInt(move _23) -> [0: bb21, otherwise: bb19];
    }

    bb19: {
        _29 = CheckedSub(_5, const 1_u64);
        assert(!move (_29.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u64) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _5 = move (_29.0: u64);
        goto -> bb23;
    }

    bb21: {
        _30 = CheckedAdd(_5, const 1_u64);
        assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_u64) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _5 = move (_30.0: u64);
        goto -> bb23;
    }

    bb23: {
        _33 = _5;
        _34 = const 52_i32 as u32 (IntToInt);
        _35 = Lt(move _34, const 64_u32);
        assert(move _35, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _32 = Shr(move _33, const 52_i32);
        _31 = BitAnd(move _32, const 2047_u64);
        switchInt(move _31) -> [2047: bb25, otherwise: bb26];
    }

    bb25: {
        _39 = Add(_1, _1);
        _38 = &_39;
        _37 = &raw const (*_38);
        _36 = read_volatile::<f64>(move _37) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _41 = _5;
        _40 = f64::<impl f64>::from_bits(move _41) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        switchInt(move _31) -> [0: bb28, otherwise: bb29];
    }

    bb28: {
        _46 = Mul(_1, _1);
        _47 = Mul(_40, _40);
        _45 = Add(move _46, move _47);
        _44 = &_45;
        _43 = &raw const (*_44);
        _42 = read_volatile::<f64>(move _43) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _0 = _40;
        goto -> bb30;
    }

    bb30: {
        return;
    }
}

fn nextafterf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: u32;
    let mut _7: bool;
    let mut _8: u32;
    let mut _10: u32;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: (u32, bool);
    let mut _18: (u32, bool);
    let mut _20: u32;
    let _21: f32;
    let mut _22: *const f32;
    let _23: &f32;
    let _24: f32;
    let mut _26: u32;
    let _27: f32;
    let mut _28: *const f32;
    let _29: &f32;
    let _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    scope 1 {
        debug ux_i => _5;
        let _6: u32;
        scope 2 {
            debug uy_i => _6;
            let _9: u32;
            scope 3 {
                debug ax => _9;
                let _11: u32;
                scope 4 {
                    debug ay => _11;
                    let _19: u32;
                    scope 5 {
                        debug e => _19;
                        let _25: f32;
                        scope 6 {
                        }
                        scope 7 {
                            debug ux_f => _25;
                            scope 8 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::is_nan(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = f32::<impl f32>::is_nan(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Add(_1, _2);
        goto -> bb25;
    }

    bb5: {
        _5 = f32::<impl f32>::to_bits(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _6 = f32::<impl f32>::to_bits(_2) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _8 = _5;
        _7 = Eq(move _8, _6);
        switchInt(move _7) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = _2;
        goto -> bb25;
    }

    bb9: {
        _10 = _5;
        _9 = BitAnd(move _10, const 2147483647_u32);
        _11 = BitAnd(_6, const 2147483647_u32);
        switchInt(move _9) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        switchInt(move _11) -> [0: bb12, otherwise: bb13];
    }

    bb11: {
        _13 = Gt(_9, _11);
        switchInt(move _13) -> [0: bb14, otherwise: bb15];
    }

    bb12: {
        _0 = _2;
        goto -> bb25;
    }

    bb13: {
        _12 = BitAnd(_6, const 2147483648_u32);
        _5 = BitOr(move _12, const 1_u32);
        goto -> bb19;
    }

    bb14: {
        _16 = _5;
        _15 = BitXor(move _16, _6);
        _14 = BitAnd(move _15, const 2147483648_u32);
        switchInt(move _14) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _17 = CheckedSub(_5, const 1_u32);
        assert(!move (_17.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, const 1_u32) -> [success: bb17, unwind unreachable];
    }

    bb16: {
        _18 = CheckedAdd(_5, const 1_u32);
        assert(!move (_18.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_u32) -> [success: bb18, unwind unreachable];
    }

    bb17: {
        _5 = move (_17.0: u32);
        goto -> bb19;
    }

    bb18: {
        _5 = move (_18.0: u32);
        goto -> bb19;
    }

    bb19: {
        _20 = _5;
        _19 = BitAnd(move _20, const 2139095040_u32);
        switchInt(move _19) -> [2139095040: bb20, otherwise: bb21];
    }

    bb20: {
        _24 = Add(_1, _1);
        _23 = &_24;
        _22 = &raw const (*_23);
        _21 = read_volatile::<f32>(move _22) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _26 = _5;
        _25 = f32::<impl f32>::from_bits(move _26) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        switchInt(move _19) -> [0: bb23, otherwise: bb24];
    }

    bb23: {
        _31 = Mul(_1, _1);
        _32 = Mul(_25, _25);
        _30 = Add(move _31, move _32);
        _29 = &_30;
        _28 = &raw const (*_29);
        _27 = read_volatile::<f32>(move _28) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _0 = _25;
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

const libm::pow::BP: [f64; 2] = {
    let mut _0: [f64; 2];

    bb0: {
        _0 = [const 1f64, const 1.5f64];
        return;
    }
}

libm::pow::BP::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const libm::pow::DP_H: [f64; 2] = {
    let mut _0: [f64; 2];

    bb0: {
        _0 = [const 0f64, const 0.58496248722076416f64];
        return;
    }
}

libm::pow::DP_H::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const libm::pow::DP_L: [f64; 2] = {
    let mut _0: [f64; 2];

    bb0: {
        _0 = [const 0f64, const 1.350039202129749E-8f64];
        return;
    }
}

libm::pow::DP_L::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const TWO53: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 9007199254740992f64;
        return;
    }
}

const libm::pow::HUGE: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.0000000000000001E+300f64;
        return;
    }
}

const libm::pow::TINY: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.0E-300f64;
        return;
    }
}

const libm::pow::L1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.59999999999999465f64;
        return;
    }
}

const libm::pow::L2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.42857142857855018f64;
        return;
    }
}

const libm::pow::L3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.33333332981837743f64;
        return;
    }
}

const libm::pow::L4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.27272812380853401f64;
        return;
    }
}

const libm::pow::L5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.23066074577556175f64;
        return;
    }
}

const libm::pow::L6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.20697501780033842f64;
        return;
    }
}

const libm::pow::P1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.16666666666666602f64;
        return;
    }
}

const libm::pow::P2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0027777777777015593f64;
        return;
    }
}

const libm::pow::P3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.6137563214379344E-5f64;
        return;
    }
}

const libm::pow::P4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.6533902205465252E-6f64;
        return;
    }
}

const libm::pow::P5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 4.1381367970572385E-8f64;
        return;
    }
}

const libm::pow::LG2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718055994529f64;
        return;
    }
}

const libm::pow::LG2_H: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.69314718246459961f64;
        return;
    }
}

const libm::pow::LG2_L: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.904654299957768E-9f64;
        return;
    }
}

const libm::pow::OVT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 8.0085662595372941E-17f64;
        return;
    }
}

const libm::pow::CP: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.96179669392597555f64;
        return;
    }
}

const libm::pow::CP_H: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.96179670095443726f64;
        return;
    }
}

const libm::pow::CP_L: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -7.0284616509527583E-9f64;
        return;
    }
}

const libm::pow::IVLN2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4426950408889634f64;
        return;
    }
}

const libm::pow::IVLN2_H: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.4426950216293335f64;
        return;
    }
}

const libm::pow::IVLN2_L: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.9259629911266175E-8f64;
        return;
    }
}

fn libm::pow::pow(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let _3: f64;
    let mut _7: (i32, u32);
    let mut _8: i32;
    let mut _9: u64;
    let mut _10: u64;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: u64;
    let mut _17: (i32, u32);
    let mut _18: i32;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: u32;
    let mut _24: u64;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: bool;
    let mut _30: i32;
    let mut _31: i32;
    let mut _32: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: i32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: (i32, bool);
    let mut _43: bool;
    let mut _44: i32;
    let mut _45: u32;
    let mut _46: i32;
    let mut _47: i32;
    let mut _48: (i32, bool);
    let mut _49: u32;
    let mut _50: bool;
    let mut _51: bool;
    let mut _52: i32;
    let mut _53: i32;
    let mut _54: i32;
    let mut _55: i32;
    let mut _56: (i32, bool);
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: i32;
    let mut _61: i32;
    let mut _62: (i32, bool);
    let mut _63: i32;
    let mut _64: i32;
    let mut _65: (i32, bool);
    let mut _66: u32;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: i32;
    let mut _70: i32;
    let mut _71: i32;
    let mut _72: i32;
    let mut _73: (i32, bool);
    let mut _74: u32;
    let mut _75: bool;
    let mut _76: i32;
    let mut _77: i32;
    let mut _78: (i32, bool);
    let mut _79: i32;
    let mut _80: i32;
    let mut _81: i32;
    let mut _82: (i32, bool);
    let mut _83: i32;
    let mut _84: bool;
    let mut _85: i32;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _91: i32;
    let mut _92: i32;
    let mut _93: i32;
    let mut _95: bool;
    let mut _96: f64;
    let mut _97: bool;
    let mut _98: i32;
    let mut _99: i32;
    let mut _100: i32;
    let mut _101: (i32, bool);
    let mut _102: i32;
    let mut _103: f64;
    let mut _104: f64;
    let mut _105: f64;
    let mut _106: f64;
    let mut _107: f64;
    let mut _108: f64;
    let mut _109: i32;
    let mut _110: f64;
    let mut _112: bool;
    let mut _113: i32;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: i32;
    let mut _117: bool;
    let mut _118: bool;
    let mut _119: bool;
    let mut _120: i32;
    let mut _121: bool;
    let mut _122: bool;
    let mut _123: i32;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: i32;
    let mut _127: bool;
    let mut _128: f64;
    let mut _129: f64;
    let mut _130: f64;
    let mut _131: f64;
    let mut _132: bool;
    let mut _133: i32;
    let mut _134: bool;
    let mut _135: f64;
    let mut _136: f64;
    let mut _137: f64;
    let mut _138: f64;
    let mut _140: f64;
    let mut _142: f64;
    let mut _143: f64;
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: f64;
    let mut _149: f64;
    let mut _150: f64;
    let mut _151: f64;
    let mut _152: f64;
    let mut _153: f64;
    let mut _154: f64;
    let mut _156: bool;
    let mut _157: i32;
    let mut _158: (i32, bool);
    let mut _159: u32;
    let mut _160: f64;
    let mut _161: i32;
    let mut _162: i32;
    let mut _163: i32;
    let mut _164: u32;
    let mut _165: bool;
    let mut _166: (i32, bool);
    let mut _167: (i32, bool);
    let mut _168: i32;
    let mut _170: i32;
    let mut _171: bool;
    let mut _172: i32;
    let mut _173: bool;
    let mut _174: i32;
    let mut _175: (i32, bool);
    let mut _176: (i32, bool);
    let mut _177: f64;
    let mut _178: f64;
    let mut _179: u32;
    let mut _180: i32;
    let mut _182: f64;
    let mut _183: f64;
    let mut _184: &f64;
    let mut _185: rustc_std_workspace_core::option::Option<&f64>;
    let mut _186: &[f64];
    let mut _187: usize;
    let mut _188: i32;
    let mut _190: f64;
    let mut _191: f64;
    let mut _192: f64;
    let mut _193: &f64;
    let mut _194: rustc_std_workspace_core::option::Option<&f64>;
    let mut _195: &[f64];
    let mut _196: usize;
    let mut _197: i32;
    let mut _201: u32;
    let mut _202: u32;
    let mut _203: u32;
    let mut _204: u32;
    let mut _205: u32;
    let mut _206: i32;
    let mut _207: u32;
    let mut _208: bool;
    let mut _209: (u32, bool);
    let mut _210: u32;
    let mut _211: u32;
    let mut _212: i32;
    let mut _213: u32;
    let mut _214: bool;
    let mut _215: (u32, bool);
    let mut _217: f64;
    let mut _218: f64;
    let mut _219: f64;
    let mut _220: &f64;
    let mut _221: rustc_std_workspace_core::option::Option<&f64>;
    let mut _222: &[f64];
    let mut _223: usize;
    let mut _224: i32;
    let mut _226: f64;
    let mut _227: f64;
    let mut _228: f64;
    let mut _229: f64;
    let mut _232: f64;
    let mut _233: f64;
    let mut _234: f64;
    let mut _235: f64;
    let mut _236: f64;
    let mut _237: f64;
    let mut _238: f64;
    let mut _239: f64;
    let mut _240: f64;
    let mut _241: f64;
    let mut _242: f64;
    let mut _243: f64;
    let mut _244: f64;
    let mut _247: f64;
    let mut _248: f64;
    let mut _249: f64;
    let mut _251: f64;
    let mut _252: f64;
    let mut _253: f64;
    let mut _256: f64;
    let mut _257: f64;
    let mut _259: f64;
    let mut _261: f64;
    let mut _264: f64;
    let mut _265: f64;
    let mut _266: f64;
    let mut _267: f64;
    let mut _268: &f64;
    let mut _269: rustc_std_workspace_core::option::Option<&f64>;
    let mut _270: &[f64];
    let mut _271: usize;
    let mut _272: i32;
    let mut _274: i32;
    let mut _275: f64;
    let mut _276: f64;
    let mut _277: f64;
    let mut _278: f64;
    let mut _279: f64;
    let mut _280: &f64;
    let mut _281: rustc_std_workspace_core::option::Option<&f64>;
    let mut _282: &[f64];
    let mut _283: usize;
    let mut _284: i32;
    let mut _285: f64;
    let mut _286: f64;
    let mut _287: f64;
    let mut _288: f64;
    let mut _289: f64;
    let mut _290: &f64;
    let mut _291: rustc_std_workspace_core::option::Option<&f64>;
    let mut _292: &[f64];
    let mut _293: usize;
    let mut _294: i32;
    let mut _297: f64;
    let mut _298: f64;
    let mut _299: f64;
    let mut _300: f64;
    let mut _301: f64;
    let mut _303: f64;
    let mut _305: f64;
    let mut _307: u64;
    let mut _308: u64;
    let mut _309: u32;
    let mut _310: bool;
    let mut _312: u64;
    let mut _313: bool;
    let mut _314: i32;
    let mut _315: i32;
    let mut _316: i32;
    let mut _317: i32;
    let mut _318: (i32, bool);
    let mut _319: f64;
    let mut _320: f64;
    let mut _321: bool;
    let mut _322: f64;
    let mut _323: f64;
    let mut _324: f64;
    let mut _325: f64;
    let mut _326: f64;
    let mut _327: bool;
    let mut _328: i32;
    let mut _329: i32;
    let mut _330: u32;
    let mut _331: u32;
    let mut _332: u32;
    let mut _333: i32;
    let mut _334: (u32, bool);
    let mut _335: u32;
    let mut _336: f64;
    let mut _337: f64;
    let mut _338: bool;
    let mut _339: f64;
    let mut _340: f64;
    let mut _341: f64;
    let mut _342: f64;
    let mut _344: i32;
    let mut _345: i32;
    let mut _346: i32;
    let mut _347: u32;
    let mut _348: bool;
    let mut _349: (i32, bool);
    let mut _351: bool;
    let mut _352: i32;
    let mut _353: i32;
    let mut _354: i32;
    let mut _355: i32;
    let mut _356: (i32, bool);
    let mut _357: u32;
    let mut _358: bool;
    let mut _359: (i32, bool);
    let mut _360: i32;
    let mut _361: i32;
    let mut _362: i32;
    let mut _363: u32;
    let mut _364: bool;
    let mut _365: (i32, bool);
    let mut _367: u32;
    let mut _368: i32;
    let mut _369: i32;
    let mut _370: i32;
    let mut _371: i32;
    let mut _372: i32;
    let mut _373: u32;
    let mut _374: bool;
    let mut _375: i32;
    let mut _376: i32;
    let mut _377: i32;
    let mut _378: i32;
    let mut _379: i32;
    let mut _380: (i32, bool);
    let mut _381: u32;
    let mut _382: bool;
    let mut _383: bool;
    let mut _384: i32;
    let mut _385: i32;
    let mut _386: bool;
    let mut _388: f64;
    let mut _389: f64;
    let mut _392: f64;
    let mut _393: f64;
    let mut _394: f64;
    let mut _395: f64;
    let mut _396: f64;
    let mut _399: f64;
    let mut _400: f64;
    let mut _402: f64;
    let mut _403: f64;
    let mut _405: f64;
    let mut _406: f64;
    let mut _407: f64;
    let mut _408: f64;
    let mut _409: f64;
    let mut _410: f64;
    let mut _411: f64;
    let mut _412: f64;
    let mut _413: f64;
    let mut _414: f64;
    let mut _416: f64;
    let mut _417: f64;
    let mut _418: f64;
    let mut _419: f64;
    let mut _420: f64;
    let mut _421: f64;
    let mut _422: f64;
    let mut _423: f64;
    let mut _424: f64;
    let mut _425: u32;
    let mut _426: f64;
    let mut _427: i32;
    let mut _428: i32;
    let mut _429: u32;
    let mut _430: bool;
    let mut _431: (i32, bool);
    let mut _432: bool;
    let mut _433: i32;
    let mut _434: i32;
    let mut _435: u32;
    let mut _436: bool;
    let mut _437: f64;
    let mut _438: f64;
    let mut _439: i32;
    let mut _440: f64;
    let mut _441: f64;
    let mut _442: u32;
    let mut _443: i32;
    let mut _444: f64;
    let mut _445: f64;
    scope 1 {
        debug t1 => _3;
        let _4: f64;
        scope 2 {
            debug t2 => _4;
            let _5: i32;
            let _6: u32;
            scope 3 {
                debug hx => _5;
                debug lx => _6;
                let _15: i32;
                let _16: u32;
                scope 4 {
                    debug hy => _15;
                    debug ly => _16;
                    let mut _25: i32;
                    scope 5 {
                        debug ix => _25;
                        let _26: i32;
                        scope 6 {
                            debug iy => _26;
                            let mut _33: i32;
                            scope 7 {
                                debug yisint => _33;
                                let mut _34: i32;
                                scope 8 {
                                    debug k => _34;
                                    let mut _35: i32;
                                    scope 9 {
                                        debug j => _35;
                                        let mut _90: f64;
                                        scope 10 {
                                            debug ax => _90;
                                            let mut _94: f64;
                                            let mut _111: f64;
                                            scope 11 {
                                                debug z => _94;
                                            }
                                            scope 12 {
                                                debug s => _111;
                                                let _139: f64;
                                                let mut _155: i32;
                                                let _295: f64;
                                                scope 13 {
                                                    debug t => _139;
                                                    let _141: f64;
                                                    scope 14 {
                                                        debug w => _141;
                                                        let _147: f64;
                                                        scope 15 {
                                                            debug u => _147;
                                                            let _148: f64;
                                                            scope 16 {
                                                                debug v => _148;
                                                            }
                                                        }
                                                    }
                                                }
                                                scope 17 {
                                                    debug n => _155;
                                                    let _169: i32;
                                                    scope 18 {
                                                        debug k => _169;
                                                        let _181: f64;
                                                        let mut _451: &[f64; 2];
                                                        scope 19 {
                                                            debug u => _181;
                                                            let _189: f64;
                                                            let mut _450: &[f64; 2];
                                                            scope 20 {
                                                                debug v => _189;
                                                                let _198: f64;
                                                                scope 21 {
                                                                    debug ss => _198;
                                                                    let _199: f64;
                                                                    scope 22 {
                                                                        debug s_h => _199;
                                                                        let _200: f64;
                                                                        scope 23 {
                                                                            debug t_h => _200;
                                                                            let _216: f64;
                                                                            let mut _449: &[f64; 2];
                                                                            scope 24 {
                                                                                debug t_l => _216;
                                                                                let _225: f64;
                                                                                scope 25 {
                                                                                    debug s_l => _225;
                                                                                    let _230: f64;
                                                                                    scope 26 {
                                                                                        debug s2 => _230;
                                                                                        let mut _231: f64;
                                                                                        scope 27 {
                                                                                            debug r => _231;
                                                                                            let _245: f64;
                                                                                            scope 28 {
                                                                                                debug s2 => _245;
                                                                                                let _246: f64;
                                                                                                scope 29 {
                                                                                                    debug t_h => _246;
                                                                                                    let _250: f64;
                                                                                                    scope 30 {
                                                                                                        debug t_l => _250;
                                                                                                        let _254: f64;
                                                                                                        scope 31 {
                                                                                                            debug u => _254;
                                                                                                            let _255: f64;
                                                                                                            scope 32 {
                                                                                                                debug v => _255;
                                                                                                                let _258: f64;
                                                                                                                scope 33 {
                                                                                                                    debug p_h => _258;
                                                                                                                    let _260: f64;
                                                                                                                    scope 34 {
                                                                                                                        debug p_l => _260;
                                                                                                                        let _262: f64;
                                                                                                                        scope 35 {
                                                                                                                            debug z_h => _262;
                                                                                                                            let _263: f64;
                                                                                                                            let mut _448: &[f64; 2];
                                                                                                                            scope 36 {
                                                                                                                                debug z_l => _263;
                                                                                                                                let _273: f64;
                                                                                                                                scope 37 {
                                                                                                                                    debug t => _273;
                                                                                                                                    let mut _446: &[f64; 2];
                                                                                                                                    let mut _447: &[f64; 2];
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                scope 38 {
                                                    debug y1 => _295;
                                                    let _296: f64;
                                                    scope 39 {
                                                        debug p_l => _296;
                                                        let mut _302: f64;
                                                        scope 40 {
                                                            debug p_h => _302;
                                                            let _304: f64;
                                                            scope 41 {
                                                                debug z => _304;
                                                                let mut _306: i32;
                                                                scope 42 {
                                                                    debug j => _306;
                                                                    let _311: i32;
                                                                    scope 43 {
                                                                        debug i => _311;
                                                                        let _343: i32;
                                                                        scope 44 {
                                                                            debug i => _343;
                                                                            let mut _350: i32;
                                                                            scope 45 {
                                                                                debug n => _350;
                                                                                let _366: f64;
                                                                                let _387: f64;
                                                                                scope 46 {
                                                                                    debug t => _366;
                                                                                }
                                                                                scope 47 {
                                                                                    debug t => _387;
                                                                                    let _390: f64;
                                                                                    scope 48 {
                                                                                        debug u => _390;
                                                                                        let _391: f64;
                                                                                        scope 49 {
                                                                                            debug v => _391;
                                                                                            let mut _397: f64;
                                                                                            scope 50 {
                                                                                                debug z => _397;
                                                                                                let _398: f64;
                                                                                                scope 51 {
                                                                                                    debug w => _398;
                                                                                                    let _401: f64;
                                                                                                    scope 52 {
                                                                                                        debug t => _401;
                                                                                                        let _404: f64;
                                                                                                        scope 53 {
                                                                                                            debug t1 => _404;
                                                                                                            let _415: f64;
                                                                                                            scope 54 {
                                                                                                                debug r => _415;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _10 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _11 = const 32_i32 as u32 (IntToInt);
        _12 = Lt(move _11, const 64_u32);
        assert(move _12, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Shr(move _10, const 32_i32);
        _8 = move _9 as i32 (IntToInt);
        _14 = f64::<impl f64>::to_bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = move _14 as u32 (IntToInt);
        _7 = (move _8, move _13);
        _5 = (_7.0: i32);
        _6 = (_7.1: u32);
        _20 = f64::<impl f64>::to_bits(_2) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _21 = const 32_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = Shr(move _20, const 32_i32);
        _18 = move _19 as i32 (IntToInt);
        _24 = f64::<impl f64>::to_bits(_2) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _23 = move _24 as u32 (IntToInt);
        _17 = (move _18, move _23);
        _15 = (_17.0: i32);
        _16 = (_17.1: u32);
        _25 = BitAnd(_5, const i32::MAX);
        _26 = BitAnd(_15, const i32::MAX);
        _28 = _26 as u32 (IntToInt);
        _27 = BitOr(move _28, _16);
        switchInt(move _27) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _0 = const 1f64;
        goto -> bb180;
    }

    bb8: {
        switchInt(move _5) -> [1072693248: bb9, otherwise: bb11];
    }

    bb9: {
        switchInt(move _6) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _0 = const 1f64;
        goto -> bb180;
    }

    bb11: {
        _30 = _25;
        _29 = Gt(move _30, const 2146435072_i32);
        switchInt(move _29) -> [0: bb12, otherwise: bb17];
    }

    bb12: {
        _31 = _25;
        switchInt(move _31) -> [2146435072: bb13, otherwise: bb14];
    }

    bb13: {
        switchInt(move _6) -> [0: bb14, otherwise: bb17];
    }

    bb14: {
        _32 = Gt(_26, const 2146435072_i32);
        switchInt(move _32) -> [0: bb15, otherwise: bb17];
    }

    bb15: {
        switchInt(move _26) -> [2146435072: bb16, otherwise: bb18];
    }

    bb16: {
        switchInt(move _16) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = Add(_1, _2);
        goto -> bb180;
    }

    bb18: {
        _33 = const 0_i32;
        _36 = Lt(_5, const 0_i32);
        switchInt(move _36) -> [0: bb40, otherwise: bb19];
    }

    bb19: {
        _37 = Ge(_26, const 1128267776_i32);
        switchInt(move _37) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _33 = const 2_i32;
        goto -> bb40;
    }

    bb21: {
        _38 = Ge(_26, const 1072693248_i32);
        switchInt(move _38) -> [0: bb40, otherwise: bb22];
    }

    bb22: {
        _40 = const 20_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 32_u32);
        assert(move _41, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _39 = Shr(_26, const 20_i32);
        _42 = CheckedSub(_39, const 1023_i32);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", move _39, const 1023_i32) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _34 = move (_42.0: i32);
        _44 = _34;
        _43 = Gt(move _44, const 20_i32);
        switchInt(move _43) -> [0: bb32, otherwise: bb25];
    }

    bb25: {
        _47 = _34;
        _48 = CheckedSub(const 52_i32, _47);
        assert(!move (_48.1: bool), "attempt to compute `{} - {}`, which would overflow", const 52_i32, move _47) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _46 = move (_48.0: i32);
        _49 = _46 as u32 (IntToInt);
        _50 = Lt(move _49, const 32_u32);
        assert(move _50, "attempt to shift right by `{}`, which would overflow", _46) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _45 = Shr(_16, move _46);
        _35 = move _45 as i32 (IntToInt);
        _53 = _35;
        _55 = _34;
        _56 = CheckedSub(const 52_i32, _55);
        assert(!move (_56.1: bool), "attempt to compute `{} - {}`, which would overflow", const 52_i32, move _55) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _54 = move (_56.0: i32);
        _57 = _54 as u32 (IntToInt);
        _58 = Lt(move _57, const 32_u32);
        assert(move _58, "attempt to shift left by `{}`, which would overflow", _54) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _52 = Shl(move _53, move _54);
        _59 = _16 as i32 (IntToInt);
        _51 = Eq(move _52, move _59);
        switchInt(move _51) -> [0: bb40, otherwise: bb30];
    }

    bb30: {
        _61 = _35;
        _60 = BitAnd(move _61, const 1_i32);
        _62 = CheckedSub(const 2_i32, _60);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", const 2_i32, move _60) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _33 = move (_62.0: i32);
        goto -> bb40;
    }

    bb32: {
        switchInt(move _16) -> [0: bb33, otherwise: bb40];
    }

    bb33: {
        _64 = _34;
        _65 = CheckedSub(const 20_i32, _64);
        assert(!move (_65.1: bool), "attempt to compute `{} - {}`, which would overflow", const 20_i32, move _64) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _63 = move (_65.0: i32);
        _66 = _63 as u32 (IntToInt);
        _67 = Lt(move _66, const 32_u32);
        assert(move _67, "attempt to shift right by `{}`, which would overflow", _63) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _35 = Shr(_26, move _63);
        _70 = _35;
        _72 = _34;
        _73 = CheckedSub(const 20_i32, _72);
        assert(!move (_73.1: bool), "attempt to compute `{} - {}`, which would overflow", const 20_i32, move _72) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _71 = move (_73.0: i32);
        _74 = _71 as u32 (IntToInt);
        _75 = Lt(move _74, const 32_u32);
        assert(move _75, "attempt to shift left by `{}`, which would overflow", _71) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _69 = Shl(move _70, move _71);
        _68 = Eq(move _69, _26);
        switchInt(move _68) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _77 = _35;
        _76 = BitAnd(move _77, const 1_i32);
        _78 = CheckedSub(const 2_i32, _76);
        assert(!move (_78.1: bool), "attempt to compute `{} - {}`, which would overflow", const 2_i32, move _76) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _33 = move (_78.0: i32);
        goto -> bb40;
    }

    bb40: {
        switchInt(move _16) -> [0: bb41, otherwise: bb61];
    }

    bb41: {
        switchInt(move _26) -> [2146435072: bb42, otherwise: bb52];
    }

    bb42: {
        _81 = _25;
        _82 = CheckedSub(_81, const 1072693248_i32);
        assert(!move (_82.1: bool), "attempt to compute `{} - {}`, which would overflow", move _81, const 1072693248_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _80 = move (_82.0: i32);
        _83 = _6 as i32 (IntToInt);
        _79 = BitOr(move _80, move _83);
        switchInt(move _79) -> [0: bb44, otherwise: bb45];
    }

    bb44: {
        _0 = const 1f64;
        goto -> bb180;
    }

    bb45: {
        _85 = _25;
        _84 = Ge(move _85, const 1072693248_i32);
        switchInt(move _84) -> [0: bb49, otherwise: bb46];
    }

    bb46: {
        _86 = Ge(_15, const 0_i32);
        switchInt(move _86) -> [0: bb48, otherwise: bb47];
    }

    bb47: {
        _0 = _2;
        goto -> bb180;
    }

    bb48: {
        _0 = const 0f64;
        goto -> bb180;
    }

    bb49: {
        _87 = Ge(_15, const 0_i32);
        switchInt(move _87) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _0 = const 0f64;
        goto -> bb180;
    }

    bb51: {
        _0 = Neg(_2);
        goto -> bb180;
    }

    bb52: {
        switchInt(move _26) -> [1072693248: bb53, otherwise: bb54];
    }

    bb53: {
        _88 = Ge(_15, const 0_i32);
        switchInt(move _88) -> [0: bb56, otherwise: bb55];
    }

    bb54: {
        switchInt(move _15) -> [1073741824: bb57, otherwise: bb58];
    }

    bb55: {
        _0 = _1;
        goto -> bb180;
    }

    bb56: {
        _0 = Div(const 1f64, _1);
        goto -> bb180;
    }

    bb57: {
        _0 = Mul(_1, _1);
        goto -> bb180;
    }

    bb58: {
        switchInt(move _15) -> [1071644672: bb59, otherwise: bb61];
    }

    bb59: {
        _89 = Ge(_5, const 0_i32);
        switchInt(move _89) -> [0: bb61, otherwise: bb60];
    }

    bb60: {
        _0 = sqrt(_1) -> [return: bb180, unwind unreachable];
    }

    bb61: {
        _90 = fabs(_1) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        switchInt(move _6) -> [0: bb63, otherwise: bb75];
    }

    bb63: {
        _91 = _25;
        switchInt(move _91) -> [2146435072: bb66, otherwise: bb64];
    }

    bb64: {
        _92 = _25;
        switchInt(move _92) -> [0: bb66, otherwise: bb65];
    }

    bb65: {
        _93 = _25;
        switchInt(move _93) -> [1072693248: bb66, otherwise: bb75];
    }

    bb66: {
        _94 = _90;
        _95 = Lt(_15, const 0_i32);
        switchInt(move _95) -> [0: bb68, otherwise: bb67];
    }

    bb67: {
        _96 = _94;
        _94 = Div(const 1f64, move _96);
        goto -> bb68;
    }

    bb68: {
        _97 = Lt(_5, const 0_i32);
        switchInt(move _97) -> [0: bb74, otherwise: bb69];
    }

    bb69: {
        _100 = _25;
        _101 = CheckedSub(_100, const 1072693248_i32);
        assert(!move (_101.1: bool), "attempt to compute `{} - {}`, which would overflow", move _100, const 1072693248_i32) -> [success: bb70, unwind unreachable];
    }

    bb70: {
        _99 = move (_101.0: i32);
        _102 = _33;
        _98 = BitOr(move _99, move _102);
        switchInt(move _98) -> [0: bb71, otherwise: bb72];
    }

    bb71: {
        _104 = _94;
        _105 = _94;
        _103 = Sub(move _104, move _105);
        _107 = _94;
        _108 = _94;
        _106 = Sub(move _107, move _108);
        _94 = Div(move _103, move _106);
        goto -> bb74;
    }

    bb72: {
        _109 = _33;
        switchInt(move _109) -> [1: bb73, otherwise: bb74];
    }

    bb73: {
        _110 = _94;
        _94 = Neg(move _110);
        goto -> bb74;
    }

    bb74: {
        _0 = _94;
        goto -> bb180;
    }

    bb75: {
        _111 = const 1f64;
        _112 = Lt(_5, const 0_i32);
        switchInt(move _112) -> [0: bb80, otherwise: bb76];
    }

    bb76: {
        _113 = _33;
        switchInt(move _113) -> [0: bb77, otherwise: bb78];
    }

    bb77: {
        _114 = Sub(_1, _1);
        _115 = Sub(_1, _1);
        _0 = Div(move _114, move _115);
        goto -> bb180;
    }

    bb78: {
        _116 = _33;
        switchInt(move _116) -> [1: bb79, otherwise: bb80];
    }

    bb79: {
        _111 = const -1f64;
        goto -> bb80;
    }

    bb80: {
        _117 = Gt(_26, const 1105199104_i32);
        switchInt(move _117) -> [0: bb100, otherwise: bb81];
    }

    bb81: {
        _118 = Gt(_26, const 1139802112_i32);
        switchInt(move _118) -> [0: bb90, otherwise: bb82];
    }

    bb82: {
        _120 = _25;
        _119 = Le(move _120, const 1072693247_i32);
        switchInt(move _119) -> [0: bb86, otherwise: bb83];
    }

    bb83: {
        _121 = Lt(_15, const 0_i32);
        switchInt(move _121) -> [0: bb85, otherwise: bb84];
    }

    bb84: {
        _0 = Mul(const _, const _);
        goto -> bb180;
    }

    bb85: {
        _0 = Mul(const _, const _);
        goto -> bb180;
    }

    bb86: {
        _123 = _25;
        _122 = Ge(move _123, const 1072693248_i32);
        switchInt(move _122) -> [0: bb90, otherwise: bb87];
    }

    bb87: {
        _124 = Gt(_15, const 0_i32);
        switchInt(move _124) -> [0: bb89, otherwise: bb88];
    }

    bb88: {
        _0 = Mul(const _, const _);
        goto -> bb180;
    }

    bb89: {
        _0 = Mul(const _, const _);
        goto -> bb180;
    }

    bb90: {
        _126 = _25;
        _125 = Lt(move _126, const 1072693247_i32);
        switchInt(move _125) -> [0: bb94, otherwise: bb91];
    }

    bb91: {
        _127 = Lt(_15, const 0_i32);
        switchInt(move _127) -> [0: bb93, otherwise: bb92];
    }

    bb92: {
        _129 = _111;
        _128 = Mul(move _129, const _);
        _0 = Mul(move _128, const _);
        goto -> bb180;
    }

    bb93: {
        _131 = _111;
        _130 = Mul(move _131, const _);
        _0 = Mul(move _130, const _);
        goto -> bb180;
    }

    bb94: {
        _133 = _25;
        _132 = Gt(move _133, const 1072693248_i32);
        switchInt(move _132) -> [0: bb96, otherwise: bb95];
    }

    bb95: {
        _134 = Gt(_15, const 0_i32);
        switchInt(move _134) -> [0: bb98, otherwise: bb97];
    }

    bb96: {
        _140 = _90;
        _139 = Sub(move _140, const 1f64);
        _142 = Mul(_139, _139);
        _146 = Mul(_139, const 0.25f64);
        _145 = Sub(const 0.33333333333333331f64, move _146);
        _144 = Mul(_139, move _145);
        _143 = Sub(const 0.5f64, move _144);
        _141 = Mul(move _142, move _143);
        _147 = Mul(const _, _139);
        _149 = Mul(_139, const _);
        _150 = Mul(_141, const _);
        _148 = Sub(move _149, move _150);
        _152 = Add(_147, _148);
        _151 = with_set_low_word(move _152, const 0_u32) -> [return: bb99, unwind unreachable];
    }

    bb97: {
        _136 = _111;
        _135 = Mul(move _136, const _);
        _0 = Mul(move _135, const _);
        goto -> bb180;
    }

    bb98: {
        _138 = _111;
        _137 = Mul(move _138, const _);
        _0 = Mul(move _137, const _);
        goto -> bb180;
    }

    bb99: {
        _3 = move _151;
        _154 = _3;
        _153 = Sub(move _154, _147);
        _4 = Sub(_148, move _153);
        goto -> bb137;
    }

    bb100: {
        _155 = const 0_i32;
        _157 = _25;
        _156 = Lt(move _157, const 1048576_i32);
        switchInt(move _156) -> [0: bb104, otherwise: bb101];
    }

    bb101: {
        _90 = Mul(_90, const _);
        _158 = CheckedSub(_155, const 53_i32);
        assert(!move (_158.1: bool), "attempt to compute `{} - {}`, which would overflow", _155, const 53_i32) -> [success: bb102, unwind unreachable];
    }

    bb102: {
        _155 = move (_158.0: i32);
        _160 = _90;
        _159 = get_high_word(move _160) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _25 = move _159 as i32 (IntToInt);
        goto -> bb104;
    }

    bb104: {
        _163 = _25;
        _164 = const 20_i32 as u32 (IntToInt);
        _165 = Lt(move _164, const 32_u32);
        assert(move _165, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb105, unwind unreachable];
    }

    bb105: {
        _162 = Shr(move _163, const 20_i32);
        _166 = CheckedSub(_162, const 1023_i32);
        assert(!move (_166.1: bool), "attempt to compute `{} - {}`, which would overflow", move _162, const 1023_i32) -> [success: bb106, unwind unreachable];
    }

    bb106: {
        _161 = move (_166.0: i32);
        _167 = CheckedAdd(_155, _161);
        assert(!move (_167.1: bool), "attempt to compute `{} + {}`, which would overflow", _155, move _161) -> [success: bb107, unwind unreachable];
    }

    bb107: {
        _155 = move (_167.0: i32);
        _168 = _25;
        _35 = BitAnd(move _168, const 1048575_i32);
        _170 = _35;
        _25 = BitOr(move _170, const 1072693248_i32);
        _172 = _35;
        _171 = Le(move _172, const 235662_i32);
        switchInt(move _171) -> [0: bb109, otherwise: bb108];
    }

    bb108: {
        _169 = const 0_i32;
        goto -> bb114;
    }

    bb109: {
        _174 = _35;
        _173 = Lt(move _174, const 767610_i32);
        switchInt(move _173) -> [0: bb111, otherwise: bb110];
    }

    bb110: {
        _169 = const 1_i32;
        goto -> bb114;
    }

    bb111: {
        _169 = const 0_i32;
        _175 = CheckedAdd(_155, const 1_i32);
        assert(!move (_175.1: bool), "attempt to compute `{} + {}`, which would overflow", _155, const 1_i32) -> [success: bb112, unwind unreachable];
    }

    bb112: {
        _155 = move (_175.0: i32);
        _176 = CheckedSub(_25, const 1048576_i32);
        assert(!move (_176.1: bool), "attempt to compute `{} - {}`, which would overflow", _25, const 1048576_i32) -> [success: bb113, unwind unreachable];
    }

    bb113: {
        _25 = move (_176.0: i32);
        goto -> bb114;
    }

    bb114: {
        _178 = _90;
        _180 = _25;
        _179 = move _180 as u32 (IntToInt);
        _177 = with_set_high_word(move _178, move _179) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _90 = move _177;
        _182 = _90;
        _451 = const _;
        _186 = _451 as &[f64] (PointerCoercion(Unsize));
        _188 = _169;
        _187 = move _188 as usize (IntToInt);
        _185 = slice::<impl [f64]>::get::<usize>(move _186, move _187) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _184 = Option::<&f64>::unwrap(move _185) -> [return: bb117, unwind unreachable];
    }

    bb117: {
        _183 = (*_184);
        _181 = Sub(move _182, move _183);
        _191 = _90;
        _450 = const _;
        _195 = _450 as &[f64] (PointerCoercion(Unsize));
        _197 = _169;
        _196 = move _197 as usize (IntToInt);
        _194 = slice::<impl [f64]>::get::<usize>(move _195, move _196) -> [return: bb118, unwind unreachable];
    }

    bb118: {
        _193 = Option::<&f64>::unwrap(move _194) -> [return: bb119, unwind unreachable];
    }

    bb119: {
        _192 = (*_193);
        _190 = Add(move _191, move _192);
        _189 = Div(const 1f64, move _190);
        _198 = Mul(_181, _189);
        _199 = with_set_low_word(_198, const 0_u32) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _206 = _25;
        _205 = move _206 as u32 (IntToInt);
        _207 = const 1_i32 as u32 (IntToInt);
        _208 = Lt(move _207, const 32_u32);
        assert(move _208, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb121, unwind unreachable];
    }

    bb121: {
        _204 = Shr(move _205, const 1_i32);
        _203 = BitOr(move _204, const 536870912_u32);
        _209 = CheckedAdd(_203, const 524288_u32);
        assert(!move (_209.1: bool), "attempt to compute `{} + {}`, which would overflow", move _203, const 524288_u32) -> [success: bb122, unwind unreachable];
    }

    bb122: {
        _202 = move (_209.0: u32);
        _212 = _169;
        _211 = move _212 as u32 (IntToInt);
        _213 = const 18_i32 as u32 (IntToInt);
        _214 = Lt(move _213, const 32_u32);
        assert(move _214, "attempt to shift left by `{}`, which would overflow", const 18_i32) -> [success: bb123, unwind unreachable];
    }

    bb123: {
        _210 = Shl(move _211, const 18_i32);
        _215 = CheckedAdd(_202, _210);
        assert(!move (_215.1: bool), "attempt to compute `{} + {}`, which would overflow", move _202, move _210) -> [success: bb124, unwind unreachable];
    }

    bb124: {
        _201 = move (_215.0: u32);
        _200 = with_set_high_word(const 0f64, move _201) -> [return: bb125, unwind unreachable];
    }

    bb125: {
        _217 = _90;
        _449 = const _;
        _222 = _449 as &[f64] (PointerCoercion(Unsize));
        _224 = _169;
        _223 = move _224 as usize (IntToInt);
        _221 = slice::<impl [f64]>::get::<usize>(move _222, move _223) -> [return: bb126, unwind unreachable];
    }

    bb126: {
        _220 = Option::<&f64>::unwrap(move _221) -> [return: bb127, unwind unreachable];
    }

    bb127: {
        _219 = (*_220);
        _218 = Sub(_200, move _219);
        _216 = Sub(move _217, move _218);
        _228 = Mul(_199, _200);
        _227 = Sub(_181, move _228);
        _229 = Mul(_199, _216);
        _226 = Sub(move _227, move _229);
        _225 = Mul(_189, move _226);
        _230 = Mul(_198, _198);
        _232 = Mul(_230, _230);
        _242 = Mul(_230, const _);
        _241 = Add(const _, move _242);
        _240 = Mul(_230, move _241);
        _239 = Add(const _, move _240);
        _238 = Mul(_230, move _239);
        _237 = Add(const _, move _238);
        _236 = Mul(_230, move _237);
        _235 = Add(const _, move _236);
        _234 = Mul(_230, move _235);
        _233 = Add(const _, move _234);
        _231 = Mul(move _232, move _233);
        _244 = Add(_199, _198);
        _243 = Mul(_225, move _244);
        _231 = Add(_231, move _243);
        _245 = Mul(_199, _199);
        _248 = Add(const 3f64, _245);
        _249 = _231;
        _247 = Add(move _248, move _249);
        _246 = with_set_low_word(move _247, const 0_u32) -> [return: bb128, unwind unreachable];
    }

    bb128: {
        _251 = _231;
        _253 = Sub(_246, const 3f64);
        _252 = Sub(move _253, _245);
        _250 = Sub(move _251, move _252);
        _254 = Mul(_199, _246);
        _256 = Mul(_225, _246);
        _257 = Mul(_250, _198);
        _255 = Add(move _256, move _257);
        _259 = Add(_254, _255);
        _258 = with_set_low_word(move _259, const 0_u32) -> [return: bb129, unwind unreachable];
    }

    bb129: {
        _261 = Sub(_258, _254);
        _260 = Sub(_255, move _261);
        _262 = Mul(const _, _258);
        _265 = Mul(const _, _258);
        _266 = Mul(_260, const _);
        _264 = Add(move _265, move _266);
        _448 = const _;
        _270 = _448 as &[f64] (PointerCoercion(Unsize));
        _272 = _169;
        _271 = move _272 as usize (IntToInt);
        _269 = slice::<impl [f64]>::get::<usize>(move _270, move _271) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _268 = Option::<&f64>::unwrap(move _269) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _267 = (*_268);
        _263 = Add(move _264, move _267);
        _274 = _155;
        _273 = move _274 as f64 (IntToFloat);
        _278 = Add(_262, _263);
        _447 = const _;
        _282 = _447 as &[f64] (PointerCoercion(Unsize));
        _284 = _169;
        _283 = move _284 as usize (IntToInt);
        _281 = slice::<impl [f64]>::get::<usize>(move _282, move _283) -> [return: bb132, unwind unreachable];
    }

    bb132: {
        _280 = Option::<&f64>::unwrap(move _281) -> [return: bb133, unwind unreachable];
    }

    bb133: {
        _279 = (*_280);
        _277 = Add(move _278, move _279);
        _276 = Add(move _277, _273);
        _275 = with_set_low_word(move _276, const 0_u32) -> [return: bb134, unwind unreachable];
    }

    bb134: {
        _3 = move _275;
        _288 = _3;
        _287 = Sub(move _288, _273);
        _446 = const _;
        _292 = _446 as &[f64] (PointerCoercion(Unsize));
        _294 = _169;
        _293 = move _294 as usize (IntToInt);
        _291 = slice::<impl [f64]>::get::<usize>(move _292, move _293) -> [return: bb135, unwind unreachable];
    }

    bb135: {
        _290 = Option::<&f64>::unwrap(move _291) -> [return: bb136, unwind unreachable];
    }

    bb136: {
        _289 = (*_290);
        _286 = Sub(move _287, move _289);
        _285 = Sub(move _286, _262);
        _4 = Sub(_263, move _285);
        goto -> bb137;
    }

    bb137: {
        _295 = with_set_low_word(_2, const 0_u32) -> [return: bb138, unwind unreachable];
    }

    bb138: {
        _298 = Sub(_2, _295);
        _299 = _3;
        _297 = Mul(move _298, move _299);
        _301 = _4;
        _300 = Mul(_2, move _301);
        _296 = Add(move _297, move _300);
        _303 = _3;
        _302 = Mul(_295, move _303);
        _305 = _302;
        _304 = Add(_296, move _305);
        _308 = f64::<impl f64>::to_bits(_304) -> [return: bb139, unwind unreachable];
    }

    bb139: {
        _309 = const 32_i32 as u32 (IntToInt);
        _310 = Lt(move _309, const 64_u32);
        assert(move _310, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb140, unwind unreachable];
    }

    bb140: {
        _307 = Shr(move _308, const 32_i32);
        _306 = move _307 as i32 (IntToInt);
        _312 = f64::<impl f64>::to_bits(_304) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _311 = move _312 as i32 (IntToInt);
        _314 = _306;
        _313 = Ge(move _314, const 1083179008_i32);
        switchInt(move _313) -> [0: bb147, otherwise: bb142];
    }

    bb142: {
        _317 = _306;
        _318 = CheckedSub(_317, const 1083179008_i32);
        assert(!move (_318.1: bool), "attempt to compute `{} - {}`, which would overflow", move _317, const 1083179008_i32) -> [success: bb143, unwind unreachable];
    }

    bb143: {
        _316 = move (_318.0: i32);
        _315 = BitOr(move _316, _311);
        switchInt(move _315) -> [0: bb145, otherwise: bb144];
    }

    bb144: {
        _320 = _111;
        _319 = Mul(move _320, const _);
        _0 = Mul(move _319, const _);
        goto -> bb180;
    }

    bb145: {
        _322 = Add(_296, const _);
        _324 = _302;
        _323 = Sub(_304, move _324);
        _321 = Gt(move _322, move _323);
        switchInt(move _321) -> [0: bb153, otherwise: bb146];
    }

    bb146: {
        _326 = _111;
        _325 = Mul(move _326, const _);
        _0 = Mul(move _325, const _);
        goto -> bb180;
    }

    bb147: {
        _329 = _306;
        _328 = BitAnd(move _329, const i32::MAX);
        _327 = Ge(move _328, const 1083231232_i32);
        switchInt(move _327) -> [0: bb153, otherwise: bb148];
    }

    bb148: {
        _333 = _306;
        _332 = move _333 as u32 (IntToInt);
        _334 = CheckedSub(_332, const 3230714880_u32);
        assert(!move (_334.1: bool), "attempt to compute `{} - {}`, which would overflow", move _332, const 3230714880_u32) -> [success: bb149, unwind unreachable];
    }

    bb149: {
        _331 = move (_334.0: u32);
        _335 = _311 as u32 (IntToInt);
        _330 = BitOr(move _331, move _335);
        switchInt(move _330) -> [0: bb151, otherwise: bb150];
    }

    bb150: {
        _337 = _111;
        _336 = Mul(move _337, const _);
        _0 = Mul(move _336, const _);
        goto -> bb180;
    }

    bb151: {
        _340 = _302;
        _339 = Sub(_304, move _340);
        _338 = Le(_296, move _339);
        switchInt(move _338) -> [0: bb153, otherwise: bb152];
    }

    bb152: {
        _342 = _111;
        _341 = Mul(move _342, const _);
        _0 = Mul(move _341, const _);
        goto -> bb180;
    }

    bb153: {
        _344 = _306;
        _345 = const i32::MAX;
        _343 = BitAnd(move _344, move _345);
        _347 = const 20_i32 as u32 (IntToInt);
        _348 = Lt(move _347, const 32_u32);
        assert(move _348, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb154, unwind unreachable];
    }

    bb154: {
        _346 = Shr(_343, const 20_i32);
        _349 = CheckedSub(_346, const 1023_i32);
        assert(!move (_349.1: bool), "attempt to compute `{} - {}`, which would overflow", move _346, const 1023_i32) -> [success: bb155, unwind unreachable];
    }

    bb155: {
        _34 = move (_349.0: i32);
        _350 = const 0_i32;
        _351 = Gt(_343, const 1071644672_i32);
        switchInt(move _351) -> [0: bb169, otherwise: bb156];
    }

    bb156: {
        _352 = _306;
        _355 = _34;
        _356 = CheckedAdd(_355, const 1_i32);
        assert(!move (_356.1: bool), "attempt to compute `{} + {}`, which would overflow", move _355, const 1_i32) -> [success: bb157, unwind unreachable];
    }

    bb157: {
        _354 = move (_356.0: i32);
        _357 = _354 as u32 (IntToInt);
        _358 = Lt(move _357, const 32_u32);
        assert(move _358, "attempt to shift right by `{}`, which would overflow", _354) -> [success: bb158, unwind unreachable];
    }

    bb158: {
        _353 = Shr(const 1048576_i32, move _354);
        _359 = CheckedAdd(_352, _353);
        assert(!move (_359.1: bool), "attempt to compute `{} + {}`, which would overflow", move _352, move _353) -> [success: bb159, unwind unreachable];
    }

    bb159: {
        _350 = move (_359.0: i32);
        _362 = _350;
        _361 = BitAnd(move _362, const i32::MAX);
        _363 = const 20_i32 as u32 (IntToInt);
        _364 = Lt(move _363, const 32_u32);
        assert(move _364, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb160, unwind unreachable];
    }

    bb160: {
        _360 = Shr(move _361, const 20_i32);
        _365 = CheckedSub(_360, const 1023_i32);
        assert(!move (_365.1: bool), "attempt to compute `{} - {}`, which would overflow", move _360, const 1023_i32) -> [success: bb161, unwind unreachable];
    }

    bb161: {
        _34 = move (_365.0: i32);
        _369 = _350;
        _372 = _34;
        _373 = _372 as u32 (IntToInt);
        _374 = Lt(move _373, const 32_u32);
        assert(move _374, "attempt to shift right by `{}`, which would overflow", _372) -> [success: bb162, unwind unreachable];
    }

    bb162: {
        _371 = Shr(const 1048575_i32, move _372);
        _370 = Not(move _371);
        _368 = BitAnd(move _369, move _370);
        _367 = move _368 as u32 (IntToInt);
        _366 = with_set_high_word(const 0f64, move _367) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _377 = _350;
        _376 = BitAnd(move _377, const 1048575_i32);
        _375 = BitOr(move _376, const 1048576_i32);
        _379 = _34;
        _380 = CheckedSub(const 20_i32, _379);
        assert(!move (_380.1: bool), "attempt to compute `{} - {}`, which would overflow", const 20_i32, move _379) -> [success: bb164, unwind unreachable];
    }

    bb164: {
        _378 = move (_380.0: i32);
        _381 = _378 as u32 (IntToInt);
        _382 = Lt(move _381, const 32_u32);
        assert(move _382, "attempt to shift right by `{}`, which would overflow", _378) -> [success: bb165, unwind unreachable];
    }

    bb165: {
        _350 = Shr(move _375, move _378);
        _384 = _306;
        _383 = Lt(move _384, const 0_i32);
        switchInt(move _383) -> [0: bb168, otherwise: bb166];
    }

    bb166: {
        _385 = _350;
        _386 = Eq(_385, const i32::MIN);
        assert(!move _386, "attempt to negate `{}`, which would overflow", _385) -> [success: bb167, unwind unreachable];
    }

    bb167: {
        _350 = Neg(move _385);
        goto -> bb168;
    }

    bb168: {
        _302 = Sub(_302, _366);
        goto -> bb169;
    }

    bb169: {
        _389 = _302;
        _388 = Add(_296, move _389);
        _387 = with_set_low_word(move _388, const 0_u32) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _390 = Mul(_387, const _);
        _395 = _302;
        _394 = Sub(_387, move _395);
        _393 = Sub(_296, move _394);
        _392 = Mul(move _393, const _);
        _396 = Mul(_387, const _);
        _391 = Add(move _392, move _396);
        _397 = Add(_390, _391);
        _400 = _397;
        _399 = Sub(move _400, _390);
        _398 = Sub(_391, move _399);
        _402 = _397;
        _403 = _397;
        _401 = Mul(move _402, move _403);
        _405 = _397;
        _414 = Mul(_401, const _);
        _413 = Add(const _, move _414);
        _412 = Mul(_401, move _413);
        _411 = Add(const _, move _412);
        _410 = Mul(_401, move _411);
        _409 = Add(const _, move _410);
        _408 = Mul(_401, move _409);
        _407 = Add(const _, move _408);
        _406 = Mul(_401, move _407);
        _404 = Sub(move _405, move _406);
        _418 = _397;
        _417 = Mul(move _418, _404);
        _419 = Sub(_404, const 2f64);
        _416 = Div(move _417, move _419);
        _422 = _397;
        _421 = Mul(move _422, _398);
        _420 = Add(_398, move _421);
        _415 = Sub(move _416, move _420);
        _424 = _397;
        _423 = Sub(_415, move _424);
        _397 = Sub(const 1f64, move _423);
        _426 = _397;
        _425 = get_high_word(move _426) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _306 = move _425 as i32 (IntToInt);
        _428 = _350;
        _429 = const 20_i32 as u32 (IntToInt);
        _430 = Lt(move _429, const 32_u32);
        assert(move _430, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb172, unwind unreachable];
    }

    bb172: {
        _427 = Shl(move _428, const 20_i32);
        _431 = CheckedAdd(_306, _427);
        assert(!move (_431.1: bool), "attempt to compute `{} + {}`, which would overflow", _306, move _427) -> [success: bb173, unwind unreachable];
    }

    bb173: {
        _306 = move (_431.0: i32);
        _434 = _306;
        _435 = const 20_i32 as u32 (IntToInt);
        _436 = Lt(move _435, const 32_u32);
        assert(move _436, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb174, unwind unreachable];
    }

    bb174: {
        _433 = Shr(move _434, const 20_i32);
        _432 = Le(move _433, const 0_i32);
        switchInt(move _432) -> [0: bb177, otherwise: bb175];
    }

    bb175: {
        _438 = _397;
        _439 = _350;
        _437 = scalbn(move _438, move _439) -> [return: bb176, unwind unreachable];
    }

    bb176: {
        _397 = move _437;
        goto -> bb179;
    }

    bb177: {
        _441 = _397;
        _443 = _306;
        _442 = move _443 as u32 (IntToInt);
        _440 = with_set_high_word(move _441, move _442) -> [return: bb178, unwind unreachable];
    }

    bb178: {
        _397 = move _440;
        goto -> bb179;
    }

    bb179: {
        _444 = _111;
        _445 = _397;
        _0 = Mul(move _444, move _445);
        goto -> bb180;
    }

    bb180: {
        return;
    }
}

promoted[0] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in libm::pow::pow: &[f64; 2] = {
    let mut _0: &[f64; 2];
    let mut _1: [f64; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const powf::BP: [f32; 2] = {
    let mut _0: [f32; 2];

    bb0: {
        _0 = [const 1f32, const 1.5f32];
        return;
    }
}

powf::BP::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const powf::DP_H: [f32; 2] = {
    let mut _0: [f32; 2];

    bb0: {
        _0 = [const 0f32, const 0.584960938f32];
        return;
    }
}

powf::DP_H::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const powf::DP_L: [f32; 2] = {
    let mut _0: [f32; 2];

    bb0: {
        _0 = [const 0f32, const 1.56322085E-6f32];
        return;
    }
}

powf::DP_L::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 2_usize;
        return;
    }
}

const TWO24: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 16777216f32;
        return;
    }
}

const powf::HUGE: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.00000002E+30f32;
        return;
    }
}

const powf::TINY: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.0E-30f32;
        return;
    }
}

const powf::L1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.600000024f32;
        return;
    }
}

const powf::L2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.428571433f32;
        return;
    }
}

const powf::L3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.333333343f32;
        return;
    }
}

const powf::L4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.272728115f32;
        return;
    }
}

const powf::L5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.230660751f32;
        return;
    }
}

const powf::L6: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.206975013f32;
        return;
    }
}

const powf::P1: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.166666672f32;
        return;
    }
}

const powf::P2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -0.00277777785f32;
        return;
    }
}

const powf::P3: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 6.61375597E-5f32;
        return;
    }
}

const powf::P4: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1.6533902E-6f32;
        return;
    }
}

const powf::P5: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 4.13813694E-8f32;
        return;
    }
}

const powf::LG2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693147182f32;
        return;
    }
}

const powf::LG2_H: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.693145751f32;
        return;
    }
}

const powf::LG2_L: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.42860654E-6f32;
        return;
    }
}

const powf::OVT: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 4.29956657E-8f32;
        return;
    }
}

const powf::CP: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.9617967f32;
        return;
    }
}

const powf::CP_H: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 0.961914062f32;
        return;
    }
}

const powf::CP_L: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const -1.17368574E-4f32;
        return;
    }
}

const powf::IVLN2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.44269502f32;
        return;
    }
}

const powf::IVLN2_H: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.44268799f32;
        return;
    }
}

const powf::IVLN2_L: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 7.05260754E-6f32;
        return;
    }
}

fn powf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: f32;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: i32;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: i32;
    let mut _37: u32;
    let mut _38: bool;
    let mut _39: (i32, bool);
    let mut _40: i32;
    let mut _41: i32;
    let mut _42: (i32, bool);
    let mut _43: u32;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: i32;
    let mut _47: i32;
    let mut _48: i32;
    let mut _49: i32;
    let mut _50: (i32, bool);
    let mut _51: u32;
    let mut _52: bool;
    let mut _53: i32;
    let mut _54: i32;
    let mut _55: (i32, bool);
    let mut _56: i32;
    let mut _57: bool;
    let mut _58: i32;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: f32;
    let mut _64: i32;
    let mut _65: i32;
    let mut _66: i32;
    let mut _67: f32;
    let mut _68: bool;
    let mut _69: f32;
    let mut _70: bool;
    let mut _71: i32;
    let mut _72: i32;
    let mut _73: i32;
    let mut _74: (i32, bool);
    let mut _75: i32;
    let mut _76: f32;
    let mut _77: f32;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f32;
    let mut _81: f32;
    let mut _82: i32;
    let mut _83: f32;
    let mut _84: bool;
    let mut _85: i32;
    let mut _86: f32;
    let mut _87: f32;
    let mut _88: i32;
    let mut _89: bool;
    let mut _90: bool;
    let mut _91: i32;
    let mut _92: bool;
    let mut _93: f32;
    let mut _94: f32;
    let mut _95: f32;
    let mut _96: f32;
    let mut _97: bool;
    let mut _98: i32;
    let mut _99: bool;
    let mut _100: f32;
    let mut _101: f32;
    let mut _102: f32;
    let mut _103: f32;
    let mut _104: f32;
    let mut _105: f32;
    let mut _106: f32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: f32;
    let mut _110: f32;
    let mut _111: f32;
    let mut _112: f32;
    let mut _113: f32;
    let mut _114: f32;
    let mut _115: f32;
    let mut _116: f32;
    let mut _117: f32;
    let mut _118: f32;
    let mut _119: f32;
    let mut _120: f32;
    let mut _121: u32;
    let mut _122: f32;
    let mut _123: f32;
    let mut _124: u32;
    let mut _125: u32;
    let mut _126: i32;
    let mut _127: f32;
    let mut _128: f32;
    let mut _129: f32;
    let mut _130: f32;
    let mut _136: bool;
    let mut _137: i32;
    let mut _138: (i32, bool);
    let mut _139: u32;
    let mut _140: f32;
    let mut _141: i32;
    let mut _142: i32;
    let mut _143: i32;
    let mut _144: u32;
    let mut _145: bool;
    let mut _146: (i32, bool);
    let mut _147: (i32, bool);
    let mut _148: i32;
    let mut _149: i32;
    let mut _150: bool;
    let mut _151: i32;
    let mut _152: bool;
    let mut _153: i32;
    let mut _154: (i32, bool);
    let mut _155: (i32, bool);
    let mut _156: f32;
    let mut _157: u32;
    let mut _158: i32;
    let mut _159: f32;
    let mut _160: f32;
    let mut _161: &f32;
    let mut _162: rustc_std_workspace_core::option::Option<&f32>;
    let mut _163: &[f32];
    let mut _164: usize;
    let mut _165: i32;
    let mut _166: f32;
    let mut _167: f32;
    let mut _168: f32;
    let mut _169: &f32;
    let mut _170: rustc_std_workspace_core::option::Option<&f32>;
    let mut _171: &[f32];
    let mut _172: usize;
    let mut _173: i32;
    let mut _174: f32;
    let mut _175: f32;
    let mut _176: u32;
    let mut _177: f32;
    let mut _178: f32;
    let mut _179: u32;
    let mut _180: u32;
    let mut _181: i32;
    let mut _182: u32;
    let mut _183: u32;
    let mut _184: u32;
    let mut _185: u32;
    let mut _186: i32;
    let mut _187: u32;
    let mut _188: bool;
    let mut _189: f32;
    let mut _190: u32;
    let mut _191: u32;
    let mut _192: u32;
    let mut _193: i32;
    let mut _194: (u32, bool);
    let mut _195: u32;
    let mut _196: u32;
    let mut _197: i32;
    let mut _198: u32;
    let mut _199: bool;
    let mut _200: (u32, bool);
    let mut _201: f32;
    let mut _202: f32;
    let mut _203: f32;
    let mut _204: f32;
    let mut _205: &f32;
    let mut _206: rustc_std_workspace_core::option::Option<&f32>;
    let mut _207: &[f32];
    let mut _208: usize;
    let mut _209: i32;
    let mut _210: f32;
    let mut _211: f32;
    let mut _212: f32;
    let mut _213: f32;
    let mut _214: f32;
    let mut _215: f32;
    let mut _216: f32;
    let mut _217: f32;
    let mut _218: f32;
    let mut _219: f32;
    let mut _220: f32;
    let mut _221: f32;
    let mut _222: f32;
    let mut _223: f32;
    let mut _224: f32;
    let mut _225: f32;
    let mut _226: f32;
    let mut _227: f32;
    let mut _228: f32;
    let mut _229: f32;
    let mut _230: f32;
    let mut _231: f32;
    let mut _232: f32;
    let mut _233: f32;
    let mut _234: f32;
    let mut _235: f32;
    let mut _236: f32;
    let mut _237: f32;
    let mut _238: f32;
    let mut _239: f32;
    let mut _240: f32;
    let mut _241: f32;
    let mut _242: f32;
    let mut _243: f32;
    let mut _244: f32;
    let mut _245: f32;
    let mut _246: u32;
    let mut _247: f32;
    let mut _248: f32;
    let mut _249: u32;
    let mut _250: u32;
    let mut _251: i32;
    let mut _252: f32;
    let mut _253: f32;
    let mut _254: f32;
    let mut _255: f32;
    let mut _256: f32;
    let mut _257: f32;
    let mut _258: f32;
    let mut _259: f32;
    let mut _260: f32;
    let mut _261: f32;
    let mut _262: f32;
    let mut _263: f32;
    let mut _264: f32;
    let mut _265: u32;
    let mut _266: f32;
    let mut _267: f32;
    let mut _268: u32;
    let mut _269: u32;
    let mut _270: i32;
    let mut _271: f32;
    let mut _272: f32;
    let mut _273: f32;
    let mut _274: f32;
    let mut _275: f32;
    let mut _276: f32;
    let mut _277: f32;
    let mut _278: f32;
    let mut _279: f32;
    let mut _280: f32;
    let mut _281: f32;
    let mut _282: &f32;
    let mut _283: rustc_std_workspace_core::option::Option<&f32>;
    let mut _284: &[f32];
    let mut _285: usize;
    let mut _286: i32;
    let mut _287: i32;
    let mut _288: f32;
    let mut _289: f32;
    let mut _290: f32;
    let mut _291: &f32;
    let mut _292: rustc_std_workspace_core::option::Option<&f32>;
    let mut _293: &[f32];
    let mut _294: usize;
    let mut _295: i32;
    let mut _296: f32;
    let mut _297: u32;
    let mut _298: f32;
    let mut _299: f32;
    let mut _300: u32;
    let mut _301: u32;
    let mut _302: i32;
    let mut _303: f32;
    let mut _304: f32;
    let mut _305: f32;
    let mut _306: f32;
    let mut _307: f32;
    let mut _308: f32;
    let mut _309: &f32;
    let mut _310: rustc_std_workspace_core::option::Option<&f32>;
    let mut _311: &[f32];
    let mut _312: usize;
    let mut _313: i32;
    let mut _314: u32;
    let mut _315: f32;
    let mut _316: u32;
    let mut _317: u32;
    let mut _318: i32;
    let mut _319: f32;
    let mut _320: f32;
    let mut _321: f32;
    let mut _322: f32;
    let mut _323: f32;
    let mut _324: f32;
    let mut _325: f32;
    let mut _326: f32;
    let mut _327: u32;
    let mut _328: f32;
    let mut _329: bool;
    let mut _330: i32;
    let mut _331: f32;
    let mut _332: f32;
    let mut _333: i32;
    let mut _334: bool;
    let mut _335: f32;
    let mut _336: f32;
    let mut _337: f32;
    let mut _338: f32;
    let mut _339: f32;
    let mut _340: f32;
    let mut _341: f32;
    let mut _342: bool;
    let mut _343: i32;
    let mut _344: i32;
    let mut _345: f32;
    let mut _346: f32;
    let mut _347: u32;
    let mut _348: i32;
    let mut _349: bool;
    let mut _350: f32;
    let mut _351: f32;
    let mut _352: f32;
    let mut _353: f32;
    let mut _354: f32;
    let mut _355: f32;
    let mut _356: i32;
    let mut _357: i32;
    let mut _358: u32;
    let mut _359: bool;
    let mut _360: (i32, bool);
    let mut _361: bool;
    let mut _362: i32;
    let mut _363: i32;
    let mut _364: i32;
    let mut _365: i32;
    let mut _366: (i32, bool);
    let mut _367: u32;
    let mut _368: bool;
    let mut _369: (i32, bool);
    let mut _370: i32;
    let mut _371: i32;
    let mut _372: i32;
    let mut _373: u32;
    let mut _374: bool;
    let mut _375: (i32, bool);
    let mut _376: f32;
    let mut _377: u32;
    let mut _378: u32;
    let mut _379: i32;
    let mut _380: u32;
    let mut _381: u32;
    let mut _382: i32;
    let mut _383: u32;
    let mut _384: bool;
    let mut _385: i32;
    let mut _386: i32;
    let mut _387: i32;
    let mut _388: i32;
    let mut _389: i32;
    let mut _390: (i32, bool);
    let mut _391: u32;
    let mut _392: bool;
    let mut _393: bool;
    let mut _394: i32;
    let mut _395: i32;
    let mut _396: bool;
    let mut _397: f32;
    let mut _398: f32;
    let mut _399: f32;
    let mut _400: u32;
    let mut _401: f32;
    let mut _402: f32;
    let mut _403: u32;
    let mut _404: u32;
    let mut _405: i32;
    let mut _406: f32;
    let mut _407: f32;
    let mut _408: f32;
    let mut _409: f32;
    let mut _410: f32;
    let mut _411: f32;
    let mut _412: f32;
    let mut _413: f32;
    let mut _414: f32;
    let mut _415: f32;
    let mut _416: f32;
    let mut _417: f32;
    let mut _418: f32;
    let mut _419: f32;
    let mut _420: f32;
    let mut _421: f32;
    let mut _422: f32;
    let mut _423: f32;
    let mut _424: f32;
    let mut _425: f32;
    let mut _426: f32;
    let mut _427: f32;
    let mut _428: f32;
    let mut _429: f32;
    let mut _430: f32;
    let mut _431: f32;
    let mut _432: f32;
    let mut _433: f32;
    let mut _434: f32;
    let mut _435: f32;
    let mut _436: f32;
    let mut _437: f32;
    let mut _438: f32;
    let mut _439: f32;
    let mut _440: f32;
    let mut _441: f32;
    let mut _442: f32;
    let mut _443: f32;
    let mut _444: f32;
    let mut _445: f32;
    let mut _446: f32;
    let mut _447: f32;
    let mut _448: f32;
    let mut _449: f32;
    let mut _450: f32;
    let mut _451: f32;
    let mut _452: u32;
    let mut _453: f32;
    let mut _454: i32;
    let mut _455: i32;
    let mut _456: u32;
    let mut _457: bool;
    let mut _458: (i32, bool);
    let mut _459: bool;
    let mut _460: i32;
    let mut _461: i32;
    let mut _462: u32;
    let mut _463: bool;
    let mut _464: f32;
    let mut _465: f32;
    let mut _466: i32;
    let mut _467: f32;
    let mut _468: u32;
    let mut _469: i32;
    let mut _470: f32;
    let mut _471: f32;
    scope 1 {
        debug z => _3;
        let mut _4: f32;
        scope 2 {
            debug ax => _4;
            let _5: f32;
            scope 3 {
                debug z_h => _5;
                let _6: f32;
                scope 4 {
                    debug z_l => _6;
                    let mut _7: f32;
                    scope 5 {
                        debug p_h => _7;
                        let mut _8: f32;
                        scope 6 {
                            debug p_l => _8;
                            scope 7 {
                                debug y1 => _315;
                                let mut _9: f32;
                                scope 8 {
                                    debug t1 => _9;
                                    let _10: f32;
                                    scope 9 {
                                        debug t2 => _10;
                                        let mut _11: f32;
                                        scope 10 {
                                            debug r => _11;
                                            let _12: f32;
                                            scope 11 {
                                                debug s => _12;
                                                let mut _13: f32;
                                                scope 12 {
                                                    debug sn => _13;
                                                    let mut _14: f32;
                                                    scope 13 {
                                                        debug t => _14;
                                                        let mut _15: f32;
                                                        scope 14 {
                                                            debug u => _15;
                                                            let mut _16: f32;
                                                            scope 15 {
                                                                debug v => _16;
                                                                let mut _17: f32;
                                                                scope 16 {
                                                                    debug w => _17;
                                                                    let _18: i32;
                                                                    scope 17 {
                                                                        debug i => _18;
                                                                        let mut _19: i32;
                                                                        scope 18 {
                                                                            debug j => _19;
                                                                            let mut _20: i32;
                                                                            scope 19 {
                                                                                debug k => _20;
                                                                                let mut _21: i32;
                                                                                scope 20 {
                                                                                    debug yisint => _21;
                                                                                    let mut _22: i32;
                                                                                    scope 21 {
                                                                                        debug n => _22;
                                                                                        let _23: i32;
                                                                                        scope 22 {
                                                                                            debug hx => _23;
                                                                                            let _24: i32;
                                                                                            scope 23 {
                                                                                                debug hy => _24;
                                                                                                let mut _25: i32;
                                                                                                scope 24 {
                                                                                                    debug ix => _25;
                                                                                                    let _26: i32;
                                                                                                    scope 25 {
                                                                                                        debug iy => _26;
                                                                                                        let mut _27: i32;
                                                                                                        scope 26 {
                                                                                                            debug is => _27;
                                                                                                            let mut _131: f32;
                                                                                                            scope 27 {
                                                                                                                debug s2 => _131;
                                                                                                                let mut _132: f32;
                                                                                                                scope 28 {
                                                                                                                    debug s_h => _132;
                                                                                                                    let _133: f32;
                                                                                                                    scope 29 {
                                                                                                                        debug s_l => _133;
                                                                                                                        let mut _134: f32;
                                                                                                                        scope 30 {
                                                                                                                            debug t_h => _134;
                                                                                                                            let mut _135: f32;
                                                                                                                            scope 31 {
                                                                                                                                debug t_l => _135;
                                                                                                                                let mut _472: &[f32; 2];
                                                                                                                                let mut _473: &[f32; 2];
                                                                                                                                let mut _474: &[f32; 2];
                                                                                                                                let mut _475: &[f32; 2];
                                                                                                                                let mut _476: &[f32; 2];
                                                                                                                                let mut _477: &[f32; 2];
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _28 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _23 = move _28 as i32 (IntToInt);
        _29 = f32::<impl f32>::to_bits(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _24 = move _29 as i32 (IntToInt);
        _25 = BitAnd(_23, const i32::MAX);
        _26 = BitAnd(_24, const i32::MAX);
        switchInt(move _26) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = const 1f32;
        goto -> bb153;
    }

    bb4: {
        switchInt(move _23) -> [1065353216: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = const 1f32;
        goto -> bb153;
    }

    bb6: {
        _31 = _25;
        _30 = Gt(move _31, const 2139095040_i32);
        switchInt(move _30) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _32 = Gt(_26, const 2139095040_i32);
        switchInt(move _32) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Add(_1, _2);
        goto -> bb153;
    }

    bb9: {
        _21 = const 0_i32;
        _33 = Lt(_23, const 0_i32);
        switchInt(move _33) -> [0: bb22, otherwise: bb10];
    }

    bb10: {
        _34 = Ge(_26, const 1266679808_i32);
        switchInt(move _34) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _21 = const 2_i32;
        goto -> bb22;
    }

    bb12: {
        _35 = Ge(_26, const 1065353216_i32);
        switchInt(move _35) -> [0: bb22, otherwise: bb13];
    }

    bb13: {
        _37 = const 23_i32 as u32 (IntToInt);
        _38 = Lt(move _37, const 32_u32);
        assert(move _38, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _36 = Shr(_26, const 23_i32);
        _39 = CheckedSub(_36, const 127_i32);
        assert(!move (_39.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, const 127_i32) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _20 = move (_39.0: i32);
        _41 = _20;
        _42 = CheckedSub(const 23_i32, _41);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", const 23_i32, move _41) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _40 = move (_42.0: i32);
        _43 = _40 as u32 (IntToInt);
        _44 = Lt(move _43, const 32_u32);
        assert(move _44, "attempt to shift right by `{}`, which would overflow", _40) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _19 = Shr(_26, move _40);
        _47 = _19;
        _49 = _20;
        _50 = CheckedSub(const 23_i32, _49);
        assert(!move (_50.1: bool), "attempt to compute `{} - {}`, which would overflow", const 23_i32, move _49) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _48 = move (_50.0: i32);
        _51 = _48 as u32 (IntToInt);
        _52 = Lt(move _51, const 32_u32);
        assert(move _52, "attempt to shift left by `{}`, which would overflow", _48) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _46 = Shl(move _47, move _48);
        _45 = Eq(move _46, _26);
        switchInt(move _45) -> [0: bb22, otherwise: bb20];
    }

    bb20: {
        _54 = _19;
        _53 = BitAnd(move _54, const 1_i32);
        _55 = CheckedSub(const 2_i32, _53);
        assert(!move (_55.1: bool), "attempt to compute `{} - {}`, which would overflow", const 2_i32, move _53) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _21 = move (_55.0: i32);
        goto -> bb22;
    }

    bb22: {
        switchInt(move _26) -> [2139095040: bb23, otherwise: bb32];
    }

    bb23: {
        _56 = _25;
        switchInt(move _56) -> [1065353216: bb24, otherwise: bb25];
    }

    bb24: {
        _0 = const 1f32;
        goto -> bb153;
    }

    bb25: {
        _58 = _25;
        _57 = Gt(move _58, const 1065353216_i32);
        switchInt(move _57) -> [0: bb29, otherwise: bb26];
    }

    bb26: {
        _59 = Ge(_24, const 0_i32);
        switchInt(move _59) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _0 = _2;
        goto -> bb153;
    }

    bb28: {
        _0 = const 0f32;
        goto -> bb153;
    }

    bb29: {
        _60 = Ge(_24, const 0_i32);
        switchInt(move _60) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _0 = const 0f32;
        goto -> bb153;
    }

    bb31: {
        _0 = Neg(_2);
        goto -> bb153;
    }

    bb32: {
        switchInt(move _26) -> [1065353216: bb33, otherwise: bb34];
    }

    bb33: {
        _61 = Ge(_24, const 0_i32);
        switchInt(move _61) -> [0: bb36, otherwise: bb35];
    }

    bb34: {
        switchInt(move _24) -> [1073741824: bb37, otherwise: bb38];
    }

    bb35: {
        _0 = _1;
        goto -> bb153;
    }

    bb36: {
        _0 = Div(const 1f32, _1);
        goto -> bb153;
    }

    bb37: {
        _0 = Mul(_1, _1);
        goto -> bb153;
    }

    bb38: {
        switchInt(move _24) -> [1056964608: bb39, otherwise: bb41];
    }

    bb39: {
        _62 = Ge(_23, const 0_i32);
        switchInt(move _62) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _0 = sqrtf(_1) -> [return: bb153, unwind unreachable];
    }

    bb41: {
        _63 = fabsf(_1) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _4 = move _63;
        _64 = _25;
        switchInt(move _64) -> [2139095040: bb45, otherwise: bb43];
    }

    bb43: {
        _65 = _25;
        switchInt(move _65) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _66 = _25;
        switchInt(move _66) -> [1065353216: bb45, otherwise: bb54];
    }

    bb45: {
        _67 = _4;
        _3 = move _67;
        _68 = Lt(_24, const 0_i32);
        switchInt(move _68) -> [0: bb47, otherwise: bb46];
    }

    bb46: {
        _69 = _3;
        _3 = Div(const 1f32, move _69);
        goto -> bb47;
    }

    bb47: {
        _70 = Lt(_23, const 0_i32);
        switchInt(move _70) -> [0: bb53, otherwise: bb48];
    }

    bb48: {
        _73 = _25;
        _74 = CheckedSub(_73, const 1065353216_i32);
        assert(!move (_74.1: bool), "attempt to compute `{} - {}`, which would overflow", move _73, const 1065353216_i32) -> [success: bb49, unwind unreachable];
    }

    bb49: {
        _72 = move (_74.0: i32);
        _75 = _21;
        _71 = BitOr(move _72, move _75);
        switchInt(move _71) -> [0: bb50, otherwise: bb51];
    }

    bb50: {
        _77 = _3;
        _78 = _3;
        _76 = Sub(move _77, move _78);
        _80 = _3;
        _81 = _3;
        _79 = Sub(move _80, move _81);
        _3 = Div(move _76, move _79);
        goto -> bb53;
    }

    bb51: {
        _82 = _21;
        switchInt(move _82) -> [1: bb52, otherwise: bb53];
    }

    bb52: {
        _83 = _3;
        _3 = Neg(move _83);
        goto -> bb53;
    }

    bb53: {
        _0 = _3;
        goto -> bb153;
    }

    bb54: {
        _13 = const 1f32;
        _84 = Lt(_23, const 0_i32);
        switchInt(move _84) -> [0: bb59, otherwise: bb55];
    }

    bb55: {
        _85 = _21;
        switchInt(move _85) -> [0: bb56, otherwise: bb57];
    }

    bb56: {
        _86 = Sub(_1, _1);
        _87 = Sub(_1, _1);
        _0 = Div(move _86, move _87);
        goto -> bb153;
    }

    bb57: {
        _88 = _21;
        switchInt(move _88) -> [1: bb58, otherwise: bb59];
    }

    bb58: {
        _13 = const -1f32;
        goto -> bb59;
    }

    bb59: {
        _89 = Gt(_26, const 1291845632_i32);
        switchInt(move _89) -> [0: bb71, otherwise: bb60];
    }

    bb60: {
        _91 = _25;
        _90 = Lt(move _91, const 1065353208_i32);
        switchInt(move _90) -> [0: bb64, otherwise: bb61];
    }

    bb61: {
        _92 = Lt(_24, const 0_i32);
        switchInt(move _92) -> [0: bb63, otherwise: bb62];
    }

    bb62: {
        _94 = _13;
        _93 = Mul(move _94, const _);
        _0 = Mul(move _93, const _);
        goto -> bb153;
    }

    bb63: {
        _96 = _13;
        _95 = Mul(move _96, const _);
        _0 = Mul(move _95, const _);
        goto -> bb153;
    }

    bb64: {
        _98 = _25;
        _97 = Gt(move _98, const 1065353223_i32);
        switchInt(move _97) -> [0: bb66, otherwise: bb65];
    }

    bb65: {
        _99 = Gt(_24, const 0_i32);
        switchInt(move _99) -> [0: bb68, otherwise: bb67];
    }

    bb66: {
        _104 = _4;
        _14 = Sub(move _104, const 1f32);
        _106 = _14;
        _107 = _14;
        _105 = Mul(move _106, move _107);
        _110 = _14;
        _113 = _14;
        _112 = Mul(move _113, const 0.25f32);
        _111 = Sub(const 0.333333343f32, move _112);
        _109 = Mul(move _110, move _111);
        _108 = Sub(const 0.5f32, move _109);
        _17 = Mul(move _105, move _108);
        _114 = _14;
        _15 = Mul(const _, move _114);
        _116 = _14;
        _115 = Mul(move _116, const _);
        _118 = _17;
        _117 = Mul(move _118, const _);
        _16 = Sub(move _115, move _117);
        _119 = _15;
        _120 = _16;
        _9 = Add(move _119, move _120);
        _122 = _9;
        _121 = f32::<impl f32>::to_bits(move _122) -> [return: bb69, unwind unreachable];
    }

    bb67: {
        _101 = _13;
        _100 = Mul(move _101, const _);
        _0 = Mul(move _100, const _);
        goto -> bb153;
    }

    bb68: {
        _103 = _13;
        _102 = Mul(move _103, const _);
        _0 = Mul(move _102, const _);
        goto -> bb153;
    }

    bb69: {
        _27 = move _121 as i32 (IntToInt);
        _126 = _27;
        _125 = move _126 as u32 (IntToInt);
        _124 = BitAnd(move _125, const 4294963200_u32);
        _123 = f32::<impl f32>::from_bits(move _124) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _9 = move _123;
        _127 = _16;
        _129 = _9;
        _130 = _15;
        _128 = Sub(move _129, move _130);
        _10 = Sub(move _127, move _128);
        goto -> bb112;
    }

    bb71: {
        _22 = const 0_i32;
        _137 = _25;
        _136 = Lt(move _137, const 8388608_i32);
        switchInt(move _136) -> [0: bb75, otherwise: bb72];
    }

    bb72: {
        _4 = Mul(_4, const _);
        _138 = CheckedSub(_22, const 24_i32);
        assert(!move (_138.1: bool), "attempt to compute `{} - {}`, which would overflow", _22, const 24_i32) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _22 = move (_138.0: i32);
        _140 = _4;
        _139 = f32::<impl f32>::to_bits(move _140) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        _25 = move _139 as i32 (IntToInt);
        goto -> bb75;
    }

    bb75: {
        _143 = _25;
        _144 = const 23_i32 as u32 (IntToInt);
        _145 = Lt(move _144, const 32_u32);
        assert(move _145, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _142 = Shr(move _143, const 23_i32);
        _146 = CheckedSub(_142, const 127_i32);
        assert(!move (_146.1: bool), "attempt to compute `{} - {}`, which would overflow", move _142, const 127_i32) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _141 = move (_146.0: i32);
        _147 = CheckedAdd(_22, _141);
        assert(!move (_147.1: bool), "attempt to compute `{} + {}`, which would overflow", _22, move _141) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _22 = move (_147.0: i32);
        _148 = _25;
        _19 = BitAnd(move _148, const 8388607_i32);
        _149 = _19;
        _25 = BitOr(move _149, const 1065353216_i32);
        _151 = _19;
        _150 = Le(move _151, const 1885297_i32);
        switchInt(move _150) -> [0: bb80, otherwise: bb79];
    }

    bb79: {
        _20 = const 0_i32;
        goto -> bb85;
    }

    bb80: {
        _153 = _19;
        _152 = Lt(move _153, const 6140887_i32);
        switchInt(move _152) -> [0: bb82, otherwise: bb81];
    }

    bb81: {
        _20 = const 1_i32;
        goto -> bb85;
    }

    bb82: {
        _20 = const 0_i32;
        _154 = CheckedAdd(_22, const 1_i32);
        assert(!move (_154.1: bool), "attempt to compute `{} + {}`, which would overflow", _22, const 1_i32) -> [success: bb83, unwind unreachable];
    }

    bb83: {
        _22 = move (_154.0: i32);
        _155 = CheckedSub(_25, const 8388608_i32);
        assert(!move (_155.1: bool), "attempt to compute `{} - {}`, which would overflow", _25, const 8388608_i32) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _25 = move (_155.0: i32);
        goto -> bb85;
    }

    bb85: {
        _158 = _25;
        _157 = move _158 as u32 (IntToInt);
        _156 = f32::<impl f32>::from_bits(move _157) -> [return: bb86, unwind unreachable];
    }

    bb86: {
        _4 = move _156;
        _159 = _4;
        _477 = const _;
        _163 = _477 as &[f32] (PointerCoercion(Unsize));
        _165 = _20;
        _164 = move _165 as usize (IntToInt);
        _162 = slice::<impl [f32]>::get::<usize>(move _163, move _164) -> [return: bb87, unwind unreachable];
    }

    bb87: {
        _161 = Option::<&f32>::unwrap(move _162) -> [return: bb88, unwind unreachable];
    }

    bb88: {
        _160 = (*_161);
        _15 = Sub(move _159, move _160);
        _167 = _4;
        _476 = const _;
        _171 = _476 as &[f32] (PointerCoercion(Unsize));
        _173 = _20;
        _172 = move _173 as usize (IntToInt);
        _170 = slice::<impl [f32]>::get::<usize>(move _171, move _172) -> [return: bb89, unwind unreachable];
    }

    bb89: {
        _169 = Option::<&f32>::unwrap(move _170) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _168 = (*_169);
        _166 = Add(move _167, move _168);
        _16 = Div(const 1f32, move _166);
        _174 = _15;
        _175 = _16;
        _12 = Mul(move _174, move _175);
        _132 = _12;
        _177 = _132;
        _176 = f32::<impl f32>::to_bits(move _177) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _27 = move _176 as i32 (IntToInt);
        _181 = _27;
        _180 = move _181 as u32 (IntToInt);
        _179 = BitAnd(move _180, const 4294963200_u32);
        _178 = f32::<impl f32>::from_bits(move _179) -> [return: bb92, unwind unreachable];
    }

    bb92: {
        _132 = move _178;
        _186 = _25;
        _185 = move _186 as u32 (IntToInt);
        _187 = const 1_i32 as u32 (IntToInt);
        _188 = Lt(move _187, const 32_u32);
        assert(move _188, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _184 = Shr(move _185, const 1_i32);
        _183 = BitAnd(move _184, const 4294963200_u32);
        _182 = BitOr(move _183, const 536870912_u32);
        _27 = move _182 as i32 (IntToInt);
        _193 = _27;
        _192 = move _193 as u32 (IntToInt);
        _194 = CheckedAdd(_192, const 4194304_u32);
        assert(!move (_194.1: bool), "attempt to compute `{} + {}`, which would overflow", move _192, const 4194304_u32) -> [success: bb94, unwind unreachable];
    }

    bb94: {
        _191 = move (_194.0: u32);
        _197 = _20;
        _196 = move _197 as u32 (IntToInt);
        _198 = const 21_i32 as u32 (IntToInt);
        _199 = Lt(move _198, const 32_u32);
        assert(move _199, "attempt to shift left by `{}`, which would overflow", const 21_i32) -> [success: bb95, unwind unreachable];
    }

    bb95: {
        _195 = Shl(move _196, const 21_i32);
        _200 = CheckedAdd(_191, _195);
        assert(!move (_200.1: bool), "attempt to compute `{} + {}`, which would overflow", move _191, move _195) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _190 = move (_200.0: u32);
        _189 = f32::<impl f32>::from_bits(move _190) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _134 = move _189;
        _201 = _4;
        _203 = _134;
        _475 = const _;
        _207 = _475 as &[f32] (PointerCoercion(Unsize));
        _209 = _20;
        _208 = move _209 as usize (IntToInt);
        _206 = slice::<impl [f32]>::get::<usize>(move _207, move _208) -> [return: bb98, unwind unreachable];
    }

    bb98: {
        _205 = Option::<&f32>::unwrap(move _206) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _204 = (*_205);
        _202 = Sub(move _203, move _204);
        _135 = Sub(move _201, move _202);
        _210 = _16;
        _213 = _15;
        _215 = _132;
        _216 = _134;
        _214 = Mul(move _215, move _216);
        _212 = Sub(move _213, move _214);
        _218 = _132;
        _219 = _135;
        _217 = Mul(move _218, move _219);
        _211 = Sub(move _212, move _217);
        _133 = Mul(move _210, move _211);
        _131 = Mul(_12, _12);
        _221 = _131;
        _222 = _131;
        _220 = Mul(move _221, move _222);
        _225 = _131;
        _228 = _131;
        _231 = _131;
        _234 = _131;
        _237 = _131;
        _236 = Mul(move _237, const _);
        _235 = Add(const _, move _236);
        _233 = Mul(move _234, move _235);
        _232 = Add(const _, move _233);
        _230 = Mul(move _231, move _232);
        _229 = Add(const _, move _230);
        _227 = Mul(move _228, move _229);
        _226 = Add(const _, move _227);
        _224 = Mul(move _225, move _226);
        _223 = Add(const _, move _224);
        _11 = Mul(move _220, move _223);
        _240 = _132;
        _239 = Add(move _240, _12);
        _238 = Mul(_133, move _239);
        _11 = Add(_11, move _238);
        _241 = _132;
        _242 = _132;
        _131 = Mul(move _241, move _242);
        _244 = _131;
        _243 = Add(const 3f32, move _244);
        _245 = _11;
        _134 = Add(move _243, move _245);
        _247 = _134;
        _246 = f32::<impl f32>::to_bits(move _247) -> [return: bb100, unwind unreachable];
    }

    bb100: {
        _27 = move _246 as i32 (IntToInt);
        _251 = _27;
        _250 = move _251 as u32 (IntToInt);
        _249 = BitAnd(move _250, const 4294963200_u32);
        _248 = f32::<impl f32>::from_bits(move _249) -> [return: bb101, unwind unreachable];
    }

    bb101: {
        _134 = move _248;
        _252 = _11;
        _255 = _134;
        _254 = Sub(move _255, const 3f32);
        _256 = _131;
        _253 = Sub(move _254, move _256);
        _135 = Sub(move _252, move _253);
        _257 = _132;
        _258 = _134;
        _15 = Mul(move _257, move _258);
        _260 = _134;
        _259 = Mul(_133, move _260);
        _262 = _135;
        _261 = Mul(move _262, _12);
        _16 = Add(move _259, move _261);
        _263 = _15;
        _264 = _16;
        _7 = Add(move _263, move _264);
        _266 = _7;
        _265 = f32::<impl f32>::to_bits(move _266) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _27 = move _265 as i32 (IntToInt);
        _270 = _27;
        _269 = move _270 as u32 (IntToInt);
        _268 = BitAnd(move _269, const 4294963200_u32);
        _267 = f32::<impl f32>::from_bits(move _268) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _7 = move _267;
        _271 = _16;
        _273 = _7;
        _274 = _15;
        _272 = Sub(move _273, move _274);
        _8 = Sub(move _271, move _272);
        _275 = _7;
        _5 = Mul(const _, move _275);
        _278 = _7;
        _277 = Mul(const _, move _278);
        _280 = _8;
        _279 = Mul(move _280, const _);
        _276 = Add(move _277, move _279);
        _474 = const _;
        _284 = _474 as &[f32] (PointerCoercion(Unsize));
        _286 = _20;
        _285 = move _286 as usize (IntToInt);
        _283 = slice::<impl [f32]>::get::<usize>(move _284, move _285) -> [return: bb104, unwind unreachable];
    }

    bb104: {
        _282 = Option::<&f32>::unwrap(move _283) -> [return: bb105, unwind unreachable];
    }

    bb105: {
        _281 = (*_282);
        _6 = Add(move _276, move _281);
        _287 = _22;
        _14 = move _287 as f32 (IntToFloat);
        _289 = Add(_5, _6);
        _473 = const _;
        _293 = _473 as &[f32] (PointerCoercion(Unsize));
        _295 = _20;
        _294 = move _295 as usize (IntToInt);
        _292 = slice::<impl [f32]>::get::<usize>(move _293, move _294) -> [return: bb106, unwind unreachable];
    }

    bb106: {
        _291 = Option::<&f32>::unwrap(move _292) -> [return: bb107, unwind unreachable];
    }

    bb107: {
        _290 = (*_291);
        _288 = Add(move _289, move _290);
        _296 = _14;
        _9 = Add(move _288, move _296);
        _298 = _9;
        _297 = f32::<impl f32>::to_bits(move _298) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        _27 = move _297 as i32 (IntToInt);
        _302 = _27;
        _301 = move _302 as u32 (IntToInt);
        _300 = BitAnd(move _301, const 4294963200_u32);
        _299 = f32::<impl f32>::from_bits(move _300) -> [return: bb109, unwind unreachable];
    }

    bb109: {
        _9 = move _299;
        _306 = _9;
        _307 = _14;
        _305 = Sub(move _306, move _307);
        _472 = const _;
        _311 = _472 as &[f32] (PointerCoercion(Unsize));
        _313 = _20;
        _312 = move _313 as usize (IntToInt);
        _310 = slice::<impl [f32]>::get::<usize>(move _311, move _312) -> [return: bb110, unwind unreachable];
    }

    bb110: {
        _309 = Option::<&f32>::unwrap(move _310) -> [return: bb111, unwind unreachable];
    }

    bb111: {
        _308 = (*_309);
        _304 = Sub(move _305, move _308);
        _303 = Sub(move _304, _5);
        _10 = Sub(_6, move _303);
        goto -> bb112;
    }

    bb112: {
        _314 = f32::<impl f32>::to_bits(_2) -> [return: bb113, unwind unreachable];
    }

    bb113: {
        _27 = move _314 as i32 (IntToInt);
        _318 = _27;
        _317 = move _318 as u32 (IntToInt);
        _316 = BitAnd(move _317, const 4294963200_u32);
        _315 = f32::<impl f32>::from_bits(move _316) -> [return: bb114, unwind unreachable];
    }

    bb114: {
        _320 = Sub(_2, _315);
        _321 = _9;
        _319 = Mul(move _320, move _321);
        _323 = _10;
        _322 = Mul(_2, move _323);
        _8 = Add(move _319, move _322);
        _324 = _9;
        _7 = Mul(_315, move _324);
        _325 = _8;
        _326 = _7;
        _3 = Add(move _325, move _326);
        _328 = _3;
        _327 = f32::<impl f32>::to_bits(move _328) -> [return: bb115, unwind unreachable];
    }

    bb115: {
        _19 = move _327 as i32 (IntToInt);
        _330 = _19;
        _329 = Gt(move _330, const 1124073472_i32);
        switchInt(move _329) -> [0: bb117, otherwise: bb116];
    }

    bb116: {
        _332 = _13;
        _331 = Mul(move _332, const _);
        _0 = Mul(move _331, const _);
        goto -> bb153;
    }

    bb117: {
        _333 = _19;
        switchInt(move _333) -> [1124073472: bb118, otherwise: bb120];
    }

    bb118: {
        _336 = _8;
        _335 = Add(move _336, const _);
        _338 = _3;
        _339 = _7;
        _337 = Sub(move _338, move _339);
        _334 = Gt(move _335, move _337);
        switchInt(move _334) -> [0: bb125, otherwise: bb119];
    }

    bb119: {
        _341 = _13;
        _340 = Mul(move _341, const _);
        _0 = Mul(move _340, const _);
        goto -> bb153;
    }

    bb120: {
        _344 = _19;
        _343 = BitAnd(move _344, const i32::MAX);
        _342 = Gt(move _343, const 1125515264_i32);
        switchInt(move _342) -> [0: bb122, otherwise: bb121];
    }

    bb121: {
        _346 = _13;
        _345 = Mul(move _346, const _);
        _0 = Mul(move _345, const _);
        goto -> bb153;
    }

    bb122: {
        _348 = _19;
        _347 = move _348 as u32 (IntToInt);
        switchInt(move _347) -> [3272998912: bb123, otherwise: bb125];
    }

    bb123: {
        _350 = _8;
        _352 = _3;
        _353 = _7;
        _351 = Sub(move _352, move _353);
        _349 = Le(move _350, move _351);
        switchInt(move _349) -> [0: bb125, otherwise: bb124];
    }

    bb124: {
        _355 = _13;
        _354 = Mul(move _355, const _);
        _0 = Mul(move _354, const _);
        goto -> bb153;
    }

    bb125: {
        _356 = _19;
        _18 = BitAnd(move _356, const i32::MAX);
        _358 = const 23_i32 as u32 (IntToInt);
        _359 = Lt(move _358, const 32_u32);
        assert(move _359, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb126, unwind unreachable];
    }

    bb126: {
        _357 = Shr(_18, const 23_i32);
        _360 = CheckedSub(_357, const 127_i32);
        assert(!move (_360.1: bool), "attempt to compute `{} - {}`, which would overflow", move _357, const 127_i32) -> [success: bb127, unwind unreachable];
    }

    bb127: {
        _20 = move (_360.0: i32);
        _22 = const 0_i32;
        _361 = Gt(_18, const 1056964608_i32);
        switchInt(move _361) -> [0: bb141, otherwise: bb128];
    }

    bb128: {
        _362 = _19;
        _365 = _20;
        _366 = CheckedAdd(_365, const 1_i32);
        assert(!move (_366.1: bool), "attempt to compute `{} + {}`, which would overflow", move _365, const 1_i32) -> [success: bb129, unwind unreachable];
    }

    bb129: {
        _364 = move (_366.0: i32);
        _367 = _364 as u32 (IntToInt);
        _368 = Lt(move _367, const 32_u32);
        assert(move _368, "attempt to shift right by `{}`, which would overflow", _364) -> [success: bb130, unwind unreachable];
    }

    bb130: {
        _363 = Shr(const 8388608_i32, move _364);
        _369 = CheckedAdd(_362, _363);
        assert(!move (_369.1: bool), "attempt to compute `{} + {}`, which would overflow", move _362, move _363) -> [success: bb131, unwind unreachable];
    }

    bb131: {
        _22 = move (_369.0: i32);
        _372 = _22;
        _371 = BitAnd(move _372, const i32::MAX);
        _373 = const 23_i32 as u32 (IntToInt);
        _374 = Lt(move _373, const 32_u32);
        assert(move _374, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb132, unwind unreachable];
    }

    bb132: {
        _370 = Shr(move _371, const 23_i32);
        _375 = CheckedSub(_370, const 127_i32);
        assert(!move (_375.1: bool), "attempt to compute `{} - {}`, which would overflow", move _370, const 127_i32) -> [success: bb133, unwind unreachable];
    }

    bb133: {
        _20 = move (_375.0: i32);
        _379 = _22;
        _378 = move _379 as u32 (IntToInt);
        _382 = _20;
        _383 = _382 as u32 (IntToInt);
        _384 = Lt(move _383, const 32_u32);
        assert(move _384, "attempt to shift right by `{}`, which would overflow", _382) -> [success: bb134, unwind unreachable];
    }

    bb134: {
        _381 = Shr(const 8388607_u32, move _382);
        _380 = Not(move _381);
        _377 = BitAnd(move _378, move _380);
        _376 = f32::<impl f32>::from_bits(move _377) -> [return: bb135, unwind unreachable];
    }

    bb135: {
        _14 = move _376;
        _387 = _22;
        _386 = BitAnd(move _387, const 8388607_i32);
        _385 = BitOr(move _386, const 8388608_i32);
        _389 = _20;
        _390 = CheckedSub(const 23_i32, _389);
        assert(!move (_390.1: bool), "attempt to compute `{} - {}`, which would overflow", const 23_i32, move _389) -> [success: bb136, unwind unreachable];
    }

    bb136: {
        _388 = move (_390.0: i32);
        _391 = _388 as u32 (IntToInt);
        _392 = Lt(move _391, const 32_u32);
        assert(move _392, "attempt to shift right by `{}`, which would overflow", _388) -> [success: bb137, unwind unreachable];
    }

    bb137: {
        _22 = Shr(move _385, move _388);
        _394 = _19;
        _393 = Lt(move _394, const 0_i32);
        switchInt(move _393) -> [0: bb140, otherwise: bb138];
    }

    bb138: {
        _395 = _22;
        _396 = Eq(_395, const i32::MIN);
        assert(!move _396, "attempt to negate `{}`, which would overflow", _395) -> [success: bb139, unwind unreachable];
    }

    bb139: {
        _22 = Neg(move _395);
        goto -> bb140;
    }

    bb140: {
        _397 = _14;
        _7 = Sub(_7, move _397);
        goto -> bb141;
    }

    bb141: {
        _398 = _8;
        _399 = _7;
        _14 = Add(move _398, move _399);
        _401 = _14;
        _400 = f32::<impl f32>::to_bits(move _401) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _27 = move _400 as i32 (IntToInt);
        _405 = _27;
        _404 = move _405 as u32 (IntToInt);
        _403 = BitAnd(move _404, const 4294934528_u32);
        _402 = f32::<impl f32>::from_bits(move _403) -> [return: bb143, unwind unreachable];
    }

    bb143: {
        _14 = move _402;
        _406 = _14;
        _15 = Mul(move _406, const _);
        _409 = _8;
        _411 = _14;
        _412 = _7;
        _410 = Sub(move _411, move _412);
        _408 = Sub(move _409, move _410);
        _407 = Mul(move _408, const _);
        _414 = _14;
        _413 = Mul(move _414, const _);
        _16 = Add(move _407, move _413);
        _415 = _15;
        _416 = _16;
        _3 = Add(move _415, move _416);
        _417 = _16;
        _419 = _3;
        _420 = _15;
        _418 = Sub(move _419, move _420);
        _17 = Sub(move _417, move _418);
        _421 = _3;
        _422 = _3;
        _14 = Mul(move _421, move _422);
        _423 = _3;
        _425 = _14;
        _428 = _14;
        _431 = _14;
        _434 = _14;
        _437 = _14;
        _436 = Mul(move _437, const _);
        _435 = Add(const _, move _436);
        _433 = Mul(move _434, move _435);
        _432 = Add(const _, move _433);
        _430 = Mul(move _431, move _432);
        _429 = Add(const _, move _430);
        _427 = Mul(move _428, move _429);
        _426 = Add(const _, move _427);
        _424 = Mul(move _425, move _426);
        _9 = Sub(move _423, move _424);
        _440 = _3;
        _441 = _9;
        _439 = Mul(move _440, move _441);
        _443 = _9;
        _442 = Sub(move _443, const 2f32);
        _438 = Div(move _439, move _442);
        _445 = _17;
        _447 = _3;
        _448 = _17;
        _446 = Mul(move _447, move _448);
        _444 = Add(move _445, move _446);
        _11 = Sub(move _438, move _444);
        _450 = _11;
        _451 = _3;
        _449 = Sub(move _450, move _451);
        _3 = Sub(const 1f32, move _449);
        _453 = _3;
        _452 = f32::<impl f32>::to_bits(move _453) -> [return: bb144, unwind unreachable];
    }

    bb144: {
        _19 = move _452 as i32 (IntToInt);
        _455 = _22;
        _456 = const 23_i32 as u32 (IntToInt);
        _457 = Lt(move _456, const 32_u32);
        assert(move _457, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb145, unwind unreachable];
    }

    bb145: {
        _454 = Shl(move _455, const 23_i32);
        _458 = CheckedAdd(_19, _454);
        assert(!move (_458.1: bool), "attempt to compute `{} + {}`, which would overflow", _19, move _454) -> [success: bb146, unwind unreachable];
    }

    bb146: {
        _19 = move (_458.0: i32);
        _461 = _19;
        _462 = const 23_i32 as u32 (IntToInt);
        _463 = Lt(move _462, const 32_u32);
        assert(move _463, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb147, unwind unreachable];
    }

    bb147: {
        _460 = Shr(move _461, const 23_i32);
        _459 = Le(move _460, const 0_i32);
        switchInt(move _459) -> [0: bb150, otherwise: bb148];
    }

    bb148: {
        _465 = _3;
        _466 = _22;
        _464 = scalbnf(move _465, move _466) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _3 = move _464;
        goto -> bb152;
    }

    bb150: {
        _469 = _19;
        _468 = move _469 as u32 (IntToInt);
        _467 = f32::<impl f32>::from_bits(move _468) -> [return: bb151, unwind unreachable];
    }

    bb151: {
        _3 = move _467;
        goto -> bb152;
    }

    bb152: {
        _470 = _13;
        _471 = _3;
        _0 = Mul(move _470, move _471);
        goto -> bb153;
    }

    bb153: {
        return;
    }
}

promoted[0] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in powf: &[f32; 2] = {
    let mut _0: &[f32; 2];
    let mut _1: [f32; 2];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn remainder(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let mut _3: (f64, i32);
    scope 1 {
        debug result => _0;
    }

    bb0: {
        _3 = remquo(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.0: f64);
        return;
    }
}

fn remainderf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;
    let mut _3: (f32, i32);
    scope 1 {
        debug result => _0;
    }

    bb0: {
        _3 = remquof(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = (_3.0: f32);
        return;
    }
}

fn remquo(_1: f64, _2: f64) -> (f64, i32) {
    debug x => _1;
    debug y => _2;
    let mut _0: (f64, i32);
    let _3: u64;
    let mut _4: f64;
    let mut _6: f64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: u64;
    let mut _16: u32;
    let mut _17: bool;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _23: u64;
    let mut _24: u64;
    let mut _25: u32;
    let mut _26: bool;
    let mut _30: u64;
    let mut _31: u64;
    let mut _32: u32;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: f64;
    let mut _36: i32;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: u64;
    let mut _45: u32;
    let mut _46: bool;
    let mut _47: f64;
    let mut _48: i32;
    let mut _49: u64;
    let mut _50: u32;
    let mut _51: bool;
    let mut _52: u64;
    let mut _53: u64;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: (i32, bool);
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: i32;
    let mut _61: i32;
    let mut _62: bool;
    let mut _63: (i32, bool);
    let mut _64: u32;
    let mut _65: bool;
    let mut _66: u64;
    let mut _67: u64;
    let mut _68: u32;
    let mut _69: bool;
    let mut _70: u64;
    let mut _71: u32;
    let mut _72: bool;
    let mut _73: i32;
    let mut _74: u64;
    let mut _75: u32;
    let mut _76: bool;
    let mut _77: u64;
    let mut _78: u64;
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: (i32, bool);
    let mut _82: u32;
    let mut _83: bool;
    let mut _84: i32;
    let mut _85: i32;
    let mut _86: i32;
    let mut _87: bool;
    let mut _88: (i32, bool);
    let mut _89: u32;
    let mut _90: bool;
    let mut _91: u64;
    let mut _92: u64;
    let mut _93: u32;
    let mut _94: bool;
    let mut _95: u64;
    let mut _96: u32;
    let mut _97: bool;
    let mut _98: bool;
    let mut _99: i32;
    let mut _100: i32;
    let mut _101: (i32, bool);
    let mut _102: i32;
    let mut _103: bool;
    let mut _104: i32;
    let mut _105: i32;
    let mut _106: f64;
    let mut _107: bool;
    let mut _108: i32;
    let mut _109: i32;
    let mut _110: u64;
    let mut _111: u64;
    let mut _112: u64;
    let mut _113: u64;
    let mut _114: u64;
    let mut _115: u32;
    let mut _116: bool;
    let mut _117: u64;
    let mut _118: (u32, bool);
    let mut _119: u32;
    let mut _120: bool;
    let mut _121: u32;
    let mut _122: bool;
    let mut _123: (i32, bool);
    let mut _124: u64;
    let mut _125: u64;
    let mut _126: u64;
    let mut _127: u64;
    let mut _128: u64;
    let mut _129: u32;
    let mut _130: bool;
    let mut _131: u64;
    let mut _132: (u32, bool);
    let mut _133: u64;
    let mut _134: u64;
    let mut _135: u64;
    let mut _136: u32;
    let mut _137: bool;
    let mut _138: u32;
    let mut _139: bool;
    let mut _140: (i32, bool);
    let mut _141: bool;
    let mut _142: i32;
    let mut _143: u64;
    let mut _144: u32;
    let mut _145: bool;
    let mut _146: (u64, bool);
    let mut _147: u64;
    let mut _148: u64;
    let mut _149: i32;
    let mut _150: u32;
    let mut _151: bool;
    let mut _152: i32;
    let mut _153: i32;
    let mut _154: i32;
    let mut _155: bool;
    let mut _156: (i32, bool);
    let mut _157: u32;
    let mut _158: bool;
    let mut _159: f64;
    let mut _160: u64;
    let mut _161: f64;
    let mut _162: bool;
    let mut _163: i32;
    let mut _164: i32;
    let mut _165: bool;
    let mut _166: i32;
    let mut _167: i32;
    let mut _168: (i32, bool);
    let mut _169: i32;
    let mut _170: bool;
    let mut _171: f64;
    let mut _172: f64;
    let mut _173: f64;
    let mut _174: bool;
    let mut _175: f64;
    let mut _176: f64;
    let mut _177: f64;
    let mut _178: u32;
    let mut _179: u32;
    let mut _180: bool;
    let mut _181: f64;
    let mut _182: u32;
    let mut _183: u32;
    let mut _185: bool;
    let mut _186: i32;
    let mut _187: u32;
    let mut _188: bool;
    let mut _189: u32;
    let mut _190: f64;
    let mut _191: f64;
    let mut _192: i32;
    let mut _193: f64;
    let mut _194: i32;
    scope 1 {
        debug ux => _3;
        let mut _5: u64;
        scope 2 {
            debug uy => _5;
            let mut _7: i32;
            scope 3 {
                debug ex => _7;
                let mut _12: i32;
                scope 4 {
                    debug ey => _12;
                    let _18: bool;
                    scope 5 {
                        debug sx => _18;
                        let _22: bool;
                        scope 6 {
                            debug sy => _22;
                            let mut _27: u32;
                            scope 7 {
                                debug q => _27;
                                let mut _28: u64;
                                scope 8 {
                                    debug i => _28;
                                    let mut _29: u64;
                                    scope 9 {
                                        debug uxi => _29;
                                        let _184: i32;
                                        scope 10 {
                                            debug quo => _184;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = _1;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _5 = f64::<impl f64>::to_bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(_3, const 52_i32);
        _8 = BitAnd(move _9, const 2047_u64);
        _7 = move _8 as i32 (IntToInt);
        _15 = _5;
        _16 = const 52_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 64_u32);
        assert(move _17, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _14 = Shr(move _15, const 52_i32);
        _13 = BitAnd(move _14, const 2047_u64);
        _12 = move _13 as i32 (IntToInt);
        _20 = const 63_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = Shr(_3, const 63_i32);
        _18 = Ne(move _19, const 0_u64);
        _24 = _5;
        _25 = const 63_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 64_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _23 = Shr(move _24, const 63_i32);
        _22 = Ne(move _23, const 0_u64);
        _29 = _3;
        _31 = _5;
        _32 = const 1_i32 as u32 (IntToInt);
        _33 = Lt(move _32, const 64_u32);
        assert(move _33, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _30 = Shl(move _31, const 1_i32);
        switchInt(move _30) -> [0: bb11, otherwise: bb8];
    }

    bb8: {
        _35 = _2;
        _34 = f64::<impl f64>::is_nan(move _35) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _34) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _36 = _7;
        switchInt(move _36) -> [2047: bb11, otherwise: bb12];
    }

    bb11: {
        _39 = _1;
        _40 = _2;
        _38 = Mul(move _39, move _40);
        _42 = _1;
        _43 = _2;
        _41 = Mul(move _42, move _43);
        _37 = Div(move _38, move _41);
        _0 = (move _37, const 0_i32);
        goto -> bb99;
    }

    bb12: {
        _45 = const 1_i32 as u32 (IntToInt);
        _46 = Lt(move _45, const 64_u32);
        assert(move _46, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _44 = Shl(_3, const 1_i32);
        switchInt(move _44) -> [0: bb14, otherwise: bb15];
    }

    bb14: {
        _47 = _1;
        _0 = (move _47, const 0_i32);
        goto -> bb99;
    }

    bb15: {
        _48 = _7;
        switchInt(move _48) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        _49 = _29;
        _50 = const 12_i32 as u32 (IntToInt);
        _51 = Lt(move _50, const 64_u32);
        assert(move _51, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb18, unwind unreachable];
    }

    bb17: {
        _67 = Not(const 0_u64);
        _68 = const 12_i32 as u32 (IntToInt);
        _69 = Lt(move _68, const 64_u32);
        assert(move _69, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb28, unwind unreachable];
    }

    bb18: {
        _28 = Shl(move _49, const 12_i32);
        goto -> bb19;
    }

    bb19: {
        _53 = _28;
        _54 = const 63_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 64_u32);
        assert(move _55, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _52 = Shr(move _53, const 63_i32);
        switchInt(move _52) -> [0: bb21, otherwise: bb24];
    }

    bb21: {
        _56 = CheckedSub(_7, const 1_i32);
        assert(!move (_56.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _7 = move (_56.0: i32);
        _57 = const 1_i32 as u32 (IntToInt);
        _58 = Lt(move _57, const 64_u32);
        assert(move _58, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _28 = Shl(_28, const 1_i32);
        goto -> bb19;
    }

    bb24: {
        _61 = _7;
        _62 = Eq(_61, const i32::MIN);
        assert(!move _62, "attempt to negate `{}`, which would overflow", _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _60 = Neg(move _61);
        _63 = CheckedAdd(_60, const 1_i32);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", move _60, const 1_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _59 = move (_63.0: i32);
        _64 = _59 as u32 (IntToInt);
        _65 = Lt(move _64, const 64_u32);
        assert(move _65, "attempt to shift left by `{}`, which would overflow", _59) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _29 = Shl(_29, move _59);
        goto -> bb30;
    }

    bb28: {
        _66 = Shr(move _67, const 12_i32);
        _29 = BitAnd(_29, move _66);
        _71 = const 52_i32 as u32 (IntToInt);
        _72 = Lt(move _71, const 64_u32);
        assert(move _72, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _70 = Shl(const 1_u64, const 52_i32);
        _29 = BitOr(_29, move _70);
        goto -> bb30;
    }

    bb30: {
        _73 = _12;
        switchInt(move _73) -> [0: bb31, otherwise: bb42];
    }

    bb31: {
        _74 = _5;
        _75 = const 12_i32 as u32 (IntToInt);
        _76 = Lt(move _75, const 64_u32);
        assert(move _76, "attempt to shift left by `{}`, which would overflow", const 12_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _28 = Shl(move _74, const 12_i32);
        goto -> bb33;
    }

    bb33: {
        _78 = _28;
        _79 = const 63_i32 as u32 (IntToInt);
        _80 = Lt(move _79, const 64_u32);
        assert(move _80, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _77 = Shr(move _78, const 63_i32);
        switchInt(move _77) -> [0: bb35, otherwise: bb38];
    }

    bb35: {
        _81 = CheckedSub(_12, const 1_i32);
        assert(!move (_81.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 1_i32) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _12 = move (_81.0: i32);
        _82 = const 1_i32 as u32 (IntToInt);
        _83 = Lt(move _82, const 64_u32);
        assert(move _83, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _28 = Shl(_28, const 1_i32);
        goto -> bb33;
    }

    bb38: {
        _86 = _12;
        _87 = Eq(_86, const i32::MIN);
        assert(!move _87, "attempt to negate `{}`, which would overflow", _86) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _85 = Neg(move _86);
        _88 = CheckedAdd(_85, const 1_i32);
        assert(!move (_88.1: bool), "attempt to compute `{} + {}`, which would overflow", move _85, const 1_i32) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _84 = move (_88.0: i32);
        _89 = _84 as u32 (IntToInt);
        _90 = Lt(move _89, const 64_u32);
        assert(move _90, "attempt to shift left by `{}`, which would overflow", _84) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _5 = Shl(_5, move _84);
        goto -> bb45;
    }

    bb42: {
        _92 = Not(const 0_u64);
        _93 = const 12_i32 as u32 (IntToInt);
        _94 = Lt(move _93, const 64_u32);
        assert(move _94, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _91 = Shr(move _92, const 12_i32);
        _5 = BitAnd(_5, move _91);
        _96 = const 52_i32 as u32 (IntToInt);
        _97 = Lt(move _96, const 64_u32);
        assert(move _97, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _95 = Shl(const 1_u64, const 52_i32);
        _5 = BitOr(_5, move _95);
        goto -> bb45;
    }

    bb45: {
        _27 = const 0_u32;
        _100 = _7;
        _101 = CheckedAdd(_100, const 1_i32);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", move _100, const 1_i32) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _99 = move (_101.0: i32);
        _102 = _12;
        _98 = Ne(move _99, move _102);
        switchInt(move _98) -> [0: bb71, otherwise: bb47];
    }

    bb47: {
        _104 = _7;
        _105 = _12;
        _103 = Lt(move _104, move _105);
        switchInt(move _103) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _106 = _1;
        _0 = (move _106, const 0_i32);
        goto -> bb99;
    }

    bb49: {
        _108 = _7;
        _109 = _12;
        _107 = Gt(move _108, move _109);
        switchInt(move _107) -> [0: bb59, otherwise: bb50];
    }

    bb50: {
        _111 = _29;
        _112 = _5;
        _110 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _111, move _112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _28 = move _110;
        _114 = _28;
        _115 = const 63_i32 as u32 (IntToInt);
        _116 = Lt(move _115, const 64_u32);
        assert(move _116, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _113 = Shr(move _114, const 63_i32);
        switchInt(move _113) -> [0: bb53, otherwise: bb55];
    }

    bb53: {
        _117 = _28;
        _29 = move _117;
        _118 = CheckedAdd(_27, const 1_u32);
        assert(!move (_118.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_u32) -> [success: bb54, unwind unreachable];
    }

    bb54: {
        _27 = move (_118.0: u32);
        goto -> bb55;
    }

    bb55: {
        _119 = const 1_i32 as u32 (IntToInt);
        _120 = Lt(move _119, const 64_u32);
        assert(move _120, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _29 = Shl(_29, const 1_i32);
        _121 = const 1_i32 as u32 (IntToInt);
        _122 = Lt(move _121, const 32_u32);
        assert(move _122, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _27 = Shl(_27, const 1_i32);
        _123 = CheckedSub(_7, const 1_i32);
        assert(!move (_123.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb58, unwind unreachable];
    }

    bb58: {
        _7 = move (_123.0: i32);
        goto -> bb49;
    }

    bb59: {
        _125 = _29;
        _126 = _5;
        _124 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _125, move _126) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _28 = move _124;
        _128 = _28;
        _129 = const 63_i32 as u32 (IntToInt);
        _130 = Lt(move _129, const 64_u32);
        assert(move _130, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _127 = Shr(move _128, const 63_i32);
        switchInt(move _127) -> [0: bb62, otherwise: bb64];
    }

    bb62: {
        _131 = _28;
        _29 = move _131;
        _132 = CheckedAdd(_27, const 1_u32);
        assert(!move (_132.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_u32) -> [success: bb63, unwind unreachable];
    }

    bb63: {
        _27 = move (_132.0: u32);
        goto -> bb64;
    }

    bb64: {
        _133 = _29;
        switchInt(move _133) -> [0: bb65, otherwise: bb66];
    }

    bb65: {
        _7 = const -60_i32;
        goto -> bb71;
    }

    bb66: {
        _135 = _29;
        _136 = const 52_i32 as u32 (IntToInt);
        _137 = Lt(move _136, const 64_u32);
        assert(move _137, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb67, unwind unreachable];
    }

    bb67: {
        _134 = Shr(move _135, const 52_i32);
        switchInt(move _134) -> [0: bb68, otherwise: bb71];
    }

    bb68: {
        _138 = const 1_i32 as u32 (IntToInt);
        _139 = Lt(move _138, const 64_u32);
        assert(move _139, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _29 = Shl(_29, const 1_i32);
        _140 = CheckedSub(_7, const 1_i32);
        assert(!move (_140.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb70, unwind unreachable];
    }

    bb70: {
        _7 = move (_140.0: i32);
        goto -> bb66;
    }

    bb71: {
        _142 = _7;
        _141 = Gt(move _142, const 0_i32);
        switchInt(move _141) -> [0: bb76, otherwise: bb72];
    }

    bb72: {
        _144 = const 52_i32 as u32 (IntToInt);
        _145 = Lt(move _144, const 64_u32);
        assert(move _145, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _143 = Shl(const 1_u64, const 52_i32);
        _146 = CheckedSub(_29, _143);
        assert(!move (_146.1: bool), "attempt to compute `{} - {}`, which would overflow", _29, move _143) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _29 = move (_146.0: u64);
        _149 = _7;
        _148 = move _149 as u64 (IntToInt);
        _150 = const 52_i32 as u32 (IntToInt);
        _151 = Lt(move _150, const 64_u32);
        assert(move _151, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _147 = Shl(move _148, const 52_i32);
        _29 = BitOr(_29, move _147);
        goto -> bb80;
    }

    bb76: {
        _154 = _7;
        _155 = Eq(_154, const i32::MIN);
        assert(!move _155, "attempt to negate `{}`, which would overflow", _154) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _153 = Neg(move _154);
        _156 = CheckedAdd(_153, const 1_i32);
        assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", move _153, const 1_i32) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _152 = move (_156.0: i32);
        _157 = _152 as u32 (IntToInt);
        _158 = Lt(move _157, const 64_u32);
        assert(move _158, "attempt to shift right by `{}`, which would overflow", _152) -> [success: bb79, unwind unreachable];
    }

    bb79: {
        _29 = Shr(_29, move _152);
        goto -> bb80;
    }

    bb80: {
        _160 = _29;
        _159 = f64::<impl f64>::from_bits(move _160) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _1 = move _159;
        switchInt(_22) -> [0: bb83, otherwise: bb82];
    }

    bb82: {
        _161 = _2;
        _2 = Neg(move _161);
        goto -> bb83;
    }

    bb83: {
        _163 = _7;
        _164 = _12;
        _162 = Eq(move _163, move _164);
        switchInt(move _162) -> [0: bb84, otherwise: bb90];
    }

    bb84: {
        _167 = _7;
        _168 = CheckedAdd(_167, const 1_i32);
        assert(!move (_168.1: bool), "attempt to compute `{} + {}`, which would overflow", move _167, const 1_i32) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _166 = move (_168.0: i32);
        _169 = _12;
        _165 = Eq(move _166, move _169);
        switchInt(move _165) -> [0: bb92, otherwise: bb86];
    }

    bb86: {
        _172 = _1;
        _171 = Mul(const 2f64, move _172);
        _173 = _2;
        _170 = Gt(move _171, move _173);
        switchInt(move _170) -> [0: bb87, otherwise: bb90];
    }

    bb87: {
        _176 = _1;
        _175 = Mul(const 2f64, move _176);
        _177 = _2;
        _174 = Eq(move _175, move _177);
        switchInt(move _174) -> [0: bb92, otherwise: bb88];
    }

    bb88: {
        _179 = _27;
        _180 = Eq(const 2_u32, const 0_u32);
        assert(!move _180, "attempt to calculate the remainder of `{}` with a divisor of zero", _179) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _178 = Rem(move _179, const 2_u32);
        switchInt(move _178) -> [0: bb92, otherwise: bb90];
    }

    bb90: {
        _181 = _2;
        _1 = Sub(_1, move _181);
        _183 = _27;
        _182 = rustc_std_workspace_core::num::<impl u32>::wrapping_add(move _183, const 1_u32) -> [return: bb91, unwind unreachable];
    }

    bb91: {
        _27 = move _182;
        goto -> bb92;
    }

    bb92: {
        _27 = BitAnd(_27, const 2147483647_u32);
        _185 = BitXor(_18, _22);
        switchInt(move _185) -> [0: bb95, otherwise: bb93];
    }

    bb93: {
        _187 = _27;
        _186 = move _187 as i32 (IntToInt);
        _188 = Eq(_186, const i32::MIN);
        assert(!move _188, "attempt to negate `{}`, which would overflow", _186) -> [success: bb94, unwind unreachable];
    }

    bb94: {
        _184 = Neg(move _186);
        goto -> bb96;
    }

    bb95: {
        _189 = _27;
        _184 = move _189 as i32 (IntToInt);
        goto -> bb96;
    }

    bb96: {
        switchInt(_18) -> [0: bb98, otherwise: bb97];
    }

    bb97: {
        _191 = _1;
        _190 = Neg(move _191);
        _192 = _184;
        _0 = (move _190, move _192);
        goto -> bb99;
    }

    bb98: {
        _193 = _1;
        _194 = _184;
        _0 = (move _193, move _194);
        goto -> bb99;
    }

    bb99: {
        return;
    }
}

fn remquof(_1: f32, _2: f32) -> (f32, i32) {
    debug x => _1;
    debug y => _2;
    let mut _0: (f32, i32);
    let _3: u32;
    let mut _4: f32;
    let mut _6: f32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _13: u32;
    let mut _14: u32;
    let mut _15: u32;
    let mut _16: u32;
    let mut _17: bool;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: bool;
    let mut _23: u32;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: bool;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: u32;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: f32;
    let mut _36: i32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f32;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: u32;
    let mut _45: u32;
    let mut _46: bool;
    let mut _47: f32;
    let mut _48: i32;
    let mut _49: u32;
    let mut _50: u32;
    let mut _51: bool;
    let mut _52: u32;
    let mut _53: u32;
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: (i32, bool);
    let mut _57: u32;
    let mut _58: bool;
    let mut _59: i32;
    let mut _60: i32;
    let mut _61: i32;
    let mut _62: bool;
    let mut _63: (i32, bool);
    let mut _64: u32;
    let mut _65: bool;
    let mut _66: u32;
    let mut _67: u32;
    let mut _68: u32;
    let mut _69: bool;
    let mut _70: u32;
    let mut _71: u32;
    let mut _72: bool;
    let mut _73: i32;
    let mut _74: u32;
    let mut _75: u32;
    let mut _76: bool;
    let mut _77: u32;
    let mut _78: u32;
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: (i32, bool);
    let mut _82: u32;
    let mut _83: bool;
    let mut _84: i32;
    let mut _85: i32;
    let mut _86: i32;
    let mut _87: bool;
    let mut _88: (i32, bool);
    let mut _89: u32;
    let mut _90: bool;
    let mut _91: u32;
    let mut _92: u32;
    let mut _93: u32;
    let mut _94: bool;
    let mut _95: u32;
    let mut _96: u32;
    let mut _97: bool;
    let mut _98: bool;
    let mut _99: i32;
    let mut _100: i32;
    let mut _101: (i32, bool);
    let mut _102: i32;
    let mut _103: bool;
    let mut _104: i32;
    let mut _105: i32;
    let mut _106: f32;
    let mut _107: bool;
    let mut _108: i32;
    let mut _109: i32;
    let mut _110: u32;
    let mut _111: u32;
    let mut _112: u32;
    let mut _113: u32;
    let mut _114: u32;
    let mut _115: u32;
    let mut _116: bool;
    let mut _117: u32;
    let mut _118: (u32, bool);
    let mut _119: u32;
    let mut _120: bool;
    let mut _121: u32;
    let mut _122: bool;
    let mut _123: (i32, bool);
    let mut _124: u32;
    let mut _125: u32;
    let mut _126: u32;
    let mut _127: u32;
    let mut _128: u32;
    let mut _129: u32;
    let mut _130: bool;
    let mut _131: u32;
    let mut _132: (u32, bool);
    let mut _133: u32;
    let mut _134: u32;
    let mut _135: u32;
    let mut _136: u32;
    let mut _137: bool;
    let mut _138: u32;
    let mut _139: bool;
    let mut _140: (i32, bool);
    let mut _141: bool;
    let mut _142: i32;
    let mut _143: u32;
    let mut _144: u32;
    let mut _145: bool;
    let mut _146: (u32, bool);
    let mut _147: u32;
    let mut _148: u32;
    let mut _149: i32;
    let mut _150: u32;
    let mut _151: bool;
    let mut _152: i32;
    let mut _153: i32;
    let mut _154: i32;
    let mut _155: bool;
    let mut _156: (i32, bool);
    let mut _157: u32;
    let mut _158: bool;
    let mut _159: f32;
    let mut _160: u32;
    let mut _161: f32;
    let mut _162: bool;
    let mut _163: i32;
    let mut _164: i32;
    let mut _165: bool;
    let mut _166: i32;
    let mut _167: i32;
    let mut _168: (i32, bool);
    let mut _169: i32;
    let mut _170: bool;
    let mut _171: f32;
    let mut _172: f32;
    let mut _173: f32;
    let mut _174: bool;
    let mut _175: f32;
    let mut _176: f32;
    let mut _177: f32;
    let mut _178: u32;
    let mut _179: u32;
    let mut _180: bool;
    let mut _181: f32;
    let mut _182: (u32, bool);
    let mut _184: bool;
    let mut _185: i32;
    let mut _186: u32;
    let mut _187: bool;
    let mut _188: u32;
    let mut _189: f32;
    let mut _190: f32;
    let mut _191: i32;
    let mut _192: f32;
    let mut _193: i32;
    scope 1 {
        debug ux => _3;
        let mut _5: u32;
        scope 2 {
            debug uy => _5;
            let mut _7: i32;
            scope 3 {
                debug ex => _7;
                let mut _12: i32;
                scope 4 {
                    debug ey => _12;
                    let _18: bool;
                    scope 5 {
                        debug sx => _18;
                        let _22: bool;
                        scope 6 {
                            debug sy => _22;
                            let mut _27: u32;
                            scope 7 {
                                debug q => _27;
                                let mut _28: u32;
                                scope 8 {
                                    debug i => _28;
                                    let mut _29: u32;
                                    scope 9 {
                                        debug uxi => _29;
                                        let _183: i32;
                                        scope 10 {
                                            debug quo => _183;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = _1;
        _3 = f32::<impl f32>::to_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _5 = f32::<impl f32>::to_bits(move _6) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(_3, const 23_i32);
        _8 = BitAnd(move _9, const 255_u32);
        _7 = move _8 as i32 (IntToInt);
        _15 = _5;
        _16 = const 23_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 32_u32);
        assert(move _17, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _14 = Shr(move _15, const 23_i32);
        _13 = BitAnd(move _14, const 255_u32);
        _12 = move _13 as i32 (IntToInt);
        _20 = const 31_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 32_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _19 = Shr(_3, const 31_i32);
        _18 = Ne(move _19, const 0_u32);
        _24 = _5;
        _25 = const 31_i32 as u32 (IntToInt);
        _26 = Lt(move _25, const 32_u32);
        assert(move _26, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _23 = Shr(move _24, const 31_i32);
        _22 = Ne(move _23, const 0_u32);
        _29 = _3;
        _31 = _5;
        _32 = const 1_i32 as u32 (IntToInt);
        _33 = Lt(move _32, const 32_u32);
        assert(move _33, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _30 = Shl(move _31, const 1_i32);
        switchInt(move _30) -> [0: bb11, otherwise: bb8];
    }

    bb8: {
        _35 = _2;
        _34 = f32::<impl f32>::is_nan(move _35) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        switchInt(move _34) -> [0: bb10, otherwise: bb11];
    }

    bb10: {
        _36 = _7;
        switchInt(move _36) -> [255: bb11, otherwise: bb12];
    }

    bb11: {
        _39 = _1;
        _40 = _2;
        _38 = Mul(move _39, move _40);
        _42 = _1;
        _43 = _2;
        _41 = Mul(move _42, move _43);
        _37 = Div(move _38, move _41);
        _0 = (move _37, const 0_i32);
        goto -> bb99;
    }

    bb12: {
        _45 = const 1_i32 as u32 (IntToInt);
        _46 = Lt(move _45, const 32_u32);
        assert(move _46, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _44 = Shl(_3, const 1_i32);
        switchInt(move _44) -> [0: bb14, otherwise: bb15];
    }

    bb14: {
        _47 = _1;
        _0 = (move _47, const 0_i32);
        goto -> bb99;
    }

    bb15: {
        _48 = _7;
        switchInt(move _48) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        _49 = _29;
        _50 = const 9_i32 as u32 (IntToInt);
        _51 = Lt(move _50, const 32_u32);
        assert(move _51, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb18, unwind unreachable];
    }

    bb17: {
        _67 = Not(const 0_u32);
        _68 = const 9_i32 as u32 (IntToInt);
        _69 = Lt(move _68, const 32_u32);
        assert(move _69, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb28, unwind unreachable];
    }

    bb18: {
        _28 = Shl(move _49, const 9_i32);
        goto -> bb19;
    }

    bb19: {
        _53 = _28;
        _54 = const 31_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 32_u32);
        assert(move _55, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _52 = Shr(move _53, const 31_i32);
        switchInt(move _52) -> [0: bb21, otherwise: bb24];
    }

    bb21: {
        _56 = CheckedSub(_7, const 1_i32);
        assert(!move (_56.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _7 = move (_56.0: i32);
        _57 = const 1_i32 as u32 (IntToInt);
        _58 = Lt(move _57, const 32_u32);
        assert(move _58, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _28 = Shl(_28, const 1_i32);
        goto -> bb19;
    }

    bb24: {
        _61 = _7;
        _62 = Eq(_61, const i32::MIN);
        assert(!move _62, "attempt to negate `{}`, which would overflow", _61) -> [success: bb25, unwind unreachable];
    }

    bb25: {
        _60 = Neg(move _61);
        _63 = CheckedAdd(_60, const 1_i32);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", move _60, const 1_i32) -> [success: bb26, unwind unreachable];
    }

    bb26: {
        _59 = move (_63.0: i32);
        _64 = _59 as u32 (IntToInt);
        _65 = Lt(move _64, const 32_u32);
        assert(move _65, "attempt to shift left by `{}`, which would overflow", _59) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _29 = Shl(_29, move _59);
        goto -> bb30;
    }

    bb28: {
        _66 = Shr(move _67, const 9_i32);
        _29 = BitAnd(_29, move _66);
        _71 = const 23_i32 as u32 (IntToInt);
        _72 = Lt(move _71, const 32_u32);
        assert(move _72, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _70 = Shl(const 1_u32, const 23_i32);
        _29 = BitOr(_29, move _70);
        goto -> bb30;
    }

    bb30: {
        _73 = _12;
        switchInt(move _73) -> [0: bb31, otherwise: bb42];
    }

    bb31: {
        _74 = _5;
        _75 = const 9_i32 as u32 (IntToInt);
        _76 = Lt(move _75, const 32_u32);
        assert(move _76, "attempt to shift left by `{}`, which would overflow", const 9_i32) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _28 = Shl(move _74, const 9_i32);
        goto -> bb33;
    }

    bb33: {
        _78 = _28;
        _79 = const 31_i32 as u32 (IntToInt);
        _80 = Lt(move _79, const 32_u32);
        assert(move _80, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _77 = Shr(move _78, const 31_i32);
        switchInt(move _77) -> [0: bb35, otherwise: bb38];
    }

    bb35: {
        _81 = CheckedSub(_12, const 1_i32);
        assert(!move (_81.1: bool), "attempt to compute `{} - {}`, which would overflow", _12, const 1_i32) -> [success: bb36, unwind unreachable];
    }

    bb36: {
        _12 = move (_81.0: i32);
        _82 = const 1_i32 as u32 (IntToInt);
        _83 = Lt(move _82, const 32_u32);
        assert(move _83, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb37, unwind unreachable];
    }

    bb37: {
        _28 = Shl(_28, const 1_i32);
        goto -> bb33;
    }

    bb38: {
        _86 = _12;
        _87 = Eq(_86, const i32::MIN);
        assert(!move _87, "attempt to negate `{}`, which would overflow", _86) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _85 = Neg(move _86);
        _88 = CheckedAdd(_85, const 1_i32);
        assert(!move (_88.1: bool), "attempt to compute `{} + {}`, which would overflow", move _85, const 1_i32) -> [success: bb40, unwind unreachable];
    }

    bb40: {
        _84 = move (_88.0: i32);
        _89 = _84 as u32 (IntToInt);
        _90 = Lt(move _89, const 32_u32);
        assert(move _90, "attempt to shift left by `{}`, which would overflow", _84) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _5 = Shl(_5, move _84);
        goto -> bb45;
    }

    bb42: {
        _92 = Not(const 0_u32);
        _93 = const 9_i32 as u32 (IntToInt);
        _94 = Lt(move _93, const 32_u32);
        assert(move _94, "attempt to shift right by `{}`, which would overflow", const 9_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _91 = Shr(move _92, const 9_i32);
        _5 = BitAnd(_5, move _91);
        _96 = const 23_i32 as u32 (IntToInt);
        _97 = Lt(move _96, const 32_u32);
        assert(move _97, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _95 = Shl(const 1_u32, const 23_i32);
        _5 = BitOr(_5, move _95);
        goto -> bb45;
    }

    bb45: {
        _27 = const 0_u32;
        _100 = _7;
        _101 = CheckedAdd(_100, const 1_i32);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", move _100, const 1_i32) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _99 = move (_101.0: i32);
        _102 = _12;
        _98 = Ne(move _99, move _102);
        switchInt(move _98) -> [0: bb71, otherwise: bb47];
    }

    bb47: {
        _104 = _7;
        _105 = _12;
        _103 = Lt(move _104, move _105);
        switchInt(move _103) -> [0: bb49, otherwise: bb48];
    }

    bb48: {
        _106 = _1;
        _0 = (move _106, const 0_i32);
        goto -> bb99;
    }

    bb49: {
        _108 = _7;
        _109 = _12;
        _107 = Gt(move _108, move _109);
        switchInt(move _107) -> [0: bb59, otherwise: bb50];
    }

    bb50: {
        _111 = _29;
        _112 = _5;
        _110 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _111, move _112) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _28 = move _110;
        _114 = _28;
        _115 = const 31_i32 as u32 (IntToInt);
        _116 = Lt(move _115, const 32_u32);
        assert(move _116, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _113 = Shr(move _114, const 31_i32);
        switchInt(move _113) -> [0: bb53, otherwise: bb55];
    }

    bb53: {
        _117 = _28;
        _29 = move _117;
        _118 = CheckedAdd(_27, const 1_u32);
        assert(!move (_118.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_u32) -> [success: bb54, unwind unreachable];
    }

    bb54: {
        _27 = move (_118.0: u32);
        goto -> bb55;
    }

    bb55: {
        _119 = const 1_i32 as u32 (IntToInt);
        _120 = Lt(move _119, const 32_u32);
        assert(move _120, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _29 = Shl(_29, const 1_i32);
        _121 = const 1_i32 as u32 (IntToInt);
        _122 = Lt(move _121, const 32_u32);
        assert(move _122, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _27 = Shl(_27, const 1_i32);
        _123 = CheckedSub(_7, const 1_i32);
        assert(!move (_123.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb58, unwind unreachable];
    }

    bb58: {
        _7 = move (_123.0: i32);
        goto -> bb49;
    }

    bb59: {
        _125 = _29;
        _126 = _5;
        _124 = rustc_std_workspace_core::num::<impl u32>::wrapping_sub(move _125, move _126) -> [return: bb60, unwind unreachable];
    }

    bb60: {
        _28 = move _124;
        _128 = _28;
        _129 = const 31_i32 as u32 (IntToInt);
        _130 = Lt(move _129, const 32_u32);
        assert(move _130, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _127 = Shr(move _128, const 31_i32);
        switchInt(move _127) -> [0: bb62, otherwise: bb64];
    }

    bb62: {
        _131 = _28;
        _29 = move _131;
        _132 = CheckedAdd(_27, const 1_u32);
        assert(!move (_132.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_u32) -> [success: bb63, unwind unreachable];
    }

    bb63: {
        _27 = move (_132.0: u32);
        goto -> bb64;
    }

    bb64: {
        _133 = _29;
        switchInt(move _133) -> [0: bb65, otherwise: bb66];
    }

    bb65: {
        _7 = const -30_i32;
        goto -> bb71;
    }

    bb66: {
        _135 = _29;
        _136 = const 23_i32 as u32 (IntToInt);
        _137 = Lt(move _136, const 32_u32);
        assert(move _137, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb67, unwind unreachable];
    }

    bb67: {
        _134 = Shr(move _135, const 23_i32);
        switchInt(move _134) -> [0: bb68, otherwise: bb71];
    }

    bb68: {
        _138 = const 1_i32 as u32 (IntToInt);
        _139 = Lt(move _138, const 32_u32);
        assert(move _139, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _29 = Shl(_29, const 1_i32);
        _140 = CheckedSub(_7, const 1_i32);
        assert(!move (_140.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_i32) -> [success: bb70, unwind unreachable];
    }

    bb70: {
        _7 = move (_140.0: i32);
        goto -> bb66;
    }

    bb71: {
        _142 = _7;
        _141 = Gt(move _142, const 0_i32);
        switchInt(move _141) -> [0: bb76, otherwise: bb72];
    }

    bb72: {
        _144 = const 23_i32 as u32 (IntToInt);
        _145 = Lt(move _144, const 32_u32);
        assert(move _145, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _143 = Shl(const 1_u32, const 23_i32);
        _146 = CheckedSub(_29, _143);
        assert(!move (_146.1: bool), "attempt to compute `{} - {}`, which would overflow", _29, move _143) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _29 = move (_146.0: u32);
        _149 = _7;
        _148 = move _149 as u32 (IntToInt);
        _150 = const 23_i32 as u32 (IntToInt);
        _151 = Lt(move _150, const 32_u32);
        assert(move _151, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _147 = Shl(move _148, const 23_i32);
        _29 = BitOr(_29, move _147);
        goto -> bb80;
    }

    bb76: {
        _154 = _7;
        _155 = Eq(_154, const i32::MIN);
        assert(!move _155, "attempt to negate `{}`, which would overflow", _154) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _153 = Neg(move _154);
        _156 = CheckedAdd(_153, const 1_i32);
        assert(!move (_156.1: bool), "attempt to compute `{} + {}`, which would overflow", move _153, const 1_i32) -> [success: bb78, unwind unreachable];
    }

    bb78: {
        _152 = move (_156.0: i32);
        _157 = _152 as u32 (IntToInt);
        _158 = Lt(move _157, const 32_u32);
        assert(move _158, "attempt to shift right by `{}`, which would overflow", _152) -> [success: bb79, unwind unreachable];
    }

    bb79: {
        _29 = Shr(_29, move _152);
        goto -> bb80;
    }

    bb80: {
        _160 = _29;
        _159 = f32::<impl f32>::from_bits(move _160) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _1 = move _159;
        switchInt(_22) -> [0: bb83, otherwise: bb82];
    }

    bb82: {
        _161 = _2;
        _2 = Neg(move _161);
        goto -> bb83;
    }

    bb83: {
        _163 = _7;
        _164 = _12;
        _162 = Eq(move _163, move _164);
        switchInt(move _162) -> [0: bb84, otherwise: bb90];
    }

    bb84: {
        _167 = _7;
        _168 = CheckedAdd(_167, const 1_i32);
        assert(!move (_168.1: bool), "attempt to compute `{} + {}`, which would overflow", move _167, const 1_i32) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _166 = move (_168.0: i32);
        _169 = _12;
        _165 = Eq(move _166, move _169);
        switchInt(move _165) -> [0: bb92, otherwise: bb86];
    }

    bb86: {
        _172 = _1;
        _171 = Mul(const 2f32, move _172);
        _173 = _2;
        _170 = Gt(move _171, move _173);
        switchInt(move _170) -> [0: bb87, otherwise: bb90];
    }

    bb87: {
        _176 = _1;
        _175 = Mul(const 2f32, move _176);
        _177 = _2;
        _174 = Eq(move _175, move _177);
        switchInt(move _174) -> [0: bb92, otherwise: bb88];
    }

    bb88: {
        _179 = _27;
        _180 = Eq(const 2_u32, const 0_u32);
        assert(!move _180, "attempt to calculate the remainder of `{}` with a divisor of zero", _179) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _178 = Rem(move _179, const 2_u32);
        switchInt(move _178) -> [0: bb92, otherwise: bb90];
    }

    bb90: {
        _181 = _2;
        _1 = Sub(_1, move _181);
        _182 = CheckedAdd(_27, const 1_u32);
        assert(!move (_182.1: bool), "attempt to compute `{} + {}`, which would overflow", _27, const 1_u32) -> [success: bb91, unwind unreachable];
    }

    bb91: {
        _27 = move (_182.0: u32);
        goto -> bb92;
    }

    bb92: {
        _27 = BitAnd(_27, const 2147483647_u32);
        _184 = BitXor(_18, _22);
        switchInt(move _184) -> [0: bb95, otherwise: bb93];
    }

    bb93: {
        _186 = _27;
        _185 = move _186 as i32 (IntToInt);
        _187 = Eq(_185, const i32::MIN);
        assert(!move _187, "attempt to negate `{}`, which would overflow", _185) -> [success: bb94, unwind unreachable];
    }

    bb94: {
        _183 = Neg(move _185);
        goto -> bb96;
    }

    bb95: {
        _188 = _27;
        _183 = move _188 as i32 (IntToInt);
        goto -> bb96;
    }

    bb96: {
        switchInt(_18) -> [0: bb98, otherwise: bb97];
    }

    bb97: {
        _190 = _1;
        _189 = Neg(move _190);
        _191 = _183;
        _0 = (move _189, move _191);
        goto -> bb99;
    }

    bb98: {
        _192 = _1;
        _193 = _183;
        _0 = (move _192, move _193);
        goto -> bb99;
    }

    bb99: {
        return;
    }
}

fn rint(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u64;
    let mut _14: (u64, bool);
    let mut _18: bool;
    let mut _19: f64;
    scope 1 {
        debug one_over_e => _2;
        let _3: u64;
        scope 2 {
            debug as_u64 => _3;
            let _4: u64;
            scope 3 {
                debug exponent => _4;
                let _8: bool;
                scope 4 {
                    debug is_positive => _8;
                    let _15: f64;
                    let _16: f64;
                    let _17: f64;
                    scope 5 {
                        debug ans => _15;
                    }
                    scope 6 {
                        debug xplusoneovere => _16;
                    }
                    scope 7 {
                        debug xminusoneovere => _17;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = Div(const 1f64, const _);
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 52_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_3, const 52_i32);
        _4 = BitAnd(move _5, const 2047_u64);
        _10 = const 63_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(_3, const 63_i32);
        _8 = Eq(move _9, const 0_u64);
        _14 = CheckedAdd(const 1023_u64, const 52_u64);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_u64, const 52_u64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = move (_14.0: u64);
        _12 = Ge(_4, move _13);
        switchInt(move _12) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _1;
        goto -> bb14;
    }

    bb6: {
        switchInt(_8) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _16 = Add(_1, _2);
        _15 = Sub(_16, _2);
        goto -> bb9;
    }

    bb8: {
        _17 = Sub(_1, _2);
        _15 = Add(_17, _2);
        goto -> bb9;
    }

    bb9: {
        _19 = _15;
        _18 = Eq(move _19, const 0f64);
        switchInt(move _18) -> [0: bb13, otherwise: bb10];
    }

    bb10: {
        switchInt(_8) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = const 0f64;
        goto -> bb14;
    }

    bb12: {
        _0 = const -0f64;
        goto -> bb14;
    }

    bb13: {
        _0 = _15;
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn rintf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: u32;
    let mut _14: (u32, bool);
    let mut _18: bool;
    let mut _19: f32;
    scope 1 {
        debug one_over_e => _2;
        let _3: u32;
        scope 2 {
            debug as_u32 => _3;
            let _4: u32;
            scope 3 {
                debug exponent => _4;
                let _8: bool;
                scope 4 {
                    debug is_positive => _8;
                    let _15: f32;
                    let _16: f32;
                    let _17: f32;
                    scope 5 {
                        debug ans => _15;
                    }
                    scope 6 {
                        debug xplusoneovere => _16;
                    }
                    scope 7 {
                        debug xminusoneovere => _17;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = Div(const 1f32, const _);
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = const 23_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(_3, const 23_i32);
        _4 = BitAnd(move _5, const 255_u32);
        _10 = const 31_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Shr(_3, const 31_i32);
        _8 = Eq(move _9, const 0_u32);
        _14 = CheckedAdd(const 127_u32, const 23_u32);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_u32, const 23_u32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _13 = move (_14.0: u32);
        _12 = Ge(_4, move _13);
        switchInt(move _12) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _1;
        goto -> bb14;
    }

    bb6: {
        switchInt(_8) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _16 = Add(_1, _2);
        _15 = Sub(_16, _2);
        goto -> bb9;
    }

    bb8: {
        _17 = Sub(_1, _2);
        _15 = Add(_17, _2);
        goto -> bb9;
    }

    bb9: {
        _19 = _15;
        _18 = Eq(move _19, const 0f32);
        switchInt(move _18) -> [0: bb13, otherwise: bb10];
    }

    bb10: {
        switchInt(_8) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = const 0f32;
        goto -> bb14;
    }

    bb12: {
        _0 = const -0f32;
        goto -> bb14;
    }

    bb13: {
        _0 = _15;
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn round(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: f64;

    bb0: {
        _5 = Mul(const 0.25f64, const _);
        _4 = Sub(const 0.5f64, move _5);
        _3 = copysign::copysign(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Add(_1, move _3);
        _0 = libm::trunc::trunc(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn roundf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f32;
    let mut _3: f32;
    let mut _4: f32;
    let mut _5: f32;

    bb0: {
        _5 = Mul(const 0.25f32, const _);
        _4 = Sub(const 0.5f32, move _5);
        _3 = copysignf(move _4, _1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = Add(_1, move _3);
        _0 = truncf(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn scalbn(_1: f64, _2: i32) -> f64 {
    debug x => _1;
    debug n => _2;
    let mut _0: f64;
    let _3: f64;
    let mut _7: bool;
    let mut _8: i32;
    let mut _9: (i32, bool);
    let mut _10: bool;
    let mut _11: i32;
    let mut _12: (i32, bool);
    let mut _13: bool;
    let mut _14: i32;
    let mut _15: bool;
    let mut _16: i32;
    let mut _17: f64;
    let mut _18: i32;
    let mut _19: (i32, bool);
    let mut _20: (i32, bool);
    let mut _21: bool;
    let mut _22: i32;
    let mut _23: f64;
    let mut _24: i32;
    let mut _25: (i32, bool);
    let mut _26: (i32, bool);
    let mut _27: bool;
    let mut _28: i32;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: u64;
    let mut _32: u64;
    let mut _33: i32;
    let mut _34: i32;
    let mut _35: (i32, bool);
    let mut _36: u32;
    let mut _37: bool;
    scope 1 {
        debug x1p1023 => _3;
        let _4: f64;
        scope 2 {
            debug x1p53 => _4;
            let _5: f64;
            scope 3 {
                debug x1p_1022 => _5;
                let mut _6: f64;
                scope 4 {
                    debug y => _6;
                }
            }
        }
    }

    bb0: {
        _3 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f64::<impl f64>::from_bits(const 4845873199050653696_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = f64::<impl f64>::from_bits(const 4503599627370496_u64) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _6 = _1;
        _8 = _2;
        _7 = Gt(move _8, const 1023_i32);
        switchInt(move _7) -> [0: bb9, otherwise: bb4];
    }

    bb4: {
        _6 = Mul(_6, _3);
        _9 = CheckedSub(_2, const 1023_i32);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1023_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _2 = move (_9.0: i32);
        _11 = _2;
        _10 = Gt(move _11, const 1023_i32);
        switchInt(move _10) -> [0: bb17, otherwise: bb6];
    }

    bb6: {
        _6 = Mul(_6, _3);
        _12 = CheckedSub(_2, const 1023_i32);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 1023_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _2 = move (_12.0: i32);
        _14 = _2;
        _13 = Gt(move _14, const 1023_i32);
        switchInt(move _13) -> [0: bb17, otherwise: bb8];
    }

    bb8: {
        _2 = const 1023_i32;
        goto -> bb17;
    }

    bb9: {
        _16 = _2;
        _15 = Lt(move _16, const -1022_i32);
        switchInt(move _15) -> [0: bb17, otherwise: bb10];
    }

    bb10: {
        _17 = Mul(_5, _4);
        _6 = Mul(_6, move _17);
        _19 = CheckedSub(const 1022_i32, const 53_i32);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1022_i32, const 53_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _18 = move (_19.0: i32);
        _20 = CheckedAdd(_2, _18);
        assert(!move (_20.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, move _18) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_20.0: i32);
        _22 = _2;
        _21 = Lt(move _22, const -1022_i32);
        switchInt(move _21) -> [0: bb17, otherwise: bb13];
    }

    bb13: {
        _23 = Mul(_5, _4);
        _6 = Mul(_6, move _23);
        _25 = CheckedSub(const 1022_i32, const 53_i32);
        assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1022_i32, const 53_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _24 = move (_25.0: i32);
        _26 = CheckedAdd(_2, _24);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, move _24) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move (_26.0: i32);
        _28 = _2;
        _27 = Lt(move _28, const -1022_i32);
        switchInt(move _27) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _2 = const -1022_i32;
        goto -> bb17;
    }

    bb17: {
        _29 = _6;
        _34 = _2;
        _35 = CheckedAdd(const 1023_i32, _34);
        assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, move _34) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _33 = move (_35.0: i32);
        _32 = move _33 as u64 (IntToInt);
        _36 = const 52_i32 as u32 (IntToInt);
        _37 = Lt(move _36, const 64_u32);
        assert(move _37, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _31 = Shl(move _32, const 52_i32);
        _30 = f64::<impl f64>::from_bits(move _31) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _0 = Mul(move _29, move _30);
        return;
    }
}

fn scalbnf(_1: f32, _2: i32) -> f32 {
    debug x => _1;
    debug n => _2;
    let mut _0: f32;
    let _3: f32;
    let mut _6: bool;
    let mut _7: i32;
    let mut _8: (i32, bool);
    let mut _9: bool;
    let mut _10: i32;
    let mut _11: (i32, bool);
    let mut _12: bool;
    let mut _13: i32;
    let mut _14: bool;
    let mut _15: i32;
    let mut _16: f32;
    let mut _17: i32;
    let mut _18: (i32, bool);
    let mut _19: (i32, bool);
    let mut _20: bool;
    let mut _21: i32;
    let mut _22: f32;
    let mut _23: i32;
    let mut _24: (i32, bool);
    let mut _25: (i32, bool);
    let mut _26: bool;
    let mut _27: i32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: u32;
    let mut _31: u32;
    let mut _32: i32;
    let mut _33: i32;
    let mut _34: (i32, bool);
    let mut _35: u32;
    let mut _36: bool;
    scope 1 {
        debug x1p127 => _3;
        let _4: f32;
        scope 2 {
            debug x1p_126 => _4;
            let _5: f32;
            scope 3 {
                debug x1p24 => _5;
            }
        }
    }

    bb0: {
        _3 = f32::<impl f32>::from_bits(const 2130706432_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::from_bits(const 8388608_u32) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _5 = f32::<impl f32>::from_bits(const 1266679808_u32) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = _2;
        _6 = Gt(move _7, const 127_i32);
        switchInt(move _6) -> [0: bb9, otherwise: bb4];
    }

    bb4: {
        _1 = Mul(_1, _3);
        _8 = CheckedSub(_2, const 127_i32);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 127_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _2 = move (_8.0: i32);
        _10 = _2;
        _9 = Gt(move _10, const 127_i32);
        switchInt(move _9) -> [0: bb17, otherwise: bb6];
    }

    bb6: {
        _1 = Mul(_1, _3);
        _11 = CheckedSub(_2, const 127_i32);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, const 127_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _2 = move (_11.0: i32);
        _13 = _2;
        _12 = Gt(move _13, const 127_i32);
        switchInt(move _12) -> [0: bb17, otherwise: bb8];
    }

    bb8: {
        _2 = const 127_i32;
        goto -> bb17;
    }

    bb9: {
        _15 = _2;
        _14 = Lt(move _15, const -126_i32);
        switchInt(move _14) -> [0: bb17, otherwise: bb10];
    }

    bb10: {
        _16 = Mul(_4, _5);
        _1 = Mul(_1, move _16);
        _18 = CheckedSub(const 126_i32, const 24_i32);
        assert(!move (_18.1: bool), "attempt to compute `{} - {}`, which would overflow", const 126_i32, const 24_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _17 = move (_18.0: i32);
        _19 = CheckedAdd(_2, _17);
        assert(!move (_19.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, move _17) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _2 = move (_19.0: i32);
        _21 = _2;
        _20 = Lt(move _21, const -126_i32);
        switchInt(move _20) -> [0: bb17, otherwise: bb13];
    }

    bb13: {
        _22 = Mul(_4, _5);
        _1 = Mul(_1, move _22);
        _24 = CheckedSub(const 126_i32, const 24_i32);
        assert(!move (_24.1: bool), "attempt to compute `{} - {}`, which would overflow", const 126_i32, const 24_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _23 = move (_24.0: i32);
        _25 = CheckedAdd(_2, _23);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, move _23) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move (_25.0: i32);
        _27 = _2;
        _26 = Lt(move _27, const -126_i32);
        switchInt(move _26) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _2 = const -126_i32;
        goto -> bb17;
    }

    bb17: {
        _28 = _1;
        _33 = _2;
        _34 = CheckedAdd(const 127_i32, _33);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_i32, move _33) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _32 = move (_34.0: i32);
        _31 = move _32 as u32 (IntToInt);
        _35 = const 23_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _30 = Shl(move _31, const 23_i32);
        _29 = f32::<impl f32>::from_bits(move _30) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _0 = Mul(move _28, move _29);
        return;
    }
}

fn sin(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: u32;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let _12: f64;
    let mut _13: *const f64;
    let _14: &f64;
    let _15: f64;
    let _16: f64;
    let mut _17: *const f64;
    let _18: &f64;
    let _19: f64;
    let mut _20: bool;
    let mut _24: (i32, f64, f64);
    let mut _25: i32;
    let mut _26: f64;
    let mut _27: f64;
    scope 1 {
        debug x1p120 => _2;
        let _3: u32;
        scope 2 {
            debug ix => _3;
            let _21: i32;
            let _22: f64;
            let _23: f64;
            scope 3 {
            }
            scope 4 {
            }
            scope 5 {
                debug n => _21;
                debug y0 => _22;
                debug y1 => _23;
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 5147614374084476928_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = const 32_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(move _6, const 32_i32);
        _4 = move _5 as u32 (IntToInt);
        _3 = BitAnd(move _4, const 2147483647_u32);
        _9 = Le(_3, const 1072243195_u32);
        switchInt(move _9) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _10 = Lt(_3, const 1045430272_u32);
        switchInt(move _10) -> [0: bb9, otherwise: bb5];
    }

    bb5: {
        _11 = Lt(_3, const 1048576_u32);
        switchInt(move _11) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _15 = Div(_1, _2);
        _14 = &_15;
        _13 = &raw const (*_14);
        _12 = read_volatile::<f64>(move _13) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _19 = Add(_1, _2);
        _18 = &_19;
        _17 = &raw const (*_18);
        _16 = read_volatile::<f64>(move _17) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = _1;
        goto -> bb20;
    }

    bb9: {
        _0 = k_sin(_1, const 0f64, const 0_i32) -> [return: bb20, unwind unreachable];
    }

    bb10: {
        _20 = Ge(_3, const 2146435072_u32);
        switchInt(move _20) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = Sub(_1, _1);
        goto -> bb20;
    }

    bb12: {
        _24 = rem_pio2(_1) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _21 = (_24.0: i32);
        _22 = (_24.1: f64);
        _23 = (_24.2: f64);
        _25 = BitAnd(_21, const 3_i32);
        switchInt(_25) -> [0: bb15, 1: bb16, 2: bb17, otherwise: bb14];
    }

    bb14: {
        _27 = k_cos(_22, _23) -> [return: bb19, unwind unreachable];
    }

    bb15: {
        _0 = k_sin(_22, _23, const 1_i32) -> [return: bb20, unwind unreachable];
    }

    bb16: {
        _0 = k_cos(_22, _23) -> [return: bb20, unwind unreachable];
    }

    bb17: {
        _26 = k_sin(_22, _23, const 1_i32) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _0 = Neg(move _26);
        goto -> bb20;
    }

    bb19: {
        _0 = Neg(move _27);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn sincos(_1: f64) -> (f64, f64) {
    debug x => _1;
    let mut _0: (f64, f64);
    let mut _3: u32;
    let mut _4: bool;
    let mut _5: u32;
    let mut _6: bool;
    let mut _7: u32;
    let mut _9: bool;
    let mut _10: u32;
    let _11: f64;
    let mut _12: *const f64;
    let _13: &f64;
    let _14: f64;
    let _15: f64;
    let mut _16: *const f64;
    let _17: &f64;
    let _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: bool;
    let mut _22: u32;
    let mut _27: (i32, f64, f64);
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: i32;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: !;
    scope 1 {
        debug s => _28;
        scope 2 {
            debug c => _29;
            let mut _2: u32;
            scope 3 {
                debug ix => _2;
                let _8: f64;
                let _23: f64;
                let _24: i32;
                let _25: f64;
                let _26: f64;
                scope 4 {
                    debug x1p120 => _8;
                    scope 5 {
                    }
                    scope 6 {
                    }
                }
                scope 7 {
                    debug rv => _23;
                }
                scope 8 {
                    debug n => _24;
                    debug y0 => _25;
                    debug y1 => _26;
                }
            }
        }
    }

    bb0: {
        _3 = get_high_word(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = move _3;
        _2 = BitAnd(_2, const 2147483647_u32);
        _5 = _2;
        _4 = Le(move _5, const 1072243195_u32);
        switchInt(move _4) -> [0: bb11, otherwise: bb2];
    }

    bb2: {
        _7 = _2;
        _6 = Lt(move _7, const 1044816030_u32);
        switchInt(move _6) -> [0: bb8, otherwise: bb3];
    }

    bb3: {
        _8 = f64::<impl f64>::from_bits(const 5147614374084476928_u64) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _10 = _2;
        _9 = Lt(move _10, const 1048576_u32);
        switchInt(move _9) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _14 = Div(_1, _8);
        _13 = &_14;
        _12 = &raw const (*_13);
        _11 = read_volatile::<f64>(move _12) -> [return: bb7, unwind unreachable];
    }

    bb6: {
        _18 = Add(_1, _8);
        _17 = &_18;
        _16 = &raw const (*_17);
        _15 = read_volatile::<f64>(move _16) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _0 = (_1, const 1f64);
        goto -> bb22;
    }

    bb8: {
        _19 = k_sin(_1, const 0f64, const 0_i32) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _20 = k_cos(_1, const 0f64) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _0 = (move _19, move _20);
        goto -> bb22;
    }

    bb11: {
        _22 = _2;
        _21 = Ge(move _22, const 2146435072_u32);
        switchInt(move _21) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _23 = Sub(_1, _1);
        _0 = (_23, _23);
        goto -> bb22;
    }

    bb13: {
        _27 = rem_pio2(_1) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _24 = (_27.0: i32);
        _25 = (_27.1: f64);
        _26 = (_27.2: f64);
        _28 = k_sin(_25, _26, const 1_i32) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _29 = k_cos(_25, _26) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _30 = BitAnd(_24, const 3_i32);
        switchInt(_30) -> [0: bb18, 1: bb19, 2: bb20, 3: bb21, otherwise: bb17];
    }

    bb17: {
        _35 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb18: {
        _0 = (_28, _29);
        goto -> bb22;
    }

    bb19: {
        _31 = Neg(_28);
        _0 = (_29, move _31);
        goto -> bb22;
    }

    bb20: {
        _32 = Neg(_28);
        _33 = Neg(_29);
        _0 = (move _32, move _33);
        goto -> bb22;
    }

    bb21: {
        _34 = Neg(_29);
        _0 = (move _34, _28);
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

const PI_2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = Mul(const 0.5f32, const 3.14159274f32);
        return;
    }
}

const S1PIO2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = Mul(const 1f32, const _);
        return;
    }
}

const S2PIO2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = Mul(const 2f32, const _);
        return;
    }
}

const S3PIO2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = Mul(const 3f32, const _);
        return;
    }
}

const S4PIO2: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = Mul(const 4f32, const _);
        return;
    }
}

fn sincosf(_1: f32) -> (f32, f32) {
    debug x => _1;
    let mut _0: (f32, f32);
    let _2: f32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: u32;
    let mut _16: bool;
    let mut _17: u32;
    let _18: f32;
    let mut _19: *const f32;
    let _20: &f32;
    let _21: f32;
    let _22: f32;
    let mut _23: *const f32;
    let _24: &f32;
    let _25: f32;
    let mut _26: f32;
    let mut _27: f64;
    let mut _28: f32;
    let mut _29: f64;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: f32;
    let mut _35: f64;
    let mut _36: f32;
    let mut _37: f32;
    let mut _38: f64;
    let mut _39: f32;
    let mut _40: f32;
    let mut _41: f64;
    let mut _42: f32;
    let mut _43: f32;
    let mut _44: f64;
    let mut _45: f32;
    let mut _46: f32;
    let mut _47: f64;
    let mut _48: f32;
    let mut _49: f32;
    let mut _50: f64;
    let mut _51: f32;
    let mut _52: f32;
    let mut _53: f64;
    let mut _54: f32;
    let mut _55: f32;
    let mut _56: f64;
    let mut _57: f32;
    let mut _58: f32;
    let mut _59: f32;
    let mut _60: bool;
    let mut _61: u32;
    let mut _62: bool;
    let mut _63: u32;
    let mut _64: f32;
    let mut _65: f64;
    let mut _66: f32;
    let mut _67: f32;
    let mut _68: f64;
    let mut _69: f32;
    let mut _70: f32;
    let mut _71: f64;
    let mut _72: f32;
    let mut _73: f32;
    let mut _74: f64;
    let mut _75: f32;
    let mut _76: f32;
    let mut _77: f64;
    let mut _78: f32;
    let mut _79: f32;
    let mut _80: f64;
    let mut _81: f32;
    let mut _82: f32;
    let mut _83: f64;
    let mut _84: f32;
    let mut _85: f32;
    let mut _86: f64;
    let mut _87: f32;
    let mut _88: f32;
    let mut _89: f32;
    let mut _90: bool;
    let mut _91: u32;
    let mut _95: (i32, f64);
    let mut _96: f32;
    let mut _97: f32;
    let mut _98: i32;
    let mut _99: f32;
    let mut _100: f32;
    let mut _101: f32;
    let mut _102: f32;
    let mut _103: f32;
    let mut _104: f32;
    let mut _105: f32;
    let mut _106: f32;
    let mut _107: f32;
    let mut _108: f32;
    let mut _109: f32;
    let mut _110: f32;
    let mut _111: !;
    scope 1 {
        debug s => _2;
        let _3: f32;
        scope 2 {
            debug c => _3;
            let mut _4: u32;
            scope 3 {
                debug ix => _4;
                let _5: bool;
                scope 4 {
                    debug sign => _5;
                    let _15: f32;
                    let _92: f32;
                    let _93: i32;
                    let _94: f64;
                    scope 5 {
                        debug x1p120 => _15;
                        scope 6 {
                        }
                        scope 7 {
                        }
                    }
                    scope 8 {
                        debug rv => _92;
                    }
                    scope 9 {
                        debug n => _93;
                        debug y => _94;
                    }
                }
            }
        }
    }

    bb0: {
        _6 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _6;
        _8 = _4;
        _9 = const 31_i32 as u32 (IntToInt);
        _10 = Lt(move _9, const 32_u32);
        assert(move _10, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Shr(move _8, const 31_i32);
        _5 = Ne(move _7, const 0_u32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _12 = _4;
        _11 = Le(move _12, const 1061752794_u32);
        switchInt(move _11) -> [0: bb12, otherwise: bb3];
    }

    bb3: {
        _14 = _4;
        _13 = Lt(move _14, const 964689920_u32);
        switchInt(move _13) -> [0: bb9, otherwise: bb4];
    }

    bb4: {
        _15 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _17 = _4;
        _16 = Lt(move _17, const 1048576_u32);
        switchInt(move _16) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _21 = Div(_1, _15);
        _20 = &_21;
        _19 = &raw const (*_20);
        _18 = read_volatile::<f32>(move _19) -> [return: bb8, unwind unreachable];
    }

    bb7: {
        _25 = Add(_1, _15);
        _24 = &_25;
        _23 = &raw const (*_24);
        _22 = read_volatile::<f32>(move _23) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = (_1, const 1f32);
        goto -> bb57;
    }

    bb9: {
        _27 = _1 as f64 (FloatToFloat);
        _26 = k_sinf(move _27) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _29 = _1 as f64 (FloatToFloat);
        _28 = k_cosf(move _29) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _0 = (move _26, move _28);
        goto -> bb57;
    }

    bb12: {
        _31 = _4;
        _30 = Le(move _31, const 1081824209_u32);
        switchInt(move _30) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _33 = _4;
        _32 = Le(move _33, const 1075235811_u32);
        switchInt(move _32) -> [0: bb22, otherwise: bb15];
    }

    bb14: {
        _61 = _4;
        _60 = Le(move _61, const 1088565717_u32);
        switchInt(move _60) -> [0: bb31, otherwise: bb30];
    }

    bb15: {
        switchInt(_5) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _36 = Add(_1, const _);
        _35 = move _36 as f64 (FloatToFloat);
        _34 = k_cosf(move _35) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _2 = Neg(move _34);
        _39 = Add(_1, const _);
        _38 = move _39 as f64 (FloatToFloat);
        _37 = k_sinf(move _38) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _3 = move _37;
        goto -> bb29;
    }

    bb19: {
        _42 = Sub(const _, _1);
        _41 = move _42 as f64 (FloatToFloat);
        _40 = k_cosf(move _41) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _2 = move _40;
        _45 = Sub(const _, _1);
        _44 = move _45 as f64 (FloatToFloat);
        _43 = k_sinf(move _44) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _3 = move _43;
        goto -> bb29;
    }

    bb22: {
        switchInt(_5) -> [0: bb26, otherwise: bb23];
    }

    bb23: {
        _48 = Add(_1, const _);
        _47 = move _48 as f64 (FloatToFloat);
        _46 = k_sinf(move _47) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _2 = Neg(move _46);
        _51 = Add(_1, const _);
        _50 = move _51 as f64 (FloatToFloat);
        _49 = k_cosf(move _50) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _3 = Neg(move _49);
        goto -> bb29;
    }

    bb26: {
        _54 = Sub(_1, const _);
        _53 = move _54 as f64 (FloatToFloat);
        _52 = k_sinf(move _53) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _2 = Neg(move _52);
        _57 = Sub(_1, const _);
        _56 = move _57 as f64 (FloatToFloat);
        _55 = k_cosf(move _56) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _3 = Neg(move _55);
        goto -> bb29;
    }

    bb29: {
        _58 = _2;
        _59 = _3;
        _0 = (move _58, move _59);
        goto -> bb57;
    }

    bb30: {
        _63 = _4;
        _62 = Le(move _63, const 1085271519_u32);
        switchInt(move _62) -> [0: bb39, otherwise: bb32];
    }

    bb31: {
        _91 = _4;
        _90 = Ge(move _91, const 2139095040_u32);
        switchInt(move _90) -> [0: bb48, otherwise: bb47];
    }

    bb32: {
        switchInt(_5) -> [0: bb36, otherwise: bb33];
    }

    bb33: {
        _66 = Add(_1, const _);
        _65 = move _66 as f64 (FloatToFloat);
        _64 = k_cosf(move _65) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _2 = move _64;
        _69 = Add(_1, const _);
        _68 = move _69 as f64 (FloatToFloat);
        _67 = k_sinf(move _68) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        _3 = Neg(move _67);
        goto -> bb46;
    }

    bb36: {
        _72 = Sub(_1, const _);
        _71 = move _72 as f64 (FloatToFloat);
        _70 = k_cosf(move _71) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _2 = Neg(move _70);
        _75 = Sub(_1, const _);
        _74 = move _75 as f64 (FloatToFloat);
        _73 = k_sinf(move _74) -> [return: bb38, unwind unreachable];
    }

    bb38: {
        _3 = move _73;
        goto -> bb46;
    }

    bb39: {
        switchInt(_5) -> [0: bb43, otherwise: bb40];
    }

    bb40: {
        _78 = Add(_1, const _);
        _77 = move _78 as f64 (FloatToFloat);
        _76 = k_sinf(move _77) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _2 = move _76;
        _81 = Add(_1, const _);
        _80 = move _81 as f64 (FloatToFloat);
        _79 = k_cosf(move _80) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        _3 = move _79;
        goto -> bb46;
    }

    bb43: {
        _84 = Sub(_1, const _);
        _83 = move _84 as f64 (FloatToFloat);
        _82 = k_sinf(move _83) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _2 = move _82;
        _87 = Sub(_1, const _);
        _86 = move _87 as f64 (FloatToFloat);
        _85 = k_cosf(move _86) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _3 = move _85;
        goto -> bb46;
    }

    bb46: {
        _88 = _2;
        _89 = _3;
        _0 = (move _88, move _89);
        goto -> bb57;
    }

    bb47: {
        _92 = Sub(_1, _1);
        _0 = (_92, _92);
        goto -> bb57;
    }

    bb48: {
        _95 = rem_pio2f(_1) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        _93 = (_95.0: i32);
        _94 = (_95.1: f64);
        _96 = k_sinf(_94) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _2 = move _96;
        _97 = k_cosf(_94) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _3 = move _97;
        _98 = BitAnd(_93, const 3_i32);
        switchInt(_98) -> [0: bb53, 1: bb54, 2: bb55, 3: bb56, otherwise: bb52];
    }

    bb52: {
        _111 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb53: {
        _99 = _2;
        _100 = _3;
        _0 = (move _99, move _100);
        goto -> bb57;
    }

    bb54: {
        _101 = _3;
        _103 = _2;
        _102 = Neg(move _103);
        _0 = (move _101, move _102);
        goto -> bb57;
    }

    bb55: {
        _105 = _2;
        _104 = Neg(move _105);
        _107 = _3;
        _106 = Neg(move _107);
        _0 = (move _104, move _106);
        goto -> bb57;
    }

    bb56: {
        _109 = _3;
        _108 = Neg(move _109);
        _110 = _2;
        _0 = (move _108, move _110);
        goto -> bb57;
    }

    bb57: {
        return;
    }
}

const S1_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 1f64, const _);
        return;
    }
}

const S2_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 2f64, const _);
        return;
    }
}

const S3_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 3f64, const _);
        return;
    }
}

const S4_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 4f64, const _);
        return;
    }
}

fn sinf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let _14: f32;
    let mut _15: *const f32;
    let _16: &f32;
    let _17: f32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: u32;
    let mut _24: f32;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: bool;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: u32;
    let mut _34: f64;
    let mut _35: f32;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: bool;
    let mut _39: u32;
    let mut _42: (i32, f64);
    let mut _43: i32;
    let mut _44: f64;
    let mut _45: f32;
    scope 1 {
        debug x64 => _2;
        let _3: f32;
        scope 2 {
            debug x1p120 => _3;
            let mut _4: u32;
            scope 3 {
                debug ix => _4;
                let _5: bool;
                scope 4 {
                    debug sign => _5;
                    let _40: i32;
                    let _41: f64;
                    scope 5 {
                    }
                    scope 6 {
                        debug n => _40;
                        debug y => _41;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1 as f64 (FloatToFloat);
        _3 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _4;
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 31_i32);
        _5 = Ne(move _6, const 0_u32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _11 = _4;
        _10 = Le(move _11, const 1061752794_u32);
        switchInt(move _10) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _13 = _4;
        _12 = Lt(move _13, const 964689920_u32);
        switchInt(move _12) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _19 = _4;
        _18 = Lt(move _19, const 8388608_u32);
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _17 = Div(_1, _3);
        goto -> bb8;
    }

    bb7: {
        _17 = Add(_1, _3);
        goto -> bb8;
    }

    bb8: {
        _16 = &_17;
        _15 = &raw const (*_16);
        _14 = read_volatile::<f32>(move _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = _1;
        goto -> bb40;
    }

    bb10: {
        _0 = k_sinf(_2) -> [return: bb40, unwind unreachable];
    }

    bb11: {
        _21 = _4;
        _20 = Le(move _21, const 1081824209_u32);
        switchInt(move _20) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _23 = _4;
        _22 = Le(move _23, const 1075235811_u32);
        switchInt(move _22) -> [0: bb18, otherwise: bb14];
    }

    bb13: {
        _31 = _4;
        _30 = Le(move _31, const 1088565717_u32);
        switchInt(move _30) -> [0: bb23, otherwise: bb22];
    }

    bb14: {
        switchInt(_5) -> [0: bb17, otherwise: bb15];
    }

    bb15: {
        _25 = Add(_2, const _);
        _24 = k_cosf(move _25) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _0 = Neg(move _24);
        goto -> bb40;
    }

    bb17: {
        _26 = Sub(_2, const _);
        _0 = k_cosf(move _26) -> [return: bb40, unwind unreachable];
    }

    bb18: {
        switchInt(_5) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _28 = Add(_2, const _);
        _27 = Neg(move _28);
        goto -> bb21;
    }

    bb20: {
        _29 = Sub(_2, const _);
        _27 = Neg(move _29);
        goto -> bb21;
    }

    bb21: {
        _0 = k_sinf(move _27) -> [return: bb40, unwind unreachable];
    }

    bb22: {
        _33 = _4;
        _32 = Le(move _33, const 1085271519_u32);
        switchInt(move _32) -> [0: bb28, otherwise: bb24];
    }

    bb23: {
        _39 = _4;
        _38 = Ge(move _39, const 2139095040_u32);
        switchInt(move _38) -> [0: bb33, otherwise: bb32];
    }

    bb24: {
        switchInt(_5) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _34 = Add(_2, const _);
        _0 = k_cosf(move _34) -> [return: bb40, unwind unreachable];
    }

    bb26: {
        _36 = Sub(_2, const _);
        _35 = k_cosf(move _36) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _0 = Neg(move _35);
        goto -> bb40;
    }

    bb28: {
        switchInt(_5) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _37 = Add(_2, const _);
        goto -> bb31;
    }

    bb30: {
        _37 = Sub(_2, const _);
        goto -> bb31;
    }

    bb31: {
        _0 = k_sinf(move _37) -> [return: bb40, unwind unreachable];
    }

    bb32: {
        _0 = Sub(_1, _1);
        goto -> bb40;
    }

    bb33: {
        _42 = rem_pio2f(_1) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _40 = (_42.0: i32);
        _41 = (_42.1: f64);
        _43 = BitAnd(_40, const 3_i32);
        switchInt(_43) -> [0: bb36, 1: bb37, 2: bb38, otherwise: bb35];
    }

    bb35: {
        _45 = k_cosf(_41) -> [return: bb39, unwind unreachable];
    }

    bb36: {
        _0 = k_sinf(_41) -> [return: bb40, unwind unreachable];
    }

    bb37: {
        _0 = k_cosf(_41) -> [return: bb40, unwind unreachable];
    }

    bb38: {
        _44 = Neg(_41);
        _0 = k_sinf(move _44) -> [return: bb40, unwind unreachable];
    }

    bb39: {
        _0 = Neg(move _45);
        goto -> bb40;
    }

    bb40: {
        return;
    }
}

fn sinh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _4: f64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: f64;
    let mut _13: u64;
    let mut _14: u64;
    let mut _15: bool;
    let mut _16: f64;
    let mut _17: u64;
    let mut _18: f64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: f64;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: u32;
    let mut _28: u32;
    let mut _29: u32;
    let mut _30: bool;
    let mut _31: (u32, bool);
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    scope 1 {
        debug uf => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let _5: u32;
            scope 3 {
                debug w => _5;
                let _6: f64;
                scope 4 {
                    debug t => _6;
                    let mut _7: f64;
                    scope 5 {
                        debug h => _7;
                        scope 6 {
                            debug absx => _18;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1;
        _4 = _2;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = const 0.5f64;
        _9 = _3;
        _10 = const 63_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 63_i32);
        switchInt(move _8) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _12 = _7;
        _7 = Neg(move _12);
        goto -> bb4;
    }

    bb4: {
        _14 = Not(const 1_u64);
        _15 = Eq(const 2_u64, const 0_u64);
        assert(!move _15, "attempt to divide `{}` by zero", _14) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _13 = Div(move _14, const 2_u64);
        _3 = BitAnd(_3, move _13);
        _17 = _3;
        _16 = f64::<impl f64>::from_bits(move _17) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _2 = move _16;
        _18 = _2;
        _20 = _3;
        _21 = const 32_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 64_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _19 = Shr(move _20, const 32_i32);
        _5 = move _19 as u32 (IntToInt);
        _23 = Lt(_5, const 1082535490_u32);
        switchInt(move _23) -> [0: bb16, otherwise: bb8];
    }

    bb8: {
        _24 = expm1(_18) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _6 = move _24;
        _25 = Lt(_5, const 1072693248_u32);
        switchInt(move _25) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        _29 = const 20_i32 as u32 (IntToInt);
        _30 = Lt(move _29, const 32_u32);
        assert(move _30, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _28 = Shl(const 26_u32, const 20_i32);
        _31 = CheckedSub(const 1072693248_u32, _28);
        assert(!move (_31.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1072693248_u32, move _28) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _27 = move (_31.0: u32);
        _26 = Lt(_5, move _27);
        switchInt(move _26) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _0 = _1;
        goto -> bb18;
    }

    bb14: {
        _32 = _7;
        _35 = _6;
        _34 = Mul(const 2f64, move _35);
        _38 = _6;
        _39 = _6;
        _37 = Mul(move _38, move _39);
        _41 = _6;
        _40 = Add(move _41, const 1f64);
        _36 = Div(move _37, move _40);
        _33 = Sub(move _34, move _36);
        _0 = Mul(move _32, move _33);
        goto -> bb18;
    }

    bb15: {
        _42 = _7;
        _44 = _6;
        _46 = _6;
        _48 = _6;
        _47 = Add(move _48, const 1f64);
        _45 = Div(move _46, move _47);
        _43 = Add(move _44, move _45);
        _0 = Mul(move _42, move _43);
        goto -> bb18;
    }

    bb16: {
        _50 = _7;
        _49 = Mul(const 2f64, move _50);
        _51 = expo2(_18) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _6 = Mul(move _49, move _51);
        _0 = _6;
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn sinhf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: f32;
    let mut _10: u32;
    let mut _12: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: u32;
    let mut _17: u32;
    let mut _18: u32;
    let mut _19: bool;
    let mut _20: (u32, bool);
    let mut _21: f32;
    let mut _22: f32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: f32;
    let mut _28: f32;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let mut _33: f32;
    scope 1 {
        debug h => _2;
        let mut _3: u32;
        scope 2 {
            debug ix => _3;
            let _9: f32;
            scope 3 {
                debug absx => _9;
                let _11: u32;
                scope 4 {
                    debug w => _11;
                    let _13: f32;
                    scope 5 {
                        debug t => _13;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0.5f32;
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = _3;
        _6 = const 31_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 32_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shr(move _5, const 31_i32);
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _8 = _2;
        _2 = Neg(move _8);
        goto -> bb4;
    }

    bb4: {
        _3 = BitAnd(_3, const 2147483647_u32);
        _10 = _3;
        _9 = f32::<impl f32>::from_bits(move _10) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _11 = _3;
        _12 = Lt(_11, const 1118925335_u32);
        switchInt(move _12) -> [0: bb14, otherwise: bb6];
    }

    bb6: {
        _13 = expm1f(_9) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = Lt(_11, const 1065353216_u32);
        switchInt(move _14) -> [0: bb13, otherwise: bb8];
    }

    bb8: {
        _18 = const 23_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 32_u32);
        assert(move _19, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _17 = Shl(const 12_u32, const 23_i32);
        _20 = CheckedSub(const 1065353216_u32, _17);
        assert(!move (_20.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1065353216_u32, move _17) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _16 = move (_20.0: u32);
        _15 = Lt(_11, move _16);
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = _1;
        goto -> bb16;
    }

    bb12: {
        _21 = _2;
        _23 = Mul(const 2f32, _13);
        _25 = Mul(_13, _13);
        _26 = Add(_13, const 1f32);
        _24 = Div(move _25, move _26);
        _22 = Sub(move _23, move _24);
        _0 = Mul(move _21, move _22);
        goto -> bb16;
    }

    bb13: {
        _27 = _2;
        _30 = Add(_13, const 1f32);
        _29 = Div(_13, move _30);
        _28 = Add(_13, move _29);
        _0 = Mul(move _27, move _28);
        goto -> bb16;
    }

    bb14: {
        _32 = _2;
        _31 = Mul(const 2f32, move _32);
        _33 = k_expo2f(_9) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _0 = Mul(move _31, move _33);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn sqrt(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _20: u32;
    let mut _21: u64;
    let mut _22: i32;
    let mut _23: i32;
    let mut _24: f64;
    let mut _25: bool;
    let mut _26: i32;
    let mut _27: i32;
    let mut _28: i32;
    let mut _29: i32;
    let mut _30: i32;
    let mut _31: i32;
    let mut _32: u32;
    let mut _33: i32;
    let mut _34: u32;
    let mut _35: bool;
    let mut _36: i32;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: i32;
    let mut _40: u32;
    let mut _41: bool;
    let mut _42: i32;
    let mut _43: i32;
    let mut _44: (i32, bool);
    let mut _45: i32;
    let mut _46: u32;
    let mut _47: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _48: rustc_std_workspace_core::num::Wrapping<u32>;
    let _49: ();
    let mut _50: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _51: i32;
    let mut _52: i32;
    let mut _53: (i32, bool);
    let mut _54: u32;
    let mut _55: bool;
    let mut _56: i32;
    let mut _57: i32;
    let mut _58: (i32, bool);
    let mut _59: (i32, bool);
    let mut _60: i32;
    let mut _61: u32;
    let mut _62: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _63: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _64: usize;
    let mut _65: i32;
    let mut _66: i32;
    let mut _67: (i32, bool);
    let mut _68: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _69: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _70: usize;
    let mut _71: i32;
    let mut _72: (i32, bool);
    let mut _73: i32;
    let mut _74: i32;
    let mut _75: i32;
    let mut _76: i32;
    let mut _77: i32;
    let mut _78: i32;
    let mut _79: i32;
    let mut _80: u32;
    let mut _81: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _82: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _83: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _84: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _85: (i32, bool);
    let mut _86: (i32, bool);
    let _87: ();
    let mut _88: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _89: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _90: u32;
    let mut _91: bool;
    let mut _92: i32;
    let mut _93: i32;
    let mut _94: i32;
    let mut _95: u32;
    let mut _96: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _97: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _98: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _99: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _100: (i32, bool);
    let mut _101: (i32, bool);
    let _102: ();
    let mut _103: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _104: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _105: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _106: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _107: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _108: bool;
    let mut _109: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _110: i32;
    let mut _111: i32;
    let mut _112: u32;
    let mut _113: (i32, bool);
    let mut _114: bool;
    let mut _115: i32;
    let mut _116: i32;
    let mut _117: i32;
    let mut _118: i32;
    let mut _119: u32;
    let mut _120: (i32, bool);
    let mut _121: i32;
    let mut _122: (i32, bool);
    let mut _123: i32;
    let mut _124: u32;
    let mut _125: (i32, bool);
    let mut _126: i32;
    let mut _127: i32;
    let mut _128: i32;
    let mut _129: u32;
    let mut _130: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _131: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _132: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _133: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _134: (i32, bool);
    let mut _135: (i32, bool);
    let _136: ();
    let mut _137: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _138: rustc_std_workspace_core::num::Wrapping<u32>;
    let _139: ();
    let mut _140: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _141: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _142: bool;
    let mut _143: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _144: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _145: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _146: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _147: i32;
    let mut _148: bool;
    let mut _149: i32;
    let mut _150: i32;
    let mut _151: bool;
    let mut _152: i32;
    let mut _153: i32;
    let mut _154: bool;
    let mut _155: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _156: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _157: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _158: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _159: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _160: bool;
    let mut _161: &rustc_std_workspace_core::num::Wrapping<u32>;
    let _162: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _163: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _164: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _165: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _166: bool;
    let mut _167: &rustc_std_workspace_core::num::Wrapping<u32>;
    let _168: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _169: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _170: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _171: (i32, bool);
    let mut _172: i32;
    let mut _173: (i32, bool);
    let mut _174: bool;
    let mut _175: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _176: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _177: (i32, bool);
    let _178: ();
    let mut _179: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _180: rustc_std_workspace_core::num::Wrapping<u32>;
    let _181: ();
    let mut _182: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _183: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _184: i32;
    let mut _185: i32;
    let mut _186: i32;
    let mut _187: u32;
    let mut _188: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _189: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _190: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _191: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _192: (i32, bool);
    let mut _193: (i32, bool);
    let _194: ();
    let mut _195: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _196: rustc_std_workspace_core::num::Wrapping<u32>;
    let _197: ();
    let mut _198: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _199: u32;
    let mut _200: u32;
    let mut _201: i32;
    let mut _202: u32;
    let mut _203: bool;
    let mut _204: f64;
    let mut _205: u32;
    let mut _206: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _207: (i32, bool);
    let mut _208: bool;
    let mut _209: f64;
    let mut _210: u32;
    let mut _211: (i32, bool);
    let _212: ();
    let mut _213: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _214: rustc_std_workspace_core::num::Wrapping<u32>;
    let _215: ();
    let mut _216: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _217: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _218: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _219: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _220: i32;
    let mut _221: i32;
    let mut _222: u32;
    let mut _223: bool;
    let mut _224: (i32, bool);
    let mut _225: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _226: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _227: i32;
    let mut _228: i32;
    let _229: ();
    let mut _230: &mut rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _231: rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _232: i32;
    let mut _233: i32;
    let mut _234: u32;
    let mut _235: bool;
    let mut _236: (i32, bool);
    let mut _237: u64;
    let mut _238: u64;
    let mut _239: u64;
    let mut _240: i32;
    let mut _241: u32;
    let mut _242: bool;
    let mut _243: u64;
    let mut _244: u32;
    scope 1 {
        debug z => _2;
        let _3: rustc_std_workspace_core::num::Wrapping<u32>;
        scope 2 {
            debug sign => _3;
            let mut _4: i32;
            scope 3 {
                debug ix0 => _4;
                let mut _5: i32;
                scope 4 {
                    debug s0 => _5;
                    let mut _6: i32;
                    scope 5 {
                        debug q => _6;
                        let mut _7: i32;
                        scope 6 {
                            debug m => _7;
                            let mut _8: i32;
                            scope 7 {
                                debug t => _8;
                                let mut _9: i32;
                                scope 8 {
                                    debug i => _9;
                                    let mut _10: rustc_std_workspace_core::num::Wrapping<u32>;
                                    scope 9 {
                                        debug r => _10;
                                        let mut _11: rustc_std_workspace_core::num::Wrapping<u32>;
                                        scope 10 {
                                            debug t1 => _11;
                                            let mut _12: rustc_std_workspace_core::num::Wrapping<u32>;
                                            scope 11 {
                                                debug s1 => _12;
                                                let mut _13: rustc_std_workspace_core::num::Wrapping<u32>;
                                                scope 12 {
                                                    debug ix1 => _13;
                                                    let mut _14: rustc_std_workspace_core::num::Wrapping<u32>;
                                                    scope 13 {
                                                        debug q1 => _14;
                                                        let mut _245: &rustc_std_workspace_core::num::Wrapping<u32>;
                                                        let mut _246: &rustc_std_workspace_core::num::Wrapping<u32>;
                                                        let mut _247: &rustc_std_workspace_core::num::Wrapping<u32>;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Wrapping::<u32>(const 2147483648_u32);
        _16 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _17 = const 32_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _15 = Shr(move _16, const 32_i32);
        _4 = move _15 as i32 (IntToInt);
        _21 = f64::<impl f64>::to_bits(_1) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _20 = move _21 as u32 (IntToInt);
        _19 = Wrapping::<u32>(move _20);
        _13 = move _19;
        _23 = _4;
        _22 = BitAnd(move _23, const 2146435072_i32);
        switchInt(move _22) -> [2146435072: bb4, otherwise: bb5];
    }

    bb4: {
        _24 = Mul(_1, _1);
        _0 = Add(move _24, _1);
        goto -> bb106;
    }

    bb5: {
        _26 = _4;
        _25 = Le(move _26, const 0_i32);
        switchInt(move _25) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _29 = _4;
        _32 = (_3.0: u32);
        _31 = move _32 as i32 (IntToInt);
        _30 = Not(move _31);
        _28 = BitAnd(move _29, move _30);
        _34 = (_13.0: u32);
        _33 = move _34 as i32 (IntToInt);
        _27 = BitOr(move _28, move _33);
        switchInt(move _27) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _0 = _1;
        goto -> bb106;
    }

    bb8: {
        _36 = _4;
        _35 = Lt(move _36, const 0_i32);
        switchInt(move _35) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _37 = Sub(_1, _1);
        _38 = Sub(_1, _1);
        _0 = Div(move _37, move _38);
        goto -> bb106;
    }

    bb10: {
        _39 = _4;
        _40 = const 20_i32 as u32 (IntToInt);
        _41 = Lt(move _40, const 32_u32);
        assert(move _41, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _7 = Shr(move _39, const 20_i32);
        _42 = _7;
        switchInt(move _42) -> [0: bb12, otherwise: bb27];
    }

    bb12: {
        _43 = _4;
        switchInt(move _43) -> [0: bb13, otherwise: bb16];
    }

    bb13: {
        _44 = CheckedSub(_7, const 21_i32);
        assert(!move (_44.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 21_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _7 = move (_44.0: i32);
        _48 = _13;
        _47 = <Wrapping<u32> as Shr<usize>>::shr(move _48, const 11_usize) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _46 = (_47.0: u32);
        _45 = move _46 as i32 (IntToInt);
        _4 = BitOr(_4, move _45);
        _50 = &mut _13;
        _49 = <Wrapping<u32> as ShlAssign<usize>>::shl_assign(move _50, const 21_usize) -> [return: bb12, unwind unreachable];
    }

    bb16: {
        _9 = const 0_i32;
        goto -> bb17;
    }

    bb17: {
        _52 = _4;
        _51 = BitAnd(move _52, const 1048576_i32);
        switchInt(move _51) -> [0: bb18, otherwise: bb21];
    }

    bb18: {
        _53 = CheckedAdd(_9, const 1_i32);
        assert(!move (_53.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _9 = move (_53.0: i32);
        _54 = const 1_i32 as u32 (IntToInt);
        _55 = Lt(move _54, const 32_u32);
        assert(move _55, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _4 = Shl(_4, const 1_i32);
        goto -> bb17;
    }

    bb21: {
        _57 = _9;
        _58 = CheckedSub(_57, const 1_i32);
        assert(!move (_58.1: bool), "attempt to compute `{} - {}`, which would overflow", move _57, const 1_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _56 = move (_58.0: i32);
        _59 = CheckedSub(_7, _56);
        assert(!move (_59.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, move _56) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _7 = move (_59.0: i32);
        _63 = _13;
        _66 = _9;
        _67 = CheckedSub(const 32_i32, _66);
        assert(!move (_67.1: bool), "attempt to compute `{} - {}`, which would overflow", const 32_i32, move _66) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _65 = move (_67.0: i32);
        _64 = move _65 as usize (IntToInt);
        _62 = <Wrapping<u32> as Shr<usize>>::shr(move _63, move _64) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _61 = (_62.0: u32);
        _60 = move _61 as i32 (IntToInt);
        _4 = BitOr(_4, move _60);
        _69 = _13;
        _71 = _9;
        _70 = move _71 as usize (IntToInt);
        _68 = <Wrapping<u32> as Shl<usize>>::shl(move _69, move _70) -> [return: bb26, unwind unreachable];
    }

    bb26: {
        _13 = move _68;
        goto -> bb27;
    }

    bb27: {
        _72 = CheckedSub(_7, const 1023_i32);
        assert(!move (_72.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1023_i32) -> [success: bb28, unwind unreachable];
    }

    bb28: {
        _7 = move (_72.0: i32);
        _74 = _4;
        _73 = BitAnd(move _74, const 1048575_i32);
        _4 = BitOr(move _73, const 1048576_i32);
        _76 = _7;
        _75 = BitAnd(move _76, const 1_i32);
        switchInt(move _75) -> [1: bb29, otherwise: bb34];
    }

    bb29: {
        _78 = _4;
        _83 = _13;
        _84 = _3;
        _82 = <Wrapping<u32> as BitAnd>::bitand(move _83, move _84) -> [return: bb30, unwind unreachable];
    }

    bb30: {
        _81 = <Wrapping<u32> as Shr<usize>>::shr(move _82, const 31_usize) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _80 = (_81.0: u32);
        _79 = move _80 as i32 (IntToInt);
        _85 = CheckedAdd(_78, _79);
        assert(!move (_85.1: bool), "attempt to compute `{} + {}`, which would overflow", move _78, move _79) -> [success: bb32, unwind unreachable];
    }

    bb32: {
        _77 = move (_85.0: i32);
        _86 = CheckedAdd(_4, _77);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _77) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _4 = move (_86.0: i32);
        _88 = &mut _13;
        _89 = _13;
        _87 = <Wrapping<u32> as AddAssign>::add_assign(move _88, move _89) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _90 = const 1_i32 as u32 (IntToInt);
        _91 = Lt(move _90, const 32_u32);
        assert(move _91, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _7 = Shr(_7, const 1_i32);
        _93 = _4;
        _98 = _13;
        _99 = _3;
        _97 = <Wrapping<u32> as BitAnd>::bitand(move _98, move _99) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _96 = <Wrapping<u32> as Shr<usize>>::shr(move _97, const 31_usize) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _95 = (_96.0: u32);
        _94 = move _95 as i32 (IntToInt);
        _100 = CheckedAdd(_93, _94);
        assert(!move (_100.1: bool), "attempt to compute `{} + {}`, which would overflow", move _93, move _94) -> [success: bb38, unwind unreachable];
    }

    bb38: {
        _92 = move (_100.0: i32);
        _101 = CheckedAdd(_4, _92);
        assert(!move (_101.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _92) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _4 = move (_101.0: i32);
        _103 = &mut _13;
        _104 = _13;
        _102 = <Wrapping<u32> as AddAssign>::add_assign(move _103, move _104) -> [return: bb40, unwind unreachable];
    }

    bb40: {
        _6 = const 0_i32;
        _105 = Wrapping::<u32>(const 0_u32);
        _14 = move _105;
        _5 = const 0_i32;
        _106 = Wrapping::<u32>(const 0_u32);
        _12 = move _106;
        _107 = Wrapping::<u32>(const 2097152_u32);
        _10 = move _107;
        goto -> bb41;
    }

    bb41: {
        _109 = &_10;
        _247 = const _;
        _108 = <Wrapping<u32> as PartialEq>::ne(move _109, _247) -> [return: bb42, unwind unreachable];
    }

    bb42: {
        switchInt(move _108) -> [0: bb55, otherwise: bb43];
    }

    bb43: {
        _110 = _5;
        _112 = (_10.0: u32);
        _111 = move _112 as i32 (IntToInt);
        _113 = CheckedAdd(_110, _111);
        assert(!move (_113.1: bool), "attempt to compute `{} + {}`, which would overflow", move _110, move _111) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _8 = move (_113.0: i32);
        _115 = _8;
        _116 = _4;
        _114 = Le(move _115, move _116);
        switchInt(move _114) -> [0: bb49, otherwise: bb45];
    }

    bb45: {
        _117 = _8;
        _119 = (_10.0: u32);
        _118 = move _119 as i32 (IntToInt);
        _120 = CheckedAdd(_117, _118);
        assert(!move (_120.1: bool), "attempt to compute `{} + {}`, which would overflow", move _117, move _118) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _5 = move (_120.0: i32);
        _121 = _8;
        _122 = CheckedSub(_4, _121);
        assert(!move (_122.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, move _121) -> [success: bb47, unwind unreachable];
    }

    bb47: {
        _4 = move (_122.0: i32);
        _124 = (_10.0: u32);
        _123 = move _124 as i32 (IntToInt);
        _125 = CheckedAdd(_6, _123);
        assert(!move (_125.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _123) -> [success: bb48, unwind unreachable];
    }

    bb48: {
        _6 = move (_125.0: i32);
        goto -> bb49;
    }

    bb49: {
        _127 = _4;
        _132 = _13;
        _133 = _3;
        _131 = <Wrapping<u32> as BitAnd>::bitand(move _132, move _133) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _130 = <Wrapping<u32> as Shr<usize>>::shr(move _131, const 31_usize) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _129 = (_130.0: u32);
        _128 = move _129 as i32 (IntToInt);
        _134 = CheckedAdd(_127, _128);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", move _127, move _128) -> [success: bb52, unwind unreachable];
    }

    bb52: {
        _126 = move (_134.0: i32);
        _135 = CheckedAdd(_4, _126);
        assert(!move (_135.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _126) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _4 = move (_135.0: i32);
        _137 = &mut _13;
        _138 = _13;
        _136 = <Wrapping<u32> as AddAssign>::add_assign(move _137, move _138) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _140 = &mut _10;
        _139 = <Wrapping<u32> as ShrAssign<usize>>::shr_assign(move _140, const 1_usize) -> [return: bb41, unwind unreachable];
    }

    bb55: {
        _141 = _3;
        _10 = move _141;
        goto -> bb56;
    }

    bb56: {
        _143 = &_10;
        _246 = const _;
        _142 = <Wrapping<u32> as PartialEq>::ne(move _143, _246) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        switchInt(move _142) -> [0: bb85, otherwise: bb58];
    }

    bb58: {
        _145 = _12;
        _146 = _10;
        _144 = <Wrapping<u32> as Add>::add(move _145, move _146) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        _11 = move _144;
        _147 = _5;
        _8 = move _147;
        _149 = _8;
        _150 = _4;
        _148 = Lt(move _149, move _150);
        switchInt(move _148) -> [0: bb60, otherwise: bb63];
    }

    bb60: {
        _152 = _8;
        _153 = _4;
        _151 = Eq(move _152, move _153);
        switchInt(move _151) -> [0: bb79, otherwise: bb61];
    }

    bb61: {
        _155 = &_11;
        _156 = &_13;
        _154 = <Wrapping<u32> as PartialOrd>::le(move _155, move _156) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        switchInt(move _154) -> [0: bb79, otherwise: bb63];
    }

    bb63: {
        _158 = _11;
        _159 = _10;
        _157 = <Wrapping<u32> as Add>::add(move _158, move _159) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _12 = move _157;
        _163 = _11;
        _164 = _3;
        _162 = <Wrapping<u32> as BitAnd>::bitand(move _163, move _164) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _161 = &_162;
        _165 = &_3;
        _160 = <Wrapping<u32> as PartialEq>::eq(move _161, move _165) -> [return: bb66, unwind unreachable];
    }

    bb66: {
        switchInt(move _160) -> [0: bb72, otherwise: bb67];
    }

    bb67: {
        _169 = _12;
        _170 = _3;
        _168 = <Wrapping<u32> as BitAnd>::bitand(move _169, move _170) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _167 = &_168;
        _245 = const _;
        _166 = <Wrapping<u32> as PartialEq>::eq(move _167, _245) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        switchInt(move _166) -> [0: bb72, otherwise: bb70];
    }

    bb70: {
        _171 = CheckedAdd(_5, const 1_i32);
        assert(!move (_171.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_i32) -> [success: bb71, unwind unreachable];
    }

    bb71: {
        _5 = move (_171.0: i32);
        goto -> bb72;
    }

    bb72: {
        _172 = _8;
        _173 = CheckedSub(_4, _172);
        assert(!move (_173.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, move _172) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _4 = move (_173.0: i32);
        _175 = &_13;
        _176 = &_11;
        _174 = <Wrapping<u32> as PartialOrd>::lt(move _175, move _176) -> [return: bb74, unwind unreachable];
    }

    bb74: {
        switchInt(move _174) -> [0: bb77, otherwise: bb75];
    }

    bb75: {
        _177 = CheckedSub(_4, const 1_i32);
        assert(!move (_177.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 1_i32) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _4 = move (_177.0: i32);
        goto -> bb77;
    }

    bb77: {
        _179 = &mut _13;
        _180 = _11;
        _178 = <Wrapping<u32> as SubAssign>::sub_assign(move _179, move _180) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _182 = &mut _14;
        _183 = _10;
        _181 = <Wrapping<u32> as AddAssign>::add_assign(move _182, move _183) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _185 = _4;
        _190 = _13;
        _191 = _3;
        _189 = <Wrapping<u32> as BitAnd>::bitand(move _190, move _191) -> [return: bb80, unwind unreachable];
    }

    bb80: {
        _188 = <Wrapping<u32> as Shr<usize>>::shr(move _189, const 31_usize) -> [return: bb81, unwind unreachable];
    }

    bb81: {
        _187 = (_188.0: u32);
        _186 = move _187 as i32 (IntToInt);
        _192 = CheckedAdd(_185, _186);
        assert(!move (_192.1: bool), "attempt to compute `{} + {}`, which would overflow", move _185, move _186) -> [success: bb82, unwind unreachable];
    }

    bb82: {
        _184 = move (_192.0: i32);
        _193 = CheckedAdd(_4, _184);
        assert(!move (_193.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _184) -> [success: bb83, unwind unreachable];
    }

    bb83: {
        _4 = move (_193.0: i32);
        _195 = &mut _13;
        _196 = _13;
        _194 = <Wrapping<u32> as AddAssign>::add_assign(move _195, move _196) -> [return: bb84, unwind unreachable];
    }

    bb84: {
        _198 = &mut _10;
        _197 = <Wrapping<u32> as ShrAssign<usize>>::shr_assign(move _198, const 1_usize) -> [return: bb56, unwind unreachable];
    }

    bb85: {
        _201 = _4;
        _200 = move _201 as u32 (IntToInt);
        _202 = (_13.0: u32);
        _199 = BitOr(move _200, move _202);
        switchInt(move _199) -> [0: bb97, otherwise: bb86];
    }

    bb86: {
        _2 = Sub(const 1f64, const _);
        _204 = _2;
        _203 = Ge(move _204, const 1f64);
        switchInt(move _203) -> [0: bb97, otherwise: bb87];
    }

    bb87: {
        _2 = Add(const 1f64, const _);
        _205 = (_14.0: u32);
        switchInt(move _205) -> [4294967295: bb88, otherwise: bb90];
    }

    bb88: {
        _206 = Wrapping::<u32>(const 0_u32);
        _14 = move _206;
        _207 = CheckedAdd(_6, const 1_i32);
        assert(!move (_207.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> [success: bb89, unwind unreachable];
    }

    bb89: {
        _6 = move (_207.0: i32);
        goto -> bb97;
    }

    bb90: {
        _209 = _2;
        _208 = Gt(move _209, const 1f64);
        switchInt(move _208) -> [0: bb95, otherwise: bb91];
    }

    bb91: {
        _210 = (_14.0: u32);
        switchInt(move _210) -> [4294967294: bb92, otherwise: bb94];
    }

    bb92: {
        _211 = CheckedAdd(_6, const 1_i32);
        assert(!move (_211.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_i32) -> [success: bb93, unwind unreachable];
    }

    bb93: {
        _6 = move (_211.0: i32);
        goto -> bb94;
    }

    bb94: {
        _213 = &mut _14;
        _214 = Wrapping::<u32>(const 2_u32);
        _212 = <Wrapping<u32> as AddAssign>::add_assign(move _213, move _214) -> [return: bb97, unwind unreachable];
    }

    bb95: {
        _216 = &mut _14;
        _218 = _14;
        _219 = Wrapping::<u32>(const 1_u32);
        _217 = <Wrapping<u32> as BitAnd>::bitand(move _218, move _219) -> [return: bb96, unwind unreachable];
    }

    bb96: {
        _215 = <Wrapping<u32> as AddAssign>::add_assign(move _216, move _217) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _221 = _6;
        _222 = const 1_i32 as u32 (IntToInt);
        _223 = Lt(move _222, const 32_u32);
        assert(move _223, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb98, unwind unreachable];
    }

    bb98: {
        _220 = Shr(move _221, const 1_i32);
        _224 = CheckedAdd(_220, const 1071644672_i32);
        assert(!move (_224.1: bool), "attempt to compute `{} + {}`, which would overflow", move _220, const 1071644672_i32) -> [success: bb99, unwind unreachable];
    }

    bb99: {
        _4 = move (_224.0: i32);
        _226 = _14;
        _225 = <Wrapping<u32> as Shr<usize>>::shr(move _226, const 1_usize) -> [return: bb100, unwind unreachable];
    }

    bb100: {
        _13 = move _225;
        _228 = _6;
        _227 = BitAnd(move _228, const 1_i32);
        switchInt(move _227) -> [1: bb101, otherwise: bb102];
    }

    bb101: {
        _230 = &mut _13;
        _231 = _3;
        _229 = <Wrapping<u32> as BitOrAssign>::bitor_assign(move _230, move _231) -> [return: bb102, unwind unreachable];
    }

    bb102: {
        _233 = _7;
        _234 = const 20_i32 as u32 (IntToInt);
        _235 = Lt(move _234, const 32_u32);
        assert(move _235, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb103, unwind unreachable];
    }

    bb103: {
        _232 = Shl(move _233, const 20_i32);
        _236 = CheckedAdd(_4, _232);
        assert(!move (_236.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _232) -> [success: bb104, unwind unreachable];
    }

    bb104: {
        _4 = move (_236.0: i32);
        _240 = _4;
        _239 = move _240 as u64 (IntToInt);
        _241 = const 32_i32 as u32 (IntToInt);
        _242 = Lt(move _241, const 64_u32);
        assert(move _242, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb105, unwind unreachable];
    }

    bb105: {
        _238 = Shl(move _239, const 32_i32);
        _244 = (_13.0: u32);
        _243 = move _244 as u64 (IntToInt);
        _237 = BitOr(move _238, move _243);
        _0 = f64::<impl f64>::from_bits(move _237) -> [return: bb106, unwind unreachable];
    }

    bb106: {
        return;
    }
}

promoted[0] in sqrt: &Wrapping<u32> = {
    let mut _0: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _1: rustc_std_workspace_core::num::Wrapping<u32>;

    bb0: {
        _1 = Wrapping::<u32>(const 0_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in sqrt: &Wrapping<u32> = {
    let mut _0: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _1: rustc_std_workspace_core::num::Wrapping<u32>;

    bb0: {
        _1 = Wrapping::<u32>(const 0_u32);
        _0 = &_1;
        return;
    }
}

promoted[2] in sqrt: &Wrapping<u32> = {
    let mut _0: &rustc_std_workspace_core::num::Wrapping<u32>;
    let mut _1: rustc_std_workspace_core::num::Wrapping<u32>;

    bb0: {
        _1 = Wrapping::<u32>(const 0_u32);
        _0 = &_1;
        return;
    }
}

const sqrt::TINY: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.0E-300f64;
        return;
    }
}

fn sqrtf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: u32;
    let mut _14: i32;
    let mut _15: f32;
    let mut _16: bool;
    let mut _17: i32;
    let mut _18: i32;
    let mut _19: i32;
    let mut _20: i32;
    let mut _21: bool;
    let mut _22: i32;
    let mut _23: f32;
    let mut _24: f32;
    let mut _25: i32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: i32;
    let mut _29: i32;
    let mut _30: i32;
    let mut _31: u32;
    let mut _32: bool;
    let mut _33: i32;
    let mut _34: (i32, bool);
    let mut _35: i32;
    let mut _36: i32;
    let mut _37: (i32, bool);
    let mut _38: (i32, bool);
    let mut _39: (i32, bool);
    let mut _40: i32;
    let mut _41: i32;
    let mut _42: i32;
    let mut _43: i32;
    let mut _44: i32;
    let mut _45: (i32, bool);
    let mut _46: u32;
    let mut _47: bool;
    let mut _48: i32;
    let mut _49: (i32, bool);
    let mut _50: u32;
    let mut _51: i32;
    let mut _52: i32;
    let mut _53: u32;
    let mut _54: (i32, bool);
    let mut _55: bool;
    let mut _56: i32;
    let mut _57: i32;
    let mut _58: u32;
    let mut _59: (i32, bool);
    let mut _60: (i32, bool);
    let mut _61: i32;
    let mut _62: u32;
    let mut _63: (i32, bool);
    let mut _64: i32;
    let mut _65: (i32, bool);
    let mut _66: u32;
    let mut _67: bool;
    let mut _68: i32;
    let mut _69: bool;
    let mut _70: f32;
    let mut _71: bool;
    let mut _72: f32;
    let mut _73: (i32, bool);
    let mut _74: i32;
    let mut _75: i32;
    let mut _76: (i32, bool);
    let mut _77: i32;
    let mut _78: i32;
    let mut _79: u32;
    let mut _80: bool;
    let mut _81: (i32, bool);
    let mut _82: i32;
    let mut _83: i32;
    let mut _84: u32;
    let mut _85: bool;
    let mut _86: (i32, bool);
    let mut _87: u32;
    let mut _88: i32;
    scope 1 {
        debug z => _2;
        let _3: i32;
        scope 2 {
            debug sign => _3;
            let mut _4: i32;
            scope 3 {
                debug ix => _4;
                let mut _5: i32;
                scope 4 {
                    debug s => _5;
                    let mut _6: i32;
                    scope 5 {
                        debug q => _6;
                        let mut _7: i32;
                        scope 6 {
                            debug m => _7;
                            let mut _8: i32;
                            scope 7 {
                                debug t => _8;
                                let mut _9: i32;
                                scope 8 {
                                    debug i => _9;
                                    let mut _10: u32;
                                    scope 9 {
                                        debug r => _10;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = const 2147483648_u32 as i32 (IntToInt);
        _11 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move _11 as i32 (IntToInt);
        _14 = _4;
        _13 = move _14 as u32 (IntToInt);
        _12 = BitAnd(move _13, const 2139095040_u32);
        switchInt(move _12) -> [2139095040: bb2, otherwise: bb3];
    }

    bb2: {
        _15 = Mul(_1, _1);
        _0 = Add(move _15, _1);
        goto -> bb47;
    }

    bb3: {
        _17 = _4;
        _16 = Le(move _17, const 0_i32);
        switchInt(move _16) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _19 = _4;
        _20 = Not(_3);
        _18 = BitAnd(move _19, move _20);
        switchInt(move _18) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = _1;
        goto -> bb47;
    }

    bb6: {
        _22 = _4;
        _21 = Lt(move _22, const 0_i32);
        switchInt(move _21) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _23 = Sub(_1, _1);
        _24 = Sub(_1, _1);
        _0 = Div(move _23, move _24);
        goto -> bb47;
    }

    bb8: {
        _25 = _4;
        _26 = const 23_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _7 = Shr(move _25, const 23_i32);
        _28 = _7;
        switchInt(move _28) -> [0: bb10, otherwise: bb18];
    }

    bb10: {
        _9 = const 0_i32;
        goto -> bb11;
    }

    bb11: {
        _30 = _4;
        _29 = BitAnd(move _30, const 8388608_i32);
        switchInt(move _29) -> [0: bb12, otherwise: bb15];
    }

    bb12: {
        _31 = const 1_i32 as u32 (IntToInt);
        _32 = Lt(move _31, const 32_u32);
        assert(move _32, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _4 = Shl(_4, const 1_i32);
        _33 = _9;
        _34 = CheckedAdd(_33, const 1_i32);
        assert(!move (_34.1: bool), "attempt to compute `{} + {}`, which would overflow", move _33, const 1_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _9 = move (_34.0: i32);
        goto -> bb11;
    }

    bb15: {
        _36 = _9;
        _37 = CheckedSub(_36, const 1_i32);
        assert(!move (_37.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, const 1_i32) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _35 = move (_37.0: i32);
        _38 = CheckedSub(_7, _35);
        assert(!move (_38.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, move _35) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _7 = move (_38.0: i32);
        goto -> bb18;
    }

    bb18: {
        _39 = CheckedSub(_7, const 127_i32);
        assert(!move (_39.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 127_i32) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _7 = move (_39.0: i32);
        _41 = _4;
        _40 = BitAnd(move _41, const 8388607_i32);
        _4 = BitOr(move _40, const 8388608_i32);
        _43 = _7;
        _42 = BitAnd(move _43, const 1_i32);
        switchInt(move _42) -> [1: bb20, otherwise: bb22];
    }

    bb20: {
        _44 = _4;
        _45 = CheckedAdd(_4, _44);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _44) -> [success: bb21, unwind unreachable];
    }

    bb21: {
        _4 = move (_45.0: i32);
        goto -> bb22;
    }

    bb22: {
        _46 = const 1_i32 as u32 (IntToInt);
        _47 = Lt(move _46, const 32_u32);
        assert(move _47, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb23, unwind unreachable];
    }

    bb23: {
        _7 = Shr(_7, const 1_i32);
        _48 = _4;
        _49 = CheckedAdd(_4, _48);
        assert(!move (_49.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _48) -> [success: bb24, unwind unreachable];
    }

    bb24: {
        _4 = move (_49.0: i32);
        _6 = const 0_i32;
        _5 = const 0_i32;
        _10 = const 16777216_u32;
        goto -> bb25;
    }

    bb25: {
        _50 = _10;
        switchInt(move _50) -> [0: bb35, otherwise: bb26];
    }

    bb26: {
        _51 = _5;
        _53 = _10;
        _52 = move _53 as i32 (IntToInt);
        _54 = CheckedAdd(_51, _52);
        assert(!move (_54.1: bool), "attempt to compute `{} + {}`, which would overflow", move _51, move _52) -> [success: bb27, unwind unreachable];
    }

    bb27: {
        _8 = move (_54.0: i32);
        _56 = _4;
        _55 = Le(_8, move _56);
        switchInt(move _55) -> [0: bb32, otherwise: bb28];
    }

    bb28: {
        _58 = _10;
        _57 = move _58 as i32 (IntToInt);
        _59 = CheckedAdd(_8, _57);
        assert(!move (_59.1: bool), "attempt to compute `{} + {}`, which would overflow", _8, move _57) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _5 = move (_59.0: i32);
        _60 = CheckedSub(_4, _8);
        assert(!move (_60.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, _8) -> [success: bb30, unwind unreachable];
    }

    bb30: {
        _4 = move (_60.0: i32);
        _62 = _10;
        _61 = move _62 as i32 (IntToInt);
        _63 = CheckedAdd(_6, _61);
        assert(!move (_63.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _61) -> [success: bb31, unwind unreachable];
    }

    bb31: {
        _6 = move (_63.0: i32);
        goto -> bb32;
    }

    bb32: {
        _64 = _4;
        _65 = CheckedAdd(_4, _64);
        assert(!move (_65.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _64) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _4 = move (_65.0: i32);
        _66 = const 1_i32 as u32 (IntToInt);
        _67 = Lt(move _66, const 32_u32);
        assert(move _67, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _10 = Shr(_10, const 1_i32);
        goto -> bb25;
    }

    bb35: {
        _68 = _4;
        switchInt(move _68) -> [0: bb42, otherwise: bb36];
    }

    bb36: {
        _2 = Sub(const 1f32, const _);
        _70 = _2;
        _69 = Ge(move _70, const 1f32);
        switchInt(move _69) -> [0: bb42, otherwise: bb37];
    }

    bb37: {
        _2 = Add(const 1f32, const _);
        _72 = _2;
        _71 = Gt(move _72, const 1f32);
        switchInt(move _71) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _73 = CheckedAdd(_6, const 2_i32);
        assert(!move (_73.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 2_i32) -> [success: bb39, unwind unreachable];
    }

    bb39: {
        _6 = move (_73.0: i32);
        goto -> bb42;
    }

    bb40: {
        _75 = _6;
        _74 = BitAnd(move _75, const 1_i32);
        _76 = CheckedAdd(_6, _74);
        assert(!move (_76.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, move _74) -> [success: bb41, unwind unreachable];
    }

    bb41: {
        _6 = move (_76.0: i32);
        goto -> bb42;
    }

    bb42: {
        _78 = _6;
        _79 = const 1_i32 as u32 (IntToInt);
        _80 = Lt(move _79, const 32_u32);
        assert(move _80, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb43, unwind unreachable];
    }

    bb43: {
        _77 = Shr(move _78, const 1_i32);
        _81 = CheckedAdd(_77, const 1056964608_i32);
        assert(!move (_81.1: bool), "attempt to compute `{} + {}`, which would overflow", move _77, const 1056964608_i32) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _4 = move (_81.0: i32);
        _83 = _7;
        _84 = const 23_i32 as u32 (IntToInt);
        _85 = Lt(move _84, const 32_u32);
        assert(move _85, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _82 = Shl(move _83, const 23_i32);
        _86 = CheckedAdd(_4, _82);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _82) -> [success: bb46, unwind unreachable];
    }

    bb46: {
        _4 = move (_86.0: i32);
        _88 = _4;
        _87 = move _88 as u32 (IntToInt);
        _0 = f32::<impl f32>::from_bits(move _87) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        return;
    }
}

const sqrtf::TINY: f32 = {
    let mut _0: f32;

    bb0: {
        _0 = const 1.0E-30f32;
        return;
    }
}

fn tan(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f32;
    let mut _4: u32;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let _11: f64;
    let mut _12: *const f64;
    let _13: &f64;
    let _14: f64;
    let mut _15: bool;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: bool;
    let mut _22: (i32, f64, f64);
    let mut _23: i32;
    scope 1 {
        debug x1p120 => _2;
        let _3: u32;
        scope 2 {
            debug ix => _3;
            let _19: i32;
            let _20: f64;
            let _21: f64;
            scope 3 {
            }
            scope 4 {
                debug n => _19;
                debug y0 => _20;
                debug y1 => _21;
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = const 32_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 64_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _5 = Shr(move _6, const 32_i32);
        _4 = move _5 as u32 (IntToInt);
        _3 = BitAnd(move _4, const 2147483647_u32);
        _9 = Le(_3, const 1072243195_u32);
        switchInt(move _9) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _10 = Lt(_3, const 1044381696_u32);
        switchInt(move _10) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _15 = Lt(_3, const 1048576_u32);
        switchInt(move _15) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _16 = _2 as f64 (FloatToFloat);
        _14 = Div(_1, move _16);
        goto -> bb8;
    }

    bb7: {
        _17 = _2 as f64 (FloatToFloat);
        _14 = Add(_1, move _17);
        goto -> bb8;
    }

    bb8: {
        _13 = &_14;
        _12 = &raw const (*_13);
        _11 = read_volatile::<f64>(move _12) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = _1;
        goto -> bb15;
    }

    bb10: {
        _0 = k_tan(_1, const 0f64, const 0_i32) -> [return: bb15, unwind unreachable];
    }

    bb11: {
        _18 = Ge(_3, const 2146435072_u32);
        switchInt(move _18) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = Sub(_1, _1);
        goto -> bb15;
    }

    bb13: {
        _22 = rem_pio2(_1) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _19 = (_22.0: i32);
        _20 = (_22.1: f64);
        _21 = (_22.2: f64);
        _23 = BitAnd(_19, const 1_i32);
        _0 = k_tan(_20, _21, move _23) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        return;
    }
}

const T1_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 1f64, const _);
        return;
    }
}

const T2_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 2f64, const _);
        return;
    }
}

const T3_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 3f64, const _);
        return;
    }
}

const T4_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Mul(const 4f64, const _);
        return;
    }
}

fn tanf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: u32;
    let mut _12: bool;
    let mut _13: u32;
    let _14: f32;
    let mut _15: *const f32;
    let _16: &f32;
    let _17: f32;
    let mut _18: bool;
    let mut _19: u32;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: bool;
    let mut _23: u32;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: bool;
    let mut _27: u32;
    let mut _28: bool;
    let mut _29: u32;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: bool;
    let mut _33: u32;
    let mut _36: (i32, f64);
    let mut _37: bool;
    let mut _38: i32;
    scope 1 {
        debug x64 => _2;
        let _3: f32;
        scope 2 {
            debug x1p120 => _3;
            let mut _4: u32;
            scope 3 {
                debug ix => _4;
                let _5: bool;
                scope 4 {
                    debug sign => _5;
                    let _34: i32;
                    let _35: f64;
                    scope 5 {
                    }
                    scope 6 {
                        debug n => _34;
                        debug y => _35;
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1 as f64 (FloatToFloat);
        _3 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _4;
        _8 = const 31_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 32_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _6 = Shr(move _7, const 31_i32);
        _5 = Ne(move _6, const 0_u32);
        _4 = BitAnd(_4, const 2147483647_u32);
        _11 = _4;
        _10 = Le(move _11, const 1061752794_u32);
        switchInt(move _10) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _13 = _4;
        _12 = Lt(move _13, const 964689920_u32);
        switchInt(move _12) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _19 = _4;
        _18 = Lt(move _19, const 8388608_u32);
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _17 = Div(_1, _3);
        goto -> bb8;
    }

    bb7: {
        _17 = Add(_1, _3);
        goto -> bb8;
    }

    bb8: {
        _16 = &_17;
        _15 = &raw const (*_16);
        _14 = read_volatile::<f32>(move _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _0 = _1;
        goto -> bb35;
    }

    bb10: {
        _0 = k_tanf(_2, const false) -> [return: bb35, unwind unreachable];
    }

    bb11: {
        _21 = _4;
        _20 = Le(move _21, const 1081824209_u32);
        switchInt(move _20) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _23 = _4;
        _22 = Le(move _23, const 1075235811_u32);
        switchInt(move _22) -> [0: bb18, otherwise: bb14];
    }

    bb13: {
        _27 = _4;
        _26 = Le(move _27, const 1088565717_u32);
        switchInt(move _26) -> [0: bb23, otherwise: bb22];
    }

    bb14: {
        switchInt(_5) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _24 = Add(_2, const _);
        goto -> bb17;
    }

    bb16: {
        _24 = Sub(_2, const _);
        goto -> bb17;
    }

    bb17: {
        _0 = k_tanf(move _24, const true) -> [return: bb35, unwind unreachable];
    }

    bb18: {
        switchInt(_5) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _25 = Add(_2, const _);
        goto -> bb21;
    }

    bb20: {
        _25 = Sub(_2, const _);
        goto -> bb21;
    }

    bb21: {
        _0 = k_tanf(move _25, const false) -> [return: bb35, unwind unreachable];
    }

    bb22: {
        _29 = _4;
        _28 = Le(move _29, const 1085271519_u32);
        switchInt(move _28) -> [0: bb28, otherwise: bb24];
    }

    bb23: {
        _33 = _4;
        _32 = Ge(move _33, const 2139095040_u32);
        switchInt(move _32) -> [0: bb33, otherwise: bb32];
    }

    bb24: {
        switchInt(_5) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _30 = Add(_2, const _);
        goto -> bb27;
    }

    bb26: {
        _30 = Sub(_2, const _);
        goto -> bb27;
    }

    bb27: {
        _0 = k_tanf(move _30, const true) -> [return: bb35, unwind unreachable];
    }

    bb28: {
        switchInt(_5) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _31 = Add(_2, const _);
        goto -> bb31;
    }

    bb30: {
        _31 = Sub(_2, const _);
        goto -> bb31;
    }

    bb31: {
        _0 = k_tanf(move _31, const false) -> [return: bb35, unwind unreachable];
    }

    bb32: {
        _0 = Sub(_1, _1);
        goto -> bb35;
    }

    bb33: {
        _36 = rem_pio2f(_1) -> [return: bb34, unwind unreachable];
    }

    bb34: {
        _34 = (_36.0: i32);
        _35 = (_36.1: f64);
        _38 = BitAnd(_34, const 1_i32);
        _37 = Ne(move _38, const 0_i32);
        _0 = k_tanf(_35, move _37) -> [return: bb35, unwind unreachable];
    }

    bb35: {
        return;
    }
}

fn tanh(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _4: f64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: u64;
    let mut _13: u64;
    let mut _14: bool;
    let mut _15: f64;
    let mut _16: u64;
    let mut _17: f64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u32;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: f64;
    let mut _25: f64;
    let mut _26: f64;
    let mut _27: f64;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: bool;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: bool;
    let mut _40: f64;
    let mut _41: f64;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let _47: f32;
    let mut _48: *const f32;
    let _49: &f32;
    let _50: f32;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    scope 1 {
        debug uf => _2;
        let mut _3: u64;
        scope 2 {
            debug ui => _3;
            let _5: u32;
            scope 3 {
                debug w => _5;
                let _6: bool;
                scope 4 {
                    debug sign => _6;
                    let mut _7: f64;
                    scope 5 {
                        debug t => _7;
                        scope 6 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1;
        _4 = _2;
        _3 = f64::<impl f64>::to_bits(move _4) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _9 = _3;
        _10 = const 63_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _8 = Shr(move _9, const 63_i32);
        _6 = Ne(move _8, const 0_u64);
        _13 = Not(const 1_u64);
        _14 = Eq(const 2_u64, const 0_u64);
        assert(!move _14, "attempt to divide `{}` by zero", _13) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _12 = Div(move _13, const 2_u64);
        _3 = BitAnd(_3, move _12);
        _16 = _3;
        _15 = f64::<impl f64>::from_bits(move _16) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _2 = move _15;
        _17 = _2;
        _1 = move _17;
        _19 = _3;
        _20 = const 32_i32 as u32 (IntToInt);
        _21 = Lt(move _20, const 64_u32);
        assert(move _21, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _18 = Shr(move _19, const 32_i32);
        _5 = move _18 as u32 (IntToInt);
        _22 = Gt(_5, const 1071748074_u32);
        switchInt(move _22) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _23 = Gt(_5, const 1077149696_u32);
        switchInt(move _23) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _25 = _1;
        _24 = Div(const 0f64, move _25);
        _7 = Sub(const 1f64, move _24);
        goto -> bb18;
    }

    bb8: {
        _28 = _1;
        _27 = Mul(const 2f64, move _28);
        _26 = expm1(move _27) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _7 = move _26;
        _31 = _7;
        _30 = Add(move _31, const 2f64);
        _29 = Div(const 2f64, move _30);
        _7 = Sub(const 1f64, move _29);
        goto -> bb18;
    }

    bb10: {
        _32 = Gt(_5, const 1070618798_u32);
        switchInt(move _32) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _35 = _1;
        _34 = Mul(const 2f64, move _35);
        _33 = expm1(move _34) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _7 = move _33;
        _36 = _7;
        _38 = _7;
        _37 = Add(move _38, const 2f64);
        _7 = Div(move _36, move _37);
        goto -> bb18;
    }

    bb13: {
        _39 = Ge(_5, const 1048576_u32);
        switchInt(move _39) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _42 = _1;
        _41 = Mul(const -2f64, move _42);
        _40 = expm1(move _41) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _7 = move _40;
        _44 = _7;
        _43 = Neg(move _44);
        _46 = _7;
        _45 = Add(move _46, const 2f64);
        _7 = Div(move _43, move _45);
        goto -> bb18;
    }

    bb16: {
        _51 = _1;
        _50 = move _51 as f32 (FloatToFloat);
        _49 = &_50;
        _48 = &raw const (*_49);
        _47 = read_volatile::<f32>(move _48) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _52 = _1;
        _7 = move _52;
        goto -> bb18;
    }

    bb18: {
        switchInt(_6) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _53 = _7;
        _0 = Neg(move _53);
        goto -> bb21;
    }

    bb20: {
        _0 = _7;
        goto -> bb21;
    }

    bb21: {
        return;
    }
}

fn tanhf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: u32;
    let mut _3: f32;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: bool;
    let mut _9: f32;
    let mut _10: u32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: f32;
    let mut _16: f32;
    let mut _18: f32;
    let mut _19: f32;
    let mut _20: f32;
    let mut _21: f32;
    let mut _22: bool;
    let mut _24: f32;
    let mut _25: f32;
    let mut _26: f32;
    let mut _27: bool;
    let mut _29: f32;
    let mut _30: f32;
    let mut _31: f32;
    let mut _32: f32;
    let _33: f32;
    let mut _34: *const f32;
    let _35: &f32;
    let _36: f32;
    let mut _37: f32;
    let mut _38: f32;
    let mut _39: f32;
    scope 1 {
        debug ix => _2;
        let _4: bool;
        scope 2 {
            debug sign => _4;
            let _11: u32;
            scope 3 {
                debug w => _11;
                let _12: f32;
                let _17: f32;
                let _23: f32;
                let _28: f32;
                scope 4 {
                    debug tt => _12;
                }
                scope 5 {
                    debug t => _17;
                }
                scope 6 {
                    debug t => _23;
                }
                scope 7 {
                    debug t => _28;
                }
                scope 8 {
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f32::<impl f32>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = _2;
        _7 = const 31_i32 as u32 (IntToInt);
        _8 = Lt(move _7, const 32_u32);
        assert(move _8, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 31_i32);
        _4 = Ne(move _5, const 0_u32);
        _2 = BitAnd(_2, const 2147483647_u32);
        _10 = _2;
        _9 = f32::<impl f32>::from_bits(move _10) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _1 = move _9;
        _11 = _2;
        _13 = Gt(_11, const 1057791828_u32);
        switchInt(move _13) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _14 = Gt(_11, const 1092616192_u32);
        switchInt(move _14) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _16 = _1;
        _15 = Div(const 0f32, move _16);
        _12 = Add(const 1f32, move _15);
        goto -> bb16;
    }

    bb6: {
        _19 = _1;
        _18 = Mul(const 2f32, move _19);
        _17 = expm1f(move _18) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _21 = Add(_17, const 2f32);
        _20 = Div(const 2f32, move _21);
        _12 = Sub(const 1f32, move _20);
        goto -> bb16;
    }

    bb8: {
        _22 = Gt(_11, const 1048757624_u32);
        switchInt(move _22) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _25 = _1;
        _24 = Mul(const 2f32, move _25);
        _23 = expm1f(move _24) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _26 = Add(_23, const 2f32);
        _12 = Div(_23, move _26);
        goto -> bb16;
    }

    bb11: {
        _27 = Ge(_11, const 8388608_u32);
        switchInt(move _27) -> [0: bb14, otherwise: bb12];
    }

    bb12: {
        _30 = _1;
        _29 = Mul(const -2f32, move _30);
        _28 = expm1f(move _29) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _31 = Neg(_28);
        _32 = Add(_28, const 2f32);
        _12 = Div(move _31, move _32);
        goto -> bb16;
    }

    bb14: {
        _37 = _1;
        _38 = _1;
        _36 = Mul(move _37, move _38);
        _35 = &_36;
        _34 = &raw const (*_35);
        _33 = read_volatile::<f32>(move _34) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _12 = _1;
        goto -> bb16;
    }

    bb16: {
        switchInt(_4) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _39 = _12;
        _0 = Neg(move _39);
        goto -> bb19;
    }

    bb18: {
        _0 = _12;
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

const tgamma::PI: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.1415926535897931f64;
        return;
    }
}

fn sinpi(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: isize;
    let mut _3: f64;
    let mut _4: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: isize;
    let mut _11: isize;
    let mut _12: (isize, bool);
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: isize;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    scope 1 {
        debug n => _2;
    }

    bb0: {
        _3 = _1;
        _1 = Mul(move _3, const 0.5f64);
        _5 = _1;
        _7 = _1;
        _6 = floor(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Sub(move _5, move _6);
        _1 = Mul(const 2f64, move _4);
        _9 = _1;
        _8 = Mul(const 4f64, move _9);
        _2 = move _8 as isize (FloatToInt);
        _11 = _2;
        _12 = CheckedAdd(_11, const 1_isize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, const 1_isize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _10 = move (_12.0: isize);
        _13 = Eq(const 2_isize, const 0_isize);
        assert(!move _13, "attempt to divide `{}` by zero", _10) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _14 = Eq(const 2_isize, const -1_isize);
        _15 = Eq(_10, const isize::MIN);
        _16 = BitAnd(move _14, move _15);
        assert(!move _16, "attempt to compute `{} / {}`, which would overflow", _10, const 2_isize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _2 = Div(move _10, const 2_isize);
        _19 = _2;
        _18 = move _19 as f64 (IntToFloat);
        _17 = Mul(move _18, const 0.5f64);
        _1 = Sub(_1, move _17);
        _1 = Mul(_1, const _);
        switchInt(_2) -> [1: bb5, 2: bb6, 3: bb7, otherwise: bb9];
    }

    bb5: {
        _20 = _1;
        _0 = k_cos(move _20, const 0f64) -> [return: bb10, unwind unreachable];
    }

    bb6: {
        _22 = _1;
        _21 = Neg(move _22);
        _0 = k_sin(move _21, const 0f64, const 0_i32) -> [return: bb10, unwind unreachable];
    }

    bb7: {
        _24 = _1;
        _23 = k_cos(move _24, const 0f64) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _0 = Neg(move _23);
        goto -> bb10;
    }

    bb9: {
        _25 = _1;
        _0 = k_sin(move _25, const 0f64, const 0_i32) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        return;
    }
}

const N: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 12_usize;
        return;
    }
}

const GMHALF: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 5.5246800407767296f64;
        return;
    }
}

const SNUM: [f64; 13] = {
    let mut _0: [f64; 13];

    bb0: {
        _0 = [const 23531376880.410759f64, const 42919803642.649101f64, const 35711959237.355667f64, const 17921034426.037209f64, const 6039542586.3520279f64, const 1439720407.3117216f64, const 248874557.86205417f64, const 31426415.585400194f64, const 2876370.6289353725f64, const 186056.26539522348f64, const 8071.6720023658163f64, const 210.82427775157936f64, const 2.5066282746310002f64];
        return;
    }
}

SNUM::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedAdd(const _, const 1_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const 1_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const SDEN: [f64; 13] = {
    let mut _0: [f64; 13];

    bb0: {
        _0 = [const 0f64, const 39916800f64, const 120543840f64, const 150917976f64, const 105258076f64, const 45995730f64, const 13339535f64, const 2637558f64, const 357423f64, const 32670f64, const 1925f64, const 66f64, const 1f64];
        return;
    }
}

SDEN::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedAdd(const _, const 1_usize);
        assert(!move (_1.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const 1_usize) -> [success: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move (_1.0: usize);
        return;
    }

    bb2 (cleanup): {
        resume;
    }
}

const FACT: [f64; 23] = {
    let mut _0: [f64; 23];

    bb0: {
        _0 = [const 1f64, const 1f64, const 2f64, const 6f64, const 24f64, const 120f64, const 720f64, const 5040f64, const 40320f64, const 362880f64, const 3628800f64, const 39916800f64, const 479001600f64, const 6227020800f64, const 87178291200f64, const 1307674368000f64, const 20922789888000f64, const 355687428096000f64, const 6402373705728000f64, const 1.21645100408832E+17f64, const 2.43290200817664E+18f64, const 5.109094217170944E+19f64, const 1.1240007277776077E+21f64];
        return;
    }
}

FACT::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 23_usize;
        return;
    }
}

fn s(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _4: bool;
    let mut _5: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _6: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _7: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _9: rustc_std_workspace_core::option::Option<usize>;
    let mut _10: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _11: isize;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: &f64;
    let mut _17: rustc_std_workspace_core::option::Option<&f64>;
    let mut _18: &[f64];
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: &f64;
    let mut _23: rustc_std_workspace_core::option::Option<&f64>;
    let mut _24: &[f64];
    let mut _25: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _26: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _28: rustc_std_workspace_core::option::Option<usize>;
    let mut _29: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _30: isize;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: &f64;
    let mut _36: rustc_std_workspace_core::option::Option<&f64>;
    let mut _37: &[f64];
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: &f64;
    let mut _42: rustc_std_workspace_core::option::Option<&f64>;
    let mut _43: &[f64];
    let mut _44: f64;
    let mut _45: f64;
    scope 1 {
        debug num => _2;
        let mut _3: f64;
        scope 2 {
            debug den => _3;
            let mut _8: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
            let mut _27: rustc_std_workspace_core::ops::RangeInclusive<usize>;
            scope 3 {
                debug iter => _8;
                let _12: usize;
                scope 4 {
                    debug i => _12;
                    let mut _46: &[f64; 13];
                    let mut _47: &[f64; 13];
                }
            }
            scope 5 {
                debug iter => _27;
                let _31: usize;
                scope 6 {
                    debug i => _31;
                    let mut _48: &[f64; 13];
                    let mut _49: &[f64; 13];
                }
            }
        }
    }

    bb0: {
        _2 = const 0f64;
        _3 = const 0f64;
        _4 = Lt(_1, const 8f64);
        switchInt(move _4) -> [0: bb12, otherwise: bb1];
    }

    bb1: {
        _7 = RangeInclusive::<usize>::new(const 0_usize, const _) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = <RangeInclusive<usize> as Iterator>::rev(move _7) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _5 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _6) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move _5;
        goto -> bb5;
    }

    bb5: {
        _10 = &mut _8;
        _9 = <Rev<RangeInclusive<usize>> as Iterator>::next(_10) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb22, 1: bb7, otherwise: bb23];
    }

    bb7: {
        _12 = ((_9 as Some).0: usize);
        _14 = _2;
        _13 = Mul(move _14, _1);
        _47 = const _;
        _18 = _47 as &[f64] (PointerCoercion(Unsize));
        _17 = slice::<impl [f64]>::get::<usize>(move _18, _12) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _16 = Option::<&f64>::unwrap(move _17) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _15 = (*_16);
        _2 = Add(move _13, move _15);
        _20 = _3;
        _19 = Mul(move _20, _1);
        _46 = const _;
        _24 = _46 as &[f64] (PointerCoercion(Unsize));
        _23 = slice::<impl [f64]>::get::<usize>(move _24, _12) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _22 = Option::<&f64>::unwrap(move _23) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _21 = (*_22);
        _3 = Add(move _19, move _21);
        goto -> bb5;
    }

    bb12: {
        _26 = RangeInclusive::<usize>::new(const 0_usize, const _) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _26) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _27 = move _25;
        goto -> bb15;
    }

    bb15: {
        _29 = &mut _27;
        _28 = <RangeInclusive<usize> as Iterator>::next(_29) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb22, 1: bb17, otherwise: bb23];
    }

    bb17: {
        _31 = ((_28 as Some).0: usize);
        _33 = _2;
        _32 = Div(move _33, _1);
        _49 = const _;
        _37 = _49 as &[f64] (PointerCoercion(Unsize));
        _36 = slice::<impl [f64]>::get::<usize>(move _37, _31) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _35 = Option::<&f64>::unwrap(move _36) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _34 = (*_35);
        _2 = Add(move _32, move _34);
        _39 = _3;
        _38 = Div(move _39, _1);
        _48 = const _;
        _43 = _48 as &[f64] (PointerCoercion(Unsize));
        _42 = slice::<impl [f64]>::get::<usize>(move _43, _31) -> [return: bb20, unwind unreachable];
    }

    bb20: {
        _41 = Option::<&f64>::unwrap(move _42) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _40 = (*_41);
        _3 = Add(move _38, move _40);
        goto -> bb15;
    }

    bb22: {
        _44 = _2;
        _45 = _3;
        _0 = Div(move _44, move _45);
        return;
    }

    bb23: {
        unreachable;
    }
}

promoted[0] in s: &[f64; 13] = {
    let mut _0: &[f64; 13];
    let mut _1: [f64; 13];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in s: &[f64; 13] = {
    let mut _0: &[f64; 13];
    let mut _1: [f64; 13];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in s: &[f64; 13] = {
    let mut _0: &[f64; 13];
    let mut _1: [f64; 13];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in s: &[f64; 13] = {
    let mut _0: &[f64; 13];
    let mut _1: [f64; 13];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn tgamma(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: u64;
    let mut _3: f64;
    let mut _10: u32;
    let mut _11: u64;
    let mut _12: u32;
    let mut _13: bool;
    let mut _15: u64;
    let mut _16: u32;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: f64;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: (u32, bool);
    let mut _24: u32;
    let mut _25: bool;
    let mut _26: f64;
    let mut _27: bool;
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: bool;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: usize;
    let mut _35: &[f64];
    let mut _36: &f64;
    let mut _37: rustc_std_workspace_core::option::Option<&f64>;
    let mut _38: &[f64];
    let mut _39: usize;
    let mut _40: usize;
    let mut _41: f64;
    let mut _42: (usize, bool);
    let mut _43: bool;
    let _45: f32;
    let mut _46: *const f32;
    let _47: &f32;
    let _48: f32;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: bool;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: bool;
    let mut _62: f64;
    let mut _63: f64;
    let mut _64: f64;
    let mut _65: f64;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: bool;
    let mut _69: f64;
    let mut _70: f64;
    let mut _71: f64;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: f64;
    let mut _76: f64;
    let mut _77: f64;
    let mut _78: f64;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: f64;
    let mut _84: f64;
    let mut _85: f64;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: f64;
    let mut _90: f64;
    let mut _91: f64;
    scope 1 {
        debug u => _2;
        let _4: f64;
        scope 2 {
            debug absx => _4;
            let mut _5: f64;
            scope 3 {
                debug y => _5;
                let mut _6: f64;
                scope 4 {
                    debug dy => _6;
                    let mut _7: f64;
                    scope 5 {
                        debug z => _7;
                        let mut _8: f64;
                        scope 6 {
                            debug r => _8;
                            let _9: u32;
                            scope 7 {
                                debug ix => _9;
                                let _14: bool;
                                scope 8 {
                                    debug sign => _14;
                                    let _44: f64;
                                    let _58: f64;
                                    let mut _92: &[f64; 23];
                                    let mut _93: &[f64; 23];
                                    scope 9 {
                                        debug x1p_126 => _44;
                                        scope 10 {
                                        }
                                    }
                                    scope 11 {
                                        debug x1p1023 => _58;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _2 = f64::<impl f64>::to_bits(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _12 = const 32_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Shr(_2, const 32_i32);
        _10 = move _11 as u32 (IntToInt);
        _9 = BitAnd(move _10, const 2147483647_u32);
        _16 = const 63_i32 as u32 (IntToInt);
        _17 = Lt(move _16, const 64_u32);
        assert(move _17, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _15 = Shr(_2, const 63_i32);
        _14 = Ne(move _15, const 0_u64);
        _18 = Ge(_9, const 2146435072_u32);
        switchInt(move _18) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _19 = _1;
        _0 = Add(move _19, const _);
        goto -> bb42;
    }

    bb5: {
        _23 = CheckedSub(const 1023_u32, const 54_u32);
        assert(!move (_23.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1023_u32, const 54_u32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _22 = move (_23.0: u32);
        _24 = const 20_i32 as u32 (IntToInt);
        _25 = Lt(move _24, const 32_u32);
        assert(move _25, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _21 = Shl(move _22, const 20_i32);
        _20 = Lt(_9, move _21);
        switchInt(move _20) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _26 = _1;
        _0 = Div(const 1f64, move _26);
        goto -> bb42;
    }

    bb9: {
        _28 = _1;
        _30 = _1;
        _29 = floor(move _30) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _27 = Eq(move _28, move _29);
        switchInt(move _27) -> [0: bb18, otherwise: bb11];
    }

    bb11: {
        switchInt(_14) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = Div(const 0f64, const 0f64);
        goto -> bb42;
    }

    bb13: {
        _32 = _1;
        _93 = const _;
        _35 = _93 as &[f64] (PointerCoercion(Unsize));
        _34 = Len((*_35));
        _33 = move _34 as f64 (IntToFloat);
        _31 = Le(move _32, move _33);
        switchInt(move _31) -> [0: bb18, otherwise: bb14];
    }

    bb14: {
        _92 = const _;
        _38 = _92 as &[f64] (PointerCoercion(Unsize));
        _41 = _1;
        _40 = move _41 as usize (FloatToInt);
        _42 = CheckedSub(_40, const 1_usize);
        assert(!move (_42.1: bool), "attempt to compute `{} - {}`, which would overflow", move _40, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _39 = move (_42.0: usize);
        _37 = slice::<impl [f64]>::get::<usize>(move _38, move _39) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _36 = Option::<&f64>::unwrap(move _37) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _0 = (*_36);
        goto -> bb42;
    }

    bb18: {
        _43 = Ge(_9, const 1080492032_u32);
        switchInt(move _43) -> [0: bb29, otherwise: bb19];
    }

    bb19: {
        switchInt(_14) -> [0: bb27, otherwise: bb20];
    }

    bb20: {
        _44 = f64::<impl f64>::from_bits(const 4039728865751334912_u64) -> [return: bb21, unwind unreachable];
    }

    bb21: {
        _50 = _1;
        _49 = Div(_44, move _50);
        _48 = move _49 as f32 (FloatToFloat);
        _47 = &_48;
        _46 = &raw const (*_47);
        _45 = read_volatile::<f32>(move _46) -> [return: bb22, unwind unreachable];
    }

    bb22: {
        _54 = _1;
        _53 = floor(move _54) -> [return: bb23, unwind unreachable];
    }

    bb23: {
        _52 = Mul(move _53, const 0.5f64);
        _57 = _1;
        _56 = Mul(move _57, const 0.5f64);
        _55 = floor(move _56) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _51 = Eq(move _52, move _55);
        switchInt(move _51) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _0 = const 0f64;
        goto -> bb42;
    }

    bb26: {
        _0 = const -0f64;
        goto -> bb42;
    }

    bb27: {
        _58 = f64::<impl f64>::from_bits(const 9214364837600034816_u64) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _1 = Mul(_1, _58);
        _0 = _1;
        goto -> bb42;
    }

    bb29: {
        switchInt(_14) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _60 = _1;
        _59 = Neg(move _60);
        goto -> bb32;
    }

    bb31: {
        _59 = _1;
        goto -> bb32;
    }

    bb32: {
        _4 = move _59;
        _5 = Add(_4, const _);
        _61 = Gt(_4, const _);
        switchInt(move _61) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _62 = _5;
        _6 = Sub(move _62, _4);
        _6 = Sub(_6, const _);
        goto -> bb35;
    }

    bb34: {
        _63 = _5;
        _6 = Sub(move _63, const _);
        _6 = Sub(_6, _4);
        goto -> bb35;
    }

    bb35: {
        _7 = Sub(_4, const 0.5f64);
        _64 = s(_4) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _67 = _5;
        _66 = Neg(move _67);
        _65 = exp(move _66) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _8 = Mul(move _64, move _65);
        _69 = _1;
        _68 = Lt(move _69, const 0f64);
        switchInt(move _68) -> [0: bb40, otherwise: bb38];
    }

    bb38: {
        _70 = Neg(const _);
        _73 = sinpi(_4) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _72 = Mul(move _73, _4);
        _74 = _8;
        _71 = Mul(move _72, move _74);
        _8 = Div(move _70, move _71);
        _75 = _6;
        _6 = Neg(move _75);
        _76 = _7;
        _7 = Neg(move _76);
        goto -> bb40;
    }

    bb40: {
        _80 = _6;
        _81 = Add(const _, const 0.5f64);
        _79 = Mul(move _80, move _81);
        _82 = _8;
        _78 = Mul(move _79, move _82);
        _83 = _5;
        _77 = Div(move _78, move _83);
        _8 = Add(_8, move _77);
        _85 = _5;
        _87 = _7;
        _86 = Mul(const 0.5f64, move _87);
        _84 = libm::pow::pow(move _85, move _86) -> [return: bb41, unwind unreachable];
    }

    bb41: {
        _7 = move _84;
        _89 = _8;
        _90 = _7;
        _88 = Mul(move _89, move _90);
        _91 = _7;
        _5 = Mul(move _88, move _91);
        _0 = _5;
        goto -> bb42;
    }

    bb42: {
        return;
    }
}

promoted[0] in tgamma: &[f64; 23] = {
    let mut _0: &[f64; 23];
    let mut _1: [f64; 23];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in tgamma: &[f64; 23] = {
    let mut _0: &[f64; 23];
    let mut _1: [f64; 23];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn tgammaf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let mut _2: f64;
    let mut _3: f64;

    bb0: {
        _3 = _1 as f64 (FloatToFloat);
        _2 = tgamma(move _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as f32 (FloatToFloat);
        return;
    }
}

fn libm::trunc::trunc(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _5: i64;
    let mut _6: i64;
    let mut _7: u64;
    let mut _8: u64;
    let mut _9: u64;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: (i64, bool);
    let mut _13: (i64, bool);
    let mut _15: bool;
    let mut _16: i64;
    let mut _17: i64;
    let mut _18: (i64, bool);
    let mut _19: bool;
    let mut _20: i64;
    let mut _21: u64;
    let mut _22: i64;
    let mut _23: u64;
    let mut _24: bool;
    let mut _25: u64;
    let mut _26: u64;
    let _27: f64;
    let mut _28: *const f64;
    let _29: &f64;
    let _30: f64;
    let mut _31: u64;
    let mut _32: u64;
    scope 1 {
        debug x1p120 => _2;
        let mut _3: u64;
        scope 2 {
            debug i => _3;
            let mut _4: i64;
            scope 3 {
                debug e => _4;
                let _14: u64;
                scope 4 {
                    debug m => _14;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 5147614374084476928_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = _3;
        _10 = const 52_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 64_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shr(move _9, const 52_i32);
        _7 = BitAnd(move _8, const 2047_u64);
        _6 = move _7 as i64 (IntToInt);
        _12 = CheckedSub(_6, const 1023_i64);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _6, const 1023_i64) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _5 = move (_12.0: i64);
        _13 = CheckedAdd(_5, const 12_i64);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _5, const 12_i64) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _4 = move (_13.0: i64);
        _16 = _4;
        _18 = CheckedAdd(const 52_i64, const 12_i64);
        assert(!move (_18.1: bool), "attempt to compute `{} + {}`, which would overflow", const 52_i64, const 12_i64) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _17 = move (_18.0: i64);
        _15 = Ge(move _16, move _17);
        switchInt(move _15) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = _1;
        goto -> bb15;
    }

    bb8: {
        _20 = _4;
        _19 = Lt(move _20, const 12_i64);
        switchInt(move _19) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _4 = const 1_i64;
        goto -> bb10;
    }

    bb10: {
        _21 = const -1_i64 as u64 (IntToInt);
        _22 = _4;
        _23 = _22 as u64 (IntToInt);
        _24 = Lt(move _23, const 64_u64);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _22) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _14 = Shr(move _21, move _22);
        _26 = _3;
        _25 = BitAnd(move _26, _14);
        switchInt(move _25) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        _0 = _1;
        goto -> bb15;
    }

    bb13: {
        _30 = Add(_1, _2);
        _29 = &_30;
        _28 = &raw const (*_29);
        _27 = read_volatile::<f64>(move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _31 = Not(_14);
        _3 = BitAnd(_3, move _31);
        _32 = _3;
        _0 = f64::<impl f64>::from_bits(move _32) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        return;
    }
}

fn truncf(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _5: i32;
    let mut _6: i32;
    let mut _7: u32;
    let mut _8: u32;
    let mut _9: u32;
    let mut _10: u32;
    let mut _11: bool;
    let mut _12: (i32, bool);
    let mut _13: (i32, bool);
    let mut _15: bool;
    let mut _16: i32;
    let mut _17: i32;
    let mut _18: (i32, bool);
    let mut _19: bool;
    let mut _20: i32;
    let mut _21: u32;
    let mut _22: i32;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: u32;
    let mut _26: u32;
    let _27: f32;
    let mut _28: *const f32;
    let _29: &f32;
    let _30: f32;
    let mut _31: u32;
    let mut _32: u32;
    scope 1 {
        debug x1p120 => _2;
        let mut _3: u32;
        scope 2 {
            debug i => _3;
            let mut _4: i32;
            scope 3 {
                debug e => _4;
                let _14: u32;
                scope 4 {
                    debug m => _14;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 2071986176_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = f32::<impl f32>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _9 = _3;
        _10 = const 23_i32 as u32 (IntToInt);
        _11 = Lt(move _10, const 32_u32);
        assert(move _11, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _8 = Shr(move _9, const 23_i32);
        _7 = BitAnd(move _8, const 255_u32);
        _6 = move _7 as i32 (IntToInt);
        _12 = CheckedSub(_6, const 127_i32);
        assert(!move (_12.1: bool), "attempt to compute `{} - {}`, which would overflow", move _6, const 127_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _5 = move (_12.0: i32);
        _13 = CheckedAdd(_5, const 9_i32);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _5, const 9_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _4 = move (_13.0: i32);
        _16 = _4;
        _18 = CheckedAdd(const 23_i32, const 9_i32);
        assert(!move (_18.1: bool), "attempt to compute `{} + {}`, which would overflow", const 23_i32, const 9_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _17 = move (_18.0: i32);
        _15 = Ge(move _16, move _17);
        switchInt(move _15) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = _1;
        goto -> bb15;
    }

    bb8: {
        _20 = _4;
        _19 = Lt(move _20, const 9_i32);
        switchInt(move _19) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _4 = const 1_i32;
        goto -> bb10;
    }

    bb10: {
        _21 = const -1_i32 as u32 (IntToInt);
        _22 = _4;
        _23 = _22 as u32 (IntToInt);
        _24 = Lt(move _23, const 32_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", _22) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _14 = Shr(move _21, move _22);
        _26 = _3;
        _25 = BitAnd(move _26, _14);
        switchInt(move _25) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        _0 = _1;
        goto -> bb15;
    }

    bb13: {
        _30 = Add(_1, _2);
        _29 = &_30;
        _28 = &raw const (*_29);
        _27 = read_volatile::<f32>(move _28) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _31 = Not(_14);
        _3 = BitAnd(_3, move _31);
        _32 = _3;
        _0 = f32::<impl f32>::from_bits(move _32) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        return;
    }
}

fn expo2(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: i32;
    let mut _7: i32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: (i32, bool);
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    scope 1 {
        debug kln2 => _2;
        let _3: f64;
        scope 2 {
            debug scale => _3;
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4653942887746821515_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Eq(const 2_i32, const 0_i32);
        assert(!move _8, "attempt to divide `{}` by zero", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Eq(const 2_i32, const -1_i32);
        _10 = Eq(const _, const i32::MIN);
        _11 = BitAnd(move _9, move _10);
        assert(!move _11, "attempt to compute `{} / {}`, which would overflow", const _, const 2_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Div(const _, const 2_i32);
        _12 = CheckedAdd(const 1023_i32, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, move _7) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _6 = move (_12.0: i32);
        _5 = move _6 as u32 (IntToInt);
        _13 = const 20_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Shl(move _5, const 20_i32);
        _3 = combine_words(move _4, const 0_u32) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Sub(_1, _2);
        _16 = exp(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = Mul(move _16, _3);
        _0 = Mul(move _15, _3);
        return;
    }
}

const expo2::K: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 2043_i32;
        return;
    }
}

const FE_UNDERFLOW: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

const FE_INEXACT: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

const FE_TONEAREST: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

fn feclearexcept(_1: i32) -> i32 {
    debug _mask => _1;
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

fn feraiseexcept(_1: i32) -> i32 {
    debug _mask => _1;
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

fn fetestexcept(_1: i32) -> i32 {
    debug _mask => _1;
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

fn fegetround() -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const _;
        return;
    }
}

const k_cos::C1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.041666666666666602f64;
        return;
    }
}

const k_cos::C2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.001388888888887411f64;
        return;
    }
}

const k_cos::C3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.4801587289476729E-5f64;
        return;
    }
}

const C4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.7557314351390663E-7f64;
        return;
    }
}

const C5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.0875723212981748E-9f64;
        return;
    }
}

const C6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.1359647557788195E-11f64;
        return;
    }
}

fn k_cos(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;
    let _3: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    scope 1 {
        debug z => _3;
        let _4: f64;
        scope 2 {
            debug w => _4;
            let _5: f64;
            scope 3 {
                debug r => _5;
                let _17: f64;
                scope 4 {
                    debug hz => _17;
                    let _18: f64;
                    scope 5 {
                        debug w => _18;
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Mul(_1, _1);
        _4 = Mul(_3, _3);
        _10 = Mul(_3, const _);
        _9 = Add(const _, move _10);
        _8 = Mul(_3, move _9);
        _7 = Add(const _, move _8);
        _6 = Mul(_3, move _7);
        _12 = Mul(_4, _4);
        _16 = Mul(_3, const _);
        _15 = Add(const _, move _16);
        _14 = Mul(_3, move _15);
        _13 = Add(const _, move _14);
        _11 = Mul(move _12, move _13);
        _5 = Add(move _6, move _11);
        _17 = Mul(const 0.5f64, _3);
        _18 = Sub(const 1f64, _17);
        _21 = Sub(const 1f64, _18);
        _20 = Sub(move _21, _17);
        _23 = Mul(_3, _5);
        _24 = Mul(_1, _2);
        _22 = Sub(move _23, move _24);
        _19 = Add(move _20, move _22);
        _0 = Add(_18, move _19);
        return;
    }
}

const C0: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.499999997251031f64;
        return;
    }
}

const k_cosf::C1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.041666623323739063f64;
        return;
    }
}

const k_cosf::C2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.0013886763774609929f64;
        return;
    }
}

const k_cosf::C3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.4390448796277409E-5f64;
        return;
    }
}

fn k_cosf(_1: f64) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug w => _3;
            let _4: f64;
            scope 3 {
                debug r => _4;
            }
        }
    }

    bb0: {
        _2 = Mul(_1, _1);
        _3 = Mul(_2, _2);
        _5 = Mul(_2, const _);
        _4 = Add(const _, move _5);
        _9 = Mul(_2, const _);
        _8 = Add(const 1f64, move _9);
        _10 = Mul(_3, const _);
        _7 = Add(move _8, move _10);
        _12 = Mul(_3, _2);
        _11 = Mul(move _12, _4);
        _6 = Add(move _7, move _11);
        _0 = move _6 as f32 (FloatToFloat);
        return;
    }
}

const k_expo2::K: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 2043_i32;
        return;
    }
}

fn k_expo2(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let _2: f64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: i32;
    let mut _9: i32;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: (i32, bool);
    let mut _15: u32;
    let mut _16: bool;
    let mut _17: u32;
    let mut _18: bool;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    scope 1 {
        debug k_ln2 => _2;
        let _3: f64;
        scope 2 {
            debug scale => _3;
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4653942887746821515_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _10 = Eq(const 2_i32, const 0_i32);
        assert(!move _10, "attempt to divide `{}` by zero", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = Eq(const 2_i32, const -1_i32);
        _12 = Eq(const _, const i32::MIN);
        _13 = BitAnd(move _11, move _12);
        assert(!move _13, "attempt to compute `{} / {}`, which would overflow", const _, const 2_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _9 = Div(const _, const 2_i32);
        _14 = CheckedAdd(const 1023_i32, _9);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, move _9) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _8 = move (_14.0: i32);
        _7 = move _8 as u32 (IntToInt);
        _15 = const 20_i32 as u32 (IntToInt);
        _16 = Lt(move _15, const 32_u32);
        assert(move _16, "attempt to shift left by `{}`, which would overflow", const 20_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _6 = Shl(move _7, const 20_i32);
        _5 = move _6 as u64 (IntToInt);
        _17 = const 32_i32 as u32 (IntToInt);
        _18 = Lt(move _17, const 64_u32);
        assert(move _18, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _4 = Shl(move _5, const 32_i32);
        _3 = f64::<impl f64>::from_bits(move _4) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _21 = Sub(_1, _2);
        _20 = exp(move _21) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _19 = Mul(move _20, _3);
        _0 = Mul(move _19, _3);
        return;
    }
}

const k_expo2f::K: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 235_i32;
        return;
    }
}

fn k_expo2f(_1: f32) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f32;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: i32;
    let mut _7: i32;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: (i32, bool);
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: f32;
    let mut _16: f32;
    let mut _17: f32;
    scope 1 {
        debug k_ln2 => _2;
        let _3: f32;
        scope 2 {
            debug scale => _3;
        }
    }

    bb0: {
        _2 = f32::<impl f32>::from_bits(const 1126359996_u32) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = Eq(const 2_i32, const 0_i32);
        assert(!move _8, "attempt to divide `{}` by zero", const _) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = Eq(const 2_i32, const -1_i32);
        _10 = Eq(const _, const i32::MIN);
        _11 = BitAnd(move _9, move _10);
        assert(!move _11, "attempt to compute `{} / {}`, which would overflow", const _, const 2_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _7 = Div(const _, const 2_i32);
        _12 = CheckedAdd(const 127_i32, _7);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_i32, move _7) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _6 = move (_12.0: i32);
        _5 = move _6 as u32 (IntToInt);
        _13 = const 23_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _4 = Shl(move _5, const 23_i32);
        _3 = f32::<impl f32>::from_bits(move _4) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _17 = Sub(_1, _2);
        _16 = expf(move _17) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _15 = Mul(move _16, _3);
        _0 = Mul(move _15, _3);
        return;
    }
}

const k_sin::S1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.16666666666666632f64;
        return;
    }
}

const k_sin::S2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0083333333333224895f64;
        return;
    }
}

const k_sin::S3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.9841269829857949E-4f64;
        return;
    }
}

const k_sin::S4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.7557313707070068E-6f64;
        return;
    }
}

const k_sin::S5: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -2.5050760253406863E-8f64;
        return;
    }
}

const k_sin::S6: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5896909952115501E-10f64;
        return;
    }
}

fn k_sin(_1: f64, _2: f64, _3: i32) -> f64 {
    debug x => _1;
    debug y => _2;
    debug iy => _3;
    let mut _0: f64;
    let _4: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _21: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: f64;
    let mut _25: f64;
    scope 1 {
        debug z => _4;
        let _5: f64;
        scope 2 {
            debug w => _5;
            let _6: f64;
            scope 3 {
                debug r => _6;
                let _15: f64;
                scope 4 {
                    debug v => _15;
                }
            }
        }
    }

    bb0: {
        _4 = Mul(_1, _1);
        _5 = Mul(_4, _4);
        _10 = Mul(_4, const _);
        _9 = Add(const _, move _10);
        _8 = Mul(_4, move _9);
        _7 = Add(const _, move _8);
        _12 = Mul(_4, _5);
        _14 = Mul(_4, const _);
        _13 = Add(const _, move _14);
        _11 = Mul(move _12, move _13);
        _6 = Add(move _7, move _11);
        _15 = Mul(_4, _1);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _18 = Mul(_4, _6);
        _17 = Add(const _, move _18);
        _16 = Mul(_15, move _17);
        _0 = Add(_1, move _16);
        goto -> bb3;
    }

    bb2: {
        _23 = Mul(const 0.5f64, _2);
        _24 = Mul(_15, _6);
        _22 = Sub(move _23, move _24);
        _21 = Mul(_4, move _22);
        _20 = Sub(move _21, _2);
        _25 = Mul(_15, const _);
        _19 = Sub(move _20, move _25);
        _0 = Sub(_1, move _19);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

const k_sinf::S1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -0.16666666641626524f64;
        return;
    }
}

const k_sinf::S2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.0083333293858894632f64;
        return;
    }
}

const k_sinf::S3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const -1.9839334836096632E-4f64;
        return;
    }
}

const k_sinf::S4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.7183114939898219E-6f64;
        return;
    }
}

fn k_sinf(_1: f64) -> f32 {
    debug x => _1;
    let mut _0: f32;
    let _2: f64;
    let mut _5: f64;
    let mut _7: f64;
    let mut _8: f64;
    let mut _9: f64;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _13: f64;
    scope 1 {
        debug z => _2;
        let _3: f64;
        scope 2 {
            debug w => _3;
            let _4: f64;
            scope 3 {
                debug r => _4;
                let _6: f64;
                scope 4 {
                    debug s => _6;
                }
            }
        }
    }

    bb0: {
        _2 = Mul(_1, _1);
        _3 = Mul(_2, _2);
        _5 = Mul(_2, const _);
        _4 = Add(const _, move _5);
        _6 = Mul(_2, _1);
        _11 = Mul(_2, const _);
        _10 = Add(const _, move _11);
        _9 = Mul(_6, move _10);
        _8 = Add(_1, move _9);
        _13 = Mul(_6, _3);
        _12 = Mul(move _13, _4);
        _7 = Add(move _8, move _12);
        _0 = move _7 as f32 (FloatToFloat);
        return;
    }
}

static k_tan::T: [f64; 13] = {
    let mut _0: [f64; 13];

    bb0: {
        _0 = [const 0.33333333333333409f64, const 0.13333333333320124f64, const 0.053968253976226052f64, const 0.021869488294859542f64, const 0.0088632398235993f64, const 0.0035920791075913124f64, const 0.0014562094543252903f64, const 5.880412408202641E-4f64, const 2.4646313481846991E-4f64, const 7.8179444293955709E-5f64, const 7.1407249138260819E-5f64, const -1.8558637485527546E-5f64, const 2.5907305186363371E-5f64];
        return;
    }
}

k_tan::T::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 13_usize;
        return;
    }
}

const PIO4: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.78539816339744828f64;
        return;
    }
}

const PIO4_LO: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 3.061616997868383E-17f64;
        return;
    }
}

fn k_tan(_1: f64, _2: f64, _3: i32) -> f64 {
    debug x => _1;
    debug y => _2;
    debug odd => _3;
    let mut _0: f64;
    let _4: u32;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: f64;
    let mut _8: u32;
    let mut _9: bool;
    let mut _11: u32;
    let mut _13: u32;
    let mut _14: bool;
    let mut _15: f64;
    let mut _16: f64;
    let mut _17: f64;
    let mut _18: f64;
    let mut _19: f64;
    let mut _20: f64;
    let mut _22: f64;
    let mut _23: f64;
    let mut _26: f64;
    let mut _27: &[f64; 13];
    let _28: usize;
    let mut _29: usize;
    let mut _30: bool;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: &[f64; 13];
    let _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    let mut _38: f64;
    let mut _39: f64;
    let mut _40: f64;
    let mut _41: &[f64; 13];
    let _42: usize;
    let mut _43: usize;
    let mut _44: bool;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: &[f64; 13];
    let _49: usize;
    let mut _50: usize;
    let mut _51: bool;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _55: &[f64; 13];
    let _56: usize;
    let mut _57: usize;
    let mut _58: bool;
    let mut _59: f64;
    let mut _60: f64;
    let mut _61: &[f64; 13];
    let _62: usize;
    let mut _63: usize;
    let mut _64: bool;
    let mut _66: f64;
    let mut _67: f64;
    let mut _68: &[f64; 13];
    let _69: usize;
    let mut _70: usize;
    let mut _71: bool;
    let mut _72: f64;
    let mut _73: f64;
    let mut _74: f64;
    let mut _75: &[f64; 13];
    let _76: usize;
    let mut _77: usize;
    let mut _78: bool;
    let mut _79: f64;
    let mut _80: f64;
    let mut _81: f64;
    let mut _82: &[f64; 13];
    let _83: usize;
    let mut _84: usize;
    let mut _85: bool;
    let mut _86: f64;
    let mut _87: f64;
    let mut _88: f64;
    let mut _89: &[f64; 13];
    let _90: usize;
    let mut _91: usize;
    let mut _92: bool;
    let mut _93: f64;
    let mut _94: f64;
    let mut _95: f64;
    let mut _96: &[f64; 13];
    let _97: usize;
    let mut _98: usize;
    let mut _99: bool;
    let mut _100: f64;
    let mut _101: f64;
    let mut _102: &[f64; 13];
    let _103: usize;
    let mut _104: usize;
    let mut _105: bool;
    let mut _107: f64;
    let mut _109: f64;
    let mut _110: f64;
    let mut _111: f64;
    let mut _112: f64;
    let mut _113: f64;
    let mut _114: f64;
    let mut _115: f64;
    let mut _116: f64;
    let mut _117: f64;
    let mut _118: &[f64; 13];
    let _119: usize;
    let mut _120: usize;
    let mut _121: bool;
    let mut _123: f64;
    let mut _125: u32;
    let mut _126: bool;
    let mut _128: f64;
    let mut _129: f64;
    let mut _131: f64;
    let mut _132: f64;
    let mut _133: f64;
    let mut _134: f64;
    let mut _135: f64;
    let mut _136: f64;
    let mut _137: f64;
    let mut _140: f64;
    let mut _141: f64;
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: f64;
    let mut _147: f64;
    let mut _148: f64;
    scope 1 {
        debug hx => _4;
        let _10: bool;
        scope 2 {
            debug big => _10;
            let _12: u32;
            let _21: f64;
            scope 3 {
                debug sign => _12;
            }
            scope 4 {
                debug z => _21;
                let _24: f64;
                scope 5 {
                    debug w => _24;
                    let _25: f64;
                    scope 6 {
                        debug r => _25;
                        let _65: f64;
                        scope 7 {
                            debug v => _65;
                            let _106: f64;
                            scope 8 {
                                debug s => _106;
                                let _108: f64;
                                scope 9 {
                                    debug r => _108;
                                    let _122: f64;
                                    scope 10 {
                                        debug w => _122;
                                        let _124: u32;
                                        let _138: f64;
                                        scope 11 {
                                            debug sign => _124;
                                            let _127: f64;
                                            scope 12 {
                                                debug s => _127;
                                                let _130: f64;
                                                scope 13 {
                                                    debug v => _130;
                                                }
                                            }
                                        }
                                        scope 14 {
                                            debug w0 => _138;
                                            let _139: f64;
                                            scope 15 {
                                                debug v => _139;
                                                let _142: f64;
                                                scope 16 {
                                                    debug a => _142;
                                                    let _143: f64;
                                                    scope 17 {
                                                        debug a0 => _143;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = _1;
        _6 = f64::<impl f64>::to_bits(move _7) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _8 = const 32_i32 as u32 (IntToInt);
        _9 = Lt(move _8, const 64_u32);
        assert(move _9, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _5 = Shr(move _6, const 32_i32);
        _4 = move _5 as u32 (IntToInt);
        _11 = BitAnd(_4, const 2147483647_u32);
        _10 = Ge(move _11, const 1072010280_u32);
        switchInt(_10) -> [0: bb7, otherwise: bb3];
    }

    bb3: {
        _13 = const 31_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 32_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _12 = Shr(_4, const 31_i32);
        switchInt(move _12) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _15 = _1;
        _1 = Neg(move _15);
        _16 = _2;
        _2 = Neg(move _16);
        goto -> bb6;
    }

    bb6: {
        _18 = _1;
        _17 = Sub(const _, move _18);
        _20 = _2;
        _19 = Sub(const _, move _20);
        _1 = Add(move _17, move _19);
        _2 = const 0f64;
        goto -> bb7;
    }

    bb7: {
        _22 = _1;
        _23 = _1;
        _21 = Mul(move _22, move _23);
        _24 = Mul(_21, _21);
        _27 = const {alloc10: &[f64; 13]};
        _28 = const 1_usize;
        _29 = const 13_usize;
        _30 = Lt(_28, _29);
        assert(move _30, "index out of bounds: the length is {} but the index is {}", move _29, _28) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _26 = (*_27)[_28];
        _34 = const {alloc10: &[f64; 13]};
        _35 = const 3_usize;
        _36 = const 13_usize;
        _37 = Lt(_35, _36);
        assert(move _37, "index out of bounds: the length is {} but the index is {}", move _36, _35) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _33 = (*_34)[_35];
        _41 = const {alloc10: &[f64; 13]};
        _42 = const 5_usize;
        _43 = const 13_usize;
        _44 = Lt(_42, _43);
        assert(move _44, "index out of bounds: the length is {} but the index is {}", move _43, _42) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _40 = (*_41)[_42];
        _48 = const {alloc10: &[f64; 13]};
        _49 = const 7_usize;
        _50 = const 13_usize;
        _51 = Lt(_49, _50);
        assert(move _51, "index out of bounds: the length is {} but the index is {}", move _50, _49) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _47 = (*_48)[_49];
        _55 = const {alloc10: &[f64; 13]};
        _56 = const 9_usize;
        _57 = const 13_usize;
        _58 = Lt(_56, _57);
        assert(move _58, "index out of bounds: the length is {} but the index is {}", move _57, _56) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _54 = (*_55)[_56];
        _61 = const {alloc10: &[f64; 13]};
        _62 = const 11_usize;
        _63 = const 13_usize;
        _64 = Lt(_62, _63);
        assert(move _64, "index out of bounds: the length is {} but the index is {}", move _63, _62) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _60 = (*_61)[_62];
        _59 = Mul(_24, move _60);
        _53 = Add(move _54, move _59);
        _52 = Mul(_24, move _53);
        _46 = Add(move _47, move _52);
        _45 = Mul(_24, move _46);
        _39 = Add(move _40, move _45);
        _38 = Mul(_24, move _39);
        _32 = Add(move _33, move _38);
        _31 = Mul(_24, move _32);
        _25 = Add(move _26, move _31);
        _68 = const {alloc10: &[f64; 13]};
        _69 = const 2_usize;
        _70 = const 13_usize;
        _71 = Lt(_69, _70);
        assert(move _71, "index out of bounds: the length is {} but the index is {}", move _70, _69) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _67 = (*_68)[_69];
        _75 = const {alloc10: &[f64; 13]};
        _76 = const 4_usize;
        _77 = const 13_usize;
        _78 = Lt(_76, _77);
        assert(move _78, "index out of bounds: the length is {} but the index is {}", move _77, _76) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _74 = (*_75)[_76];
        _82 = const {alloc10: &[f64; 13]};
        _83 = const 6_usize;
        _84 = const 13_usize;
        _85 = Lt(_83, _84);
        assert(move _85, "index out of bounds: the length is {} but the index is {}", move _84, _83) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _81 = (*_82)[_83];
        _89 = const {alloc10: &[f64; 13]};
        _90 = const 8_usize;
        _91 = const 13_usize;
        _92 = Lt(_90, _91);
        assert(move _92, "index out of bounds: the length is {} but the index is {}", move _91, _90) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _88 = (*_89)[_90];
        _96 = const {alloc10: &[f64; 13]};
        _97 = const 10_usize;
        _98 = const 13_usize;
        _99 = Lt(_97, _98);
        assert(move _99, "index out of bounds: the length is {} but the index is {}", move _98, _97) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _95 = (*_96)[_97];
        _102 = const {alloc10: &[f64; 13]};
        _103 = const 12_usize;
        _104 = const 13_usize;
        _105 = Lt(_103, _104);
        assert(move _105, "index out of bounds: the length is {} but the index is {}", move _104, _103) -> [success: bb19, unwind unreachable];
    }

    bb19: {
        _101 = (*_102)[_103];
        _100 = Mul(_24, move _101);
        _94 = Add(move _95, move _100);
        _93 = Mul(_24, move _94);
        _87 = Add(move _88, move _93);
        _86 = Mul(_24, move _87);
        _80 = Add(move _81, move _86);
        _79 = Mul(_24, move _80);
        _73 = Add(move _74, move _79);
        _72 = Mul(_24, move _73);
        _66 = Add(move _67, move _72);
        _65 = Mul(_21, move _66);
        _107 = _1;
        _106 = Mul(_21, move _107);
        _110 = _2;
        _114 = Add(_25, _65);
        _113 = Mul(_106, move _114);
        _115 = _2;
        _112 = Add(move _113, move _115);
        _111 = Mul(_21, move _112);
        _109 = Add(move _110, move _111);
        _118 = const {alloc10: &[f64; 13]};
        _119 = const 0_usize;
        _120 = const 13_usize;
        _121 = Lt(_119, _120);
        assert(move _121, "index out of bounds: the length is {} but the index is {}", move _120, _119) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _117 = (*_118)[_119];
        _116 = Mul(_106, move _117);
        _108 = Add(move _109, move _116);
        _123 = _1;
        _122 = Add(move _123, _108);
        switchInt(_10) -> [0: bb25, otherwise: bb21];
    }

    bb21: {
        _125 = const 31_i32 as u32 (IntToInt);
        _126 = Lt(move _125, const 32_u32);
        assert(move _126, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb22, unwind unreachable];
    }

    bb22: {
        _124 = Shr(_4, const 31_i32);
        _129 = _3 as f64 (IntToFloat);
        _128 = Mul(const 2f64, move _129);
        _127 = Sub(const 1f64, move _128);
        _133 = _1;
        _136 = Mul(_122, _122);
        _137 = Add(_122, _127);
        _135 = Div(move _136, move _137);
        _134 = Sub(_108, move _135);
        _132 = Add(move _133, move _134);
        _131 = Mul(const 2f64, move _132);
        _130 = Sub(_127, move _131);
        switchInt(move _124) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _0 = Neg(_130);
        goto -> bb30;
    }

    bb24: {
        _0 = _130;
        goto -> bb30;
    }

    bb25: {
        switchInt(move _3) -> [0: bb26, otherwise: bb27];
    }

    bb26: {
        _0 = _122;
        goto -> bb30;
    }

    bb27: {
        _138 = zero_low_word(_122) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        _141 = _1;
        _140 = Sub(_138, move _141);
        _139 = Sub(_108, move _140);
        _142 = Div(const -1f64, _122);
        _143 = zero_low_word(_142) -> [return: bb29, unwind unreachable];
    }

    bb29: {
        _147 = Mul(_143, _138);
        _146 = Add(const 1f64, move _147);
        _148 = Mul(_143, _139);
        _145 = Add(move _146, move _148);
        _144 = Mul(_142, move _145);
        _0 = Add(_143, move _144);
        goto -> bb30;
    }

    bb30: {
        return;
    }
}

alloc10 (static: k_tan::T, size: 104, align: 8) {
    0x00  63 55 55 55 55 55 d5 3f 7a fe 10 11 11 11 c1 3f  cUUUUU.?z......?
    0x10  fe 41 b3 1b ba a1 ab 3f 37 d6 06 84 f4 64 96 3f  .A.....?7....d.?
    0x20  93 84 6e e9 e3 26 82 3f 28 03 56 c9 22 6d 6d 3f  ..n..&.?(.V."mm?
    0x30  15 83 e0 fe c8 db 57 3f 01 65 f2 f2 d8 44 43 3f  ......W?.e...DC?
    0x40  68 10 8d 1a f7 26 30 3f a6 92 37 a0 88 7e 14 3f  h....&0?..7..~.?
    0x50  e9 a7 f0 32 0f b8 12 3f 73 53 60 db cb 75 f3 be  ...2...?sS`..u..
    0x60  d4 7a bf 74 70 2a fb 3e                          .z.tp*.>
}

fn zero_low_word(_1: f64) -> f64 {
    debug x => _1;
    let mut _0: f64;
    let mut _2: u64;
    let mut _3: u64;

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _2 = BitAnd(move _3, const 18446744069414584320_u64);
        _0 = f64::<impl f64>::from_bits(move _2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

const k_tanf::T: [f64; 6] = {
    let mut _0: [f64; 6];

    bb0: {
        _0 = [const 0.3333313950307914f64, const 0.13339200271297674f64, const 0.053381237844567039f64, const 0.024528318116654728f64, const 0.002974357433599673f64, const 0.0094656478494367316f64];
        return;
    }
}

k_tanf::T::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 6_usize;
        return;
    }
}

fn k_tanf(_1: f64, _2: bool) -> f32 {
    debug x => _1;
    debug odd => _2;
    let mut _0: f32;
    let _3: f64;
    let mut _5: f64;
    let mut _6: [f64; 6];
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: f64;
    let mut _11: f64;
    let mut _12: [f64; 6];
    let _13: usize;
    let mut _14: usize;
    let mut _15: bool;
    let mut _17: f64;
    let mut _18: [f64; 6];
    let _19: usize;
    let mut _20: usize;
    let mut _21: bool;
    let mut _22: f64;
    let mut _23: f64;
    let mut _24: [f64; 6];
    let _25: usize;
    let mut _26: usize;
    let mut _27: bool;
    let mut _31: f64;
    let mut _32: [f64; 6];
    let _33: usize;
    let mut _34: usize;
    let mut _35: bool;
    let mut _36: f64;
    let mut _37: f64;
    let mut _38: [f64; 6];
    let _39: usize;
    let mut _40: usize;
    let mut _41: bool;
    let mut _42: f64;
    let mut _43: f64;
    let mut _44: f64;
    let mut _45: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    scope 1 {
        debug z => _3;
        let mut _4: f64;
        scope 2 {
            debug r => _4;
            let _16: f64;
            scope 3 {
                debug t => _16;
                let _28: f64;
                scope 4 {
                    debug w => _28;
                    let _29: f64;
                    scope 5 {
                        debug s => _29;
                        let _30: f64;
                        scope 6 {
                            debug u => _30;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = Mul(_1, _1);
        _6 = const _;
        _7 = const 4_usize;
        _8 = const 6_usize;
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = _6[_7];
        _12 = const _;
        _13 = const 5_usize;
        _14 = const 6_usize;
        _15 = Lt(_13, _14);
        assert(move _15, "index out of bounds: the length is {} but the index is {}", move _14, _13) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _11 = _12[_13];
        _10 = Mul(_3, move _11);
        _4 = Add(move _5, move _10);
        _18 = const _;
        _19 = const 2_usize;
        _20 = const 6_usize;
        _21 = Lt(_19, _20);
        assert(move _21, "index out of bounds: the length is {} but the index is {}", move _20, _19) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _17 = _18[_19];
        _24 = const _;
        _25 = const 3_usize;
        _26 = const 6_usize;
        _27 = Lt(_25, _26);
        assert(move _27, "index out of bounds: the length is {} but the index is {}", move _26, _25) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _23 = _24[_25];
        _22 = Mul(_3, move _23);
        _16 = Add(move _17, move _22);
        _28 = Mul(_3, _3);
        _29 = Mul(_3, _1);
        _32 = const _;
        _33 = const 0_usize;
        _34 = const 6_usize;
        _35 = Lt(_33, _34);
        assert(move _35, "index out of bounds: the length is {} but the index is {}", move _34, _33) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _31 = _32[_33];
        _38 = const _;
        _39 = const 1_usize;
        _40 = const 6_usize;
        _41 = Lt(_39, _40);
        assert(move _41, "index out of bounds: the length is {} but the index is {}", move _40, _39) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _37 = _38[_39];
        _36 = Mul(_3, move _37);
        _30 = Add(move _31, move _36);
        _43 = Mul(_29, _30);
        _42 = Add(_1, move _43);
        _45 = Mul(_29, _28);
        _48 = _4;
        _47 = Mul(_28, move _48);
        _46 = Add(_16, move _47);
        _44 = Mul(move _45, move _46);
        _4 = Add(move _42, move _44);
        switchInt(_2) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _50 = _4;
        _49 = Div(const -1f64, move _50);
        goto -> bb9;
    }

    bb8: {
        _49 = _4;
        goto -> bb9;
    }

    bb9: {
        _0 = move _49 as f32 (FloatToFloat);
        return;
    }
}

const EPS: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.2204460492503131E-16f64;
        return;
    }
}

const TO_INT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Div(const 1.5f64, const _);
        return;
    }
}

const rem_pio2::INV_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.63661977236758138f64;
        return;
    }
}

const rem_pio2::PIO2_1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5707963267341256f64;
        return;
    }
}

const rem_pio2::PIO2_1T: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.0771005065061922E-11f64;
        return;
    }
}

const PIO2_2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 6.077100506303966E-11f64;
        return;
    }
}

const PIO2_2T: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.0222662487959506E-21f64;
        return;
    }
}

const PIO2_3: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 2.0222662487111665E-21f64;
        return;
    }
}

const PIO2_3T: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 8.4784276603688995E-32f64;
        return;
    }
}

fn rem_pio2(_1: f64) -> (i32, f64, f64) {
    debug x => _1;
    let mut _0: (i32, f64, f64);
    let _2: f64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: u32;
    let mut _10: u64;
    let mut _11: u64;
    let mut _12: u32;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: u32;
    let mut _16: bool;
    let mut _20: f64;
    let mut _24: f64;
    let mut _26: f64;
    let mut _28: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _33: f64;
    let mut _35: f64;
    let mut _37: f64;
    let mut _38: f64;
    let mut _39: bool;
    let mut _40: bool;
    let mut _42: f64;
    let mut _44: f64;
    let mut _46: f64;
    let mut _47: f64;
    let mut _49: f64;
    let mut _51: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _56: f64;
    let mut _58: f64;
    let mut _60: f64;
    let mut _61: f64;
    let mut _63: f64;
    let mut _65: f64;
    let mut _67: f64;
    let mut _68: f64;
    let mut _69: bool;
    let mut _70: bool;
    let mut _73: u64;
    let mut _74: u64;
    let mut _75: u32;
    let mut _76: bool;
    let mut _77: u64;
    let mut _78: u64;
    let mut _79: (u64, bool);
    let mut _80: u32;
    let mut _81: bool;
    let mut _83: u64;
    let mut _85: rustc_std_workspace_core::ops::Range<usize>;
    let mut _86: rustc_std_workspace_core::ops::Range<usize>;
    let mut _88: rustc_std_workspace_core::option::Option<usize>;
    let mut _89: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _90: isize;
    let mut _92: i32;
    let mut _93: f64;
    let mut _94: &mut f64;
    let mut _95: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _96: &mut [f64];
    let mut _97: &mut [f64; 3];
    let mut _98: f64;
    let mut _99: f64;
    let mut _100: f64;
    let mut _101: &f64;
    let mut _102: rustc_std_workspace_core::option::Option<&f64>;
    let mut _103: &[f64];
    let mut _104: &[f64; 3];
    let mut _105: f64;
    let mut _106: &mut f64;
    let mut _107: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _108: &mut [f64];
    let mut _109: &mut [f64; 3];
    let mut _111: usize;
    let mut _112: bool;
    let mut _113: f64;
    let mut _114: &f64;
    let mut _115: rustc_std_workspace_core::option::Option<&f64>;
    let mut _116: &[f64];
    let mut _117: &[f64; 3];
    let mut _118: usize;
    let mut _119: (usize, bool);
    let _122: &[f64];
    let mut _123: &[f64; 3];
    let mut _124: rustc_std_workspace_core::ops::RangeToInclusive<usize>;
    let mut _125: usize;
    let mut _126: &mut [f64];
    let mut _127: &mut [f64; 3];
    let mut _128: i32;
    let mut _129: i32;
    let mut _130: i32;
    let mut _131: u32;
    let mut _132: bool;
    let mut _133: i32;
    let mut _134: (i32, bool);
    let mut _135: (i32, bool);
    let mut _136: i32;
    let mut _137: bool;
    let mut _138: f64;
    let mut _139: f64;
    let mut _140: &f64;
    let mut _141: rustc_std_workspace_core::option::Option<&f64>;
    let mut _142: &[f64];
    let mut _143: &[f64; 3];
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: &f64;
    let mut _147: rustc_std_workspace_core::option::Option<&f64>;
    let mut _148: &[f64];
    let mut _149: &[f64; 3];
    let mut _150: f64;
    let mut _151: &f64;
    let mut _152: rustc_std_workspace_core::option::Option<&f64>;
    let mut _153: &[f64];
    let mut _154: &[f64; 3];
    let mut _155: f64;
    let mut _156: &f64;
    let mut _157: rustc_std_workspace_core::option::Option<&f64>;
    let mut _158: &[f64];
    let mut _159: &[f64; 3];
    scope 1 {
        debug x1p24 => _2;
        let _3: i32;
        scope 2 {
            debug sign => _3;
            let _8: u32;
            scope 3 {
                debug ix => _8;
                let _17: f64;
                let _21: f64;
                let _25: f64;
                let _32: f64;
                let _41: f64;
                let _48: f64;
                let _55: f64;
                let _62: f64;
                let _71: f64;
                let mut _72: u64;
                scope 4 {
                    debug z => _17;
                    let _18: f64;
                    scope 5 {
                        debug y0 => _18;
                        let _19: f64;
                        scope 6 {
                            debug y1 => _19;
                        }
                    }
                }
                scope 7 {
                    debug z => _21;
                    let _22: f64;
                    scope 8 {
                        debug y0 => _22;
                        let _23: f64;
                        scope 9 {
                            debug y1 => _23;
                        }
                    }
                }
                scope 10 {
                    debug z => _25;
                    let _27: f64;
                    scope 11 {
                        debug y0 => _27;
                        let _29: f64;
                        scope 12 {
                            debug y1 => _29;
                        }
                    }
                }
                scope 13 {
                    debug z => _32;
                    let _34: f64;
                    scope 14 {
                        debug y0 => _34;
                        let _36: f64;
                        scope 15 {
                            debug y1 => _36;
                        }
                    }
                }
                scope 16 {
                    debug z => _41;
                    let _43: f64;
                    scope 17 {
                        debug y0 => _43;
                        let _45: f64;
                        scope 18 {
                            debug y1 => _45;
                        }
                    }
                }
                scope 19 {
                    debug z => _48;
                    let _50: f64;
                    scope 20 {
                        debug y0 => _50;
                        let _52: f64;
                        scope 21 {
                            debug y1 => _52;
                        }
                    }
                }
                scope 22 {
                    debug z => _55;
                    let _57: f64;
                    scope 23 {
                        debug y0 => _57;
                        let _59: f64;
                        scope 24 {
                            debug y1 => _59;
                        }
                    }
                }
                scope 25 {
                    debug z => _62;
                    let _64: f64;
                    scope 26 {
                        debug y0 => _64;
                        let _66: f64;
                        scope 27 {
                            debug y1 => _66;
                        }
                    }
                }
                scope 28 {
                    debug y0 => _71;
                    scope 29 {
                        debug y1 => _71;
                    }
                }
                scope 30 {
                    debug ui => _72;
                    let mut _82: f64;
                    scope 31 {
                        debug z => _82;
                        let mut _84: [f64; 3];
                        scope 32 {
                            debug tx => _84;
                            let mut _87: rustc_std_workspace_core::ops::Range<usize>;
                            let mut _110: usize;
                            scope 33 {
                                debug iter => _87;
                                let _91: usize;
                                scope 34 {
                                    debug i => _91;
                                }
                            }
                            scope 35 {
                                debug i => _110;
                                let mut _120: [f64; 3];
                                scope 36 {
                                    debug ty => _120;
                                    let _121: i32;
                                    scope 37 {
                                        debug n => _121;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = f64::<impl f64>::from_bits(const 4715268809856909312_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = f64::<impl f64>::to_bits(_1) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = const 63_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift right by `{}`, which would overflow", const 63_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _4 = Shr(move _5, const 63_i32);
        _3 = move _4 as i32 (IntToInt);
        _11 = f64::<impl f64>::to_bits(_1) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = const 32_i32 as u32 (IntToInt);
        _13 = Lt(move _12, const 64_u32);
        assert(move _13, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _10 = Shr(move _11, const 32_i32);
        _9 = move _10 as u32 (IntToInt);
        _8 = BitAnd(move _9, const 2147483647_u32);
        _14 = Le(_8, const 1074752122_u32);
        switchInt(move _14) -> [0: bb15, otherwise: bb6];
    }

    bb6: {
        _15 = BitAnd(_8, const 1048575_u32);
        switchInt(move _15) -> [598523: bb7, otherwise: bb8];
    }

    bb7: {
        _0 = medium(_1, _8) -> [return: bb71, unwind unreachable];
    }

    bb8: {
        _16 = Le(_8, const 1073928572_u32);
        switchInt(move _16) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        switchInt(move _3) -> [0: bb11, otherwise: bb12];
    }

    bb10: {
        switchInt(move _3) -> [0: bb13, otherwise: bb14];
    }

    bb11: {
        _17 = Sub(_1, const _);
        _18 = Sub(_17, const _);
        _20 = Sub(_17, _18);
        _19 = Sub(move _20, const _);
        _0 = (const 1_i32, _18, _19);
        goto -> bb71;
    }

    bb12: {
        _21 = Add(_1, const _);
        _22 = Add(_21, const _);
        _24 = Sub(_21, _22);
        _23 = Add(move _24, const _);
        _0 = (const -1_i32, _22, _23);
        goto -> bb71;
    }

    bb13: {
        _26 = Mul(const 2f64, const _);
        _25 = Sub(_1, move _26);
        _28 = Mul(const 2f64, const _);
        _27 = Sub(_25, move _28);
        _30 = Sub(_25, _27);
        _31 = Mul(const 2f64, const _);
        _29 = Sub(move _30, move _31);
        _0 = (const 2_i32, _27, _29);
        goto -> bb71;
    }

    bb14: {
        _33 = Mul(const 2f64, const _);
        _32 = Add(_1, move _33);
        _35 = Mul(const 2f64, const _);
        _34 = Add(_32, move _35);
        _37 = Sub(_32, _34);
        _38 = Mul(const 2f64, const _);
        _36 = Add(move _37, move _38);
        _0 = (const -2_i32, _34, _36);
        goto -> bb71;
    }

    bb15: {
        _39 = Le(_8, const 1075594811_u32);
        switchInt(move _39) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _40 = Le(_8, const 1075183036_u32);
        switchInt(move _40) -> [0: bb23, otherwise: bb18];
    }

    bb17: {
        _69 = Lt(_8, const 1094263291_u32);
        switchInt(move _69) -> [0: bb29, otherwise: bb28];
    }

    bb18: {
        switchInt(move _8) -> [1074977148: bb19, otherwise: bb20];
    }

    bb19: {
        _0 = medium(_1, _8) -> [return: bb71, unwind unreachable];
    }

    bb20: {
        switchInt(move _3) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _42 = Mul(const 3f64, const _);
        _41 = Sub(_1, move _42);
        _44 = Mul(const 3f64, const _);
        _43 = Sub(_41, move _44);
        _46 = Sub(_41, _43);
        _47 = Mul(const 3f64, const _);
        _45 = Sub(move _46, move _47);
        _0 = (const 3_i32, _43, _45);
        goto -> bb71;
    }

    bb22: {
        _49 = Mul(const 3f64, const _);
        _48 = Add(_1, move _49);
        _51 = Mul(const 3f64, const _);
        _50 = Add(_48, move _51);
        _53 = Sub(_48, _50);
        _54 = Mul(const 3f64, const _);
        _52 = Add(move _53, move _54);
        _0 = (const -3_i32, _50, _52);
        goto -> bb71;
    }

    bb23: {
        switchInt(move _8) -> [1075388923: bb24, otherwise: bb25];
    }

    bb24: {
        _0 = medium(_1, _8) -> [return: bb71, unwind unreachable];
    }

    bb25: {
        switchInt(move _3) -> [0: bb26, otherwise: bb27];
    }

    bb26: {
        _56 = Mul(const 4f64, const _);
        _55 = Sub(_1, move _56);
        _58 = Mul(const 4f64, const _);
        _57 = Sub(_55, move _58);
        _60 = Sub(_55, _57);
        _61 = Mul(const 4f64, const _);
        _59 = Sub(move _60, move _61);
        _0 = (const 4_i32, _57, _59);
        goto -> bb71;
    }

    bb27: {
        _63 = Mul(const 4f64, const _);
        _62 = Add(_1, move _63);
        _65 = Mul(const 4f64, const _);
        _64 = Add(_62, move _65);
        _67 = Sub(_62, _64);
        _68 = Mul(const 4f64, const _);
        _66 = Add(move _67, move _68);
        _0 = (const -4_i32, _64, _66);
        goto -> bb71;
    }

    bb28: {
        _0 = medium(_1, _8) -> [return: bb71, unwind unreachable];
    }

    bb29: {
        _70 = Ge(_8, const 2146435072_u32);
        switchInt(move _70) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _71 = Sub(_1, _1);
        _0 = (const 0_i32, _71, _71);
        goto -> bb71;
    }

    bb31: {
        _72 = f64::<impl f64>::to_bits(_1) -> [return: bb32, unwind unreachable];
    }

    bb32: {
        _74 = Not(const 1_u64);
        _75 = const 12_i32 as u32 (IntToInt);
        _76 = Lt(move _75, const 64_u32);
        assert(move _76, "attempt to shift right by `{}`, which would overflow", const 12_i32) -> [success: bb33, unwind unreachable];
    }

    bb33: {
        _73 = Shr(move _74, const 12_i32);
        _72 = BitAnd(_72, move _73);
        _79 = CheckedAdd(const 1023_u64, const 23_u64);
        assert(!move (_79.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_u64, const 23_u64) -> [success: bb34, unwind unreachable];
    }

    bb34: {
        _78 = move (_79.0: u64);
        _80 = const 52_i32 as u32 (IntToInt);
        _81 = Lt(move _80, const 64_u32);
        assert(move _81, "attempt to shift left by `{}`, which would overflow", const 52_i32) -> [success: bb35, unwind unreachable];
    }

    bb35: {
        _77 = Shl(move _78, const 52_i32);
        _72 = BitOr(_72, move _77);
        _83 = _72;
        _82 = f64::<impl f64>::from_bits(move _83) -> [return: bb36, unwind unreachable];
    }

    bb36: {
        _84 = [const 0f64; 3];
        _86 = Range::<usize> { start: const 0_usize, end: const 2_usize };
        _85 = <Range<usize> as IntoIterator>::into_iter(move _86) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _87 = move _85;
        goto -> bb38;
    }

    bb38: {
        _89 = &mut _87;
        _88 = <Range<usize> as Iterator>::next(_89) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _90 = discriminant(_88);
        switchInt(move _90) -> [0: bb41, 1: bb40, otherwise: bb72];
    }

    bb40: {
        _91 = ((_88 as Some).0: usize);
        _93 = _82;
        _92 = move _93 as i32 (FloatToInt);
        _97 = &mut _84;
        _96 = move _97 as &mut [f64] (PointerCoercion(Unsize));
        _95 = slice::<impl [f64]>::get_mut::<usize>(move _96, _91) -> [return: bb42, unwind unreachable];
    }

    bb41: {
        _105 = _82;
        _109 = &mut _84;
        _108 = move _109 as &mut [f64] (PointerCoercion(Unsize));
        _107 = slice::<impl [f64]>::get_mut::<usize>(move _108, const 2_usize) -> [return: bb46, unwind unreachable];
    }

    bb42: {
        _94 = Option::<&mut f64>::unwrap(move _95) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        (*_94) = move _92 as f64 (IntToFloat);
        _99 = _82;
        _104 = &_84;
        _103 = move _104 as &[f64] (PointerCoercion(Unsize));
        _102 = slice::<impl [f64]>::get::<usize>(move _103, _91) -> [return: bb44, unwind unreachable];
    }

    bb44: {
        _101 = Option::<&f64>::unwrap(move _102) -> [return: bb45, unwind unreachable];
    }

    bb45: {
        _100 = (*_101);
        _98 = Sub(move _99, move _100);
        _82 = Mul(move _98, _2);
        goto -> bb38;
    }

    bb46: {
        _106 = Option::<&mut f64>::unwrap(move _107) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        (*_106) = move _105;
        _110 = const 2_usize;
        goto -> bb48;
    }

    bb48: {
        _111 = _110;
        switchInt(move _111) -> [0: bb54, otherwise: bb49];
    }

    bb49: {
        _117 = &_84;
        _116 = move _117 as &[f64] (PointerCoercion(Unsize));
        _118 = _110;
        _115 = slice::<impl [f64]>::get::<usize>(move _116, move _118) -> [return: bb50, unwind unreachable];
    }

    bb50: {
        _114 = Option::<&f64>::unwrap(move _115) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _113 = (*_114);
        _112 = Eq(move _113, const 0f64);
        switchInt(move _112) -> [0: bb54, otherwise: bb52];
    }

    bb52: {
        _119 = CheckedSub(_110, const 1_usize);
        assert(!move (_119.1: bool), "attempt to compute `{} - {}`, which would overflow", _110, const 1_usize) -> [success: bb53, unwind unreachable];
    }

    bb53: {
        _110 = move (_119.0: usize);
        goto -> bb48;
    }

    bb54: {
        _120 = [const 0f64; 3];
        _123 = &_84;
        _125 = _110;
        _124 = RangeToInclusive::<usize> { end: move _125 };
        _122 = <[f64; 3] as Index<RangeToInclusive<usize>>>::index(move _123, move _124) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _127 = &mut _120;
        _126 = _127 as &mut [f64] (PointerCoercion(Unsize));
        _130 = _8 as i32 (IntToInt);
        _131 = const 20_i32 as u32 (IntToInt);
        _132 = Lt(move _131, const 32_u32);
        assert(move _132, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb56, unwind unreachable];
    }

    bb56: {
        _129 = Shr(move _130, const 20_i32);
        _134 = CheckedAdd(const 1023_i32, const 23_i32);
        assert(!move (_134.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1023_i32, const 23_i32) -> [success: bb57, unwind unreachable];
    }

    bb57: {
        _133 = move (_134.0: i32);
        _135 = CheckedSub(_129, _133);
        assert(!move (_135.1: bool), "attempt to compute `{} - {}`, which would overflow", move _129, move _133) -> [success: bb58, unwind unreachable];
    }

    bb58: {
        _128 = move (_135.0: i32);
        _121 = rem_pio2_large(_122, move _126, move _128, const 1_usize) -> [return: bb59, unwind unreachable];
    }

    bb59: {
        switchInt(move _3) -> [0: bb66, otherwise: bb60];
    }

    bb60: {
        _137 = Eq(_121, const i32::MIN);
        assert(!move _137, "attempt to negate `{}`, which would overflow", _121) -> [success: bb61, unwind unreachable];
    }

    bb61: {
        _136 = Neg(_121);
        _143 = &_120;
        _142 = move _143 as &[f64] (PointerCoercion(Unsize));
        _141 = slice::<impl [f64]>::get::<usize>(move _142, const 0_usize) -> [return: bb62, unwind unreachable];
    }

    bb62: {
        _140 = Option::<&f64>::unwrap(move _141) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _139 = (*_140);
        _138 = Neg(move _139);
        _149 = &_120;
        _148 = move _149 as &[f64] (PointerCoercion(Unsize));
        _147 = slice::<impl [f64]>::get::<usize>(move _148, const 1_usize) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _146 = Option::<&f64>::unwrap(move _147) -> [return: bb65, unwind unreachable];
    }

    bb65: {
        _145 = (*_146);
        _144 = Neg(move _145);
        _0 = (move _136, move _138, move _144);
        goto -> bb71;
    }

    bb66: {
        _154 = &_120;
        _153 = move _154 as &[f64] (PointerCoercion(Unsize));
        _152 = slice::<impl [f64]>::get::<usize>(move _153, const 0_usize) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _151 = Option::<&f64>::unwrap(move _152) -> [return: bb68, unwind unreachable];
    }

    bb68: {
        _150 = (*_151);
        _159 = &_120;
        _158 = move _159 as &[f64] (PointerCoercion(Unsize));
        _157 = slice::<impl [f64]>::get::<usize>(move _158, const 1_usize) -> [return: bb69, unwind unreachable];
    }

    bb69: {
        _156 = Option::<&f64>::unwrap(move _157) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _155 = (*_156);
        _0 = (_121, move _150, move _155);
        goto -> bb71;
    }

    bb71: {
        return;
    }

    bb72: {
        unreachable;
    }
}

fn medium(_1: f64, _2: u32) -> (i32, f64, f64) {
    debug x => _1;
    debug ix => _2;
    let mut _0: (i32, f64, f64);
    let _3: f64;
    let mut _4: f64;
    let mut _8: f64;
    let mut _11: f64;
    let mut _12: f64;
    let mut _14: f64;
    let mut _16: i32;
    let mut _17: u64;
    let mut _18: u32;
    let mut _19: bool;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: i32;
    let mut _26: (i32, bool);
    let mut _28: f64;
    let mut _29: f64;
    let mut _30: f64;
    let mut _31: f64;
    let mut _32: f64;
    let mut _33: f64;
    let mut _34: f64;
    let mut _35: f64;
    let mut _37: i32;
    let mut _38: u64;
    let mut _39: u64;
    let mut _40: f64;
    let mut _41: u32;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: i32;
    let mut _45: (i32, bool);
    let mut _47: f64;
    let mut _48: f64;
    let mut _49: f64;
    let mut _50: f64;
    let mut _51: f64;
    let mut _52: f64;
    let mut _53: f64;
    let mut _54: f64;
    let mut _56: f64;
    let mut _57: f64;
    let mut _58: f64;
    let mut _59: f64;
    let mut _60: f64;
    scope 1 {
        debug tmp => _3;
        let _5: f64;
        scope 2 {
            debug f_n => _5;
            let _6: i32;
            scope 3 {
                debug n => _6;
                let mut _7: f64;
                scope 4 {
                    debug r => _7;
                    let mut _9: f64;
                    scope 5 {
                        debug w => _9;
                        let mut _10: f64;
                        scope 6 {
                            debug y0 => _10;
                            let _13: u64;
                            scope 7 {
                                debug ui => _13;
                                let _15: i32;
                                scope 8 {
                                    debug ey => _15;
                                    let _20: i32;
                                    scope 9 {
                                        debug ex => _20;
                                        let _27: f64;
                                        let _55: f64;
                                        scope 10 {
                                            debug t => _27;
                                            let _36: i32;
                                            scope 11 {
                                                debug ey => _36;
                                                let _46: f64;
                                                scope 12 {
                                                    debug t => _46;
                                                }
                                            }
                                        }
                                        scope 13 {
                                            debug y1 => _55;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = Mul(_1, const _);
        _3 = Add(move _4, const _);
        _5 = Sub(_3, const _);
        _6 = _5 as i32 (FloatToInt);
        _8 = Mul(_5, const _);
        _7 = Sub(_1, move _8);
        _9 = Mul(_5, const _);
        _11 = _7;
        _12 = _9;
        _10 = Sub(move _11, move _12);
        _14 = _10;
        _13 = f64::<impl f64>::to_bits(move _14) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _18 = const 52_i32 as u32 (IntToInt);
        _19 = Lt(move _18, const 64_u32);
        assert(move _19, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _17 = Shr(_13, const 52_i32);
        _16 = move _17 as i32 (IntToInt);
        _15 = BitAnd(move _16, const 2047_i32);
        _22 = const 20_i32 as u32 (IntToInt);
        _23 = Lt(move _22, const 32_u32);
        assert(move _23, "attempt to shift right by `{}`, which would overflow", const 20_i32) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _21 = Shr(_2, const 20_i32);
        _20 = move _21 as i32 (IntToInt);
        _26 = CheckedSub(_20, _15);
        assert(!move (_26.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, _15) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _25 = move (_26.0: i32);
        _24 = Gt(move _25, const 16_i32);
        switchInt(move _24) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _27 = _7;
        _9 = Mul(_5, const _);
        _28 = _9;
        _7 = Sub(_27, move _28);
        _29 = Mul(_5, const _);
        _32 = _7;
        _31 = Sub(_27, move _32);
        _33 = _9;
        _30 = Sub(move _31, move _33);
        _9 = Sub(move _29, move _30);
        _34 = _7;
        _35 = _9;
        _10 = Sub(move _34, move _35);
        _40 = _10;
        _39 = f64::<impl f64>::to_bits(move _40) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _41 = const 52_i32 as u32 (IntToInt);
        _42 = Lt(move _41, const 64_u32);
        assert(move _42, "attempt to shift right by `{}`, which would overflow", const 52_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _38 = Shr(move _39, const 52_i32);
        _37 = move _38 as i32 (IntToInt);
        _36 = BitAnd(move _37, const 2047_i32);
        _45 = CheckedSub(_20, _36);
        assert(!move (_45.1: bool), "attempt to compute `{} - {}`, which would overflow", _20, _36) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _44 = move (_45.0: i32);
        _43 = Gt(move _44, const 49_i32);
        switchInt(move _43) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _46 = _7;
        _9 = Mul(_5, const _);
        _47 = _9;
        _7 = Sub(_46, move _47);
        _48 = Mul(_5, const _);
        _51 = _7;
        _50 = Sub(_46, move _51);
        _52 = _9;
        _49 = Sub(move _50, move _52);
        _9 = Sub(move _48, move _49);
        _53 = _7;
        _54 = _9;
        _10 = Sub(move _53, move _54);
        goto -> bb10;
    }

    bb10: {
        _57 = _7;
        _58 = _10;
        _56 = Sub(move _57, move _58);
        _59 = _9;
        _55 = Sub(move _56, move _59);
        _60 = _10;
        _0 = (_6, move _60, _55);
        return;
    }
}

rem_pio2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

rem_pio2::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 3_usize;
        return;
    }
}

const INIT_JK: [usize; 4] = {
    let mut _0: [usize; 4];

    bb0: {
        _0 = [const 3_usize, const 4_usize, const 4_usize, const 6_usize];
        return;
    }
}

INIT_JK::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 4_usize;
        return;
    }
}

const IPIO2: [i32; 690] = {
    let mut _0: [i32; 690];

    bb0: {
        _0 = [const 10680707_i32, const 7228996_i32, const 1387004_i32, const 2578385_i32, const 16069853_i32, const 12639074_i32, const 9804092_i32, const 4427841_i32, const 16666979_i32, const 11263675_i32, const 12935607_i32, const 2387514_i32, const 4345298_i32, const 14681673_i32, const 3074569_i32, const 13734428_i32, const 16653803_i32, const 1880361_i32, const 10960616_i32, const 8533493_i32, const 3062596_i32, const 8710556_i32, const 7349940_i32, const 6258241_i32, const 3772886_i32, const 3769171_i32, const 3798172_i32, const 8675211_i32, const 12450088_i32, const 3874808_i32, const 9961438_i32, const 366607_i32, const 15675153_i32, const 9132554_i32, const 7151469_i32, const 3571407_i32, const 2607881_i32, const 12013382_i32, const 4155038_i32, const 6285869_i32, const 7677882_i32, const 13102053_i32, const 15825725_i32, const 473591_i32, const 9065106_i32, const 15363067_i32, const 6271263_i32, const 9264392_i32, const 5636912_i32, const 4652155_i32, const 7056368_i32, const 13614112_i32, const 10155062_i32, const 1944035_i32, const 9527646_i32, const 15080200_i32, const 6658437_i32, const 6231200_i32, const 6832269_i32, const 16767104_i32, const 5075751_i32, const 3212806_i32, const 1398474_i32, const 7579849_i32, const 6349435_i32, const 12618859_i32, const 4703257_i32, const 12806093_i32, const 14477321_i32, const 2786137_i32, const 12875403_i32, const 9837734_i32, const 14528324_i32, const 13719321_i32, const 343717_i32, const 16713477_i32, const 4161075_i32, const 15217346_i32, const 14569368_i32, const 3308987_i32, const 12795174_i32, const 15690526_i32, const 6224031_i32, const 3809077_i32, const 13300351_i32, const 1935345_i32, const 2199676_i32, const 8135786_i32, const 16412373_i32, const 7810352_i32, const 4406037_i32, const 12981429_i32, const 10295747_i32, const 12764333_i32, const 4279596_i32, const 6094860_i32, const 4619654_i32, const 2978275_i32, const 10143387_i32, const 25139_i32, const 8180404_i32, const 9938868_i32, const 13980983_i32, const 16137943_i32, const 1577123_i32, const 16545357_i32, const 2792804_i32, const 11261808_i32, const 16284771_i32, const 5746810_i32, const 15144215_i32, const 5654976_i32, const 14276155_i32, const 3703975_i32, const 13312804_i32, const 7834326_i32, const 2315354_i32, const 12132096_i32, const 1772273_i32, const 14667289_i32, const 16724383_i32, const 6954598_i32, const 6379417_i32, const 4717484_i32, const 14188414_i32, const 12018978_i32, const 9037874_i32, const 6340582_i32, const 13485295_i32, const 603756_i32, const 13909853_i32, const 14147094_i32, const 14564184_i32, const 9608158_i32, const 2630354_i32, const 15238696_i32, const 5069026_i32, const 3328710_i32, const 1499912_i32, const 13336032_i32, const 5292055_i32, const 10952179_i32, const 6021144_i32, const 3412782_i32, const 6427267_i32, const 84099_i32, const 6000373_i32, const 8368301_i32, const 15919390_i32, const 4409928_i32, const 13854480_i32, const 14212522_i32, const 4349870_i32, const 13525354_i32, const 10758154_i32, const 11835859_i32, const 15902214_i32, const 8353628_i32, const 8635043_i32, const 8928353_i32, const 7893898_i32, const 5934255_i32, const 12441455_i32, const 6530605_i32, const 13352948_i32, const 15696269_i32, const 6799654_i32, const 4573781_i32, const 3594698_i32, const 13805608_i32, const 9265602_i32, const 7850258_i32, const 1320452_i32, const 10176018_i32, const 12868036_i32, const 4507080_i32, const 9548365_i32, const 15931136_i32, const 11355092_i32, const 15026473_i32, const 1103357_i32, const 16563712_i32, const 13407262_i32, const 15650416_i32, const 16072211_i32, const 8450540_i32, const 12838835_i32, const 2685127_i32, const 9700755_i32, const 4092353_i32, const 11733294_i32, const 15942923_i32, const 10228360_i32, const 8069291_i32, const 10466606_i32, const 12751431_i32, const 3093115_i32, const 7165196_i32, const 9480050_i32, const 2090859_i32, const 9882417_i32, const 4855417_i32, const 14842177_i32, const 9035764_i32, const 9934056_i32, const 8709858_i32, const 9908633_i32, const 7073160_i32, const 3563359_i32, const 982459_i32, const 11835976_i32, const 7119975_i32, const 4354673_i32, const 3300749_i32, const 12064159_i32, const 648636_i32, const 2437517_i32, const 3765495_i32, const 1836336_i32, const 68621_i32, const 6817867_i32, const 5828140_i32, const 9480775_i32, const 190324_i32, const 2414269_i32, const 10911223_i32, const 7489646_i32, const 15668895_i32, const 10917006_i32, const 16159156_i32, const 5329873_i32, const 15862479_i32, const 3381280_i32, const 8276981_i32, const 6841266_i32, const 6242013_i32, const 220480_i32, const 8358277_i32, const 2708053_i32, const 12608567_i32, const 1103981_i32, const 3295282_i32, const 7687259_i32, const 13922638_i32, const 7230533_i32, const 12650763_i32, const 6944042_i32, const 13985300_i32, const 10290983_i32, const 5243997_i32, const 14367668_i32, const 12941034_i32, const 1571207_i32, const 8219465_i32, const 12199709_i32, const 2714006_i32, const 11324614_i32, const 5510317_i32, const 7004816_i32, const 9034120_i32, const 5272108_i32, const 12493828_i32, const 9701239_i32, const 7352563_i32, const 2620416_i32, const 11039210_i32, const 4833894_i32, const 4055140_i32, const 8641943_i32, const 9912227_i32, const 16618563_i32, const 9209357_i32, const 14565681_i32, const 10303890_i32, const 9203933_i32, const 15185687_i32, const 3923720_i32, const 2832149_i32, const 10518620_i32, const 9666650_i32, const 9572624_i32, const 14215183_i32, const 11501676_i32, const 4980699_i32, const 1019960_i32, const 7739481_i32, const 1418594_i32, const 12307297_i32, const 12159431_i32, const 12402704_i32, const 324306_i32, const 2585929_i32, const 16168683_i32, const 12264155_i32, const 11146250_i32, const 3090057_i32, const 7766884_i32, const 3357449_i32, const 1741838_i32, const 11156049_i32, const 12755741_i32, const 11464111_i32, const 1189468_i32, const 5096045_i32, const 10254893_i32, const 9918144_i32, const 8601347_i32, const 16183305_i32, const 9191467_i32, const 10039661_i32, const 504889_i32, const 1384460_i32, const 6013912_i32, const 12882677_i32, const 4959686_i32, const 10865230_i32, const 13449127_i32, const 3582438_i32, const 9736875_i32, const 6832861_i32, const 14574361_i32, const 15699062_i32, const 5409640_i32, const 3660796_i32, const 11248046_i32, const 3216863_i32, const 10595840_i32, const 14351116_i32, const 6704484_i32, const 11994605_i32, const 3171625_i32, const 12539479_i32, const 3866439_i32, const 12188010_i32, const 15974005_i32, const 14652200_i32, const 3178667_i32, const 16157798_i32, const 1428228_i32, const 402170_i32, const 1959129_i32, const 10793789_i32, const 9378647_i32, const 642358_i32, const 15286862_i32, const 10796563_i32, const 11871027_i32, const 1747696_i32, const 11035983_i32, const 10863058_i32, const 999179_i32, const 13465691_i32, const 7797027_i32, const 297851_i32, const 7477129_i32, const 5482182_i32, const 14839407_i32, const 60399_i32, const 5786267_i32, const 12049092_i32, const 12215978_i32, const 13619062_i32, const 1901265_i32, const 3010993_i32, const 12687756_i32, const 7843267_i32, const 14305414_i32, const 10509815_i32, const 16023750_i32, const 3141804_i32, const 10153181_i32, const 12344383_i32, const 7200464_i32, const 2082704_i32, const 11983658_i32, const 3810723_i32, const 10137344_i32, const 9655213_i32, const 284598_i32, const 11808041_i32, const 8290379_i32, const 10946522_i32, const 961142_i32, const 10574203_i32, const 2757142_i32, const 2996188_i32, const 16639482_i32, const 16702345_i32, const 16629385_i32, const 7108324_i32, const 16558342_i32, const 7372862_i32, const 1404549_i32, const 16746493_i32, const 474664_i32, const 3368801_i32, const 8788010_i32, const 15383885_i32, const 11528115_i32, const 7237007_i32, const 3762069_i32, const 6012721_i32, const 4773764_i32, const 1498928_i32, const 4402631_i32, const 3498277_i32, const 13529289_i32, const 12110640_i32, const 16608447_i32, const 10616996_i32, const 14969861_i32, const 10542426_i32, const 4681505_i32, const 13767266_i32, const 8674489_i32, const 4809072_i32, const 14702187_i32, const 86681_i32, const 3626320_i32, const 12047646_i32, const 12906803_i32, const 6254099_i32, const 14954589_i32, const 11087493_i32, const 12825117_i32, const 3551905_i32, const 10794760_i32, const 13939178_i32, const 2225942_i32, const 14969231_i32, const 7864103_i32, const 8389388_i32, const 2965645_i32, const 10538319_i32, const 10069280_i32, const 13869747_i32, const 679215_i32, const 4389300_i32, const 13359633_i32, const 13680253_i32, const 12704667_i32, const 12392363_i32, const 8495818_i32, const 6056456_i32, const 1529134_i32, const 5570599_i32, const 15733887_i32, const 8783841_i32, const 6556436_i32, const 9257366_i32, const 14597767_i32, const 2817498_i32, const 11937131_i32, const 3443067_i32, const 16708357_i32, const 10403769_i32, const 5204584_i32, const 11020874_i32, const 5948495_i32, const 12384301_i32, const 9984727_i32, const 9816052_i32, const 9260301_i32, const 10893856_i32, const 6248356_i32, const 11616020_i32, const 9779328_i32, const 73932_i32, const 8838513_i32, const 11984585_i32, const 16081087_i32, const 1140045_i32, const 7014145_i32, const 11317388_i32, const 13680818_i32, const 4740433_i32, const 981790_i32, const 12808853_i32, const 3868323_i32, const 3489984_i32, const 8117254_i32, const 13387232_i32, const 16394574_i32, const 13159126_i32, const 4322280_i32, const 14574716_i32, const 14181531_i32, const 3260121_i32, const 12818340_i32, const 13916279_i32, const 12968809_i32, const 1301232_i32, const 3947194_i32, const 4593734_i32, const 6255957_i32, const 16104914_i32, const 13013614_i32, const 6106796_i32, const 15549454_i32, const 4341276_i32, const 8897633_i32, const 15334697_i32, const 15980263_i32, const 13270050_i32, const 3510639_i32, const 12967944_i32, const 9295871_i32, const 14838382_i32, const 13041072_i32, const 12650643_i32, const 7626108_i32, const 11709803_i32, const 10317517_i32, const 8090174_i32, const 6951366_i32, const 11128823_i32, const 14644009_i32, const 12241333_i32, const 5308599_i32, const 897762_i32, const 2407028_i32, const 6323685_i32, const 9099380_i32, const 2888973_i32, const 792705_i32, const 9725566_i32, const 1452289_i32, const 7764639_i32, const 12516861_i32, const 15680854_i32, const 3571417_i32, const 1300972_i32, const 12171915_i32, const 16553924_i32, const 2598961_i32, const 12807921_i32, const 3589524_i32, const 5679320_i32, const 11905204_i32, const 969935_i32, const 2984210_i32, const 3430255_i32, const 9000492_i32, const 14929561_i32, const 12132566_i32, const 11165291_i32, const 10234430_i32, const 13393681_i32, const 4852733_i32, const 16512225_i32, const 7158670_i32, const 2918114_i32, const 8705257_i32, const 11121916_i32, const 13758191_i32, const 13186350_i32, const 6371631_i32, const 4464952_i32, const 13162779_i32, const 720001_i32, const 6966011_i32, const 14162991_i32, const 8696915_i32, const 9214286_i32, const 13378132_i32, const 14439722_i32, const 14075584_i32, const 9836811_i32, const 12087322_i32, const 6591849_i32, const 6314534_i32, const 15618623_i32, const 987519_i32, const 1160692_i32, const 16108540_i32, const 2997300_i32, const 15645748_i32, const 13393384_i32, const 6315741_i32, const 10194535_i32, const 15676306_i32, const 12064713_i32, const 10180705_i32, const 12343265_i32, const 13009745_i32, const 1064664_i32, const 4747741_i32, const 14490669_i32, const 10557615_i32, const 4598817_i32, const 14152537_i32, const 9992921_i32, const 12604574_i32, const 16418383_i32, const 16516694_i32, const 11434469_i32, const 3547785_i32, const 2272568_i32, const 14455655_i32, const 11200597_i32, const 3679874_i32, const 10217418_i32, const 10751313_i32, const 11613081_i32, const 972713_i32, const 4719977_i32, const 15774309_i32, const 10979455_i32, const 9915528_i32, const 3592697_i32, const 11768353_i32, const 4883067_i32, const 2215832_i32, const 14458688_i32, const 5588956_i32, const 3831009_i32, const 4385639_i32, const 14654974_i32, const 6280286_i32, const 10774395_i32, const 8039610_i32, const 10679893_i32, const 2328619_i32, const 5618241_i32, const 552537_i32, const 8792609_i32, const 8603449_i32, const 15131529_i32, const 13934309_i32, const 4258633_i32, const 15292159_i32, const 13242140_i32, const 9066949_i32, const 2882196_i32, const 12960211_i32, const 13616399_i32, const 11426523_i32, const 8832327_i32, const 6439813_i32, const 3900961_i32, const 9730348_i32, const 8872208_i32, const 8080426_i32, const 1715328_i32, const 1228611_i32, const 9447048_i32, const 8993912_i32, const 14992552_i32, const 8117221_i32, const 12729028_i32, const 15397926_i32, const 9070583_i32, const 12554765_i32, const 2859877_i32, const 11637565_i32, const 752829_i32, const 14438820_i32, const 6544679_i32, const 14541161_i32, const 1676442_i32, const 9775528_i32, const 2674280_i32, const 11857161_i32, const 2137924_i32, const 13277262_i32, const 6521456_i32, const 2325630_i32, const 3324175_i32, const 9368999_i32, const 15160852_i32, const 586017_i32, const 2792885_i32, const 5078639_i32, const 5314981_i32, const 11270581_i32, const 14081922_i32, const 6413718_i32, const 144918_i32, const 10435268_i32, const 10592899_i32, const 7204210_i32, const 8031545_i32, const 11122818_i32, const 6042219_i32, const 5973830_i32, const 15545344_i32, const 7798994_i32, const 5633276_i32, const 5069057_i32, const 8417760_i32];
        return;
    }
}

IPIO2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 690_usize;
        return;
    }
}

const rem_pio2_large::PIO2: [f64; 8] = {
    let mut _0: [f64; 8];

    bb0: {
        _0 = [const 1.5707962512969971f64, const 7.5497894158615964E-8f64, const 5.3903025299577648E-15f64, const 3.2820034158079129E-22f64, const 1.2706557530806761E-29f64, const 1.2293330898111133E-36f64, const 2.7337005381646456E-44f64, const 2.1674168387780482E-51f64];
        return;
    }
}

rem_pio2_large::PIO2::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 8_usize;
        return;
    }
}

fn rem_pio2_large(_1: &[f64], _2: &mut [f64], _3: i32, _4: usize) -> i32 {
    debug x => _1;
    debug y => _2;
    debug e0 => _3;
    debug prec => _4;
    let mut _0: i32;
    let _5: f64;
    let mut _17: &usize;
    let mut _18: rustc_std_workspace_core::option::Option<&usize>;
    let mut _19: &[usize];
    let mut _21: (usize, bool);
    let mut _23: i32;
    let mut _24: (i32, bool);
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: i32;
    let mut _32: i32;
    let mut _33: i32;
    let mut _34: i32;
    let mut _35: (i32, bool);
    let mut _36: (i32, bool);
    let mut _37: (i32, bool);
    let mut _39: i32;
    let mut _41: i32;
    let mut _42: i32;
    let mut _43: (i32, bool);
    let mut _45: (usize, bool);
    let mut _46: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _47: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _49: rustc_std_workspace_core::option::Option<usize>;
    let mut _50: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _51: isize;
    let mut _53: f64;
    let mut _54: bool;
    let mut _55: i32;
    let mut _56: i32;
    let mut _57: &i32;
    let mut _58: rustc_std_workspace_core::option::Option<&i32>;
    let mut _59: &[i32];
    let mut _60: usize;
    let mut _61: i32;
    let mut _62: &mut f64;
    let mut _63: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _64: &mut [f64];
    let mut _65: &mut [f64; 20];
    let mut _66: (i32, bool);
    let mut _67: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _68: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _70: rustc_std_workspace_core::option::Option<usize>;
    let mut _71: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _72: isize;
    let mut _74: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _75: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _77: rustc_std_workspace_core::option::Option<usize>;
    let mut _78: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _79: isize;
    let mut _81: f64;
    let mut _82: f64;
    let mut _83: &f64;
    let mut _84: rustc_std_workspace_core::option::Option<&f64>;
    let mut _85: f64;
    let mut _86: &f64;
    let mut _87: rustc_std_workspace_core::option::Option<&f64>;
    let mut _88: &[f64];
    let mut _89: &[f64; 20];
    let mut _90: usize;
    let mut _91: usize;
    let mut _92: (usize, bool);
    let mut _93: (usize, bool);
    let mut _94: f64;
    let mut _95: &mut f64;
    let mut _96: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _97: &mut [f64];
    let mut _98: &mut [f64; 20];
    let mut _101: f64;
    let mut _102: &f64;
    let mut _103: rustc_std_workspace_core::option::Option<&f64>;
    let mut _104: &[f64];
    let mut _105: &[f64; 20];
    let mut _106: usize;
    let mut _107: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _108: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _109: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _110: usize;
    let mut _112: rustc_std_workspace_core::option::Option<usize>;
    let mut _113: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _114: isize;
    let mut _116: i32;
    let mut _117: f64;
    let mut _118: f64;
    let mut _119: f64;
    let mut _120: f64;
    let mut _121: f64;
    let mut _122: f64;
    let mut _123: &mut i32;
    let mut _124: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _125: &mut [i32];
    let mut _126: &mut [i32; 20];
    let mut _127: usize;
    let mut _128: i32;
    let mut _129: f64;
    let mut _130: &f64;
    let mut _131: rustc_std_workspace_core::option::Option<&f64>;
    let mut _132: &[f64];
    let mut _133: &[f64; 20];
    let mut _134: usize;
    let mut _135: (usize, bool);
    let mut _136: f64;
    let mut _137: (i32, bool);
    let mut _138: f64;
    let mut _139: f64;
    let mut _140: i32;
    let mut _141: f64;
    let mut _142: f64;
    let mut _143: f64;
    let mut _144: f64;
    let mut _145: f64;
    let mut _146: f64;
    let mut _147: i32;
    let mut _148: bool;
    let mut _149: i32;
    let mut _150: i32;
    let mut _151: &i32;
    let mut _152: rustc_std_workspace_core::option::Option<&i32>;
    let mut _153: &[i32];
    let mut _154: &[i32; 20];
    let mut _155: usize;
    let mut _156: usize;
    let mut _157: (usize, bool);
    let mut _158: i32;
    let mut _159: i32;
    let mut _160: (i32, bool);
    let mut _161: u32;
    let mut _162: bool;
    let mut _163: i32;
    let mut _164: (i32, bool);
    let mut _165: i32;
    let mut _166: i32;
    let mut _167: i32;
    let mut _168: i32;
    let mut _169: (i32, bool);
    let mut _170: u32;
    let mut _171: bool;
    let mut _172: &mut i32;
    let mut _173: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _174: &mut [i32];
    let mut _175: &mut [i32; 20];
    let mut _176: usize;
    let mut _177: usize;
    let mut _178: (usize, bool);
    let mut _179: (i32, bool);
    let mut _180: i32;
    let mut _181: &i32;
    let mut _182: rustc_std_workspace_core::option::Option<&i32>;
    let mut _183: &[i32];
    let mut _184: &[i32; 20];
    let mut _185: usize;
    let mut _186: usize;
    let mut _187: (usize, bool);
    let mut _188: i32;
    let mut _189: i32;
    let mut _190: (i32, bool);
    let mut _191: u32;
    let mut _192: bool;
    let mut _193: i32;
    let mut _194: i32;
    let mut _195: &i32;
    let mut _196: rustc_std_workspace_core::option::Option<&i32>;
    let mut _197: &[i32];
    let mut _198: &[i32; 20];
    let mut _199: usize;
    let mut _200: usize;
    let mut _201: (usize, bool);
    let mut _202: u32;
    let mut _203: bool;
    let mut _204: bool;
    let mut _205: f64;
    let mut _206: bool;
    let mut _207: i32;
    let mut _208: (i32, bool);
    let mut _210: rustc_std_workspace_core::ops::Range<usize>;
    let mut _211: rustc_std_workspace_core::ops::Range<usize>;
    let mut _212: usize;
    let mut _214: rustc_std_workspace_core::option::Option<usize>;
    let mut _215: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _216: isize;
    let mut _219: &i32;
    let mut _220: rustc_std_workspace_core::option::Option<&i32>;
    let mut _221: &[i32];
    let mut _222: &[i32; 20];
    let mut _223: i32;
    let mut _224: (i32, bool);
    let mut _225: &mut i32;
    let mut _226: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _227: &mut [i32];
    let mut _228: &mut [i32; 20];
    let mut _229: (i32, bool);
    let mut _230: &mut i32;
    let mut _231: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _232: &mut [i32];
    let mut _233: &mut [i32; 20];
    let mut _234: bool;
    let mut _235: i32;
    let mut _236: &mut i32;
    let mut _237: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _238: &mut [i32];
    let mut _239: &mut [i32; 20];
    let mut _240: usize;
    let mut _241: usize;
    let mut _242: (usize, bool);
    let mut _243: &mut i32;
    let mut _244: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _245: &mut [i32];
    let mut _246: &mut [i32; 20];
    let mut _247: usize;
    let mut _248: usize;
    let mut _249: (usize, bool);
    let mut _250: i32;
    let mut _251: f64;
    let mut _252: i32;
    let mut _253: f64;
    let mut _254: i32;
    let mut _255: bool;
    let mut _256: f64;
    let mut _258: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _259: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _260: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _261: usize;
    let mut _262: usize;
    let mut _263: (usize, bool);
    let mut _265: rustc_std_workspace_core::option::Option<usize>;
    let mut _266: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _267: isize;
    let mut _269: i32;
    let mut _270: &i32;
    let mut _271: rustc_std_workspace_core::option::Option<&i32>;
    let mut _272: &[i32];
    let mut _273: &[i32; 20];
    let mut _274: i32;
    let mut _276: i32;
    let mut _277: &mut i32;
    let mut _278: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _279: &mut [i32];
    let mut _280: &mut [i32; 20];
    let mut _281: usize;
    let mut _282: usize;
    let mut _283: (usize, bool);
    let mut _284: (usize, bool);
    let mut _285: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _286: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _287: usize;
    let mut _288: usize;
    let mut _289: (usize, bool);
    let mut _290: usize;
    let mut _291: usize;
    let mut _292: usize;
    let mut _293: (usize, bool);
    let mut _295: rustc_std_workspace_core::option::Option<usize>;
    let mut _296: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _297: isize;
    let mut _299: i32;
    let mut _300: &i32;
    let mut _301: rustc_std_workspace_core::option::Option<&i32>;
    let mut _302: &[i32];
    let mut _303: usize;
    let mut _304: (usize, bool);
    let mut _305: &mut f64;
    let mut _306: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _307: &mut [f64];
    let mut _308: &mut [f64; 20];
    let mut _309: usize;
    let mut _310: (usize, bool);
    let mut _311: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _312: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _314: rustc_std_workspace_core::option::Option<usize>;
    let mut _315: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _316: isize;
    let mut _318: f64;
    let mut _319: f64;
    let mut _320: &f64;
    let mut _321: rustc_std_workspace_core::option::Option<&f64>;
    let mut _322: f64;
    let mut _323: &f64;
    let mut _324: rustc_std_workspace_core::option::Option<&f64>;
    let mut _325: &[f64];
    let mut _326: &[f64; 20];
    let mut _327: usize;
    let mut _328: usize;
    let mut _329: (usize, bool);
    let mut _330: (usize, bool);
    let mut _331: f64;
    let mut _332: &mut f64;
    let mut _333: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _334: &mut [f64];
    let mut _335: &mut [f64; 20];
    let mut _336: usize;
    let mut _337: (usize, bool);
    let mut _338: bool;
    let mut _339: f64;
    let mut _340: (usize, bool);
    let mut _341: (i32, bool);
    let mut _342: i32;
    let mut _343: &i32;
    let mut _344: rustc_std_workspace_core::option::Option<&i32>;
    let mut _345: &[i32];
    let mut _346: &[i32; 20];
    let mut _347: usize;
    let mut _348: (usize, bool);
    let mut _349: (i32, bool);
    let mut _350: f64;
    let mut _351: f64;
    let mut _352: i32;
    let mut _353: i32;
    let mut _354: bool;
    let mut _355: bool;
    let mut _356: f64;
    let mut _357: i32;
    let mut _358: f64;
    let mut _359: f64;
    let mut _360: f64;
    let mut _361: f64;
    let mut _362: f64;
    let mut _363: f64;
    let mut _364: &mut i32;
    let mut _365: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _366: &mut [i32];
    let mut _367: &mut [i32; 20];
    let mut _368: usize;
    let mut _369: (usize, bool);
    let mut _370: (i32, bool);
    let mut _371: f64;
    let mut _372: &mut i32;
    let mut _373: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _374: &mut [i32];
    let mut _375: &mut [i32; 20];
    let mut _376: usize;
    let mut _377: f64;
    let mut _378: &mut i32;
    let mut _379: rustc_std_workspace_core::option::Option<&mut i32>;
    let mut _380: &mut [i32];
    let mut _381: &mut [i32; 20];
    let mut _382: usize;
    let mut _383: f64;
    let mut _384: i32;
    let mut _385: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _386: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _387: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _388: usize;
    let mut _390: rustc_std_workspace_core::option::Option<usize>;
    let mut _391: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _392: isize;
    let mut _394: f64;
    let mut _395: f64;
    let mut _396: i32;
    let mut _397: &i32;
    let mut _398: rustc_std_workspace_core::option::Option<&i32>;
    let mut _399: &[i32];
    let mut _400: &[i32; 20];
    let mut _401: &mut f64;
    let mut _402: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _403: &mut [f64];
    let mut _404: &mut [f64; 20];
    let mut _405: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _406: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _407: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _408: usize;
    let mut _410: rustc_std_workspace_core::option::Option<usize>;
    let mut _411: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _412: isize;
    let mut _415: bool;
    let mut _416: usize;
    let mut _417: bool;
    let mut _418: usize;
    let mut _419: usize;
    let mut _420: usize;
    let mut _421: (usize, bool);
    let mut _422: f64;
    let mut _423: f64;
    let mut _424: &f64;
    let mut _425: rustc_std_workspace_core::option::Option<&f64>;
    let mut _426: &[f64];
    let mut _427: usize;
    let mut _428: f64;
    let mut _429: &f64;
    let mut _430: rustc_std_workspace_core::option::Option<&f64>;
    let mut _431: &[f64];
    let mut _432: &[f64; 20];
    let mut _433: usize;
    let mut _434: usize;
    let mut _435: (usize, bool);
    let mut _436: (usize, bool);
    let mut _437: f64;
    let mut _438: &mut f64;
    let mut _439: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _440: &mut [f64];
    let mut _441: &mut [f64; 20];
    let mut _442: usize;
    let mut _443: usize;
    let mut _444: (usize, bool);
    let mut _445: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _446: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _447: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _448: usize;
    let mut _450: rustc_std_workspace_core::option::Option<usize>;
    let mut _451: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _452: isize;
    let mut _454: f64;
    let mut _455: &f64;
    let mut _456: rustc_std_workspace_core::option::Option<&f64>;
    let mut _457: &[f64];
    let mut _458: &[f64; 20];
    let mut _459: f64;
    let mut _460: i32;
    let mut _461: f64;
    let mut _462: &mut f64;
    let mut _463: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _464: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _465: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _466: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _467: usize;
    let mut _469: rustc_std_workspace_core::option::Option<usize>;
    let mut _470: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _471: isize;
    let mut _473: f64;
    let mut _474: &f64;
    let mut _475: rustc_std_workspace_core::option::Option<&f64>;
    let mut _476: &[f64];
    let mut _477: &[f64; 20];
    let mut _478: f64;
    let mut _479: f64;
    let mut _480: i32;
    let mut _481: f64;
    let mut _482: &mut f64;
    let mut _483: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _484: f64;
    let mut _485: &f64;
    let mut _486: rustc_std_workspace_core::option::Option<&f64>;
    let mut _487: &[f64];
    let mut _488: &[f64; 20];
    let mut _489: f64;
    let mut _490: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _491: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _492: usize;
    let mut _494: rustc_std_workspace_core::option::Option<usize>;
    let mut _495: &mut rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _496: isize;
    let mut _498: f64;
    let mut _499: &f64;
    let mut _500: rustc_std_workspace_core::option::Option<&f64>;
    let mut _501: &[f64];
    let mut _502: &[f64; 20];
    let mut _503: f64;
    let mut _504: i32;
    let mut _505: f64;
    let mut _506: &mut f64;
    let mut _507: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _508: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _509: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _510: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _511: usize;
    let mut _513: rustc_std_workspace_core::option::Option<usize>;
    let mut _514: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _515: isize;
    let mut _517: f64;
    let mut _518: &f64;
    let mut _519: rustc_std_workspace_core::option::Option<&f64>;
    let mut _520: &[f64];
    let mut _521: &[f64; 20];
    let mut _522: usize;
    let mut _523: (usize, bool);
    let mut _524: f64;
    let mut _525: &f64;
    let mut _526: rustc_std_workspace_core::option::Option<&f64>;
    let mut _527: &[f64];
    let mut _528: &[f64; 20];
    let mut _529: f64;
    let mut _530: f64;
    let mut _531: &f64;
    let mut _532: rustc_std_workspace_core::option::Option<&f64>;
    let mut _533: &[f64];
    let mut _534: &[f64; 20];
    let mut _535: usize;
    let mut _536: (usize, bool);
    let mut _537: f64;
    let mut _538: &mut f64;
    let mut _539: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _540: &mut [f64];
    let mut _541: &mut [f64; 20];
    let mut _542: f64;
    let mut _543: &mut f64;
    let mut _544: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _545: &mut [f64];
    let mut _546: &mut [f64; 20];
    let mut _547: usize;
    let mut _548: (usize, bool);
    let mut _549: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _550: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _551: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _552: usize;
    let mut _554: rustc_std_workspace_core::option::Option<usize>;
    let mut _555: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _556: isize;
    let mut _558: f64;
    let mut _559: &f64;
    let mut _560: rustc_std_workspace_core::option::Option<&f64>;
    let mut _561: &[f64];
    let mut _562: &[f64; 20];
    let mut _563: usize;
    let mut _564: (usize, bool);
    let mut _565: f64;
    let mut _566: &f64;
    let mut _567: rustc_std_workspace_core::option::Option<&f64>;
    let mut _568: &[f64];
    let mut _569: &[f64; 20];
    let mut _570: f64;
    let mut _571: f64;
    let mut _572: &f64;
    let mut _573: rustc_std_workspace_core::option::Option<&f64>;
    let mut _574: &[f64];
    let mut _575: &[f64; 20];
    let mut _576: usize;
    let mut _577: (usize, bool);
    let mut _578: f64;
    let mut _579: &mut f64;
    let mut _580: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _581: &mut [f64];
    let mut _582: &mut [f64; 20];
    let mut _583: f64;
    let mut _584: &mut f64;
    let mut _585: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _586: &mut [f64];
    let mut _587: &mut [f64; 20];
    let mut _588: usize;
    let mut _589: (usize, bool);
    let mut _590: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _591: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _592: rustc_std_workspace_core::ops::RangeInclusive<usize>;
    let mut _593: usize;
    let mut _595: rustc_std_workspace_core::option::Option<usize>;
    let mut _596: &mut rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
    let mut _597: isize;
    let mut _599: f64;
    let mut _600: &f64;
    let mut _601: rustc_std_workspace_core::option::Option<&f64>;
    let mut _602: &[f64];
    let mut _603: &[f64; 20];
    let mut _604: i32;
    let mut _605: f64;
    let mut _606: &f64;
    let mut _607: rustc_std_workspace_core::option::Option<&f64>;
    let mut _608: &[f64];
    let mut _609: &[f64; 20];
    let mut _610: &mut f64;
    let mut _611: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _612: f64;
    let mut _613: &f64;
    let mut _614: rustc_std_workspace_core::option::Option<&f64>;
    let mut _615: &[f64];
    let mut _616: &[f64; 20];
    let mut _617: &mut f64;
    let mut _618: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _619: f64;
    let mut _620: &mut f64;
    let mut _621: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _622: f64;
    let mut _623: &f64;
    let mut _624: rustc_std_workspace_core::option::Option<&f64>;
    let mut _625: &[f64];
    let mut _626: &[f64; 20];
    let mut _627: &mut f64;
    let mut _628: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _629: f64;
    let mut _630: &f64;
    let mut _631: rustc_std_workspace_core::option::Option<&f64>;
    let mut _632: &[f64];
    let mut _633: &[f64; 20];
    let mut _634: &mut f64;
    let mut _635: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _636: f64;
    let mut _637: &mut f64;
    let mut _638: rustc_std_workspace_core::option::Option<&mut f64>;
    let mut _639: !;
    let mut _640: i32;
    scope 1 {
        debug x1p24 => _5;
        let _6: f64;
        scope 2 {
            debug x1p_24 => _6;
            let _7: usize;
            scope 3 {
                debug nx => _7;
                let mut _8: f64;
                scope 4 {
                    debug fw => _8;
                    let mut _9: i32;
                    scope 5 {
                        debug n => _9;
                        let mut _10: i32;
                        scope 6 {
                            debug ih => _10;
                            let mut _11: f64;
                            scope 7 {
                                debug z => _11;
                                let mut _12: [f64; 20];
                                scope 8 {
                                    debug f => _12;
                                    let mut _13: [f64; 20];
                                    scope 9 {
                                        debug fq => _13;
                                        let mut _14: [f64; 20];
                                        scope 10 {
                                            debug q => _14;
                                            let mut _15: [i32; 20];
                                            scope 11 {
                                                debug iq => _15;
                                                let _16: usize;
                                                let mut _644: &[usize; 4];
                                                scope 12 {
                                                    debug jk => _16;
                                                    scope 13 {
                                                        debug jp => _16;
                                                        let _20: usize;
                                                        scope 14 {
                                                            debug jx => _20;
                                                            let mut _22: i32;
                                                            scope 15 {
                                                                debug jv => _22;
                                                                let mut _31: i32;
                                                                scope 16 {
                                                                    debug q0 => _31;
                                                                    let _38: usize;
                                                                    scope 17 {
                                                                        debug jv => _38;
                                                                        let mut _40: i32;
                                                                        scope 18 {
                                                                            debug j => _40;
                                                                            let _44: usize;
                                                                            scope 19 {
                                                                                debug m => _44;
                                                                                let mut _48: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                let mut _69: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                let mut _99: usize;
                                                                                scope 20 {
                                                                                    debug iter => _48;
                                                                                    let _52: usize;
                                                                                    scope 21 {
                                                                                        debug i => _52;
                                                                                        let mut _641: &[i32; 690];
                                                                                    }
                                                                                }
                                                                                scope 22 {
                                                                                    debug iter => _69;
                                                                                    let _73: usize;
                                                                                    scope 23 {
                                                                                        debug i => _73;
                                                                                        let mut _76: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                        scope 24 {
                                                                                            debug iter => _76;
                                                                                            let _80: usize;
                                                                                            scope 25 {
                                                                                                debug j => _80;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                scope 26 {
                                                                                    debug jz => _99;
                                                                                    let mut _100: i32;
                                                                                    let mut _389: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _409: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _449: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _468: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _493: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                    let mut _512: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _553: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    let mut _594: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                    scope 27 {
                                                                                        debug i => _100;
                                                                                        let mut _111: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                        let mut _209: i32;
                                                                                        let mut _257: i32;
                                                                                        scope 28 {
                                                                                            debug iter => _111;
                                                                                            let _115: usize;
                                                                                            scope 29 {
                                                                                                debug j => _115;
                                                                                            }
                                                                                        }
                                                                                        scope 30 {
                                                                                            debug carry => _209;
                                                                                            let mut _213: rustc_std_workspace_core::ops::Range<usize>;
                                                                                            scope 31 {
                                                                                                debug iter => _213;
                                                                                                let _217: usize;
                                                                                                scope 32 {
                                                                                                    debug i => _217;
                                                                                                    let _218: i32;
                                                                                                    scope 33 {
                                                                                                        debug j => _218;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        scope 34 {
                                                                                            debug j => _257;
                                                                                            let mut _264: rustc_std_workspace_core::iter::Rev<rustc_std_workspace_core::ops::RangeInclusive<usize>>;
                                                                                            let mut _275: usize;
                                                                                            scope 35 {
                                                                                                debug iter => _264;
                                                                                                let _268: usize;
                                                                                                scope 36 {
                                                                                                    debug i => _268;
                                                                                                }
                                                                                            }
                                                                                            scope 37 {
                                                                                                debug k => _275;
                                                                                                let mut _294: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                                scope 38 {
                                                                                                    debug iter => _294;
                                                                                                    let _298: usize;
                                                                                                    scope 39 {
                                                                                                        debug i => _298;
                                                                                                        let mut _313: rustc_std_workspace_core::ops::RangeInclusive<usize>;
                                                                                                        let mut _642: &[i32; 690];
                                                                                                        scope 40 {
                                                                                                            debug iter => _313;
                                                                                                            let _317: usize;
                                                                                                            scope 41 {
                                                                                                                debug j => _317;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 42 {
                                                                                        debug iter => _389;
                                                                                        let _393: usize;
                                                                                        scope 43 {
                                                                                            debug i => _393;
                                                                                        }
                                                                                    }
                                                                                    scope 44 {
                                                                                        debug iter => _409;
                                                                                        let _413: usize;
                                                                                        scope 45 {
                                                                                            debug i => _413;
                                                                                            let mut _414: usize;
                                                                                            scope 46 {
                                                                                                debug k => _414;
                                                                                                let mut _643: &[f64; 8];
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 47 {
                                                                                        debug iter => _449;
                                                                                        let _453: usize;
                                                                                        scope 48 {
                                                                                            debug i => _453;
                                                                                        }
                                                                                    }
                                                                                    scope 49 {
                                                                                        debug iter => _468;
                                                                                        let _472: usize;
                                                                                        scope 50 {
                                                                                            debug i => _472;
                                                                                        }
                                                                                    }
                                                                                    scope 51 {
                                                                                        debug iter => _493;
                                                                                        let _497: usize;
                                                                                        scope 52 {
                                                                                            debug i => _497;
                                                                                        }
                                                                                    }
                                                                                    scope 53 {
                                                                                        debug iter => _512;
                                                                                        let _516: usize;
                                                                                        scope 54 {
                                                                                            debug i => _516;
                                                                                        }
                                                                                    }
                                                                                    scope 55 {
                                                                                        debug iter => _553;
                                                                                        let _557: usize;
                                                                                        scope 56 {
                                                                                            debug i => _557;
                                                                                        }
                                                                                    }
                                                                                    scope 57 {
                                                                                        debug iter => _594;
                                                                                        let _598: usize;
                                                                                        scope 58 {
                                                                                            debug i => _598;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = f64::<impl f64>::from_bits(const 4715268809856909312_u64) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _6 = f64::<impl f64>::from_bits(const 4499096027743125504_u64) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = Len((*_1));
        _12 = [const 0f64; 20];
        _13 = [const 0f64; 20];
        _14 = [const 0f64; 20];
        _15 = [const 0_i32; 20];
        _644 = const _;
        _19 = _644 as &[usize] (PointerCoercion(Unsize));
        _18 = slice::<impl [usize]>::get::<usize>(move _19, _4) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _17 = Option::<&usize>::unwrap(move _18) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _16 = (*_17);
        _21 = CheckedSub(_7, const 1_usize);
        assert(!move (_21.1: bool), "attempt to compute `{} - {}`, which would overflow", _7, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _20 = move (_21.0: usize);
        _24 = CheckedSub(_3, const 3_i32);
        assert(!move (_24.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 3_i32) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _23 = move (_24.0: i32);
        _25 = Eq(const 24_i32, const 0_i32);
        assert(!move _25, "attempt to divide `{}` by zero", _23) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _26 = Eq(const 24_i32, const -1_i32);
        _27 = Eq(_23, const i32::MIN);
        _28 = BitAnd(move _26, move _27);
        assert(!move _28, "attempt to compute `{} / {}`, which would overflow", _23, const 24_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _22 = Div(move _23, const 24_i32);
        _30 = _22;
        _29 = Lt(move _30, const 0_i32);
        switchInt(move _29) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _22 = const 0_i32;
        goto -> bb10;
    }

    bb10: {
        _34 = _22;
        _35 = CheckedAdd(_34, const 1_i32);
        assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", move _34, const 1_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _33 = move (_35.0: i32);
        _36 = CheckedMul(const 24_i32, _33);
        assert(!move (_36.1: bool), "attempt to compute `{} * {}`, which would overflow", const 24_i32, move _33) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _32 = move (_36.0: i32);
        _37 = CheckedSub(_3, _32);
        assert(!move (_37.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, move _32) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _31 = move (_37.0: i32);
        _39 = _22;
        _38 = move _39 as usize (IntToInt);
        _41 = _38 as i32 (IntToInt);
        _42 = _20 as i32 (IntToInt);
        _43 = CheckedSub(_41, _42);
        assert(!move (_43.1: bool), "attempt to compute `{} - {}`, which would overflow", move _41, move _42) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _40 = move (_43.0: i32);
        _45 = CheckedAdd(_20, _16);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, _16) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _44 = move (_45.0: usize);
        _47 = RangeInclusive::<usize>::new(const 0_usize, _44) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _46 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _47) -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _48 = move _46;
        goto -> bb18;
    }

    bb18: {
        _50 = &mut _48;
        _49 = <RangeInclusive<usize> as Iterator>::next(_50) -> [return: bb19, unwind unreachable];
    }

    bb19: {
        _51 = discriminant(_49);
        switchInt(move _51) -> [0: bb21, 1: bb20, otherwise: bb351];
    }

    bb20: {
        _52 = ((_49 as Some).0: usize);
        _55 = _40;
        _54 = Lt(move _55, const 0_i32);
        switchInt(move _54) -> [0: bb23, otherwise: bb22];
    }

    bb21: {
        _68 = RangeInclusive::<usize>::new(const 0_usize, _16) -> [return: bb30, unwind unreachable];
    }

    bb22: {
        _53 = const 0f64;
        goto -> bb26;
    }

    bb23: {
        _641 = const _;
        _59 = _641 as &[i32] (PointerCoercion(Unsize));
        _61 = _40;
        _60 = move _61 as usize (IntToInt);
        _58 = slice::<impl [i32]>::get::<usize>(move _59, move _60) -> [return: bb24, unwind unreachable];
    }

    bb24: {
        _57 = Option::<&i32>::unwrap(move _58) -> [return: bb25, unwind unreachable];
    }

    bb25: {
        _56 = (*_57);
        _53 = move _56 as f64 (IntToFloat);
        goto -> bb26;
    }

    bb26: {
        _65 = &mut _12;
        _64 = move _65 as &mut [f64] (PointerCoercion(Unsize));
        _63 = slice::<impl [f64]>::get_mut::<usize>(move _64, _52) -> [return: bb27, unwind unreachable];
    }

    bb27: {
        _62 = Option::<&mut f64>::unwrap(move _63) -> [return: bb28, unwind unreachable];
    }

    bb28: {
        (*_62) = move _53;
        _66 = CheckedAdd(_40, const 1_i32);
        assert(!move (_66.1: bool), "attempt to compute `{} + {}`, which would overflow", _40, const 1_i32) -> [success: bb29, unwind unreachable];
    }

    bb29: {
        _40 = move (_66.0: i32);
        goto -> bb18;
    }

    bb30: {
        _67 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _68) -> [return: bb31, unwind unreachable];
    }

    bb31: {
        _69 = move _67;
        goto -> bb32;
    }

    bb32: {
        _71 = &mut _69;
        _70 = <RangeInclusive<usize> as Iterator>::next(_71) -> [return: bb33, unwind unreachable];
    }

    bb33: {
        _72 = discriminant(_70);
        switchInt(move _72) -> [0: bb35, 1: bb34, otherwise: bb351];
    }

    bb34: {
        _73 = ((_70 as Some).0: usize);
        _8 = const 0f64;
        _75 = RangeInclusive::<usize>::new(const 0_usize, _20) -> [return: bb36, unwind unreachable];
    }

    bb35: {
        _99 = _16;
        goto -> bb50;
    }

    bb36: {
        _74 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _75) -> [return: bb37, unwind unreachable];
    }

    bb37: {
        _76 = move _74;
        goto -> bb38;
    }

    bb38: {
        _78 = &mut _76;
        _77 = <RangeInclusive<usize> as Iterator>::next(_78) -> [return: bb39, unwind unreachable];
    }

    bb39: {
        _79 = discriminant(_77);
        switchInt(move _79) -> [0: bb41, 1: bb40, otherwise: bb351];
    }

    bb40: {
        _80 = ((_77 as Some).0: usize);
        _84 = slice::<impl [f64]>::get::<usize>(_1, _80) -> [return: bb42, unwind unreachable];
    }

    bb41: {
        _94 = _8;
        _98 = &mut _14;
        _97 = move _98 as &mut [f64] (PointerCoercion(Unsize));
        _96 = slice::<impl [f64]>::get_mut::<usize>(move _97, _73) -> [return: bb48, unwind unreachable];
    }

    bb42: {
        _83 = Option::<&f64>::unwrap(move _84) -> [return: bb43, unwind unreachable];
    }

    bb43: {
        _82 = (*_83);
        _89 = &_12;
        _88 = move _89 as &[f64] (PointerCoercion(Unsize));
        _92 = CheckedAdd(_20, _73);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, _73) -> [success: bb44, unwind unreachable];
    }

    bb44: {
        _91 = move (_92.0: usize);
        _93 = CheckedSub(_91, _80);
        assert(!move (_93.1: bool), "attempt to compute `{} - {}`, which would overflow", move _91, _80) -> [success: bb45, unwind unreachable];
    }

    bb45: {
        _90 = move (_93.0: usize);
        _87 = slice::<impl [f64]>::get::<usize>(move _88, move _90) -> [return: bb46, unwind unreachable];
    }

    bb46: {
        _86 = Option::<&f64>::unwrap(move _87) -> [return: bb47, unwind unreachable];
    }

    bb47: {
        _85 = (*_86);
        _81 = Mul(move _82, move _85);
        _8 = Add(_8, move _81);
        goto -> bb38;
    }

    bb48: {
        _95 = Option::<&mut f64>::unwrap(move _96) -> [return: bb49, unwind unreachable];
    }

    bb49: {
        (*_95) = move _94;
        goto -> bb32;
    }

    bb50: {
        _100 = const 0_i32;
        _105 = &_14;
        _104 = move _105 as &[f64] (PointerCoercion(Unsize));
        _106 = _99;
        _103 = slice::<impl [f64]>::get::<usize>(move _104, move _106) -> [return: bb51, unwind unreachable];
    }

    bb51: {
        _102 = Option::<&f64>::unwrap(move _103) -> [return: bb52, unwind unreachable];
    }

    bb52: {
        _101 = (*_102);
        _11 = move _101;
        _110 = _99;
        _109 = RangeInclusive::<usize>::new(const 1_usize, move _110) -> [return: bb53, unwind unreachable];
    }

    bb53: {
        _108 = <RangeInclusive<usize> as Iterator>::rev(move _109) -> [return: bb54, unwind unreachable];
    }

    bb54: {
        _107 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _108) -> [return: bb55, unwind unreachable];
    }

    bb55: {
        _111 = move _107;
        goto -> bb56;
    }

    bb56: {
        _113 = &mut _111;
        _112 = <Rev<RangeInclusive<usize>> as Iterator>::next(_113) -> [return: bb57, unwind unreachable];
    }

    bb57: {
        _114 = discriminant(_112);
        switchInt(move _114) -> [0: bb59, 1: bb58, otherwise: bb351];
    }

    bb58: {
        _115 = ((_112 as Some).0: usize);
        _118 = _11;
        _117 = Mul(_6, move _118);
        _116 = move _117 as i32 (FloatToInt);
        _8 = move _116 as f64 (IntToFloat);
        _120 = _11;
        _122 = _8;
        _121 = Mul(_5, move _122);
        _119 = Sub(move _120, move _121);
        _126 = &mut _15;
        _125 = move _126 as &mut [i32] (PointerCoercion(Unsize));
        _128 = _100;
        _127 = move _128 as usize (IntToInt);
        _124 = slice::<impl [i32]>::get_mut::<usize>(move _125, move _127) -> [return: bb60, unwind unreachable];
    }

    bb59: {
        _139 = _11;
        _140 = _31;
        _138 = scalbn(move _139, move _140) -> [return: bb66, unwind unreachable];
    }

    bb60: {
        _123 = Option::<&mut i32>::unwrap(move _124) -> [return: bb61, unwind unreachable];
    }

    bb61: {
        (*_123) = move _119 as i32 (FloatToInt);
        _133 = &_14;
        _132 = move _133 as &[f64] (PointerCoercion(Unsize));
        _135 = CheckedSub(_115, const 1_usize);
        assert(!move (_135.1: bool), "attempt to compute `{} - {}`, which would overflow", _115, const 1_usize) -> [success: bb62, unwind unreachable];
    }

    bb62: {
        _134 = move (_135.0: usize);
        _131 = slice::<impl [f64]>::get::<usize>(move _132, move _134) -> [return: bb63, unwind unreachable];
    }

    bb63: {
        _130 = Option::<&f64>::unwrap(move _131) -> [return: bb64, unwind unreachable];
    }

    bb64: {
        _129 = (*_130);
        _136 = _8;
        _11 = Add(move _129, move _136);
        _137 = CheckedAdd(_100, const 1_i32);
        assert(!move (_137.1: bool), "attempt to compute `{} + {}`, which would overflow", _100, const 1_i32) -> [success: bb65, unwind unreachable];
    }

    bb65: {
        _100 = move (_137.0: i32);
        goto -> bb56;
    }

    bb66: {
        _11 = move _138;
        _144 = _11;
        _143 = Mul(move _144, const 0.125f64);
        _142 = floor(move _143) -> [return: bb67, unwind unreachable];
    }

    bb67: {
        _141 = Mul(const 8f64, move _142);
        _11 = Sub(_11, move _141);
        _145 = _11;
        _9 = move _145 as i32 (FloatToInt);
        _147 = _9;
        _146 = move _147 as f64 (IntToFloat);
        _11 = Sub(_11, move _146);
        _10 = const 0_i32;
        _149 = _31;
        _148 = Gt(move _149, const 0_i32);
        switchInt(move _148) -> [0: bb86, otherwise: bb68];
    }

    bb68: {
        _154 = &_15;
        _153 = move _154 as &[i32] (PointerCoercion(Unsize));
        _156 = _99;
        _157 = CheckedSub(_156, const 1_usize);
        assert(!move (_157.1: bool), "attempt to compute `{} - {}`, which would overflow", move _156, const 1_usize) -> [success: bb69, unwind unreachable];
    }

    bb69: {
        _155 = move (_157.0: usize);
        _152 = slice::<impl [i32]>::get::<usize>(move _153, move _155) -> [return: bb70, unwind unreachable];
    }

    bb70: {
        _151 = Option::<&i32>::unwrap(move _152) -> [return: bb71, unwind unreachable];
    }

    bb71: {
        _150 = (*_151);
        _159 = _31;
        _160 = CheckedSub(const 24_i32, _159);
        assert(!move (_160.1: bool), "attempt to compute `{} - {}`, which would overflow", const 24_i32, move _159) -> [success: bb72, unwind unreachable];
    }

    bb72: {
        _158 = move (_160.0: i32);
        _161 = _158 as u32 (IntToInt);
        _162 = Lt(move _161, const 32_u32);
        assert(move _162, "attempt to shift right by `{}`, which would overflow", _158) -> [success: bb73, unwind unreachable];
    }

    bb73: {
        _100 = Shr(move _150, move _158);
        _163 = _100;
        _164 = CheckedAdd(_9, _163);
        assert(!move (_164.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, move _163) -> [success: bb74, unwind unreachable];
    }

    bb74: {
        _9 = move (_164.0: i32);
        _166 = _100;
        _168 = _31;
        _169 = CheckedSub(const 24_i32, _168);
        assert(!move (_169.1: bool), "attempt to compute `{} - {}`, which would overflow", const 24_i32, move _168) -> [success: bb75, unwind unreachable];
    }

    bb75: {
        _167 = move (_169.0: i32);
        _170 = _167 as u32 (IntToInt);
        _171 = Lt(move _170, const 32_u32);
        assert(move _171, "attempt to shift left by `{}`, which would overflow", _167) -> [success: bb76, unwind unreachable];
    }

    bb76: {
        _165 = Shl(move _166, move _167);
        _175 = &mut _15;
        _174 = move _175 as &mut [i32] (PointerCoercion(Unsize));
        _177 = _99;
        _178 = CheckedSub(_177, const 1_usize);
        assert(!move (_178.1: bool), "attempt to compute `{} - {}`, which would overflow", move _177, const 1_usize) -> [success: bb77, unwind unreachable];
    }

    bb77: {
        _176 = move (_178.0: usize);
        _173 = slice::<impl [i32]>::get_mut::<usize>(move _174, move _176) -> [return: bb78, unwind unreachable];
    }

    bb78: {
        _172 = Option::<&mut i32>::unwrap(move _173) -> [return: bb79, unwind unreachable];
    }

    bb79: {
        _179 = CheckedSub((*_172), _165);
        assert(!move (_179.1: bool), "attempt to compute `{} - {}`, which would overflow", (*_172), move _165) -> [success: bb80, unwind unreachable];
    }

    bb80: {
        (*_172) = move (_179.0: i32);
        _184 = &_15;
        _183 = move _184 as &[i32] (PointerCoercion(Unsize));
        _186 = _99;
        _187 = CheckedSub(_186, const 1_usize);
        assert(!move (_187.1: bool), "attempt to compute `{} - {}`, which would overflow", move _186, const 1_usize) -> [success: bb81, unwind unreachable];
    }

    bb81: {
        _185 = move (_187.0: usize);
        _182 = slice::<impl [i32]>::get::<usize>(move _183, move _185) -> [return: bb82, unwind unreachable];
    }

    bb82: {
        _181 = Option::<&i32>::unwrap(move _182) -> [return: bb83, unwind unreachable];
    }

    bb83: {
        _180 = (*_181);
        _189 = _31;
        _190 = CheckedSub(const 23_i32, _189);
        assert(!move (_190.1: bool), "attempt to compute `{} - {}`, which would overflow", const 23_i32, move _189) -> [success: bb84, unwind unreachable];
    }

    bb84: {
        _188 = move (_190.0: i32);
        _191 = _188 as u32 (IntToInt);
        _192 = Lt(move _191, const 32_u32);
        assert(move _192, "attempt to shift right by `{}`, which would overflow", _188) -> [success: bb85, unwind unreachable];
    }

    bb85: {
        _10 = Shr(move _180, move _188);
        goto -> bb94;
    }

    bb86: {
        _193 = _31;
        switchInt(move _193) -> [0: bb87, otherwise: bb92];
    }

    bb87: {
        _198 = &_15;
        _197 = move _198 as &[i32] (PointerCoercion(Unsize));
        _200 = _99;
        _201 = CheckedSub(_200, const 1_usize);
        assert(!move (_201.1: bool), "attempt to compute `{} - {}`, which would overflow", move _200, const 1_usize) -> [success: bb88, unwind unreachable];
    }

    bb88: {
        _199 = move (_201.0: usize);
        _196 = slice::<impl [i32]>::get::<usize>(move _197, move _199) -> [return: bb89, unwind unreachable];
    }

    bb89: {
        _195 = Option::<&i32>::unwrap(move _196) -> [return: bb90, unwind unreachable];
    }

    bb90: {
        _194 = (*_195);
        _202 = const 23_i32 as u32 (IntToInt);
        _203 = Lt(move _202, const 32_u32);
        assert(move _203, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb91, unwind unreachable];
    }

    bb91: {
        _10 = Shr(move _194, const 23_i32);
        goto -> bb94;
    }

    bb92: {
        _205 = _11;
        _204 = Ge(move _205, const 0.5f64);
        switchInt(move _204) -> [0: bb94, otherwise: bb93];
    }

    bb93: {
        _10 = const 2_i32;
        goto -> bb94;
    }

    bb94: {
        _207 = _10;
        _206 = Gt(move _207, const 0_i32);
        switchInt(move _206) -> [0: bb126, otherwise: bb95];
    }

    bb95: {
        _208 = CheckedAdd(_9, const 1_i32);
        assert(!move (_208.1: bool), "attempt to compute `{} + {}`, which would overflow", _9, const 1_i32) -> [success: bb96, unwind unreachable];
    }

    bb96: {
        _9 = move (_208.0: i32);
        _209 = const 0_i32;
        _212 = _99;
        _211 = Range::<usize> { start: const 0_usize, end: move _212 };
        _210 = <Range<usize> as IntoIterator>::into_iter(move _211) -> [return: bb97, unwind unreachable];
    }

    bb97: {
        _213 = move _210;
        goto -> bb98;
    }

    bb98: {
        _215 = &mut _213;
        _214 = <Range<usize> as Iterator>::next(_215) -> [return: bb99, unwind unreachable];
    }

    bb99: {
        _216 = discriminant(_214);
        switchInt(move _216) -> [0: bb101, 1: bb100, otherwise: bb351];
    }

    bb100: {
        _217 = ((_214 as Some).0: usize);
        _222 = &_15;
        _221 = move _222 as &[i32] (PointerCoercion(Unsize));
        _220 = slice::<impl [i32]>::get::<usize>(move _221, _217) -> [return: bb102, unwind unreachable];
    }

    bb101: {
        _235 = _31;
        _234 = Gt(move _235, const 0_i32);
        switchInt(move _234) -> [0: bb122, otherwise: bb113];
    }

    bb102: {
        _219 = Option::<&i32>::unwrap(move _220) -> [return: bb103, unwind unreachable];
    }

    bb103: {
        _218 = (*_219);
        _223 = _209;
        switchInt(move _223) -> [0: bb104, otherwise: bb109];
    }

    bb104: {
        switchInt(move _218) -> [0: bb98, otherwise: bb105];
    }

    bb105: {
        _209 = const 1_i32;
        _224 = CheckedSub(const 16777216_i32, _218);
        assert(!move (_224.1: bool), "attempt to compute `{} - {}`, which would overflow", const 16777216_i32, _218) -> [success: bb106, unwind unreachable];
    }

    bb106: {
        _228 = &mut _15;
        _227 = move _228 as &mut [i32] (PointerCoercion(Unsize));
        _226 = slice::<impl [i32]>::get_mut::<usize>(move _227, _217) -> [return: bb107, unwind unreachable];
    }

    bb107: {
        _225 = Option::<&mut i32>::unwrap(move _226) -> [return: bb108, unwind unreachable];
    }

    bb108: {
        (*_225) = move (_224.0: i32);
        goto -> bb98;
    }

    bb109: {
        _229 = CheckedSub(const 16777215_i32, _218);
        assert(!move (_229.1: bool), "attempt to compute `{} - {}`, which would overflow", const 16777215_i32, _218) -> [success: bb110, unwind unreachable];
    }

    bb110: {
        _233 = &mut _15;
        _232 = move _233 as &mut [i32] (PointerCoercion(Unsize));
        _231 = slice::<impl [i32]>::get_mut::<usize>(move _232, _217) -> [return: bb111, unwind unreachable];
    }

    bb111: {
        _230 = Option::<&mut i32>::unwrap(move _231) -> [return: bb112, unwind unreachable];
    }

    bb112: {
        (*_230) = move (_229.0: i32);
        goto -> bb98;
    }

    bb113: {
        switchInt(_31) -> [1: bb114, 2: bb118, otherwise: bb122];
    }

    bb114: {
        _239 = &mut _15;
        _238 = move _239 as &mut [i32] (PointerCoercion(Unsize));
        _241 = _99;
        _242 = CheckedSub(_241, const 1_usize);
        assert(!move (_242.1: bool), "attempt to compute `{} - {}`, which would overflow", move _241, const 1_usize) -> [success: bb115, unwind unreachable];
    }

    bb115: {
        _240 = move (_242.0: usize);
        _237 = slice::<impl [i32]>::get_mut::<usize>(move _238, move _240) -> [return: bb116, unwind unreachable];
    }

    bb116: {
        _236 = Option::<&mut i32>::unwrap(move _237) -> [return: bb117, unwind unreachable];
    }

    bb117: {
        (*_236) = BitAnd((*_236), const 8388607_i32);
        goto -> bb122;
    }

    bb118: {
        _246 = &mut _15;
        _245 = move _246 as &mut [i32] (PointerCoercion(Unsize));
        _248 = _99;
        _249 = CheckedSub(_248, const 1_usize);
        assert(!move (_249.1: bool), "attempt to compute `{} - {}`, which would overflow", move _248, const 1_usize) -> [success: bb119, unwind unreachable];
    }

    bb119: {
        _247 = move (_249.0: usize);
        _244 = slice::<impl [i32]>::get_mut::<usize>(move _245, move _247) -> [return: bb120, unwind unreachable];
    }

    bb120: {
        _243 = Option::<&mut i32>::unwrap(move _244) -> [return: bb121, unwind unreachable];
    }

    bb121: {
        (*_243) = BitAnd((*_243), const 4194303_i32);
        goto -> bb122;
    }

    bb122: {
        _250 = _10;
        switchInt(move _250) -> [2: bb123, otherwise: bb126];
    }

    bb123: {
        _251 = _11;
        _11 = Sub(const 1f64, move _251);
        _252 = _209;
        switchInt(move _252) -> [0: bb126, otherwise: bb124];
    }

    bb124: {
        _254 = _31;
        _253 = scalbn(const 1f64, move _254) -> [return: bb125, unwind unreachable];
    }

    bb125: {
        _11 = Sub(_11, move _253);
        goto -> bb126;
    }

    bb126: {
        _256 = _11;
        _255 = Eq(move _256, const 0f64);
        switchInt(move _255) -> [0: bb175, otherwise: bb127];
    }

    bb127: {
        _257 = const 0_i32;
        _262 = _99;
        _263 = CheckedSub(_262, const 1_usize);
        assert(!move (_263.1: bool), "attempt to compute `{} - {}`, which would overflow", move _262, const 1_usize) -> [success: bb128, unwind unreachable];
    }

    bb128: {
        _261 = move (_263.0: usize);
        _260 = RangeInclusive::<usize>::new(_16, move _261) -> [return: bb129, unwind unreachable];
    }

    bb129: {
        _259 = <RangeInclusive<usize> as Iterator>::rev(move _260) -> [return: bb130, unwind unreachable];
    }

    bb130: {
        _258 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _259) -> [return: bb131, unwind unreachable];
    }

    bb131: {
        _264 = move _258;
        goto -> bb132;
    }

    bb132: {
        _266 = &mut _264;
        _265 = <Rev<RangeInclusive<usize>> as Iterator>::next(_266) -> [return: bb133, unwind unreachable];
    }

    bb133: {
        _267 = discriminant(_265);
        switchInt(move _267) -> [0: bb135, 1: bb134, otherwise: bb351];
    }

    bb134: {
        _268 = ((_265 as Some).0: usize);
        _273 = &_15;
        _272 = move _273 as &[i32] (PointerCoercion(Unsize));
        _271 = slice::<impl [i32]>::get::<usize>(move _272, _268) -> [return: bb136, unwind unreachable];
    }

    bb135: {
        _274 = _257;
        switchInt(move _274) -> [0: bb138, otherwise: bb175];
    }

    bb136: {
        _270 = Option::<&i32>::unwrap(move _271) -> [return: bb137, unwind unreachable];
    }

    bb137: {
        _269 = (*_270);
        _257 = BitOr(_257, move _269);
        goto -> bb132;
    }

    bb138: {
        _275 = const 1_usize;
        goto -> bb139;
    }

    bb139: {
        _280 = &mut _15;
        _279 = move _280 as &mut [i32] (PointerCoercion(Unsize));
        _282 = _275;
        _283 = CheckedSub(_16, _282);
        assert(!move (_283.1: bool), "attempt to compute `{} - {}`, which would overflow", _16, move _282) -> [success: bb140, unwind unreachable];
    }

    bb140: {
        _281 = move (_283.0: usize);
        _278 = slice::<impl [i32]>::get_mut::<usize>(move _279, move _281) -> [return: bb141, unwind unreachable];
    }

    bb141: {
        _277 = Option::<&mut i32>::unwrap(move _278) -> [return: bb142, unwind unreachable];
    }

    bb142: {
        _276 = (*_277);
        switchInt(move _276) -> [0: bb143, otherwise: bb145];
    }

    bb143: {
        _284 = CheckedAdd(_275, const 1_usize);
        assert(!move (_284.1: bool), "attempt to compute `{} + {}`, which would overflow", _275, const 1_usize) -> [success: bb144, unwind unreachable];
    }

    bb144: {
        _275 = move (_284.0: usize);
        goto -> bb139;
    }

    bb145: {
        _288 = _99;
        _289 = CheckedAdd(_288, const 1_usize);
        assert(!move (_289.1: bool), "attempt to compute `{} + {}`, which would overflow", move _288, const 1_usize) -> [success: bb146, unwind unreachable];
    }

    bb146: {
        _287 = move (_289.0: usize);
        _291 = _99;
        _292 = _275;
        _293 = CheckedAdd(_291, _292);
        assert(!move (_293.1: bool), "attempt to compute `{} + {}`, which would overflow", move _291, move _292) -> [success: bb147, unwind unreachable];
    }

    bb147: {
        _290 = move (_293.0: usize);
        _286 = RangeInclusive::<usize>::new(move _287, move _290) -> [return: bb148, unwind unreachable];
    }

    bb148: {
        _285 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _286) -> [return: bb149, unwind unreachable];
    }

    bb149: {
        _294 = move _285;
        goto -> bb150;
    }

    bb150: {
        _296 = &mut _294;
        _295 = <RangeInclusive<usize> as Iterator>::next(_296) -> [return: bb151, unwind unreachable];
    }

    bb151: {
        _297 = discriminant(_295);
        switchInt(move _297) -> [0: bb153, 1: bb152, otherwise: bb351];
    }

    bb152: {
        _298 = ((_295 as Some).0: usize);
        _642 = const _;
        _302 = _642 as &[i32] (PointerCoercion(Unsize));
        _304 = CheckedAdd(_38, _298);
        assert(!move (_304.1: bool), "attempt to compute `{} + {}`, which would overflow", _38, _298) -> [success: bb154, unwind unreachable];
    }

    bb153: {
        _336 = _275;
        _337 = CheckedAdd(_99, _336);
        assert(!move (_337.1: bool), "attempt to compute `{} + {}`, which would overflow", _99, move _336) -> [success: bb174, unwind unreachable];
    }

    bb154: {
        _303 = move (_304.0: usize);
        _301 = slice::<impl [i32]>::get::<usize>(move _302, move _303) -> [return: bb155, unwind unreachable];
    }

    bb155: {
        _300 = Option::<&i32>::unwrap(move _301) -> [return: bb156, unwind unreachable];
    }

    bb156: {
        _299 = (*_300);
        _308 = &mut _12;
        _307 = move _308 as &mut [f64] (PointerCoercion(Unsize));
        _310 = CheckedAdd(_20, _298);
        assert(!move (_310.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, _298) -> [success: bb157, unwind unreachable];
    }

    bb157: {
        _309 = move (_310.0: usize);
        _306 = slice::<impl [f64]>::get_mut::<usize>(move _307, move _309) -> [return: bb158, unwind unreachable];
    }

    bb158: {
        _305 = Option::<&mut f64>::unwrap(move _306) -> [return: bb159, unwind unreachable];
    }

    bb159: {
        (*_305) = move _299 as f64 (IntToFloat);
        _8 = const 0f64;
        _312 = RangeInclusive::<usize>::new(const 0_usize, _20) -> [return: bb160, unwind unreachable];
    }

    bb160: {
        _311 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _312) -> [return: bb161, unwind unreachable];
    }

    bb161: {
        _313 = move _311;
        goto -> bb162;
    }

    bb162: {
        _315 = &mut _313;
        _314 = <RangeInclusive<usize> as Iterator>::next(_315) -> [return: bb163, unwind unreachable];
    }

    bb163: {
        _316 = discriminant(_314);
        switchInt(move _316) -> [0: bb165, 1: bb164, otherwise: bb351];
    }

    bb164: {
        _317 = ((_314 as Some).0: usize);
        _321 = slice::<impl [f64]>::get::<usize>(_1, _317) -> [return: bb166, unwind unreachable];
    }

    bb165: {
        _331 = _8;
        _335 = &mut _14;
        _334 = move _335 as &mut [f64] (PointerCoercion(Unsize));
        _333 = slice::<impl [f64]>::get_mut::<usize>(move _334, _298) -> [return: bb172, unwind unreachable];
    }

    bb166: {
        _320 = Option::<&f64>::unwrap(move _321) -> [return: bb167, unwind unreachable];
    }

    bb167: {
        _319 = (*_320);
        _326 = &_12;
        _325 = move _326 as &[f64] (PointerCoercion(Unsize));
        _329 = CheckedAdd(_20, _298);
        assert(!move (_329.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, _298) -> [success: bb168, unwind unreachable];
    }

    bb168: {
        _328 = move (_329.0: usize);
        _330 = CheckedSub(_328, _317);
        assert(!move (_330.1: bool), "attempt to compute `{} - {}`, which would overflow", move _328, _317) -> [success: bb169, unwind unreachable];
    }

    bb169: {
        _327 = move (_330.0: usize);
        _324 = slice::<impl [f64]>::get::<usize>(move _325, move _327) -> [return: bb170, unwind unreachable];
    }

    bb170: {
        _323 = Option::<&f64>::unwrap(move _324) -> [return: bb171, unwind unreachable];
    }

    bb171: {
        _322 = (*_323);
        _318 = Mul(move _319, move _322);
        _8 = Add(_8, move _318);
        goto -> bb162;
    }

    bb172: {
        _332 = Option::<&mut f64>::unwrap(move _333) -> [return: bb173, unwind unreachable];
    }

    bb173: {
        (*_332) = move _331;
        goto -> bb150;
    }

    bb174: {
        _99 = move (_337.0: usize);
        goto -> bb50;
    }

    bb175: {
        _339 = _11;
        _338 = Eq(move _339, const 0f64);
        switchInt(move _338) -> [0: bb177, otherwise: bb176];
    }

    bb176: {
        _340 = CheckedSub(_99, const 1_usize);
        assert(!move (_340.1: bool), "attempt to compute `{} - {}`, which would overflow", _99, const 1_usize) -> [success: bb178, unwind unreachable];
    }

    bb177: {
        _351 = _11;
        _353 = _31;
        _354 = Eq(_353, const i32::MIN);
        assert(!move _354, "attempt to negate `{}`, which would overflow", _353) -> [success: bb186, unwind unreachable];
    }

    bb178: {
        _99 = move (_340.0: usize);
        _341 = CheckedSub(_31, const 24_i32);
        assert(!move (_341.1: bool), "attempt to compute `{} - {}`, which would overflow", _31, const 24_i32) -> [success: bb179, unwind unreachable];
    }

    bb179: {
        _31 = move (_341.0: i32);
        goto -> bb180;
    }

    bb180: {
        _346 = &_15;
        _345 = move _346 as &[i32] (PointerCoercion(Unsize));
        _347 = _99;
        _344 = slice::<impl [i32]>::get::<usize>(move _345, move _347) -> [return: bb181, unwind unreachable];
    }

    bb181: {
        _343 = Option::<&i32>::unwrap(move _344) -> [return: bb182, unwind unreachable];
    }

    bb182: {
        _342 = (*_343);
        switchInt(move _342) -> [0: bb183, otherwise: bb198];
    }

    bb183: {
        _348 = CheckedSub(_99, const 1_usize);
        assert(!move (_348.1: bool), "attempt to compute `{} - {}`, which would overflow", _99, const 1_usize) -> [success: bb184, unwind unreachable];
    }

    bb184: {
        _99 = move (_348.0: usize);
        _349 = CheckedSub(_31, const 24_i32);
        assert(!move (_349.1: bool), "attempt to compute `{} - {}`, which would overflow", _31, const 24_i32) -> [success: bb185, unwind unreachable];
    }

    bb185: {
        _31 = move (_349.0: i32);
        goto -> bb180;
    }

    bb186: {
        _352 = Neg(move _353);
        _350 = scalbn(move _351, move _352) -> [return: bb187, unwind unreachable];
    }

    bb187: {
        _11 = move _350;
        _356 = _11;
        _355 = Ge(move _356, _5);
        switchInt(move _355) -> [0: bb195, otherwise: bb188];
    }

    bb188: {
        _359 = _11;
        _358 = Mul(_6, move _359);
        _357 = move _358 as i32 (FloatToInt);
        _8 = move _357 as f64 (IntToFloat);
        _361 = _11;
        _363 = _8;
        _362 = Mul(_5, move _363);
        _360 = Sub(move _361, move _362);
        _367 = &mut _15;
        _366 = move _367 as &mut [i32] (PointerCoercion(Unsize));
        _368 = _99;
        _365 = slice::<impl [i32]>::get_mut::<usize>(move _366, move _368) -> [return: bb189, unwind unreachable];
    }

    bb189: {
        _364 = Option::<&mut i32>::unwrap(move _365) -> [return: bb190, unwind unreachable];
    }

    bb190: {
        (*_364) = move _360 as i32 (FloatToInt);
        _369 = CheckedAdd(_99, const 1_usize);
        assert(!move (_369.1: bool), "attempt to compute `{} + {}`, which would overflow", _99, const 1_usize) -> [success: bb191, unwind unreachable];
    }

    bb191: {
        _99 = move (_369.0: usize);
        _370 = CheckedAdd(_31, const 24_i32);
        assert(!move (_370.1: bool), "attempt to compute `{} + {}`, which would overflow", _31, const 24_i32) -> [success: bb192, unwind unreachable];
    }

    bb192: {
        _31 = move (_370.0: i32);
        _371 = _8;
        _375 = &mut _15;
        _374 = move _375 as &mut [i32] (PointerCoercion(Unsize));
        _376 = _99;
        _373 = slice::<impl [i32]>::get_mut::<usize>(move _374, move _376) -> [return: bb193, unwind unreachable];
    }

    bb193: {
        _372 = Option::<&mut i32>::unwrap(move _373) -> [return: bb194, unwind unreachable];
    }

    bb194: {
        (*_372) = move _371 as i32 (FloatToInt);
        goto -> bb198;
    }

    bb195: {
        _377 = _11;
        _381 = &mut _15;
        _380 = move _381 as &mut [i32] (PointerCoercion(Unsize));
        _382 = _99;
        _379 = slice::<impl [i32]>::get_mut::<usize>(move _380, move _382) -> [return: bb196, unwind unreachable];
    }

    bb196: {
        _378 = Option::<&mut i32>::unwrap(move _379) -> [return: bb197, unwind unreachable];
    }

    bb197: {
        (*_378) = move _377 as i32 (FloatToInt);
        goto -> bb198;
    }

    bb198: {
        _384 = _31;
        _383 = scalbn(const 1f64, move _384) -> [return: bb199, unwind unreachable];
    }

    bb199: {
        _8 = move _383;
        _388 = _99;
        _387 = RangeInclusive::<usize>::new(const 0_usize, move _388) -> [return: bb200, unwind unreachable];
    }

    bb200: {
        _386 = <RangeInclusive<usize> as Iterator>::rev(move _387) -> [return: bb201, unwind unreachable];
    }

    bb201: {
        _385 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _386) -> [return: bb202, unwind unreachable];
    }

    bb202: {
        _389 = move _385;
        goto -> bb203;
    }

    bb203: {
        _391 = &mut _389;
        _390 = <Rev<RangeInclusive<usize>> as Iterator>::next(_391) -> [return: bb204, unwind unreachable];
    }

    bb204: {
        _392 = discriminant(_390);
        switchInt(move _392) -> [0: bb206, 1: bb205, otherwise: bb351];
    }

    bb205: {
        _393 = ((_390 as Some).0: usize);
        _394 = _8;
        _400 = &_15;
        _399 = move _400 as &[i32] (PointerCoercion(Unsize));
        _398 = slice::<impl [i32]>::get::<usize>(move _399, _393) -> [return: bb207, unwind unreachable];
    }

    bb206: {
        _408 = _99;
        _407 = RangeInclusive::<usize>::new(const 0_usize, move _408) -> [return: bb211, unwind unreachable];
    }

    bb207: {
        _397 = Option::<&i32>::unwrap(move _398) -> [return: bb208, unwind unreachable];
    }

    bb208: {
        _396 = (*_397);
        _395 = move _396 as f64 (IntToFloat);
        _404 = &mut _14;
        _403 = move _404 as &mut [f64] (PointerCoercion(Unsize));
        _402 = slice::<impl [f64]>::get_mut::<usize>(move _403, _393) -> [return: bb209, unwind unreachable];
    }

    bb209: {
        _401 = Option::<&mut f64>::unwrap(move _402) -> [return: bb210, unwind unreachable];
    }

    bb210: {
        (*_401) = Mul(move _394, move _395);
        _8 = Mul(_8, _6);
        goto -> bb203;
    }

    bb211: {
        _406 = <RangeInclusive<usize> as Iterator>::rev(move _407) -> [return: bb212, unwind unreachable];
    }

    bb212: {
        _405 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _406) -> [return: bb213, unwind unreachable];
    }

    bb213: {
        _409 = move _405;
        goto -> bb214;
    }

    bb214: {
        _411 = &mut _409;
        _410 = <Rev<RangeInclusive<usize>> as Iterator>::next(_411) -> [return: bb215, unwind unreachable];
    }

    bb215: {
        _412 = discriminant(_410);
        switchInt(move _412) -> [0: bb217, 1: bb216, otherwise: bb351];
    }

    bb216: {
        _413 = ((_410 as Some).0: usize);
        _8 = const 0f64;
        _414 = const 0_usize;
        goto -> bb218;
    }

    bb217: {
        switchInt(_4) -> [0: bb233, 1: bb248, 2: bb248, 3: bb278, otherwise: bb232];
    }

    bb218: {
        _416 = _414;
        _415 = Le(move _416, _16);
        switchInt(move _415) -> [0: bb228, otherwise: bb219];
    }

    bb219: {
        _418 = _414;
        _420 = _99;
        _421 = CheckedSub(_420, _413);
        assert(!move (_421.1: bool), "attempt to compute `{} - {}`, which would overflow", move _420, _413) -> [success: bb220, unwind unreachable];
    }

    bb220: {
        _419 = move (_421.0: usize);
        _417 = Le(move _418, move _419);
        switchInt(move _417) -> [0: bb228, otherwise: bb221];
    }

    bb221: {
        _643 = const _;
        _426 = _643 as &[f64] (PointerCoercion(Unsize));
        _427 = _414;
        _425 = slice::<impl [f64]>::get::<usize>(move _426, move _427) -> [return: bb222, unwind unreachable];
    }

    bb222: {
        _424 = Option::<&f64>::unwrap(move _425) -> [return: bb223, unwind unreachable];
    }

    bb223: {
        _423 = (*_424);
        _432 = &_14;
        _431 = move _432 as &[f64] (PointerCoercion(Unsize));
        _434 = _414;
        _435 = CheckedAdd(_413, _434);
        assert(!move (_435.1: bool), "attempt to compute `{} + {}`, which would overflow", _413, move _434) -> [success: bb224, unwind unreachable];
    }

    bb224: {
        _433 = move (_435.0: usize);
        _430 = slice::<impl [f64]>::get::<usize>(move _431, move _433) -> [return: bb225, unwind unreachable];
    }

    bb225: {
        _429 = Option::<&f64>::unwrap(move _430) -> [return: bb226, unwind unreachable];
    }

    bb226: {
        _428 = (*_429);
        _422 = Mul(move _423, move _428);
        _8 = Add(_8, move _422);
        _436 = CheckedAdd(_414, const 1_usize);
        assert(!move (_436.1: bool), "attempt to compute `{} + {}`, which would overflow", _414, const 1_usize) -> [success: bb227, unwind unreachable];
    }

    bb227: {
        _414 = move (_436.0: usize);
        goto -> bb218;
    }

    bb228: {
        _437 = _8;
        _441 = &mut _13;
        _440 = move _441 as &mut [f64] (PointerCoercion(Unsize));
        _443 = _99;
        _444 = CheckedSub(_443, _413);
        assert(!move (_444.1: bool), "attempt to compute `{} - {}`, which would overflow", move _443, _413) -> [success: bb229, unwind unreachable];
    }

    bb229: {
        _442 = move (_444.0: usize);
        _439 = slice::<impl [f64]>::get_mut::<usize>(move _440, move _442) -> [return: bb230, unwind unreachable];
    }

    bb230: {
        _438 = Option::<&mut f64>::unwrap(move _439) -> [return: bb231, unwind unreachable];
    }

    bb231: {
        (*_438) = move _437;
        goto -> bb214;
    }

    bb232: {
        _639 = panic(const "internal error: entered unreachable code") -> unwind unreachable;
    }

    bb233: {
        _8 = const 0f64;
        _448 = _99;
        _447 = RangeInclusive::<usize>::new(const 0_usize, move _448) -> [return: bb234, unwind unreachable];
    }

    bb234: {
        _446 = <RangeInclusive<usize> as Iterator>::rev(move _447) -> [return: bb235, unwind unreachable];
    }

    bb235: {
        _445 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _446) -> [return: bb236, unwind unreachable];
    }

    bb236: {
        _449 = move _445;
        goto -> bb237;
    }

    bb237: {
        _451 = &mut _449;
        _450 = <Rev<RangeInclusive<usize>> as Iterator>::next(_451) -> [return: bb238, unwind unreachable];
    }

    bb238: {
        _452 = discriminant(_450);
        switchInt(move _452) -> [0: bb240, 1: bb239, otherwise: bb351];
    }

    bb239: {
        _453 = ((_450 as Some).0: usize);
        _458 = &_13;
        _457 = move _458 as &[f64] (PointerCoercion(Unsize));
        _456 = slice::<impl [f64]>::get::<usize>(move _457, _453) -> [return: bb241, unwind unreachable];
    }

    bb240: {
        _460 = _10;
        switchInt(move _460) -> [0: bb243, otherwise: bb244];
    }

    bb241: {
        _455 = Option::<&f64>::unwrap(move _456) -> [return: bb242, unwind unreachable];
    }

    bb242: {
        _454 = (*_455);
        _8 = Add(_8, move _454);
        goto -> bb237;
    }

    bb243: {
        _459 = _8;
        goto -> bb245;
    }

    bb244: {
        _461 = _8;
        _459 = Neg(move _461);
        goto -> bb245;
    }

    bb245: {
        _463 = slice::<impl [f64]>::get_mut::<usize>(_2, const 0_usize) -> [return: bb246, unwind unreachable];
    }

    bb246: {
        _462 = Option::<&mut f64>::unwrap(move _463) -> [return: bb247, unwind unreachable];
    }

    bb247: {
        (*_462) = move _459;
        goto -> bb350;
    }

    bb248: {
        _8 = const 0f64;
        _467 = _99;
        _466 = RangeInclusive::<usize>::new(const 0_usize, move _467) -> [return: bb249, unwind unreachable];
    }

    bb249: {
        _465 = <RangeInclusive<usize> as Iterator>::rev(move _466) -> [return: bb250, unwind unreachable];
    }

    bb250: {
        _464 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _465) -> [return: bb251, unwind unreachable];
    }

    bb251: {
        _468 = move _464;
        goto -> bb252;
    }

    bb252: {
        _470 = &mut _468;
        _469 = <Rev<RangeInclusive<usize>> as Iterator>::next(_470) -> [return: bb253, unwind unreachable];
    }

    bb253: {
        _471 = discriminant(_469);
        switchInt(move _471) -> [0: bb255, 1: bb254, otherwise: bb351];
    }

    bb254: {
        _472 = ((_469 as Some).0: usize);
        _477 = &_13;
        _476 = move _477 as &[f64] (PointerCoercion(Unsize));
        _475 = slice::<impl [f64]>::get::<usize>(move _476, _472) -> [return: bb256, unwind unreachable];
    }

    bb255: {
        _478 = _8;
        _8 = move _478;
        _480 = _10;
        switchInt(move _480) -> [0: bb258, otherwise: bb259];
    }

    bb256: {
        _474 = Option::<&f64>::unwrap(move _475) -> [return: bb257, unwind unreachable];
    }

    bb257: {
        _473 = (*_474);
        _8 = Add(_8, move _473);
        goto -> bb252;
    }

    bb258: {
        _479 = _8;
        goto -> bb260;
    }

    bb259: {
        _481 = _8;
        _479 = Neg(move _481);
        goto -> bb260;
    }

    bb260: {
        _483 = slice::<impl [f64]>::get_mut::<usize>(_2, const 0_usize) -> [return: bb261, unwind unreachable];
    }

    bb261: {
        _482 = Option::<&mut f64>::unwrap(move _483) -> [return: bb262, unwind unreachable];
    }

    bb262: {
        (*_482) = move _479;
        _488 = &_13;
        _487 = move _488 as &[f64] (PointerCoercion(Unsize));
        _486 = slice::<impl [f64]>::get::<usize>(move _487, const 0_usize) -> [return: bb263, unwind unreachable];
    }

    bb263: {
        _485 = Option::<&f64>::unwrap(move _486) -> [return: bb264, unwind unreachable];
    }

    bb264: {
        _484 = (*_485);
        _489 = _8;
        _8 = Sub(move _484, move _489);
        _492 = _99;
        _491 = RangeInclusive::<usize>::new(const 1_usize, move _492) -> [return: bb265, unwind unreachable];
    }

    bb265: {
        _490 = <RangeInclusive<usize> as IntoIterator>::into_iter(move _491) -> [return: bb266, unwind unreachable];
    }

    bb266: {
        _493 = move _490;
        goto -> bb267;
    }

    bb267: {
        _495 = &mut _493;
        _494 = <RangeInclusive<usize> as Iterator>::next(_495) -> [return: bb268, unwind unreachable];
    }

    bb268: {
        _496 = discriminant(_494);
        switchInt(move _496) -> [0: bb270, 1: bb269, otherwise: bb351];
    }

    bb269: {
        _497 = ((_494 as Some).0: usize);
        _502 = &_13;
        _501 = move _502 as &[f64] (PointerCoercion(Unsize));
        _500 = slice::<impl [f64]>::get::<usize>(move _501, _497) -> [return: bb271, unwind unreachable];
    }

    bb270: {
        _504 = _10;
        switchInt(move _504) -> [0: bb273, otherwise: bb274];
    }

    bb271: {
        _499 = Option::<&f64>::unwrap(move _500) -> [return: bb272, unwind unreachable];
    }

    bb272: {
        _498 = (*_499);
        _8 = Add(_8, move _498);
        goto -> bb267;
    }

    bb273: {
        _503 = _8;
        goto -> bb275;
    }

    bb274: {
        _505 = _8;
        _503 = Neg(move _505);
        goto -> bb275;
    }

    bb275: {
        _507 = slice::<impl [f64]>::get_mut::<usize>(_2, const 1_usize) -> [return: bb276, unwind unreachable];
    }

    bb276: {
        _506 = Option::<&mut f64>::unwrap(move _507) -> [return: bb277, unwind unreachable];
    }

    bb277: {
        (*_506) = move _503;
        goto -> bb350;
    }

    bb278: {
        _511 = _99;
        _510 = RangeInclusive::<usize>::new(const 1_usize, move _511) -> [return: bb279, unwind unreachable];
    }

    bb279: {
        _509 = <RangeInclusive<usize> as Iterator>::rev(move _510) -> [return: bb280, unwind unreachable];
    }

    bb280: {
        _508 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _509) -> [return: bb281, unwind unreachable];
    }

    bb281: {
        _512 = move _508;
        goto -> bb282;
    }

    bb282: {
        _514 = &mut _512;
        _513 = <Rev<RangeInclusive<usize>> as Iterator>::next(_514) -> [return: bb283, unwind unreachable];
    }

    bb283: {
        _515 = discriminant(_513);
        switchInt(move _515) -> [0: bb285, 1: bb284, otherwise: bb351];
    }

    bb284: {
        _516 = ((_513 as Some).0: usize);
        _521 = &_13;
        _520 = move _521 as &[f64] (PointerCoercion(Unsize));
        _523 = CheckedSub(_516, const 1_usize);
        assert(!move (_523.1: bool), "attempt to compute `{} - {}`, which would overflow", _516, const 1_usize) -> [success: bb286, unwind unreachable];
    }

    bb285: {
        _552 = _99;
        _551 = RangeInclusive::<usize>::new(const 2_usize, move _552) -> [return: bb299, unwind unreachable];
    }

    bb286: {
        _522 = move (_523.0: usize);
        _519 = slice::<impl [f64]>::get::<usize>(move _520, move _522) -> [return: bb287, unwind unreachable];
    }

    bb287: {
        _518 = Option::<&f64>::unwrap(move _519) -> [return: bb288, unwind unreachable];
    }

    bb288: {
        _517 = (*_518);
        _528 = &_13;
        _527 = move _528 as &[f64] (PointerCoercion(Unsize));
        _526 = slice::<impl [f64]>::get::<usize>(move _527, _516) -> [return: bb289, unwind unreachable];
    }

    bb289: {
        _525 = Option::<&f64>::unwrap(move _526) -> [return: bb290, unwind unreachable];
    }

    bb290: {
        _524 = (*_525);
        _8 = Add(move _517, move _524);
        _534 = &_13;
        _533 = move _534 as &[f64] (PointerCoercion(Unsize));
        _536 = CheckedSub(_516, const 1_usize);
        assert(!move (_536.1: bool), "attempt to compute `{} - {}`, which would overflow", _516, const 1_usize) -> [success: bb291, unwind unreachable];
    }

    bb291: {
        _535 = move (_536.0: usize);
        _532 = slice::<impl [f64]>::get::<usize>(move _533, move _535) -> [return: bb292, unwind unreachable];
    }

    bb292: {
        _531 = Option::<&f64>::unwrap(move _532) -> [return: bb293, unwind unreachable];
    }

    bb293: {
        _530 = (*_531);
        _537 = _8;
        _529 = Sub(move _530, move _537);
        _541 = &mut _13;
        _540 = move _541 as &mut [f64] (PointerCoercion(Unsize));
        _539 = slice::<impl [f64]>::get_mut::<usize>(move _540, _516) -> [return: bb294, unwind unreachable];
    }

    bb294: {
        _538 = Option::<&mut f64>::unwrap(move _539) -> [return: bb295, unwind unreachable];
    }

    bb295: {
        (*_538) = Add((*_538), move _529);
        _542 = _8;
        _546 = &mut _13;
        _545 = move _546 as &mut [f64] (PointerCoercion(Unsize));
        _548 = CheckedSub(_516, const 1_usize);
        assert(!move (_548.1: bool), "attempt to compute `{} - {}`, which would overflow", _516, const 1_usize) -> [success: bb296, unwind unreachable];
    }

    bb296: {
        _547 = move (_548.0: usize);
        _544 = slice::<impl [f64]>::get_mut::<usize>(move _545, move _547) -> [return: bb297, unwind unreachable];
    }

    bb297: {
        _543 = Option::<&mut f64>::unwrap(move _544) -> [return: bb298, unwind unreachable];
    }

    bb298: {
        (*_543) = move _542;
        goto -> bb282;
    }

    bb299: {
        _550 = <RangeInclusive<usize> as Iterator>::rev(move _551) -> [return: bb300, unwind unreachable];
    }

    bb300: {
        _549 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _550) -> [return: bb301, unwind unreachable];
    }

    bb301: {
        _553 = move _549;
        goto -> bb302;
    }

    bb302: {
        _555 = &mut _553;
        _554 = <Rev<RangeInclusive<usize>> as Iterator>::next(_555) -> [return: bb303, unwind unreachable];
    }

    bb303: {
        _556 = discriminant(_554);
        switchInt(move _556) -> [0: bb305, 1: bb304, otherwise: bb351];
    }

    bb304: {
        _557 = ((_554 as Some).0: usize);
        _562 = &_13;
        _561 = move _562 as &[f64] (PointerCoercion(Unsize));
        _564 = CheckedSub(_557, const 1_usize);
        assert(!move (_564.1: bool), "attempt to compute `{} - {}`, which would overflow", _557, const 1_usize) -> [success: bb306, unwind unreachable];
    }

    bb305: {
        _8 = const 0f64;
        _593 = _99;
        _592 = RangeInclusive::<usize>::new(const 2_usize, move _593) -> [return: bb319, unwind unreachable];
    }

    bb306: {
        _563 = move (_564.0: usize);
        _560 = slice::<impl [f64]>::get::<usize>(move _561, move _563) -> [return: bb307, unwind unreachable];
    }

    bb307: {
        _559 = Option::<&f64>::unwrap(move _560) -> [return: bb308, unwind unreachable];
    }

    bb308: {
        _558 = (*_559);
        _569 = &_13;
        _568 = move _569 as &[f64] (PointerCoercion(Unsize));
        _567 = slice::<impl [f64]>::get::<usize>(move _568, _557) -> [return: bb309, unwind unreachable];
    }

    bb309: {
        _566 = Option::<&f64>::unwrap(move _567) -> [return: bb310, unwind unreachable];
    }

    bb310: {
        _565 = (*_566);
        _8 = Add(move _558, move _565);
        _575 = &_13;
        _574 = move _575 as &[f64] (PointerCoercion(Unsize));
        _577 = CheckedSub(_557, const 1_usize);
        assert(!move (_577.1: bool), "attempt to compute `{} - {}`, which would overflow", _557, const 1_usize) -> [success: bb311, unwind unreachable];
    }

    bb311: {
        _576 = move (_577.0: usize);
        _573 = slice::<impl [f64]>::get::<usize>(move _574, move _576) -> [return: bb312, unwind unreachable];
    }

    bb312: {
        _572 = Option::<&f64>::unwrap(move _573) -> [return: bb313, unwind unreachable];
    }

    bb313: {
        _571 = (*_572);
        _578 = _8;
        _570 = Sub(move _571, move _578);
        _582 = &mut _13;
        _581 = move _582 as &mut [f64] (PointerCoercion(Unsize));
        _580 = slice::<impl [f64]>::get_mut::<usize>(move _581, _557) -> [return: bb314, unwind unreachable];
    }

    bb314: {
        _579 = Option::<&mut f64>::unwrap(move _580) -> [return: bb315, unwind unreachable];
    }

    bb315: {
        (*_579) = Add((*_579), move _570);
        _583 = _8;
        _587 = &mut _13;
        _586 = move _587 as &mut [f64] (PointerCoercion(Unsize));
        _589 = CheckedSub(_557, const 1_usize);
        assert(!move (_589.1: bool), "attempt to compute `{} - {}`, which would overflow", _557, const 1_usize) -> [success: bb316, unwind unreachable];
    }

    bb316: {
        _588 = move (_589.0: usize);
        _585 = slice::<impl [f64]>::get_mut::<usize>(move _586, move _588) -> [return: bb317, unwind unreachable];
    }

    bb317: {
        _584 = Option::<&mut f64>::unwrap(move _585) -> [return: bb318, unwind unreachable];
    }

    bb318: {
        (*_584) = move _583;
        goto -> bb302;
    }

    bb319: {
        _591 = <RangeInclusive<usize> as Iterator>::rev(move _592) -> [return: bb320, unwind unreachable];
    }

    bb320: {
        _590 = <Rev<RangeInclusive<usize>> as IntoIterator>::into_iter(move _591) -> [return: bb321, unwind unreachable];
    }

    bb321: {
        _594 = move _590;
        goto -> bb322;
    }

    bb322: {
        _596 = &mut _594;
        _595 = <Rev<RangeInclusive<usize>> as Iterator>::next(_596) -> [return: bb323, unwind unreachable];
    }

    bb323: {
        _597 = discriminant(_595);
        switchInt(move _597) -> [0: bb325, 1: bb324, otherwise: bb351];
    }

    bb324: {
        _598 = ((_595 as Some).0: usize);
        _603 = &_13;
        _602 = move _603 as &[f64] (PointerCoercion(Unsize));
        _601 = slice::<impl [f64]>::get::<usize>(move _602, _598) -> [return: bb326, unwind unreachable];
    }

    bb325: {
        _604 = _10;
        switchInt(move _604) -> [0: bb328, otherwise: bb329];
    }

    bb326: {
        _600 = Option::<&f64>::unwrap(move _601) -> [return: bb327, unwind unreachable];
    }

    bb327: {
        _599 = (*_600);
        _8 = Add(_8, move _599);
        goto -> bb322;
    }

    bb328: {
        _609 = &_13;
        _608 = move _609 as &[f64] (PointerCoercion(Unsize));
        _607 = slice::<impl [f64]>::get::<usize>(move _608, const 0_usize) -> [return: bb330, unwind unreachable];
    }

    bb329: {
        _626 = &_13;
        _625 = move _626 as &[f64] (PointerCoercion(Unsize));
        _624 = slice::<impl [f64]>::get::<usize>(move _625, const 0_usize) -> [return: bb340, unwind unreachable];
    }

    bb330: {
        _606 = Option::<&f64>::unwrap(move _607) -> [return: bb331, unwind unreachable];
    }

    bb331: {
        _605 = (*_606);
        _611 = slice::<impl [f64]>::get_mut::<usize>(_2, const 0_usize) -> [return: bb332, unwind unreachable];
    }

    bb332: {
        _610 = Option::<&mut f64>::unwrap(move _611) -> [return: bb333, unwind unreachable];
    }

    bb333: {
        (*_610) = move _605;
        _616 = &_13;
        _615 = move _616 as &[f64] (PointerCoercion(Unsize));
        _614 = slice::<impl [f64]>::get::<usize>(move _615, const 1_usize) -> [return: bb334, unwind unreachable];
    }

    bb334: {
        _613 = Option::<&f64>::unwrap(move _614) -> [return: bb335, unwind unreachable];
    }

    bb335: {
        _612 = (*_613);
        _618 = slice::<impl [f64]>::get_mut::<usize>(_2, const 1_usize) -> [return: bb336, unwind unreachable];
    }

    bb336: {
        _617 = Option::<&mut f64>::unwrap(move _618) -> [return: bb337, unwind unreachable];
    }

    bb337: {
        (*_617) = move _612;
        _619 = _8;
        _621 = slice::<impl [f64]>::get_mut::<usize>(_2, const 2_usize) -> [return: bb338, unwind unreachable];
    }

    bb338: {
        _620 = Option::<&mut f64>::unwrap(move _621) -> [return: bb339, unwind unreachable];
    }

    bb339: {
        (*_620) = move _619;
        goto -> bb350;
    }

    bb340: {
        _623 = Option::<&f64>::unwrap(move _624) -> [return: bb341, unwind unreachable];
    }

    bb341: {
        _622 = (*_623);
        _628 = slice::<impl [f64]>::get_mut::<usize>(_2, const 0_usize) -> [return: bb342, unwind unreachable];
    }

    bb342: {
        _627 = Option::<&mut f64>::unwrap(move _628) -> [return: bb343, unwind unreachable];
    }

    bb343: {
        (*_627) = Neg(move _622);
        _633 = &_13;
        _632 = move _633 as &[f64] (PointerCoercion(Unsize));
        _631 = slice::<impl [f64]>::get::<usize>(move _632, const 1_usize) -> [return: bb344, unwind unreachable];
    }

    bb344: {
        _630 = Option::<&f64>::unwrap(move _631) -> [return: bb345, unwind unreachable];
    }

    bb345: {
        _629 = (*_630);
        _635 = slice::<impl [f64]>::get_mut::<usize>(_2, const 1_usize) -> [return: bb346, unwind unreachable];
    }

    bb346: {
        _634 = Option::<&mut f64>::unwrap(move _635) -> [return: bb347, unwind unreachable];
    }

    bb347: {
        (*_634) = Neg(move _629);
        _636 = _8;
        _638 = slice::<impl [f64]>::get_mut::<usize>(_2, const 2_usize) -> [return: bb348, unwind unreachable];
    }

    bb348: {
        _637 = Option::<&mut f64>::unwrap(move _638) -> [return: bb349, unwind unreachable];
    }

    bb349: {
        (*_637) = Neg(move _636);
        goto -> bb350;
    }

    bb350: {
        _640 = _9;
        _0 = BitAnd(move _640, const 7_i32);
        return;
    }

    bb351: {
        unreachable;
    }
}

promoted[0] in rem_pio2_large: &[i32; 690] = {
    let mut _0: &[i32; 690];
    let mut _1: [i32; 690];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in rem_pio2_large: &[i32; 690] = {
    let mut _0: &[i32; 690];
    let mut _1: [i32; 690];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in rem_pio2_large: &[f64; 8] = {
    let mut _0: &[f64; 8];
    let mut _1: [f64; 8];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in rem_pio2_large: &[usize; 4] = {
    let mut _0: &[usize; 4];
    let mut _1: [usize; 4];

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

rem_pio2_large::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#3}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#2}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#5}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#4}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#7}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

rem_pio2_large::{constant#6}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 20_usize;
        return;
    }
}

const rem_pio2f::TOINT: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = Div(const 1.5f64, const _);
        return;
    }
}

const rem_pio2f::INV_PIO2: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 0.63661977236758138f64;
        return;
    }
}

const rem_pio2f::PIO2_1: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5707963109016418f64;
        return;
    }
}

const rem_pio2f::PIO2_1T: f64 = {
    let mut _0: f64;

    bb0: {
        _0 = const 1.5893254773528196E-8f64;
        return;
    }
}

fn rem_pio2f(_1: f32) -> (i32, f64) {
    debug x => _1;
    let mut _0: (i32, f64);
    let _2: f64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _9: f64;
    let mut _11: i32;
    let mut _12: f64;
    let mut _13: f64;
    let mut _14: f64;
    let mut _15: f64;
    let mut _16: bool;
    let mut _17: f64;
    let mut _19: u32;
    let mut _20: u32;
    let mut _21: u32;
    let mut _22: bool;
    let mut _24: u32;
    let mut _25: u32;
    let mut _26: u32;
    let mut _27: bool;
    let mut _28: u32;
    let mut _29: (u32, bool);
    let mut _30: (u32, bool);
    let mut _31: f32;
    let mut _32: u32;
    let mut _33: u32;
    let mut _34: i32;
    let mut _35: u32;
    let mut _36: bool;
    let mut _37: (u32, bool);
    let _38: usize;
    let mut _39: usize;
    let mut _40: bool;
    let mut _42: &[f64];
    let _43: &[f64; 1];
    let mut _44: &mut [f64];
    let mut _45: &mut [f64; 1];
    let mut _46: i32;
    let mut _47: bool;
    let mut _48: f64;
    let mut _49: f64;
    let _50: usize;
    let mut _51: usize;
    let mut _52: bool;
    let mut _53: f64;
    let _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    scope 1 {
        debug x64 => _2;
        let mut _3: [f64; 1];
        scope 2 {
            debug tx => _3;
            let mut _4: [f64; 1];
            scope 3 {
                debug ty => _4;
                let _5: u32;
                scope 4 {
                    debug ix => _5;
                    let _8: f64;
                    let _18: bool;
                    scope 5 {
                        debug tmp => _8;
                        let _10: f64;
                        scope 6 {
                            debug f_n => _10;
                        }
                    }
                    scope 7 {
                        debug sign => _18;
                        let _23: i32;
                        scope 8 {
                            debug e0 => _23;
                            let _41: i32;
                            scope 9 {
                                debug n => _41;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = _1 as f64 (FloatToFloat);
        _3 = [const 0f64];
        _4 = [const 0f64];
        _6 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _5 = BitAnd(move _6, const 2147483647_u32);
        _7 = Lt(_5, const 1305022427_u32);
        switchInt(move _7) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _9 = Mul(_2, const _);
        _8 = Add(move _9, const _);
        _10 = Sub(_8, const _);
        _11 = _10 as i32 (FloatToInt);
        _14 = Mul(_10, const _);
        _13 = Sub(_2, move _14);
        _15 = Mul(_10, const _);
        _12 = Sub(move _13, move _15);
        _0 = (move _11, move _12);
        goto -> bb21;
    }

    bb3: {
        _16 = Ge(_5, const 2139095040_u32);
        switchInt(move _16) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _17 = Sub(_2, _2);
        _0 = (const 0_i32, move _17);
        goto -> bb21;
    }

    bb5: {
        _20 = f32::<impl f32>::to_bits(_1) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _21 = const 31_i32 as u32 (IntToInt);
        _22 = Lt(move _21, const 32_u32);
        assert(move _22, "attempt to shift right by `{}`, which would overflow", const 31_i32) -> [success: bb7, unwind unreachable];
    }

    bb7: {
        _19 = Shr(move _20, const 31_i32);
        _18 = Ne(move _19, const 0_u32);
        _26 = const 23_i32 as u32 (IntToInt);
        _27 = Lt(move _26, const 32_u32);
        assert(move _27, "attempt to shift right by `{}`, which would overflow", const 23_i32) -> [success: bb8, unwind unreachable];
    }

    bb8: {
        _25 = Shr(_5, const 23_i32);
        _29 = CheckedAdd(const 127_u32, const 23_u32);
        assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", const 127_u32, const 23_u32) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _28 = move (_29.0: u32);
        _30 = CheckedSub(_25, _28);
        assert(!move (_30.1: bool), "attempt to compute `{} - {}`, which would overflow", move _25, move _28) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _24 = move (_30.0: u32);
        _23 = move _24 as i32 (IntToInt);
        _35 = const 23_i32 as u32 (IntToInt);
        _36 = Lt(move _35, const 32_u32);
        assert(move _36, "attempt to shift left by `{}`, which would overflow", const 23_i32) -> [success: bb11, unwind unreachable];
    }

    bb11: {
        _34 = Shl(_23, const 23_i32);
        _33 = move _34 as u32 (IntToInt);
        _37 = CheckedSub(_5, _33);
        assert(!move (_37.1: bool), "attempt to compute `{} - {}`, which would overflow", _5, move _33) -> [success: bb12, unwind unreachable];
    }

    bb12: {
        _32 = move (_37.0: u32);
        _31 = f32::<impl f32>::from_bits(move _32) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _38 = const 0_usize;
        _39 = const 1_usize;
        _40 = Lt(_38, _39);
        assert(move _40, "index out of bounds: the length is {} but the index is {}", move _39, _38) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _3[_38] = move _31 as f64 (FloatToFloat);
        _43 = &_3;
        _42 = _43 as &[f64] (PointerCoercion(Unsize));
        _45 = &mut _4;
        _44 = _45 as &mut [f64] (PointerCoercion(Unsize));
        _41 = rem_pio2_large(move _42, move _44, _23, const 0_usize) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        switchInt(_18) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _47 = Eq(_41, const i32::MIN);
        assert(!move _47, "attempt to negate `{}`, which would overflow", _41) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _46 = Neg(_41);
        _50 = const 0_usize;
        _51 = const 1_usize;
        _52 = Lt(_50, _51);
        assert(move _52, "index out of bounds: the length is {} but the index is {}", move _51, _50) -> [success: bb18, unwind unreachable];
    }

    bb18: {
        _49 = _4[_50];
        _48 = Neg(move _49);
        _0 = (move _46, move _48);
        goto -> bb21;
    }

    bb19: {
        _54 = const 0_usize;
        _55 = const 1_usize;
        _56 = Lt(_54, _55);
        assert(move _56, "index out of bounds: the length is {} but the index is {}", move _55, _54) -> [success: bb20, unwind unreachable];
    }

    bb20: {
        _53 = _4[_54];
        _0 = (_41, move _53);
        goto -> bb21;
    }

    bb21: {
        return;
    }
}

rem_pio2f::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

rem_pio2f::{constant#1}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 1_usize;
        return;
    }
}

fn get_high_word(_1: f64) -> u32 {
    debug x => _1;
    let mut _0: u32;
    let mut _2: u64;
    let mut _3: u64;
    let mut _4: u32;
    let mut _5: bool;

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = const 32_i32 as u32 (IntToInt);
        _5 = Lt(move _4, const 64_u32);
        assert(move _5, "attempt to shift right by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _2 = Shr(move _3, const 32_i32);
        _0 = move _2 as u32 (IntToInt);
        return;
    }
}

fn get_low_word(_1: f64) -> u32 {
    debug x => _1;
    let mut _0: u32;
    let mut _2: u64;

    bb0: {
        _2 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = move _2 as u32 (IntToInt);
        return;
    }
}

fn with_set_high_word(_1: f64, _2: u32) -> f64 {
    debug f => _1;
    debug hi => _2;
    let mut _0: f64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u64;
    scope 1 {
        debug tmp => _3;
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(_3, const 4294967295_u64);
        _5 = _2 as u64 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _4 = Shl(move _5, const 32_i32);
        _3 = BitOr(_3, move _4);
        _8 = _3;
        _0 = f64::<impl f64>::from_bits(move _8) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn with_set_low_word(_1: f64, _2: u32) -> f64 {
    debug f => _1;
    debug lo => _2;
    let mut _0: f64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    scope 1 {
        debug tmp => _3;
    }

    bb0: {
        _3 = f64::<impl f64>::to_bits(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _3 = BitAnd(_3, const 18446744069414584320_u64);
        _4 = _2 as u64 (IntToInt);
        _3 = BitOr(_3, move _4);
        _5 = _3;
        _0 = f64::<impl f64>::from_bits(move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn combine_words(_1: u32, _2: u32) -> f64 {
    debug hi => _1;
    debug lo => _2;
    let mut _0: f64;
    let mut _3: u64;
    let mut _4: u64;
    let mut _5: u64;
    let mut _6: u32;
    let mut _7: bool;
    let mut _8: u64;

    bb0: {
        _5 = _1 as u64 (IntToInt);
        _6 = const 32_i32 as u32 (IntToInt);
        _7 = Lt(move _6, const 64_u32);
        assert(move _7, "attempt to shift left by `{}`, which would overflow", const 32_i32) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = Shl(move _5, const 32_i32);
        _8 = _2 as u64 (IntToInt);
        _3 = BitOr(move _4, move _8);
        _0 = f64::<impl f64>::from_bits(move _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        return;
    }
}

fn math::fmin(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = libm::fmin::fmin(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmin::fmin(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = math::fmin(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fminf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = libm::fminf::fminf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fminf::fminf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = math::fminf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmax(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = libm::fmax::fmax(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmax::fmax(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = math::fmax(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmaxf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = libm::fmaxf::fmaxf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmaxf::fmaxf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = math::fmaxf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmod(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = libm::fmod::fmod(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmod::fmod(_1: f64, _2: f64) -> f64 {
    debug x => _1;
    debug y => _2;
    let mut _0: f64;

    bb0: {
        _0 = math::fmod(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmodf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = libm::fmodf::fmodf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn math::fmodf::fmodf(_1: f32, _2: f32) -> f32 {
    debug x => _1;
    debug y => _2;
    let mut _0: f32;

    bb0: {
        _0 = math::fmodf(_1, _2) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn copy_forward(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug count => _3;
    let mut _0: ();
    let _4: usize;
    let _5: usize;
    let _6: usize;
    let mut _7: (usize, usize, usize);
    let mut _8: *mut u8;
    let mut _9: *mut u8;
    let mut _10: *const u8;
    let mut _11: *mut u8;
    let mut _12: *const u8;
    let mut _13: *mut u8;
    let mut _14: *const u8;
    scope 1 {
        debug pre_byte_count => _4;
        debug qword_count => _5;
        debug byte_count => _6;
    }

    bb0: {
        _8 = _1;
        _7 = rep_param(move _8, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_7.0: usize);
        _5 = (_7.1: usize);
        _6 = (_7.2: usize);
        _9 = _1;
        _10 = _2;
        asm!("rep movsb", inout("cx") _4 => _, inout("di") move _9 => _1, inout("si") move _10 => _2, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _11 = _1;
        _12 = _2;
        asm!("rep movsq", inout("cx") _5 => _, inout("di") move _11 => _1, inout("si") move _12 => _2, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = _1;
        _14 = _2;
        asm!("rep movsb", inout("cx") _6 => _, inout("di") move _13 => _, inout("si") move _14 => _, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        return;
    }
}

fn copy_backward(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug count => _3;
    let mut _0: ();
    let _4: usize;
    let _5: usize;
    let _6: usize;
    let mut _7: (usize, usize, usize);
    let mut _8: *mut u8;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: *const u8;
    let mut _12: usize;
    let mut _13: (usize, bool);
    scope 1 {
        debug pre_byte_count => _4;
        debug qword_count => _5;
        debug byte_count => _6;
    }

    bb0: {
        _7 = rep_param(_1, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = (_7.0: usize);
        _5 = (_7.1: usize);
        _6 = (_7.2: usize);
        _10 = CheckedSub(_3, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_usize) -> [success: bb2, unwind unreachable];
    }

    bb2: {
        _9 = move (_10.0: usize);
        _8 = rustc_std_workspace_core::ptr::mut_ptr::<impl *mut u8>::add(_1, move _9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = CheckedSub(_3, const 1_usize);
        assert(!move (_13.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1_usize) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _12 = move (_13.0: usize);
        _11 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::add(_2, move _12) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        asm!("std
rep movsb
sub $7, %rsi
sub $7, %rdi
mov {1}, %rcx
rep movsq
test {0:e}, {0:e}
add $7, %rsi
add $7, %rdi
mov {0:e}, %ecx
rep movsb
cld", in(reg) _4, in(reg) _5, inout("cx") _6 => _, inout("di") move _8 => _, inout("si") move _11 => _, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        return;
    }
}

fn set_bytes(_1: *mut u8, _2: u8, _3: usize) -> () {
    debug dest => _1;
    debug c => _2;
    debug count => _3;
    let mut _0: ();
    let _4: u64;
    let mut _5: u64;
    let mut _6: (u64, bool);
    let mut _10: (usize, usize, usize);
    let mut _11: *mut u8;
    let mut _12: *mut u8;
    let mut _13: *mut u8;
    let mut _14: *mut u8;
    scope 1 {
        debug c => _4;
        let _7: usize;
        let _8: usize;
        let _9: usize;
        scope 2 {
            debug pre_byte_count => _7;
            debug qword_count => _8;
            debug byte_count => _9;
        }
    }

    bb0: {
        _5 = _2 as u64 (IntToInt);
        _6 = CheckedMul(_5, const 72340172838076673_u64);
        assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", move _5, const 72340172838076673_u64) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _4 = move (_6.0: u64);
        _11 = _1;
        _10 = rep_param(move _11, _3) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = (_10.0: usize);
        _8 = (_10.1: usize);
        _9 = (_10.2: usize);
        _12 = _1;
        asm!("rep stosb", inout("cx") _7 => _, inout("di") move _12 => _1, in("ax") _4, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _13 = _1;
        asm!("rep stosq", inout("cx") _8 => _, inout("di") move _13 => _1, in("ax") _4, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _14 = _1;
        asm!("rep stosb", inout("cx") _9 => _, inout("di") move _14 => _, in("ax") _4, options(PRESERVES_FLAGS | NOSTACK | ATT_SYNTAX)) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        return;
    }
}

fn impls::compare_bytes(_1: *const u8, _2: *const u8, _3: usize) -> i32 {
    debug a => _1;
    debug b => _2;
    debug n => _3;
    let mut _0: i32;
    let _4: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53};
    let mut _6: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53};
    let mut _8: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35};
    let mut _10: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35};
    let mut _12: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35};
    let mut _13: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:172:15: 172:37};
    let mut _14: (*const u128, *const u128, usize);
    let mut _15: *const u128;
    let mut _16: *const u128;
    scope 1 {
        debug c1 => const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53};
        let _5: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35};
        scope 2 {
            debug c2 => _5;
            let _7: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35};
            scope 3 {
                debug c4 => _7;
                let _9: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35};
                scope 4 {
                    debug c8 => _9;
                    let _11: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:172:15: 172:37};
                    scope 5 {
                        debug c16 => _11;
                    }
                }
            }
        }
    }

    bb0: {
        _6 = &_4;
        _5 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35} { c1: move _6 };
        _8 = &_5;
        _7 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35} { c2: move _8 };
        _10 = &_7;
        _9 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35} { c4: move _10 };
        _12 = &_9;
        _11 = {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:172:15: 172:37} { c8: move _12 };
        _13 = &_11;
        _15 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::cast::<u128>(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _16 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::cast::<u128>(_2) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _14 = (move _15, move _16, _3);
        _0 = <{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:172:15: 172:37} as Fn<(*const u128, *const u128, usize)>>::call(move _13, move _14) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        return;
    }
}

fn impls::compare_bytes::cmp(_1: *const T, _2: *const T, _3: usize, _4: F) -> i32 {
    debug a => _1;
    debug b => _2;
    debug n => _3;
    debug f => _4;
    let mut _0: i32;
    let _5: *const T;
    let mut _6: *const T;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: *const T;
    let mut _11: bool;
    let mut _12: &T;
    let _13: T;
    let mut _14: *const T;
    let mut _15: &T;
    let _16: T;
    let mut _17: *const T;
    let mut _18: (*const U, *const U, usize);
    let mut _19: *const U;
    let mut _20: *const T;
    let mut _21: *const U;
    let mut _22: *const T;
    let mut _23: usize;
    let mut _24: *const T;
    let mut _25: *const T;
    let mut _26: *const T;
    let mut _27: *const T;
    let mut _28: (*const U, *const U, usize);
    let mut _29: *const U;
    let mut _30: *const T;
    let mut _31: *const U;
    let mut _32: *const T;
    let mut _33: usize;
    let mut _34: usize;
    scope 1 {
        debug end => _5;
    }

    bb0: {
        _6 = _1;
        _8 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = Div(_3, move _8);
        _5 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(move _6, move _7) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = _1;
        _9 = Ne(move _10, _5);
        switchInt(move _9) -> [0: bb14, otherwise: bb3];
    }

    bb3: {
        _14 = _1;
        _13 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::read_unaligned(move _14) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _12 = &_13;
        _17 = _2;
        _16 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::read_unaligned(move _17) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _15 = &_16;
        _11 = <T as PartialEq>::ne(move _12, move _15) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        switchInt(move _11) -> [0: bb11, otherwise: bb7];
    }

    bb7: {
        _20 = _1;
        _19 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::cast::<U>(move _20) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _22 = _2;
        _21 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::cast::<U>(move _22) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _23 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _18 = (move _19, move _21, move _23);
        _0 = <F as FnOnce<(*const U, *const U, usize)>>::call_once(move _4, move _18) -> [return: bb18, unwind unreachable];
    }

    bb11: {
        _25 = _1;
        _24 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(move _25, const 1_usize) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _1 = move _24;
        _27 = _2;
        _26 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(move _27, const 1_usize) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _2 = move _26;
        goto -> bb2;
    }

    bb14: {
        _30 = _1;
        _29 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::cast::<U>(move _30) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _32 = _2;
        _31 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::cast::<U>(move _32) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _34 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb17, unwind unreachable];
    }

    bb17: {
        _33 = Rem(_3, move _34);
        _28 = (move _29, move _31, move _33);
        _0 = <F as FnOnce<(*const U, *const U, usize)>>::call_once(move _4, move _28) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        return;
    }
}

impls::compare_bytes::cmp::{constant#0}: () = {
    let mut _0: ();
    let mut _1: bool;
    let mut _2: usize;
    let mut _3: !;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        ConstEvalCounter;
        _2 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _1 = Ne(move _2, const 0_usize);
        switchInt(move _1) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        StorageDead(_2);
        _0 = const ();
        StorageDead(_1);
        return;
    }

    bb3: {
        StorageDead(_2);
        StorageLive(_3);
        ConstEvalCounter;
        _3 = panic(const "assertion failed: mem::size_of::<T>() != 0") -> bb4;
    }

    bb4 (cleanup): {
        resume;
    }
}

fn impls::compare_bytes::{closure#0}(_1: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53}, _2: *const u8, _3: *const u8, _4: usize) -> i32 {
    debug a => _2;
    debug b => _3;
    debug n => _4;
    let mut _0: i32;
    let mut _5: rustc_std_workspace_core::ops::Range<usize>;
    let mut _6: rustc_std_workspace_core::ops::Range<usize>;
    let mut _7: rustc_std_workspace_core::ops::Range<usize>;
    let mut _8: rustc_std_workspace_core::option::Option<usize>;
    let mut _9: &mut rustc_std_workspace_core::ops::Range<usize>;
    let mut _10: isize;
    let mut _11: bool;
    let mut _12: u8;
    let mut _13: *const u8;
    let mut _14: u8;
    let mut _15: *const u8;
    let mut _16: i32;
    let mut _17: u8;
    let mut _18: *const u8;
    let mut _19: i32;
    let mut _20: u8;
    let mut _21: *const u8;
    let mut _22: (i32, bool);
    let mut _23: *const u8;
    let mut _24: *const u8;
    let mut _25: *const u8;
    let mut _26: *const u8;
    scope 1 {
        debug iter => _7;
    }

    bb0: {
        _6 = Range::<usize> { start: const 0_usize, end: _4 };
        _5 = <Range<usize> as IntoIterator>::into_iter(move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = move _5;
        goto -> bb2;
    }

    bb2: {
        _9 = &mut _7;
        _8 = <Range<usize> as Iterator>::next(_9) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb5, 1: bb4, otherwise: bb18];
    }

    bb4: {
        _13 = _2;
        _12 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::read(move _13) -> [return: bb6, unwind unreachable];
    }

    bb5: {
        _0 = const 0_i32;
        goto -> bb17;
    }

    bb6: {
        _15 = _3;
        _14 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::read(move _15) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _11 = Ne(move _12, move _14);
        switchInt(move _11) -> [0: bb14, otherwise: bb8];
    }

    bb8: {
        _18 = _2;
        _17 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::read(move _18) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _16 = <i32 as From<u8>>::from(move _17) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _21 = _3;
        _20 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::read(move _21) -> [return: bb11, unwind unreachable];
    }

    bb11: {
        _19 = <i32 as From<u8>>::from(move _20) -> [return: bb12, unwind unreachable];
    }

    bb12: {
        _22 = CheckedSub(_16, _19);
        assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", move _16, move _19) -> [success: bb13, unwind unreachable];
    }

    bb13: {
        _0 = move (_22.0: i32);
        goto -> bb17;
    }

    bb14: {
        _24 = _2;
        _23 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::add(move _24, const 1_usize) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move _23;
        _26 = _3;
        _25 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u8>::add(move _26, const 1_usize) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _3 = move _25;
        goto -> bb2;
    }

    bb17: {
        return;
    }

    bb18: {
        unreachable;
    }
}

fn impls::compare_bytes::{closure#1}(_1: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35}, _2: *const u16, _3: *const u16, _4: usize) -> i32 {
    debug a => _2;
    debug b => _3;
    debug n => _4;
    debug c1 => const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53};
    let mut _0: i32;

    bb0: {
        _0 = impls::compare_bytes::cmp::<u16, u8, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53}>(_2, _3, _4, const ZeroSized: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:159:14: 159:53}) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn impls::compare_bytes::{closure#2}(_1: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35}, _2: *const u32, _3: *const u32, _4: usize) -> i32 {
    debug a => _2;
    debug b => _3;
    debug n => _4;
    debug c2 => (*((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35}));
    let mut _0: i32;
    let mut _5: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35};
    let mut _6: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35};

    bb0: {
        _6 = deref_copy ((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35});
        _5 = (*_6);
        _0 = impls::compare_bytes::cmp::<u32, u16, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:169:14: 169:35}>(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn impls::compare_bytes::{closure#3}(_1: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35}, _2: *const u64, _3: *const u64, _4: usize) -> i32 {
    debug a => _2;
    debug b => _3;
    debug n => _4;
    debug c4 => (*((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35}));
    let mut _0: i32;
    let mut _5: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35};
    let mut _6: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35};

    bb0: {
        _6 = deref_copy ((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35});
        _5 = (*_6);
        _0 = impls::compare_bytes::cmp::<u64, u32, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:170:14: 170:35}>(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn impls::compare_bytes::{closure#4}(_1: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:172:15: 172:37}, _2: *const u128, _3: *const u128, _4: usize) -> i32 {
    debug a => _2;
    debug b => _3;
    debug n => _4;
    debug c8 => (*((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35}));
    let mut _0: i32;
    let mut _5: {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35};
    let mut _6: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35};

    bb0: {
        _6 = deref_copy ((*_1).0: &{closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35});
        _5 = (*_6);
        _0 = impls::compare_bytes::cmp::<u128, u64, {closure@/Users/yaw/.cargo/registry/src/index.crates.io-6f17d22bba15001f/compiler_builtins-0.1.104/src/mem/x86_64.rs:171:14: 171:35}>(_2, _3, _4, move _5) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn c_string_length(_1: *const i8) -> usize {
    debug s => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: *const i8;
    let mut _6: i8;
    let mut _7: (usize, bool);
    let mut _8: *const i8;
    let mut _9: *const i8;
    let mut _11: *const i8;
    let mut _14: *const u64;
    let mut _15: u64;
    let mut _16: u64;
    let mut _17: u64;
    let mut _18: u64;
    let mut _19: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _22: u64;
    let mut _23: u32;
    let mut _24: bool;
    let mut _25: (usize, bool);
    let mut _26: (usize, bool);
    let mut _27: *const u64;
    let mut _28: *const u64;
    scope 1 {
        debug n => _2;
        let mut _10: *const u64;
        scope 2 {
            debug s => _10;
            let mut _12: u64;
            let _13: u64;
            scope 3 {
                debug cs => _12;
            }
            scope 4 {
                debug r => _13;
            }
        }
    }

    bb0: {
        _2 = const 0_usize;
        goto -> bb1;
    }

    bb1: {
        _5 = _1;
        _4 = move _5 as usize (PointerExposeAddress);
        _3 = BitAnd(move _4, const 7_usize);
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _6 = (*_1);
        switchInt(move _6) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = _2;
        goto -> bb19;
    }

    bb4: {
        _7 = CheckedAdd(_2, const 1_usize);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb5, unwind unreachable];
    }

    bb5: {
        _2 = move (_7.0: usize);
        _9 = _1;
        _8 = rustc_std_workspace_core::ptr::const_ptr::<impl *const i8>::add(move _9, const 1_usize) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _1 = move _8;
        goto -> bb1;
    }

    bb7: {
        _11 = _1;
        _10 = move _11 as *const u64 (PtrToPtr);
        goto -> bb8;
    }

    bb8: {
        _14 = _10;
        asm!("mov ({0}), {1}", in(reg) move _14, out(reg) _13, options(NOSTACK | ATT_SYNTAX)) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _12 = _13;
        _18 = _12;
        _17 = rustc_std_workspace_core::num::<impl u64>::wrapping_sub(move _18, const 72340172838076673_u64) -> [return: bb10, unwind unreachable];
    }

    bb10: {
        _20 = _12;
        _19 = Not(move _20);
        _16 = BitAnd(move _17, move _19);
        _15 = BitAnd(move _16, const 9259542123273814144_u64);
        switchInt(move _15) -> [0: bb16, otherwise: bb11];
    }

    bb11: {
        _22 = _12;
        _21 = BitAnd(move _22, const 255_u64);
        switchInt(move _21) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        _0 = _2;
        goto -> bb19;
    }

    bb13: {
        _23 = const 8_i32 as u32 (IntToInt);
        _24 = Lt(move _23, const 64_u32);
        assert(move _24, "attempt to shift right by `{}`, which would overflow", const 8_i32) -> [success: bb14, unwind unreachable];
    }

    bb14: {
        _12 = Shr(_12, const 8_i32);
        _25 = CheckedAdd(_2, const 1_usize);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb15, unwind unreachable];
    }

    bb15: {
        _2 = move (_25.0: usize);
        goto -> bb11;
    }

    bb16: {
        _26 = CheckedAdd(_2, const 8_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 8_usize) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _2 = move (_26.0: usize);
        _28 = _10;
        _27 = rustc_std_workspace_core::ptr::const_ptr::<impl *const u64>::add(move _28, const 1_usize) -> [return: bb18, unwind unreachable];
    }

    bb18: {
        _10 = move _27;
        goto -> bb8;
    }

    bb19: {
        return;
    }
}

fn rep_param(_1: *mut u8, _2: usize) -> (usize, usize, usize) {
    debug dest => _1;
    debug count => _2;
    let mut _0: (usize, usize, usize);
    let _3: usize;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: (usize, bool);
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _12: usize;
    let mut _13: u32;
    let mut _14: bool;
    let mut _16: usize;
    scope 1 {
        debug pre_byte_count => _3;
        let _11: usize;
        scope 2 {
            debug qword_count => _11;
            let _15: usize;
            scope 3 {
                debug byte_count => _15;
            }
        }
    }

    bb0: {
        _7 = _1 as usize (PointerExposeAddress);
        _6 = BitAnd(move _7, const 7_usize);
        _8 = CheckedSub(const 8_usize, _6);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", const 8_usize, move _6) -> [success: bb1, unwind unreachable];
    }

    bb1: {
        _5 = move (_8.0: usize);
        _4 = BitAnd(move _5, const 7_usize);
        _9 = _2;
        _3 = <usize as Ord>::min(move _4, move _9) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _10 = CheckedSub(_2, _3);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, _3) -> [success: bb3, unwind unreachable];
    }

    bb3: {
        _2 = move (_10.0: usize);
        _12 = _2;
        _13 = const 3_i32 as u32 (IntToInt);
        _14 = Lt(move _13, const 64_u32);
        assert(move _14, "attempt to shift right by `{}`, which would overflow", const 3_i32) -> [success: bb4, unwind unreachable];
    }

    bb4: {
        _11 = Shr(move _12, const 3_i32);
        _16 = _2;
        _15 = BitAnd(move _16, const 7_usize);
        _0 = (_3, _11, _15);
        return;
    }
}

fn mem::memcpy(_1: *mut u8, _2: *const u8, _3: usize) -> *mut u8 {
    debug dest => _1;
    debug src => _2;
    debug n => _3;
    let mut _0: *mut u8;
    let _4: ();

    bb0: {
        _4 = copy_forward(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn memcpy::memcpy(_1: *mut u8, _2: *const u8, _3: usize) -> *mut u8 {
    debug dest => _1;
    debug src => _2;
    debug n => _3;
    let mut _0: *mut u8;

    bb0: {
        _0 = mem::memcpy(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::memmove(_1: *mut u8, _2: *const u8, _3: usize) -> *mut u8 {
    debug dest => _1;
    debug src => _2;
    debug n => _3;
    let mut _0: *mut u8;
    let _4: usize;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let _8: ();
    let _9: ();
    scope 1 {
        debug delta => _4;
    }

    bb0: {
        _5 = _1 as usize (PointerExposeAddress);
        _6 = _2 as usize (PointerExposeAddress);
        _4 = rustc_std_workspace_core::num::<impl usize>::wrapping_sub(move _5, move _6) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _7 = Ge(_4, _3);
        switchInt(move _7) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = copy_forward(_1, _2, _3) -> [return: bb4, unwind unreachable];
    }

    bb3: {
        _9 = copy_backward(_1, _2, _3) -> [return: bb4, unwind unreachable];
    }

    bb4: {
        _0 = _1;
        return;
    }
}

fn memmove::memmove(_1: *mut u8, _2: *const u8, _3: usize) -> *mut u8 {
    debug dest => _1;
    debug src => _2;
    debug n => _3;
    let mut _0: *mut u8;

    bb0: {
        _0 = mem::memmove(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::memset(_1: *mut u8, _2: i32, _3: usize) -> *mut u8 {
    debug s => _1;
    debug c => _2;
    debug n => _3;
    let mut _0: *mut u8;
    let _4: ();
    let mut _5: u8;

    bb0: {
        _5 = _2 as u8 (IntToInt);
        _4 = set_bytes(_1, move _5, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _0 = _1;
        return;
    }
}

fn memset::memset(_1: *mut u8, _2: i32, _3: usize) -> *mut u8 {
    debug s => _1;
    debug c => _2;
    debug n => _3;
    let mut _0: *mut u8;

    bb0: {
        _0 = mem::memset(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::memcmp(_1: *const u8, _2: *const u8, _3: usize) -> i32 {
    debug s1 => _1;
    debug s2 => _2;
    debug n => _3;
    let mut _0: i32;

    bb0: {
        _0 = impls::compare_bytes(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn memcmp::memcmp(_1: *const u8, _2: *const u8, _3: usize) -> i32 {
    debug s1 => _1;
    debug s2 => _2;
    debug n => _3;
    let mut _0: i32;

    bb0: {
        _0 = mem::memcmp(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::bcmp(_1: *const u8, _2: *const u8, _3: usize) -> i32 {
    debug s1 => _1;
    debug s2 => _2;
    debug n => _3;
    let mut _0: i32;

    bb0: {
        _0 = mem::memcmp(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn bcmp::bcmp(_1: *const u8, _2: *const u8, _3: usize) -> i32 {
    debug s1 => _1;
    debug s2 => _2;
    debug n => _3;
    let mut _0: i32;

    bb0: {
        _0 = mem::bcmp(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::strlen(_1: *const i8) -> usize {
    debug s => _1;
    let mut _0: usize;

    bb0: {
        _0 = c_string_length(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn strlen::strlen(_1: *const i8) -> usize {
    debug s => _1;
    let mut _0: usize;

    bb0: {
        _0 = mem::strlen(_1) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn memcpy_element_unordered_atomic(_1: *mut T, _2: *const T, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let mut _5: usize;
    let mut _7: bool;
    let mut _8: usize;
    let _9: ();
    let mut _10: *mut T;
    let mut _11: usize;
    let mut _12: T;
    let mut _13: *const T;
    let mut _14: usize;
    let mut _15: (usize, bool);
    scope 1 {
        let _4: usize;
        scope 2 {
            debug n => _4;
            let mut _6: usize;
            scope 3 {
                debug i => _6;
            }
        }
    }

    bb0: {
        _5 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = exact_div::<usize>(_3, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = const 0_usize;
        goto -> bb3;
    }

    bb3: {
        _8 = _6;
        _7 = Lt(move _8, _4);
        switchInt(move _7) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _11 = _6;
        _10 = rustc_std_workspace_core::ptr::mut_ptr::<impl *mut T>::add(_1, move _11) -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _14 = _6;
        _13 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(_2, move _14) -> [return: bb6, unwind unreachable];
    }

    bb6: {
        _12 = atomic_load_unordered::<T>(move _13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _9 = atomic_store_unordered::<T>(move _10, move _12) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _15 = CheckedAdd(_6, const 1_usize);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_usize) -> [success: bb9, unwind unreachable];
    }

    bb9: {
        _6 = move (_15.0: usize);
        goto -> bb3;
    }

    bb10: {
        return;
    }
}

fn memmove_element_unordered_atomic(_1: *mut T, _2: *const T, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: *const T;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let _11: ();
    let mut _12: *mut T;
    let mut _13: usize;
    let mut _14: T;
    let mut _15: *const T;
    let mut _16: usize;
    let mut _18: bool;
    let mut _19: usize;
    let _20: ();
    let mut _21: *mut T;
    let mut _22: usize;
    let mut _23: T;
    let mut _24: *const T;
    let mut _25: usize;
    let mut _26: (usize, bool);
    scope 1 {
        let _4: usize;
        scope 2 {
            debug n => _4;
            let mut _8: usize;
            let mut _17: usize;
            scope 3 {
                debug i => _8;
            }
            scope 4 {
                debug i => _17;
            }
        }
    }

    bb0: {
        _5 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = exact_div::<usize>(_3, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _7 = _1 as *const T (PointerCoercion(MutToConstPointer));
        _6 = Lt(_2, move _7);
        switchInt(move _6) -> [0: bb10, otherwise: bb3];
    }

    bb3: {
        _8 = _4;
        goto -> bb4;
    }

    bb4: {
        _9 = _8;
        switchInt(move _9) -> [0: bb18, otherwise: bb5];
    }

    bb5: {
        _10 = CheckedSub(_8, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} - {}`, which would overflow", _8, const 1_usize) -> [success: bb6, unwind unreachable];
    }

    bb6: {
        _8 = move (_10.0: usize);
        _13 = _8;
        _12 = rustc_std_workspace_core::ptr::mut_ptr::<impl *mut T>::add(_1, move _13) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _16 = _8;
        _15 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(_2, move _16) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _14 = atomic_load_unordered::<T>(move _15) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _11 = atomic_store_unordered::<T>(move _12, move _14) -> [return: bb4, unwind unreachable];
    }

    bb10: {
        _17 = const 0_usize;
        goto -> bb11;
    }

    bb11: {
        _19 = _17;
        _18 = Lt(move _19, _4);
        switchInt(move _18) -> [0: bb18, otherwise: bb12];
    }

    bb12: {
        _22 = _17;
        _21 = rustc_std_workspace_core::ptr::mut_ptr::<impl *mut T>::add(_1, move _22) -> [return: bb13, unwind unreachable];
    }

    bb13: {
        _25 = _17;
        _24 = rustc_std_workspace_core::ptr::const_ptr::<impl *const T>::add(_2, move _25) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _23 = atomic_load_unordered::<T>(move _24) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _20 = atomic_store_unordered::<T>(move _21, move _23) -> [return: bb16, unwind unreachable];
    }

    bb16: {
        _26 = CheckedAdd(_17, const 1_usize);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _17, const 1_usize) -> [success: bb17, unwind unreachable];
    }

    bb17: {
        _17 = move (_26.0: usize);
        goto -> bb11;
    }

    bb18: {
        return;
    }
}

fn memset_element_unordered_atomic(_1: *mut T, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();
    let mut _5: usize;
    let mut _8: bool;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: T;
    let mut _12: T;
    let mut _13: T;
    let mut _14: T;
    let mut _15: (usize, bool);
    let mut _17: bool;
    let mut _18: usize;
    let _19: ();
    let mut _20: *mut T;
    let mut _21: usize;
    let mut _22: T;
    let mut _23: (usize, bool);
    scope 1 {
        let _4: usize;
        scope 2 {
            debug n => _4;
            let mut _6: T;
            scope 3 {
                debug x => _6;
                let mut _7: usize;
                scope 4 {
                    debug i => _7;
                    let mut _16: usize;
                    scope 5 {
                        debug i => _16;
                    }
                }
            }
        }
    }

    bb0: {
        _5 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];
    }

    bb1: {
        _4 = exact_div::<usize>(_3, move _5) -> [return: bb2, unwind unreachable];
    }

    bb2: {
        _6 = <T as From<u8>>::from(_2) -> [return: bb3, unwind unreachable];
    }

    bb3: {
        _7 = const 1_usize;
        goto -> bb4;
    }

    bb4: {
        _9 = _7;
        _10 = rustc_std_workspace_core::mem::size_of::<T>() -> [return: bb5, unwind unreachable];
    }

    bb5: {
        _8 = Lt(move _9, move _10);
        switchInt(move _8) -> [0: bb11, otherwise: bb6];
    }

    bb6: {
        _13 = _6;
        _12 = <T as Shl<u32>>::shl(move _13, const 8_u32) -> [return: bb7, unwind unreachable];
    }

    bb7: {
        _14 = <T as From<u8>>::from(_2) -> [return: bb8, unwind unreachable];
    }

    bb8: {
        _11 = <T as BitOr>::bitor(move _12, move _14) -> [return: bb9, unwind unreachable];
    }

    bb9: {
        _6 = move _11;
        _15 = CheckedAdd(_7, const 1_usize);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, const 1_usize) -> [success: bb10, unwind unreachable];
    }

    bb10: {
        _7 = move (_15.0: usize);
        goto -> bb4;
    }

    bb11: {
        _16 = const 0_usize;
        goto -> bb12;
    }

    bb12: {
        _18 = _16;
        _17 = Lt(move _18, _4);
        switchInt(move _17) -> [0: bb17, otherwise: bb13];
    }

    bb13: {
        _21 = _16;
        _20 = rustc_std_workspace_core::ptr::mut_ptr::<impl *mut T>::add(_1, move _21) -> [return: bb14, unwind unreachable];
    }

    bb14: {
        _22 = _6;
        _19 = atomic_store_unordered::<T>(move _20, move _22) -> [return: bb15, unwind unreachable];
    }

    bb15: {
        _23 = CheckedAdd(_16, const 1_usize);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", _16, const 1_usize) -> [success: bb16, unwind unreachable];
    }

    bb16: {
        _16 = move (_23.0: usize);
        goto -> bb12;
    }

    bb17: {
        return;
    }
}

fn mem::__llvm_memcpy_element_unordered_atomic_1(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memcpy_element_unordered_atomic::<u8>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memcpy_element_unordered_atomic_1::__llvm_memcpy_element_unordered_atomic_1(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memcpy_element_unordered_atomic_1(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memcpy_element_unordered_atomic_2(_1: *mut u16, _2: *const u16, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memcpy_element_unordered_atomic::<u16>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memcpy_element_unordered_atomic_2::__llvm_memcpy_element_unordered_atomic_2(_1: *mut u16, _2: *const u16, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memcpy_element_unordered_atomic_2(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memcpy_element_unordered_atomic_4(_1: *mut u32, _2: *const u32, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memcpy_element_unordered_atomic::<u32>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memcpy_element_unordered_atomic_4::__llvm_memcpy_element_unordered_atomic_4(_1: *mut u32, _2: *const u32, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memcpy_element_unordered_atomic_4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memcpy_element_unordered_atomic_8(_1: *mut u64, _2: *const u64, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memcpy_element_unordered_atomic::<u64>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memcpy_element_unordered_atomic_8::__llvm_memcpy_element_unordered_atomic_8(_1: *mut u64, _2: *const u64, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memcpy_element_unordered_atomic_8(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memmove_element_unordered_atomic_1(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memmove_element_unordered_atomic::<u8>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memmove_element_unordered_atomic_1::__llvm_memmove_element_unordered_atomic_1(_1: *mut u8, _2: *const u8, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memmove_element_unordered_atomic_1(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memmove_element_unordered_atomic_2(_1: *mut u16, _2: *const u16, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memmove_element_unordered_atomic::<u16>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memmove_element_unordered_atomic_2::__llvm_memmove_element_unordered_atomic_2(_1: *mut u16, _2: *const u16, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memmove_element_unordered_atomic_2(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memmove_element_unordered_atomic_4(_1: *mut u32, _2: *const u32, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memmove_element_unordered_atomic::<u32>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memmove_element_unordered_atomic_4::__llvm_memmove_element_unordered_atomic_4(_1: *mut u32, _2: *const u32, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memmove_element_unordered_atomic_4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memmove_element_unordered_atomic_8(_1: *mut u64, _2: *const u64, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memmove_element_unordered_atomic::<u64>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memmove_element_unordered_atomic_8::__llvm_memmove_element_unordered_atomic_8(_1: *mut u64, _2: *const u64, _3: usize) -> () {
    debug dest => _1;
    debug src => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memmove_element_unordered_atomic_8(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memset_element_unordered_atomic_1(_1: *mut u8, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memset_element_unordered_atomic::<u8>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memset_element_unordered_atomic_1::__llvm_memset_element_unordered_atomic_1(_1: *mut u8, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memset_element_unordered_atomic_1(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memset_element_unordered_atomic_2(_1: *mut u16, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memset_element_unordered_atomic::<u16>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memset_element_unordered_atomic_2::__llvm_memset_element_unordered_atomic_2(_1: *mut u16, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memset_element_unordered_atomic_2(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memset_element_unordered_atomic_4(_1: *mut u32, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memset_element_unordered_atomic::<u32>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memset_element_unordered_atomic_4::__llvm_memset_element_unordered_atomic_4(_1: *mut u32, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memset_element_unordered_atomic_4(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn mem::__llvm_memset_element_unordered_atomic_8(_1: *mut u64, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = memset_element_unordered_atomic::<u64>(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}

fn __llvm_memset_element_unordered_atomic_8::__llvm_memset_element_unordered_atomic_8(_1: *mut u64, _2: u8, _3: usize) -> () {
    debug s => _1;
    debug c => _2;
    debug bytes => _3;
    let mut _0: ();

    bb0: {
        _0 = mem::__llvm_memset_element_unordered_atomic_8(_1, _2, _3) -> [return: bb1, unwind unreachable];
    }

    bb1: {
        return;
    }
}
